// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import Fuzzilli

let Seconds = 1.0
let Minutes = 60.0 * Seconds
let Hours   = 60.0 * Minutes

// Keep track of the coverage to determine progress over time
var oldCoverage = 0.0
var TicksNewCoverage = 0

// A very basic terminal UI.
class TerminalUI {
    // If set, the next program generated by the fuzzer will be printed to the screen.
    var printNextGeneratedProgram: Bool

    
    init(for fuzzer: Fuzzer) {
        printNextGeneratedProgram = false

        // Event listeners etc. have to be registered on the fuzzer's queue
        fuzzer.queue.addOperation {
            self.initOnFuzzerQueue(fuzzer)
            
        }
    }

    // Everything for new UI goes here for now

    // Run a terminal command
    func runCommand(cmd : String, args : String...) -> (output: [String], error: [String], exitCode: Int32) {

        var output : [String] = []
        var error : [String] = []

        let task = Process()
        task.launchPath = cmd
        task.arguments = args

        let outpipe = Pipe()
        task.standardOutput = outpipe
        let errpipe = Pipe()
        task.standardError = errpipe

        task.launch()

        let outdata = outpipe.fileHandleForReading.readDataToEndOfFile()
        if var string = String(data: outdata, encoding: .utf8) {
            string = string.trimmingCharacters(in: .newlines)
            output = string.components(separatedBy: "\n")
        }

        let errdata = errpipe.fileHandleForReading.readDataToEndOfFile()
        if var string = String(data: errdata, encoding: .utf8) {
            string = string.trimmingCharacters(in: .newlines)
            error = string.components(separatedBy: "\n")
        }

        task.waitUntilExit()
        let status = task.terminationStatus

        return (output, error, status)
    }

    // This print just gives us a bit more buffer
    func printUpdate(_ statusUpdate: String) {
        print()
        print(statusUpdate) 
    }

    var statusmsgArray = [""]
    var msgRowsSpace: Int = 24
    var msgColsSpace: Int = 80

    func initOnFuzzerQueue(_ fuzzer: Fuzzer) {
        // Register log event listener now to be able to print log messages
        // generated during fuzzer initialization

        // Clear screen in the beginning for good printing of stats
        print("\u{001B}[2J")

        // Calculate the terminal length if we have the opportunity (not within a Docker instance)
        self.msgRowsSpace = Int(String(describing: self.runCommand(cmd: "/usr/bin/tput", args: "lines").output[0])) ?? self.msgRowsSpace
        self.msgColsSpace = Int(String(describing: self.runCommand(cmd: "/usr/bin/tput", args: "cols").output[0])) ?? self.msgColsSpace

        fuzzer.events.Log.observe { (creator, level, label, msg) in
            let color = self.colorForLevel[level]!            
            
            if creator == fuzzer.id {
                if level == .fatal {
                    print("\u{001B}[2K\u{001B}[0;\(color.rawValue)m[\(label)] \(msg)\u{001B}[0;\(Color.reset.rawValue)m")    
                }
                var msg = String("\u{001B}[2K\u{001B}[0;\(color.rawValue)m[\(label)] \(msg)\u{001B}[0;\(Color.reset.rawValue)m")
                if msg.count > self.msgColsSpace {
                    while msg.count > 0 {
                        let cut: Int = msg.count >= self.msgColsSpace ? self.msgColsSpace : msg.count
                        self.statusmsgArray.append(String(msg.prefix(cut)))
                        msg = String(msg.dropFirst(cut))
                    }
                } else {
                    self.statusmsgArray.append(msg)
                }
                
            } else {
                // Mark message as coming from a worker by including its id
                let shortId = creator.uuidString.split(separator: "-")[0]
                if level == .fatal {
                    print("\u{001B}[2K\u{001B}[0;\(color.rawValue)m[\(shortId):\(label)] \(msg)\u{001B}[0;\(Color.reset.rawValue)m")
                }
                var msg: String = "\u{001B}[2K\u{001B}[0;\(color.rawValue)m[\(shortId):\(label)] \(msg)\u{001B}[0;\(Color.reset.rawValue)m"
                if msg.count > self.msgColsSpace {
                    while msg.count > 0 {
                        let cut: Int = msg.count >= self.msgColsSpace ? self.msgColsSpace : msg.count
                        self.statusmsgArray.append(String(msg.prefix(cut)))
                        msg = String(msg.dropFirst(cut))
                    }
                } else {
                    self.statusmsgArray.append(msg)
                }
            }

        }
        
        fuzzer.events.CrashFound.observe { crash in
            if crash.isUnique {
                self.printUpdate("########## Unique Crash Found ##########")
                self.printUpdate(fuzzer.lifter.lift(crash.program))
            }
        }
        
        fuzzer.events.ProgramGenerated.observe { program in
            if self.printNextGeneratedProgram {
                self.printUpdate("--------- Generated Program -----------")
                self.printUpdate(fuzzer.lifter.lift(program, withOptions: [.dumpTypes]))
                self.printNextGeneratedProgram = false
            }
        }
        
        // Do everything else after fuzzer initialization finished
        fuzzer.events.Initialized.observe {
            if let stats = Statistics.instance(for: fuzzer) {
                fuzzer.events.Shutdown.observe {
                    self.printStats(stats.compute(), of: fuzzer)
                    print("\n++++++++++ Fuzzer Finished ++++++++++\n")
                }
                
                // We could also run our own timer on the main queue instead if we want to
                fuzzer.timers.scheduleTask(every: 1 * Seconds) {
                    self.printStats(stats.compute(), of: fuzzer)
                    print()
                }
            }
        }
    }
    
    func printStats(_ stats: Statistics.Data, of fuzzer: Fuzzer) {
        // Clean the entire screen
        for _ in 1...self.msgRowsSpace {
            print("\u{001B}[2K")
        }

        // Calculate the whole space that we have for status messages every print
        self.msgRowsSpace = Int(String(describing: self.runCommand(cmd: "/usr/bin/tput", args: "lines").output[0])) ?? self.msgRowsSpace
        self.msgColsSpace = Int(String(describing: self.runCommand(cmd: "/usr/bin/tput", args: "cols").output[0])) ?? self.msgColsSpace

        // Space for printing - 22 is the fixed rows size of the stats
        let statusMsgsSpace: Int = self.msgRowsSpace > 22 ? self.msgRowsSpace - 22 : 1
        
        // Cleanup of the array elements
        self.statusmsgArray = self.statusmsgArray.filter({ $0 != ""})
        while self.statusmsgArray.count > statusMsgsSpace {
            self.statusmsgArray.remove(at:0)
        }

        print("\u{001B}[0;0H\u{001B}[2K") // move to 0, 0 on the terminal and clean that part
        
        var CoverageColor = ""
        var CrashingColor = ""

        // TODO: Move this to the right part; assuming where all the "stats" are defined
        // Check how many "ticks" ago the coverage hasn't changed
        if oldCoverage == stats.coverage {
            TicksNewCoverage += 1
        } else {
            // If the coverage is updated then reset the counter
            TicksNewCoverage = 0
        }
        // Save the current coverage
        oldCoverage = stats.coverage

        // Colours for Low, Mid, Good coverage (Red, Blue, Green)
        switch stats.coverage {
            case 0.10...0.29:
                CoverageColor = "\u{001B}[0;34m"
            case 0.29...1.00:
                CoverageColor = "\u{001B}[0;32m"
            default:
                CoverageColor = "\u{001B}[0;31m"
        }
        // Red colour in case there's a crash
        if stats.crashingSamples != 0 {
            CrashingColor = "\u{001B}[0;31m"
        }

        // Print the actual stats
        print("""
        \u{001B}[2KFuzzer Statistics
        \u{001B}[2K-----------------
        \u{001B}[2KCoverage:                     \(CoverageColor)\(String(format: "%.2f%%", stats.coverage * 100))\u{001B}[0;0m
        \u{001B}[2KCoverage Last Updated:        \(TicksNewCoverage)
        \u{001B}[2KTotal Samples:                \(stats.totalSamples)
        \u{001B}[2KInteresting Samples Found:    \(stats.interestingSamples)
        \u{001B}[2KValid Samples Found:          \(stats.validSamples)
        \u{001B}[2KCorpus Size:                  \(fuzzer.corpus.size)
        \u{001B}[2KSuccess Rate:                 \(String(format: "%.2f%%", stats.successRate * 100))
        \u{001B}[2KTimeout Rate:                 \(String(format: "%.2f%%", stats.timeoutRate * 100))
        \u{001B}[2KDonatepies:                   \(CrashingColor)\(stats.crashingSamples)\u{001B}[0;0m
        \u{001B}[2KTimeouts Hit:                 \(stats.timedOutSamples)
        \u{001B}[2KAvg. program size:            \(String(format: "%.2f", stats.avgProgramSize))
        \u{001B}[2KConnected workers:            \(stats.numWorkers)
        \u{001B}[2KExecs / Second:               \(String(format: "%.2f", stats.execsPerSecond))
        \u{001B}[2KTotal Execs:                  \(stats.totalExecs)
        """)
        print("\u{001B}[2K-----------STATUS MESSAGES---------------")
        for msg in self.statusmsgArray {
            if msg.count > self.msgColsSpace {
                print("\(msg.prefix(self.msgColsSpace - 6)) ... \u{001B}[0;\(Color.reset.rawValue)m")    
            } else {
                print(msg)
            }
        }
    }

    // End of new ui thingy
    
    private enum Color: Int {
        case reset   = 0
        case black   = 30
        case red     = 31
        case green   = 32
        case yellow  = 33
        case blue    = 34
        case magenta = 35
        case cyan    = 36
        case white   = 37
    }
    
    // The color with which to print log entries.
    private let colorForLevel: [LogLevel: Color] = [
        .verbose: .cyan,
        .info:    .white,
        .warning: .yellow,
        .error:   .magenta,
        .fatal:   .red
    ]
}
