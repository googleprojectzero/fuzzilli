I must go in; the fog is rising
Initializing FatherOfGod
╭────────────────────────────────────────────────────────────────────────────────────────── New run - FatherOfGeorge ──────────────────────────────────────────────────────────────────────────────────────────╮
│                                                                                                                                                                                                              │
│ Task: Initialize Root Manager orchestration                                                                                                                                                                  │
│                                                                                                                                                                                                              │
│ Context:                                                                                                                                                                                                     │
│ - PickSection: Select a promising V8 code region to analyze                                                                                                                                                  │
│ - FatherOfGeorge: Primary orchestrator of the system, coordinates between analysis and program generation                                                                                                    │
│ - CodeAnalyzer: Analyze V8 code and knowledge bases to guide the program template building                                                                                                                   │
│ - ProgramBuilder: Generate Fuzzilli program templates for fuzzing a specific code region                                                                                                                     │
│                                                                                                                                                                                                              │
╰─ LiteLLMModel - gpt-5 ───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ Step 1 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'search_knowledge_base' with arguments: {'query': 'What is V8 Inline Caching (IC), how does it work, what are key components (LoadIC, StoreIC, CallIC, feedback vector, megamorphic state,     │
│ monomorphic/polymorphic IC), and how it ties into optimizing compiler (Turbofan) and feedback collection?', 'top_k': 5, 'topic_filter': 'v8'}                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
Observations: |
  {
    "topic": "V8 JavaScript Engine",
    "file": "v8/v8.dev/blog/improved-code-caching.txt",
    "similarity": 0.622,
    "content_preview": "Topic: V8 JavaScript Engine\nFile: v8/v8.dev/blog/improved-code-caching.txt\n\nImproved code caching \u00b7 V8 V8 Show navigation Home Blog Docs Tools JS/Wasm features Research 
Improved code caching Published 24 April 2018 \u00b7 Tagged with internals V8 uses code caching to cache the generated code for frequently-used scripts. Starting with Chrome 66, we are caching more code by 
generating the cache after top-level execution. This leads to a 20\u201340% reduction in parse and compilation time during the initial load. Background # V8 uses two kinds of code caching to cache generated 
code to be reused later. The first is the in-memory cache that is available within each instance of V8. The code generated after the initial compile is stored into this cache, keyed on the source string. This
is available for reuse within the same instance of V8. The other kind of code caching serializes the generated code and stores it on disk for future use. This cache is not specific to a particular instance of
V8 and can be used across different instances of V8. This blog post focuses on this second kind of code caching as used in Chrome. (Other embedders also use this kind of code caching; it\u2019s not limited to
Chrome. However, this blog post only focuses on the usage in Chrome.) Chrome stores the serialized generated code onto the disk cache and keys it with the URL of the script resource. When loading a script, 
Chrome checks the disk cache. If the script is already cached, Chrome passes the serialized data to V8 as a part of compile request. V8 then deserializes this data instead of parsing and compiling the script.
There are also additional checks involved to ensure that the code is still usable (for example: a version mismatch makes the cached data unusable). Real-world data shows that the code cache hit rates (for 
scripts that could be cached) is high (~86%). Though the cache hit rates are high for these scripts, the amount of code we cache per script is not very high. Our analysis showed that increasing the amount of 
code that is cached would reduce the time spent in parsing and compiling JavaScript code by around 40%. Increasing the amount of code that is cached # In the previous approach, code caching was coupled with 
the requests to compile the script. Embedders could request that V8 serialize the code it generated during its top-level compilation of a new JavaScript source file. V8 returned the serialized code after 
compiling the script. When Chrome requests the same script again, V8 fetches the serialized code from the cache and deserializes it. V8 completely avoids recompiling functions that are already in the cache. 
These scenarios are shown in the following figure: V8 only compiles the functions that are expected to be immediately executed (IIFEs) during the top-level compile and marks other functions for lazy 
compilation. This helps improve page load times by avoiding compiling functions that are not required, however it means that the serialized data only contains the code for the functions that are eagerly 
compiled. Prior to Chrome 59, we had to generate the code cache before any execution has started. The earlier baseline compiler of V8 (Full-codegen) generates specialized code for the execution context. 
Full-codegen used code patching to fast-path operations for the specific execution context. Such code cannot be serialized easily by removing the context specific data to be used in other execution contexts. 
With the launch of Ignition in Chrome 59, this restriction is no longer necessary. Ignition uses data-driven inline caches to fast-path operations in the current execution context. The context-dependent data 
is stored in feedback vectors and is separate from the generated code. This has opened the possibility of generating code caches even after the execution of the script. As we execute the script, more 
functions (that were marked for lazy compile) are compiled, allowing us to cache more code. V8 exposes a new API, ScriptCompiler::CreateCodeCache , to request code caches independent of the compile requests. 
Requesting code caches along with compile requests is deprecated and would not work in V8 v6.6 onwards. Since version 66, Chrome uses this API to request the code cache after the top-level execute. The 
following figure shows the new scenario of requesting the code cache. The code cache is requested after the top level execute and hence contains the code for functions that were compiled later during the 
execution of the script. In the later runs (shown as hot runs in the following figure), it avoids compilation of functions during top level execute. Results # The performance of this feature is measured using
our internal real-world benchmarks . The following graph shows the reduction in the parse and compile time over the earlier caching scheme. There is a reduction of around 20\u201340% in both parse and 
compilation time on most of the pages. Data from the wild shows similar results with a 20\u201340% reduction in the time spent in compiling JavaScript code both on desktop and mobile. On Android, this 
optimization also translates to a 1\u20132% reduction in the top-level page-load metrics like the time a webpage takes to become interactive. We also monitored the memory and disk usage of Chrome and did not 
see any noticeable regressions. Posted by Mythri Alle, Chief Code Cacher. Retweet this article! Branding Terms Privacy Twitter Edit this page on GitHub Except as otherwise noted, any code samples from the V8 
project are licensed under V8\u2019s BSD-style license . Other content on this page is licensed under the Creative Commons Attribution 3.0 License . For details, see our site policies ."
  },
  {
    "topic": "V8 JavaScript Engine",
    "file": "v8/v8.dev/blog/code-caching.txt",
    "similarity": 0.591,
    "content_preview": "Topic: V8 JavaScript Engine\nFile: v8/v8.dev/blog/code-caching.txt\n\nCode caching \u00b7 V8 V8 Show navigation Home Blog Docs Tools JS/Wasm features Research Code caching Published 27
July 2015 \u00b7 Tagged with internals V8 uses just-in-time compilation (JIT) to execute JavaScript code. This means that immediately prior to running a script, it has to be parsed and compiled \u2014 which 
can cause considerable overhead. As we announced recently , code caching is a technique that lessens this overhead. When a script is compiled for the first time, cache data is produced and stored. The next 
time V8 needs to compile the same script, even in a different V8 instance, it can use the cache data to recreate the compilation result instead of compiling from scratch. As a result the script is executed 
much sooner. Code caching has been available since V8 version 4.2 and not limited to Chrome alone. It is exposed through V8\u2019s API, so that every V8 embedder can take advantage of it. The test case used 
to exercise this feature serves as an example of how to use this API. When a script is compiled by V8, cache data can be produced to speed up later compilations by passing 
v8::ScriptCompiler::kProduceCodeCache as an option. If the compilation succeeds, the cache data is attached to the source object and can be retrieved via v8::ScriptCompiler::Source::GetCachedData . It can 
then be persisted for later, for example by writing it to disk. During later compilations, the previously produced cache data can be attached to the source object and passed 
v8::ScriptCompiler::kConsumeCodeCache as an option. This time, code will be produced much faster, as V8 bypasses compiling the code and deserializes it from the provided cache data. Producing cache data comes
at a certain computational and memory cost. For this reason, Chrome only produces cache data if the same script is seen at least twice within a couple of days. This way Chrome is able to turn script files 
into executable code twice as fast on average, saving users valuable time on each subsequent page load. Posted by Yang Guo ( @hashseed ), Software Engineer. Branding Terms Privacy Twitter Edit this page on 
GitHub Except as otherwise noted, any code samples from the V8 project are licensed under V8\u2019s BSD-style license . Other content on this page is licensed under the Creative Commons Attribution 3.0 
License . For details, see our site policies ."
  },
  {
    "topic": "V8 JavaScript Engine",
    "file": "v8/v8.dev/blog/csa.txt",
    "similarity": 0.558,
    "content_preview": "Topic: V8 JavaScript Engine\nFile: v8/v8.dev/blog/csa.txt\n\nTaming architecture complexity in V8 \u2014 the CodeStubAssembler \u00b7 V8 V8 Show navigation Home Blog Docs Tools JS/Wasm
features Research Taming architecture complexity in V8 \u2014 the CodeStubAssembler Published 16 November 2017 \u00b7 Tagged with internals In this post we\u2019d like to introduce the CodeStubAssembler 
(CSA), a component in V8 that has been a very useful tool in achieving some big performance wins over the last several V8 releases. The CSA also significantly improved the V8 team\u2019s ability to quickly 
optimize JavaScript features at a low-level with a high degree of reliability, which improved the team\u2019s development velocity. A brief history of builtins and hand-written assembly in V8 # To understand 
the CSA\u2019s role in V8, it\u2019s important to understand a little bit of the context and history that led to its development. V8 squeezes performance out of JavaScript using a combination of techniques. 
For JavaScript code that runs a long time, V8\u2019s TurboFan optimizing compiler does a great job of speeding up the entire spectrum of ES2015+ functionality for peak performance. However, V8 also needs to 
execute short-running JavaScript efficiently for good baseline performance. This is especially the case for the so-called builtin functions on the pre-defined objects that are available to all JavaScript 
programs as defined by the ECMAScript specification . Historically, many of these builtin functions were self-hosted , that is, they were authored by a V8 developer in JavaScript\u2014albeit a special 
V8-internal dialect. To achieve good performance, these self-hosted builtins rely on the same mechanisms V8 uses to optimize user-supplied JavaScript. As with user-supplied code, the self-hosted builtins 
require a warm-up phase in which type feedback is gathered and they need to be compiled by the optimizing compiler. Although this technique provides good builtin performance in some situations, it\u2019s 
possible to do better. The exact semantics of the pre-defined functions on the Array.prototype are specified in exquisite detail in the spec. For important and common special cases, V8\u2019s implementers 
know in advance exactly how these builtin functions should work by understanding the specification, and they use this knowledge to carefully craft custom, hand-tuned versions up front. These optimized 
builtins handle common cases without warm-up or the need to invoke the optimizing compiler, since by construction baseline performance is already optimal upon first invocation. To squeeze the best performance
out of hand-written built-in JavaScript functions (and from other fast-path V8 code that are also somewhat confusingly called builtins), V8 developers traditionally wrote optimized builtins in assembly 
language. By using assembly, the hand-written builtin functions were especially fast by, among other things, avoiding expensive calls to V8\u2019s C++ code via trampolines and by taking advantage of V8\u2019s
custom register-based ABI that it uses internally to call JavaScript functions. Because of the advantages of hand-written assembly, V8 accumulated literally tens of thousands of lines of hand-written assembly
code for builtins over the years\u2026 per platform . All of these hand-written assembly builtins were great for improving performance, but new language features are always being standardized, and maintaining
and extending this hand-written assembly was laborious and error-prone. Enter the CodeStubAssembler # V8 developers wrestled with a dilemma for many years: is it possible to create builtins that have the 
advantage of hand-written assembly without also being fragile and difficult to maintain? With the advent of TurboFan the answer to this question is finally \u201cyes\u201d. TurboFan\u2019s backend uses a 
cross-platform intermediate representation (IR) for low-level machine operations. This low-level machine IR is input to an instruction selector, register allocator, instruction scheduler and code generator 
that produce very good code on all platforms. The backend also knows about many of the tricks that are used in V8\u2019s hand-written assembly builtins\u2014e.g. how to use and call a custom register-based 
ABI, how to support machine-level tail calls, and how to elide the construction of stack frames in leaf functions. That knowledge makes the TurboFan backend especially well-suited for generating fast code 
that integrates well with the rest of V8. This combination of functionality made a robust and maintainable alternative to hand-written assembly builtins feasible for the first time. The team built a new V8 
component\u2014dubbed the CodeStubAssembler or CSA\u2014that defines a portable assembly language built on top of TurboFan\u2019s backend. The CSA adds an API to generate TurboFan machine-level IR directly 
without having to write and parse JavaScript or apply TurboFan\u2019s JavaScript-specific optimizations. Although this fast-path to code generation is something that only V8 developers can use to speed up the
V8 engine internally, this efficient path for generating optimized assembly code in a cross-platform way directly benefits all developers\u2019 JavaScript code in the builtins constructed with the CSA, 
including the performance-critical bytecode handlers for V8\u2019s interpreter, Ignition . The CSA and JavaScript compilation pipelines The CSA interface includes operations that are very low-level and 
familiar to anybody who has ever written assembly code. For example, it includes functionality like \u201cload this object pointer from a given address\u201d and \u201cmultiply these two 32-bit numbers\u201d.
The CSA has type verification at the IR level to catch many correctness bugs at compile time rather than runtime. For example, it can ensure that a V8 developer doesn\u2019t accidentally use an object pointer
that is loaded from memory as the input for a 32-bit multiplication. This kind of type verification is simply not possible with hand-written assembly stubs. A CSA test-drive # To get a better idea of what the
CSA offers, let\u2019s go through a quick example. We\u2019ll add a new internal builtin to V8 that returns the string length from an object if it is a String. If the input object is not a String, the builtin
will return undefined . First, we add a line to the BUILTIN_LIST_BASE macro in V8\u2019s builtin-definitions.h file that declares the new builtin called GetStringLength and specifies that it has a single 
input parameter that is identified with the constant kInputObject : TFS ( GetStringLength , kInputObject ) The TFS macro declares the builtin as a T urbo F an builtin using standard Code S tub linkage, which 
simply means that it uses the CSA to generate its code and expects parameters to be passed via registers. We can then define the contents of the builtin in builtins-string-gen.cc : TF_BUILTIN ( 
GetStringLength , CodeStubAssembler ) { Label not_string ( this ) ; // Fetch the incoming object using the constant we defined for // the first parameter. Node * const maybe_string = Parameter ( Descriptor ::
kInputObject ) ; // Check to see if input is a Smi (a special representation // of small numbers). This needs to be done before the IsString // check below, since IsString assumes its argument is an // object
pointer and not a Smi. If the argument is indeed a // Smi, jump to the label |not_string|. GotoIf ( TaggedIsSmi ( maybe_string ) , & not_string ) ; // Check to see if the input object is a string. If not, 
jump to // the label |not_string|. GotoIfNot ( IsString ( maybe_string ) , & not_string ) ; // Load the length of the string (having ended up in this code // path because we verified it was string above) and 
return it // using a CSA \"macro\" LoadStringLength. Return ( LoadStringLength ( maybe_string ) ) ; // Define the location of label that is the target of the failed // IsString check above. BIND ( & 
not_string ) ; // Input object isn't a string. Return the JavaScript undefined // constant. Return ( UndefinedConstant ( ) ) ; } Note that in the example above, there are two types of instructions used. There
are primitive CSA instructions that translate directly into one or two assembly instructions like GotoIf and Return . There are a fixed set of pre-defined CSA primitive instructions roughly corresponding to 
the most commonly used assembly instructions you would find on one of V8\u2019s supported chip architectures. Others instructions in the example are macro instructions, like LoadStringLength , TaggedIsSmi , 
and IsString , that are convenience functions to output one or more primitive or macro instructions inline. Macro instructions are used to encapsulate commonly used V8 implementation idioms for easy reuse. 
They can be arbitrarily long and new macro instructions can be easily defined by V8 developers whenever needed. After compiling V8 with the above changes, we can run mksnapshot , the tool that compiles 
builtins to prepare them for V8\u2019s snapshot, with the --print-code command-line option. This options prints the generated assembly code for each builtin. If we grep for GetStringLength in the output, we 
get the following result on x64 (the code output is cleaned up a bit to make it more readable): test al , 0x1 jz not_string movq rbx , | rax - 0x1 ] cmpb | rbx + 0xb ] , 0x80 jnc not_string movq rax , | rax +
0xf ] retl not_string: movq rax , | r13 - 0x60 ] retl On 32-bit ARM platforms, the following code is generated by mksnapshot : tst r0 , #1 beq + 28 - > not_string ldr r1 , | r0 , #-1 ] ldrb r1 , | r1 , #+7 ] 
cmp r1 , #128 bge + 12 - > not_string ldr r0 , | r0 , #+7 ] bx lr not_string: ldr r0 , | r10 , #+16 ] bx lr Even though our new builtin uses a non-standard (at least non-C++) calling convention, it\u2019s 
possible to write test cases for it. The following code can be added to test-run-stubs.cc to test the builtin on all platforms: TEST ( GetStringLength ) { HandleAndZoneScope scope ; Isolate * isolate = scope 
. main_isolate ( ) ; Heap * heap = isolate -> heap ( ) ; Zone * zone = scope . main_zone ( ) ; // Test the case where input is a string StubTester tester ( isolate , zone , Builtins :: kGetStringLength ) ; 
Handle < String > input_string ( isolate -> factory ( ) -> NewStringFromAsciiChecked ( \"Oktoberfest\" ) ) ; Handle < Object > result1 = tester . Call ( input_string ) ; CHECK_EQ ( 11 , Handle < Smi > :: cast
( result1 ) -> value ( ) ) ; // Test the case where input is not a string (e.g. undefined) Handle < Object > result2 = tester . Call ( factory -> undefined_value ( ) ) ; CHECK ( result2 -> IsUndefined ( 
isolate ) ) ; } For more details about using the CSA for different kinds of builtins and for further examples, see this wiki page . A V8 developer velocity multiplier # The CSA is more than just an universal 
assembly language that targets multiple platforms. It enables much quicker turnaround when implementing new features compared to hand-writing code for each architecture as we used to do. It does this by 
providing all of the benefits of hand-written assembly while protecting developers against its most treacherous pitfalls: With the CSA, developers can write builtin code with a cross-platform set of low-level
primitives that translate directly to assembly instructions. The CSA\u2019s instruction selector ensures that this code is optimal on all of the platforms that V8 targets without requiring V8 developers to be
experts in each of those platform\u2019s assembly languages. The CSA\u2019s interface has optional types to ensure that the values manipulated by the low-level generated assembly are of the type that the code
author expects. Register allocation between assembly instructions is done by the CSA automatically rather than explicitly by hand, including building stack frames and spilling values to the stack if a builtin
uses more registers than available or makes call. This eliminates a whole class of subtle, hard-to-find bugs that plagued hand-written assembly builtins. By making the generated code less fragile the CSA 
drastically reduces the time required to write correct low-level builtins. The CSA understands ABI calling conventions\u2014both standard C++ and internal V8 register-based ones\u2014making it possible to 
easily interoperate between CSA-generated code and other parts of V8. Since CSA code is C++, it\u2019s easy to encapsulate common code generation patterns in macros that can be easily reused in many builtins.
Because V8 uses the CSA to generate the bytecode handlers for Ignition, it is very easy to inline the functionality of CSA-based builtins directly into the handlers to improve the interpreter\u2019s 
performance. V8\u2019s testing framework supports testing CSA functionality and CSA-generated builtins from C++ without having to write assembly adapters. All in all, the CSA has been a game changer for V8 
development. It has significantly improved the team\u2019s ability to optimize V8. That means we are able to optimize more of the JavaScript language faster for V8\u2019s embedders. Posted by Daniel Clifford 
, CodeStubAssembler assembler. Retweet this article! Branding Terms Privacy Twitter Edit this page on GitHub Except as otherwise noted, any code samples from the V8 project are licensed under V8\u2019s 
BSD-style license . Other content on this page is licensed under the Creative Commons Attribution 3.0 License . For details, see our site policies ."
  },
  {
    "topic": "V8 JavaScript Engine",
    "file": "v8/v8.dev/blog/v8-release-64.txt",
    "similarity": 0.557,
    "content_preview": "Topic: V8 JavaScript Engine\nFile: v8/v8.dev/blog/v8-release-64.txt\n\nV8 release v6.4 \u00b7 V8 V8 Show navigation Home Blog Docs Tools JS/Wasm features Research V8 release v6.4 
Published 19 December 2017 \u00b7 Tagged with release Every six weeks, we create a new branch of V8 as part of our release process . Each version is branched from V8\u2019s Git master immediately before a 
Chrome Beta milestone. Today we\u2019re pleased to announce our newest branch, V8 version 6.4 , which is in beta until its release in coordination with Chrome 64 Stable in several weeks. V8 v6.4 is filled 
with all sorts of developer-facing goodies. This post provides a preview of some of the highlights in anticipation of the release. Speed # V8 v6.4 improves the performance of the instanceof operator by 
3.6\u00d7. As a direct result, uglify-js is now 15\u201320% faster according to V8\u2019s Web Tooling Benchmark . This release also addresses some performance cliffs in Function.prototype.bind . For example, 
TurboFan now consistently inlines all monomorphic calls to bind . In addition, TurboFan also supports the bound callback pattern , meaning that instead of the following: doSomething ( callback , someObj ) ; 
You can now use: doSomething ( callback . bind ( someObj ) ) ; This way, the code is more readable, and you still get the same performance. Thanks to Peter Wong \u2019s latest contributions, WeakMap and 
WeakSet are now implemented using the CodeStubAssembler , resulting in performance improvements of up to 5\u00d7 across the board. As part of V8\u2019s on-going effort to improve the performance of array 
built-ins, we improved Array.prototype.slice performance ~4\u00d7 by reimplementing it using the CodeStubAssembler. Additionally, calls to Array.prototype.map and Array.prototype.filter are now inlined for 
many cases, giving them a performance profile competitive with hand-written versions. We worked to make out-of-bounds loads in arrays, typed arrays, and strings no longer incur a ~10\u00d7 performance hit 
after noticing this coding pattern being used in the wild. Memory # V8\u2019s built-in code objects and bytecode handlers are now deserialized lazily from the snapshot, which can significantly reduce memory 
consumed by each Isolate. Benchmarks in Chrome show savings of several hundred KB per tab when browsing common sites. Look out for a dedicated blog post on this subject early next year. ECMAScript language 
features # This V8 release includes support for two new exciting regular expression features. In regular expressions with the /u flag, Unicode property escapes are now enabled by default. const 
regexGreekSymbol = / \\p{Script_Extensions=Greek} / u ; regexGreekSymbol . test ( '\u03c0' ) ; // \u2192 true Support for named capture groups in regular expressions is now enabled by default. const pattern =
/ (?<year>\\d{4})-(?<month>\\d{2})-(?<day>\\d{2}) / u ; const result = pattern . exec ( '2017-12-15' ) ; // result.groups.year === '2017' // result.groups.month === '12' // result.groups.day === '15' More 
details about these features are available in our blog post titled Upcoming regular expression features . Thanks to Groupon , V8 now implements import.meta , which enables embedders to expose host-specific 
metadata about the current module. For example, Chrome 64 exposes the module URL via import.meta.url , and Chrome plans to add more properties to import.meta in the future. To assist with local-aware 
formatting of strings produced by internationalization formatters, developers can now use Intl.NumberFormat.prototype.formatToParts() to format a number to a list of tokens and their type. Thanks to Igalia 
for implementing this in V8! V8 API # Please use git log branch-heads/6.3..branch-heads/6.4 include/v8.h to get a list of the API changes. Developers with an active V8 checkout can use git checkout -b 6.4 -t 
branch-heads/6.4 to experiment with the new features in V8 v6.4. Alternatively you can subscribe to Chrome\u2019s Beta channel and try the new features out yourself soon. Posted by the V8 team. Retweet this 
article! Branding Terms Privacy Twitter Edit this page on GitHub Except as otherwise noted, any code samples from the V8 project are licensed under V8\u2019s BSD-style license . Other content on this page is 
licensed under the Creative Commons Attribution 3.0 License . For details, see our site policies ."
  },
  {
    "topic": "V8 JavaScript Engine",
    "file": "v8/v8.dev/blog/wasm-code-caching.txt",
    "similarity": 0.553,
    "content_preview": "Topic: V8 JavaScript Engine\nFile: v8/v8.dev/blog/wasm-code-caching.txt\n\nCode caching for WebAssembly developers \u00b7 V8 V8 Show navigation Home Blog Docs Tools JS/Wasm features 
Research Code caching for WebAssembly developers Published 17 June 2019 \u00b7 Tagged with WebAssembly internals There\u2019s a saying among developers that the fastest code is code that doesn\u2019t run. 
Likewise, the fastest compiling code is code that doesn\u2019t have to be compiled. WebAssembly code caching is a new optimization in Chrome and V8 that tries to avoid code compilation by caching the native 
code produced by the compiler. We\u2019ve written about how Chrome and V8 cache JavaScript code in the past, and best practices for taking advantage of this optimization. In this blog post, we describe the 
operation of Chrome\u2019s WebAssembly code cache and how developers can take advantage of it to speed up loading for applications with large WebAssembly modules. WebAssembly compilation recap # WebAssembly 
is a way to run non-JavaScript code on the Web. A web app can use WebAssembly by loading a .wasm resource, which contains partially compiled code from another language, such as C, C++, or Rust (and more to 
come.) The WebAssembly compiler\u2019s job is to decode the .wasm resource, validate that it is well-formed, and then compile it to native machine code that can be executed on the user\u2019s machine. V8 has 
two compilers for WebAssembly: Liftoff and TurboFan. Liftoff is the baseline compiler, which compiles modules as quickly as possible so execution can begin as soon as possible. TurboFan is V8\u2019s 
optimizing compiler for both JavaScript and WebAssembly. It runs in the background to generate high-quality native code to give a web app optimal performance over the long term. For large WebAssembly modules,
TurboFan can take significant amounts of time \u2014 30 seconds to a minute or more \u2014 to completely finish compiling a WebAssembly module to native code. That\u2019s where code caching comes in. Once 
TurboFan has finished compiling a large WebAssembly module, Chrome can save the code in its cache so that the next time the module is loaded, we can skip both Liftoff and TurboFan compilation, leading to 
faster startup and reduced power consumption \u2014 compiling code is very CPU-intensive. WebAssembly code caching uses the same machinery in Chrome that is used for JavaScript code caching. We use the same 
type of storage, and the same double-keyed caching technique that keeps code compiled by different origins separate in accordance with site isolation , an important Chrome security feature. WebAssembly code 
caching algorithm # For now, WebAssembly caching is only implemented for the streaming API calls, compileStreaming and instantiateStreaming . These operate on an HTTP fetch of a .wasm resource, making it 
easier to use Chrome\u2019s resource fetching and caching mechanisms, and providing a handy resource URL to use as the key to identify the WebAssembly module. The caching algorithm works as follows: When a 
.wasm resource is first requested (i.e. a cold run ), Chrome downloads it from the network and streams it to V8 to compile. Chrome also stores the .wasm resource in the browser\u2019s resource cache, stored 
in the file system of the user\u2019s device. This resource cache allows Chrome to load the resource faster the next time it\u2019s needed. When TurboFan has completely finished compiling the module, and if 
the .wasm resource is large enough (currently 128 kB), Chrome writes the compiled code to the WebAssembly code cache. This code cache is physically separate from the resource cache in step 1. When a .wasm 
resource is requested a second time (i.e. a hot run ), Chrome loads the .wasm resource from the resource cache and simultaneously queries the code cache. If there is a cache hit, then the compiled module 
bytes are sent to the renderer process and passed to V8 which deserializes the code instead of compiling the module. Deserializing is faster and less CPU-intensive than compiling. It may be that the cached 
code is no longer valid. This can happen because the .wasm resource has changed, or because V8 has changed, something that is expected to happen at least every 6 weeks because of Chrome\u2019s rapid release 
cycle. In this case the cached native code is cleared from the cache, and compilation proceeds as in step 1. Based on this description, we can give some recommendations for improving your website\u2019s use 
of the WebAssembly code cache. Tip 1: use the WebAssembly streaming API # Since code caching only works with the streaming API, compile or instantiate your WebAssembly module with compileStreaming or 
instantiateStreaming , as in this JavaScript snippet: ( async ( ) => { const fetchPromise = fetch ( 'fibonacci.wasm' ) ; const { instance } = await WebAssembly . instantiateStreaming ( fetchPromise ) ; const 
result = instance . exports . fibonacci ( 42 ) ; console . log ( result ) ; } ) ( ) ; This article goes into detail about the advantages of using the WebAssembly streaming API. Emscripten tries to use this 
API by default when it generates loader code for your app. Note that streaming requires that the .wasm resource has the correct MIME type, so the server must send the Content-Type: application/wasm header in 
its response. Tip 2: be cache-friendly # Since code caching depends on the resource URL and whether the .wasm resource is up-to-date, developers should try to keep those both stable. If the .wasm resource is 
fetched from a different URL, it is considered different and V8 has to compile the module again. Similarly, if the .wasm resource is no longer valid in the resource cache, then Chrome has to throw away any 
cached code. Keep your code stable # Whenever you ship a new WebAssembly module, it must be completely recompiled. Ship new versions of your code only when necessary to deliver new features or fix bugs. When 
your code hasn\u2019t changed, let Chrome know. When the browser makes an HTTP request for a resource URL, such as a WebAssembly module, it includes the date and time of the last fetch of that URL. If the 
server knows that the file hasn\u2019t changed, it can send back a 304 Not Modified response, which tells Chrome and V8 that the cached resource and therefore the cached code are still valid. On the other 
hand, returning a 200 OK response updates the cached .wasm resource and invalidates the code cache, reverting WebAssembly back to a cold run. Follow web resource best practices by using the response to inform
the browser about whether the .wasm resource is cacheable, how long it\u2019s expected to be valid, or when it was last modified. Don\u2019t change your code\u2019s URL # Cached compiled code is associated 
with the URL of the .wasm resource, which makes it easy to look up without having to scan the actual resource. This means that changing the URL of a resource (including any query parameters!) creates a new 
entry in our resource cache, which also requires a complete recompile and creates a new code cache entry. Go big (but not too big!) # The principal heuristic of WebAssembly code caching is the size of the 
.wasm resource. If the .wasm resource is smaller than a certain threshold size, we don\u2019t cache the compiled module bytes. The reasoning here is that V8 can compile small modules quickly, possibly faster 
than loading the compiled code from the cache. At the moment, the cutoff is for .wasm resources of 128 kB or more. But bigger is better only up to a point. Because caches take up space on the user\u2019s 
machine, Chrome is careful not to consume too much space. Right now, on desktop machines, the code caches typically hold a few hundred megabytes of data. Since the Chrome caches also restrict the largest 
entries in the cache to some fraction of the total cache size, there is a further limit of about 150 MB for the compiled WebAssembly code (half the total cache size). It is important to note that compiled 
modules are often 5\u20137 times larger than the corresponding .wasm resource on a typical desktop machine. This size heuristic, like the rest of the caching behavior, may change as we determine what works 
best for users and developers. Use a service worker # WebAssembly code caching is enabled for workers and service workers, so it\u2019s possible to use them to load, compile, and cache a new version of code 
so it\u2019s available the next time your app starts. Every web site must perform at least one full compilation of a WebAssembly module \u2014 use workers to hide that from your users. Tracing # As a 
developer, you might want to check that your compiled module is being cached by Chrome. WebAssembly code caching events are not exposed by default in Chrome\u2019s Developer Tools, so the best way to find out
whether your modules are being cached is to use the slightly lower-level chrome://tracing feature. chrome://tracing records instrumented traces of Chrome during some period of time. Tracing records the 
behavior of the entire browser, including other tabs, windows, and extensions, so it works best when done in a clean user profile, with extensions disabled, and with no other browser tabs open: # Start a new 
Chrome browser session with a clean user profile and extensions disabled google-chrome --user-data-dir = \" $( mktemp -d ) \" --disable-extensions Navigate to chrome://tracing and click \u2018Record\u2019 to 
begin a tracing session. On the dialog window that appears, click \u2018Edit Categories\u2019 and check the devtools.timeline category on the right side under \u2018Disabled by Default Categories\u2019 (you 
can uncheck any other pre-selected categories to reduce the amount of data collected). Then click the \u2018Record\u2019 button on the dialog to begin the trace. In another tab load or reload your app. Let it
run long enough, 10 seconds or more, to make sure TurboFan compilation completes. When done, click \u2018Stop\u2019 to end the trace. A timeline view of events appears. At the top right of the tracing window,
there is a text box, just to the right of \u2018View Options\u2019. Type v8.wasm to filter out non-WebAssembly events. You should see one or more of the following events: v8.wasm.streamFromResponseCallback 
\u2014 The resource fetch passed to instantiateStreaming received a response. v8.wasm.compiledModule \u2014 TurboFan finished compiling the .wasm resource. v8.wasm.cachedModule \u2014 Chrome wrote the 
compiled module to the code cache. v8.wasm.moduleCacheHit \u2014 Chrome found the code in its cache while loading the .wasm resource. v8.wasm.moduleCacheInvalid \u2014 V8 wasn\u2019t able to deserialize the 
cached code because it was out of date. On a cold run, we expect to see v8.wasm.streamFromResponseCallback and v8.wasm.compiledModule events. This indicates that the WebAssembly module was received, and 
compilation succeeded. If neither event is observed, check that your WebAssembly streaming API calls are working correctly. After a cold run, if the size threshold was exceeded, we also expect to see a 
v8.wasm.cachedModule event, meaning that the compiled code was sent to the cache. It is possible that we get this event but that the write doesn\u2019t succeed for some reason. There is currently no way to 
observe this, but metadata on the events can show the size of the code. Very large modules may not fit in the cache. When caching is working correctly, a hot run produces two events: 
v8.wasm.streamFromResponseCallback and v8.wasm.moduleCacheHit . The metadata on these events allows you to see the size of the compiled code. For more on using chrome://tracing , see our article on JavaScript
(byte)code caching for developers . Conclusion # For most developers, code caching should \u201cjust work\u201d. It works best, like any cache, when things are stable. Chrome\u2019s caching heuristics may 
change between versions, but code caching does have behaviors that can be used, and limitations which can be avoided. Careful analysis using chrome://tracing can help you tweak and optimize the use of the 
WebAssembly code cache by your web app. Posted by Bill Budge , putting the Ca-ching! in caching. Retweet this article! Branding Terms Privacy Twitter Edit this page on GitHub Except as otherwise noted, any 
code samples from the V8 project are licensed under V8\u2019s BSD-style license . Other content on this page is licensed under the Creative Commons Attribution 3.0 License . For details, see our site policies
."
  }
]
[Step 1: Duration 11.76 seconds| Input tokens: 2,339 | Output tokens: 611]
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ Step 2 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'PickSection' with arguments: {'task': 'Autonomously select a promising V8 code region related to the JIT/IC pipeline for deeper analysis and later fuzzing template generation. Do not take   │
│ any hints from me; freely choose a target area you assess as impactful for stability/security (e.g., parts of feedback collection, IC state transitions, or optimizing compiler interactions). Return the    │
│ concrete subsystem/file(s)/classes/functions and a brief rationale.'}                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── New run - PickSection ────────────────────────────────────────────────────────────────────────────────────────────╮
│                                                                                                                                                                                                              │
│ You're a helpful agent named 'PickSection'.                                                                                                                                                                  │
│ You have been submitted this task by your manager.                                                                                                                                                           │
│ ---                                                                                                                                                                                                          │
│ Task:                                                                                                                                                                                                        │
│ Autonomously select a promising V8 code region related to the JIT/IC pipeline for deeper analysis and later fuzzing template generation. Do not take any hints from me; freely choose a target area you      │
│ assess as impactful for stability/security (e.g., parts of feedback collection, IC state transitions, or optimizing compiler interactions). Return the concrete subsystem/file(s)/classes/functions and a    │
│ brief rationale.                                                                                                                                                                                             │
│ ---                                                                                                                                                                                                          │
│ You're helping your manager solve a wider task: so make sure to not provide a one-line answer, but give as much information as possible to give them a clear understanding of the answer.                    │
│                                                                                                                                                                                                              │
│ Your final_answer WILL HAVE to contain these parts:                                                                                                                                                          │
│ ### 1. Task outcome (short version):                                                                                                                                                                         │
│ ### 2. Task outcome (extremely detailed version):                                                                                                                                                            │
│ ### 3. Additional context (if relevant):                                                                                                                                                                     │
│                                                                                                                                                                                                              │
│ Put all these in your final_answer tool, everything that you do not pass as an argument to final_answer will be lost.                                                                                        │
│ And even if your task resolution is not successful, please return as much context as possible, so that your manager can act upon this feedback.                                                              │
│                                                                                                                                                                                                              │
╰─ LiteLLMModel - gpt-5 ───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ Step 1 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'get_random_entry_data' with arguments: {}                                                                                                                                                     │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
Observations: this is entry data for regress/regress-crbug-977012
{"js": "// Copyright 2019 the V8 project authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nfunction foo(arg) {\n  var 
ret = { x: arg };\n  ret.__defineSetter__(\"y\", function() { });\n  return ret;\n}\n\n// v1 creates a map with a Smi field, v2 deprecates v1's map.\nlet v1 = foo(10);\nlet v2 = foo(10.5);\n\n// Trigger a 
PrepareForDataProperty on v1, which also triggers an update to\n// dictionary due to the different accessors on v1 and v2's y property.\nv1.x = 20.5;\n", "Fuzzilli": "v0 <- BeginPlainFunction -> v1\n    
BeginObjectLiteral\n        ObjectLiteralAddProperty `x`, v1\n    v2 <- EndObjectLiteral\n    v3 <- CreateNamedVariable 'ret', 'var', v2\n    v4 <- LoadString 'y'\n    v5 <- BeginPlainFunction -> \n    
EndPlainFunction\n    v6 <- CallMethod v3, '__defineSetter__', |v4, v5]\n    Return v3\nEndPlainFunction\nv7 <- LoadInteger '10'\nv8 <- CallFunction v0, |v7]\nv9 <- CreateNamedVariable 'v1', 'let', v8\nv10 <-
LoadFloat '10.5'\nv11 <- CallFunction v0, |v10]\nv12 <- CreateNamedVariable 'v2', 'let', v11\nv13 <- LoadFloat '20.5'\nSetProperty v9, 'x', v13\n\n\nfunction foo(a1) {\n    var ret = { x: a1 };\n    function 
f5() {\n    }\n    ret.__defineSetter__(\"y\", f5);\n    return ret;\n}\nlet v1 = foo(10);\nlet v2 = foo(10.5);\nv1.x = 20.5;", "execution_data": 
"--no-experimental\n--abort-on-contradictory-flags\n--no-exit-on-contradictory-flags\n--no-allow-overwriting-for-next-flag\n--no-use-strict\n--no-trace-temporal\n--no-harmony\n--harmony-shipping\n--no-js-stag
ing\n--js-shipping\n--no-harmony-shadow-realm\n--no-harmony-struct\n--no-js-decorators\n--no-js-source-phase-imports\n--no-harmony-temporal\n--harmony-import-attributes\n--js-regexp-duplicate-named-groups\n--
js-regexp-modifiers\n--js-promise-try\n--js-atomics-pause\n--js-error-iserror\n--js-regexp-escape\n--js-explicit-resource-management\n--js-float16array\n--js-base-64\n--builtin-subclassing\n--no-enable-shared
arraybuffer-per-context\n--no-for-of-optimization\n--no-stress-snapshot\n--no-lite-mode\n--enable-allocation-folding\n--no-disable-write-barriers\n--no-enable-unconditional-write-barriers\n--no-single-generat
ion\n--no-conservative-stack-scanning\n--no-direct-handle\n--no-scavenger-conservative-object-pinning\n--no-stress-scavenger-conservative-object-pinning\n--no-stress-scavenger-conservative-object-pinning-rand
om\n--no-scavenger-precise-object-pinning\n--no-precise-object-pinning\n--scavenger-promote-quarantined-pages\n--no-local-off-stack-check\n--no-experimental-fuzzing\n--no-future\n--no-force-emit-interrupt-bud
get-checks\n--maglev\n--no-maglev-future\n--no-optimize-on-next-call-optimizes-to-maglev\n--no-stress-maglev\n--no-maglev-as-top-tier\n--maglev-inlining\n--maglev-loop-peeling\n--maglev-optimistic-peeled-loop
s\n--maglev-loop-peeling-max-size=400\n--maglev-loop-peeling-max-size-cumulative=900\n--maglev-deopt-data-on-background\n--maglev-build-code-on-background\n--maglev-destroy-on-background\n--no-maglev-inline-a
pi-calls\n--maglev-cons-string-elision\n--maglev-pretenure-store-values\n--maglev-poly-calls\n--maglev-truncation\n--no-maglev-licm\n--concurrent-maglev-max-threads=2\n--no-concurrent-maglev-high-priority-thr
eads\n--max-maglev-inline-depth=1\n--max-maglev-hard-inline-depth=10\n--max-maglev-inlined-bytecode-size=100\n--max-maglev-inlined-bytecode-size-cumulative=920\n--max-maglev-inlined-bytecode-size-small-total=
3000\n--max-maglev-inlined-bytecode-size-small=27\n--max-maglev-inlined-bytecode-size-small-with-heapnum-in-out=75\n--min-maglev-inlining-frequency=0.95\n--maglev-reuse-stack-slots\n--maglev-untagged-phis\n--
maglev-hoist-osr-value-phi-untagging\n--no-maglev-speculative-hoist-phi-untagging\n--maglev-cse\n--no-maglev-non-eager-inlining\n--no-turbolev-non-eager-inlining\n--maglev-filter=\"*\"\n--maglev-print-filter=
\"*\"\n--no-maglev-assert\n--maglev-assert-stack-size\n--no-maglev-break-on-entry\n--maglev-print-bytecode\n--maglev-print-feedback\n--maglev-print-inlined\n--print-maglev-code\n--no-trace-maglev-graph-buildi
ng\n--no-trace-maglev-loop-speeling\n--no-trace-maglev-inlining\n--no-trace-maglev-kna-processor\n--no-print-maglev-deopt-verbose\n--print-maglev-graph\n--print-maglev-graphs\n--no-trace-maglev-phi-untagging\
n--no-trace-maglev-regalloc\n--no-maglev-stats\n--no-maglev-stats-nvp\n--maglev-function-context-specialization\n--no-specialize-code-for-one-byte-seq-strings\n--additive-safe-int-feedback\n--enable-enumerate
d-keyed-access-bytecode\n--no-dict-property-const-tracking\n--script-context-cells\n--function-context-cells\n--function-context-cells-max-size=1\n--empty-context-extension-dep\n--json-stringify-fast-path\n--
cache-property-key-string-adds\n--smi-string-cache-size=8192\n--double-string-cache-size=4096\n--no-trace-number-string-cache\n--maglev-inline-date-accessors\n--turbofan-inline-date-accessors\n--inline-date-a
ccessors\n--extensible-ro-snapshot\n--max-opt=999\n--efficiency-mode=unset\n--battery-saver-mode=unset\n--memory-saver-mode=unset\n--no-efficiency-mode-disable-turbofan\n--efficiency-mode-delay-turbofan-multi
ply=3\n--wasm-trace-native=\"\"\n--no-jitless\n--no-disable-optimizing-compilers\n--memory-protection-keys\n--no-force-memory-protection-keys\n--no-assert-types\n--no-turboshaft-assert-types\n--no-verify-simp
lified-lowering\n--no-trace-compilation-dependencies\n--no-unmap-holes\n--no-assert-hole-checked-by-value\n--allocation-site-tracking\n--allocation-site-pretenuring\n--page-promotion\n--page-promotion-thresho
ld=70\n--minor-ms-page-promotion-threshold=50\n--minor-ms-page-promotion-max-lab-threshold=30\n--minor-ms-max-page-age=4\n--no-trace-page-promotions\n--trace-pretenuring\n--no-trace-pretenuring-statistics\n--
no-trace-resize-large-object\n--track-field-types\n--no-trace-block-coverage\n--trace-protector-invalidation\n--decommit-pooled-pages\n--zero-unused-memory\n--no-high-end-android\n--high-end-android-physical-
memory-threshold=4294967295\n--no-minor-ms-shortcut-strings\n--no-feedback-normalization\n--internalize-on-the-fly\n--unbox-double-arrays\n--string-slices\n--invocation-count-for-feedback-allocation=8\n--invo
cation-count-for-maglev=400\n--invocation-count-for-maglev-osr=100\n--osr-from-maglev\n--osr-from-maglev-interrupt-scale-factor=0.8\n--no-always-osr-from-maglev\n--invocation-count-for-turbofan=16000\n--invoc
ation-count-for-osr=800\n--osr-to-tierup=1\n--minimum-invocations-after-ic-update=500\n--minimum-invocations-before-optimization=2\n--no-jit-fuzzing\n--use-std-math-pow\n--use-ic\n--lazy-feedback-allocation\n
--no-stress-ic\n--ignition-elide-noneffectful-bytecodes\n--ignition-reo\n--ignition-filter-expression-positions\n--ignition-share-named-property-feedback\n--ignition-elide-redundant-tdz-checks\n--print-byteco
de\n--enable-lazy-source-positions\n--no-stress-lazy-source-positions\n--print-bytecode-filter=\"*\"\n--omit-default-ctors\n--no-trace-ignition-codegen\n--trace-ignition-dispatches-output-file=\"\"\n--no-trac
e-track-allocation-sites\n--trace-migration\n--trace-generalization\n--reuse-scope-infos\n--sparkplug\n--no-always-sparkplug\n--baseline-batch-compilation\n--concurrent-sparkplug\n--concurrent-sparkplug-max-t
hreads=1\n--no-concurrent-sparkplug-high-priority-threads\n--sparkplug-filter=\"*\"\n--no-sparkplug-needs-short-builtins\n--baseline-batch-compilation-threshold=4096\n--no-trace-baseline\n--no-trace-baseline-
batch-compilation\n--no-shared-string-table\n--no-always-use-string-forwarding-table\n--no-transition-strings-during-gc-with-stack\n--initial-shared-heap-size=0\n--max-shared-heap-size=0\n--no-concurrent-buil
tin-generation\n--concurrent-recompilation\n--no-trace-concurrent-recompilation\n--concurrent-recompilation-queue-length=8\n--concurrent-recompilation-delay=0\n--concurrent-recompilation-front-running\n--conc
urrent-turbofan-max-threads=4\n--no-stress-concurrent-inlining\n--maglev-overwrite-budget\n--maglev-overwrite-osr-budget\n--no-stress-concurrent-inlining-attach-code\n--max-serializer-nesting=25\n--no-trace-h
eap-broker-verbose\n--no-trace-heap-broker\n--stress-runs=0\n--deopt-every-n-times=0\n--no-print-deopt-stress\n--turbofan\n--opt\n--no-stress-turbo-late-spilling\n--turbo-wasm-address-reassociation\n--no-conc
urrent-turbo-tracing\n--no-optimize-maglev-optimizes-to-turbofan\n--turbo-filter=\"*\"\n--no-trace-turbo\n--trace-turbo-path=\"\"\n--trace-turbo-filter=\"*\"\n--no-trace-turbo-graph\n--no-trace-turbo-schedule
d\n--trace-turbo-file-prefix=\"turbo\"\n--trace-turbo-cfg-file=\"turbo.cfg\"\n--trace-turbo-types\n--no-trace-turbo-scheduler\n--no-trace-turbo-reduction\n--no-trace-turbo-bailouts\n--no-trace-turbo-trimming\
n--no-trace-turbo-jt\n--no-trace-turbo-ceq\n--no-trace-turbo-loop\n--no-trace-turbo-alloc\n--no-trace-all-uses\n--no-trace-representation\n--no-trace-turbo-stack-accesses\n--no-fuzzing-and-concurrent-recompil
ation\n--turbo-verify\n--turbo-verify-machine-graph=\"\"\n--no-verify-csa\n--no-trace-verify-csa\n--csa-trap-on-node=\"\"\n--builtins-effects-src=\"\"\n--fixed-array-bounds-checks\n--no-turbo-stats\n--no-turb
o-stats-nvp\n--no-turbo-stats-wasm\n--turbo-splitting\n--turbo-inlining\n--turbo-elide-frames\n--max-inlined-bytecode-size=460\n--max-inlined-bytecode-size-cumulative=920\n--max-turbolev-inlined-bytecode-size
-cumulative=1840\n--max-inlined-bytecode-size-absolute=4600\n--max-inlined-bytecode-size-small-total=30000\n--reserve-inline-budget-scale-factor=1.2\n--max-inlined-bytecode-size-small=27\n--max-inlined-byteco
de-size-small-with-heapnum-in-out=75\n--max-optimized-bytecode-size=61440\n--min-inlining-frequency=0.05\n--no-stress-inline\n--no-trace-turbo-inlining\n--turbo-inline-array-builtins\n--use-osr\n--maglev-osr\
n--concurrent-osr\n--maglev-allocation-folding=2\n--maglev-escape-analysis\n--no-trace-maglev-escape-analysis\n--no-maglev-object-tracking\n--trace-maglev-object-tracking\n--no-turbo-string-builder\n--trace-o
sr\n--log-or-trace-osr\n--analyze-environment-liveness\n--no-trace-environment-liveness\n--turbo-load-elimination\n--trace-turbo-load-elimination\n--no-turbo-profiling\n--no-turbo-profiling-verbose\n--turbo-p
rofiling-output=\"\"\n--no-reorder-builtins\n--no-abort-on-bad-builtin-profile-data\n--no-warn-about-builtin-profile-data\n--dump-builtins-hashes-to-file=\"\"\n--turbo-verify-allocation\n--turbo-move-optimiza
tion\n--turbo-jt\n--turbo-loop-peeling\n--turbo-loop-variable\n--turbo-loop-rotation\n--turbo-cf-optimization\n--turbo-escape\n--turbo-allocation-folding\n--no-turbo-instruction-scheduling\n--no-turbo-stress-
instruction-scheduling\n--turbo-store-elimination\n--trace-store-elimination\n--turbo-typer-hardening\n--turbo-rewrite-far-jumps\n--no-stress-gc-during-compilation\n--turbo-fast-api-calls\n--no-fast-api-allow
-float-in-sim\n--no-turbo-compress-frame-translations\n--turbo-inline-js-wasm-calls\n--no-turbo-optimize-inlined-js-wasm-wrappers\n--turbo-optimize-apply\n--turbo-optimize-math-minmax\n--turboshaft\n--no-turb
oshaft-enable-debug-features\n--turboshaft-wasm-load-elimination\n--no-turboshaft-wasm-in-js-inlining\n--no-turbolev-inline-js-wasm-wrappers\n--turboshaft-load-elimination\n--turboshaft-loop-unrolling\n--turb
oshaft-string-concat-escape-analysis\n--no-turboshaft-typed-optimizations\n--no-turbolev\n--no-print-turbolev-frontend\n--no-turbolev-future\n--typed-array-length-loading\n--no-deduplicate-heap-number-request
s\n--no-turboshaft-verify-load-elimination\n--turboshaft-opt-bisect-limit=18446744073709551615\n--turboshaft-opt-bisect-break=18446744073709551615\n--no-turboshaft-verify-reductions\n--turboshaft-trace-typing
\n--turboshaft-trace-reduction\n--no-turboshaft-trace-intermediate-reductions\n--turboshaft-trace-emitted\n--no-turboshaft-trace-unrolling\n--no-turboshaft-trace-peeling\n--no-turboshaft-trace-load-eliminatio
n\n--no-turboshaft-trace-if-else-to-switch\n--trace-turbolev-graph-building\n--profile-guided-optimization\n--profile-guided-optimization-for-empty-feedback-vector\n--invocation-count-for-early-optimization=3
0\n--invocation-count-for-maglev-with-delay=600\n--no-optimize-for-size\n--reopt-after-lazy-deopts\n--no-verify-get-js-builtin-state\n--wasm-generic-wrapper\n--wasm-num-compilation-tasks=128\n--no-trace-wasm-
native-heap\n--no-trace-wasm-offheap-memory\n--no-print-wasm-offheap-memory-size\n--no-trace-wasm-serialization\n--wasm-async-compilation\n--no-wasm-test-streaming\n--wasm-native-module-cache\n--wasm-max-mem-
pages=4294967295\n--wasm-max-table-size=10000000\n--wasm-max-committed-code-mb=4095\n--wasm-max-code-space-size-mb=1024\n--wasm-tier-up\n--wasm-dynamic-tiering\n--no-wasm-sync-tier-up\n--wasm-tiering-budget=1
3000000\n--wasm-wrapper-tiering-budget=1000\n--max-wasm-functions=1000000\n--wasm-caching-threshold=1000\n--wasm-caching-hard-threshold=1000000\n--wasm-caching-timeout-ms=2000\n--no-trace-wasm-compilation-tim
es\n--wasm-tier-up-filter=-1\n--wasm-eager-tier-up-function=-1\n--no-trace-wasm-decoder\n--no-trace-wasm-compiler\n--no-trace-wasm-streaming\n--no-trace-wasm-stack-switching\n--no-stress-wasm-stack-switching\
n--wasm-stack-switching-stack-size=984\n--liftoff\n--no-liftoff-only\n--no-enable-testing-opcode-in-wasm\n--no-trace-liftoff\n--no-trace-wasm-memory\n--no-trace-wasm-globals\n--wasm-tier-mask-for-testing=0\n-
-wasm-debug-mask-for-testing=0\n--no-experimental-wasm-pgo-to-file\n--no-experimental-wasm-pgo-from-file\n--validate-asm\n--no-suppress-asm-messages\n--no-trace-asm-time\n--no-trace-asm-scanner\n--no-trace-as
m-parser\n--no-stress-validate-asm\n--no-dump-wasm-module\n--dump-wasm-module-path=\"\"\n--no-wasm-fast-api\n--wasm-deopt\n--wasm-deopts-per-function-limit=10\n--no-experimental-wasm-type-reflection\n--no-exp
erimental-wasm-instruction-tracing\n--no-experimental-wasm-custom-descriptors\n--no-experimental-wasm-shared\n--no-experimental-wasm-fp16\n--no-experimental-wasm-memory-control\n--no-experimental-wasm-wasmfx\
n--no-experimental-wasm-rab-integration\n--no-experimental-wasm-compilation-hints\n--no-experimental-wasm-stringref\n--no-experimental-wasm-imported-strings-utf8\n--no-experimental-wasm-growable-stacks\n--exp
erimental-wasm-legacy-eh\n--experimental-wasm-branch-hinting\n--experimental-wasm-exnref\n--no-experimental-wasm-assume-ref-cast-succeeds\n--no-experimental-wasm-ref-cast-nop\n--no-experimental-wasm-skip-null
-checks\n--no-experimental-wasm-skip-bounds-checks\n--no-experimental-wasm-js-interop\n--no-wasm-staging\n--wasm-opt\n--wasm-bounds-checks\n--wasm-stack-checks\n--no-wasm-enforce-bounds-checks\n--wasm-math-in
trinsics\n--no-wasm-inlining\n--wasm-inlining-budget=5000\n--wasm-inlining-max-size=500\n--wasm-inlining-factor=3\n--wasm-inlining-min-budget=50\n--no-wasm-inlining-ignore-call-counts\n--no-trace-wasm-inlinin
g\n--no-trace-wasm-typer\n--no-wasm-inlining-call-indirect\n--wasm-bulkmem-inlining\n--wasm-loop-unrolling\n--wasm-loop-peeling\n--wasm-loop-peeling-max-size=1000\n--no-trace-wasm-loop-peeling\n--no-wasm-fuzz
er-gen-test\n--no-print-wasm-code\n--print-wasm-code-function-index=-1\n--no-print-wasm-stub-code\n--asm-wasm-lazy-compilation\n--wasm-lazy-compilation\n--no-trace-wasm-lazy-compilation\n--no-wasm-lazy-valida
tion\n--no-wasm-simd-ssse3-codegen\n--wasm-code-gc\n--no-trace-wasm-code-gc\n--no-stress-wasm-code-gc\n--wasm-max-initial-code-space-reservation=0\n--no-stress-wasm-memory-moving\n--flush-liftoff-code\n--no-s
tress-branch-hinting\n--wasm-max-module-size=1073741824\n--wasm-disassembly-max-mb=1000\n--wasm-capi-thread-pool-size=0\n--trace-wasm\n--no-trace-wasm-instances\n--no-experimental-wasm-revectorize\n--no-trace
-wasm-revectorize\n--wasm-memory64-trap-handling\n--no-wasm-jitless\n--no-wasm-jitless-if-available-for-testing\n--no-wasm-allow-mixed-eh-for-testing\n--no-wasm-code-coverage\n--stress-sampling-allocation-pro
filer=0\n--no-lazy-new-space-shrinking\n--min-semi-space-size=0\n--max-semi-space-size=0\n--semi-space-growth-factor=2\n--max-old-space-size=0\n--max-heap-size=0\n--initial-heap-size=0\n--initial-old-space-si
ze=0\n--preconfigured-old-space-size=0\n--no-gc-global\n--random-gc-interval=0\n--gc-interval=-1\n--cppgc-random-gc-interval=0\n--retain-maps-for-n-gc=2\n--trace-gc\n--no-trace-gc-nvp\n--no-trace-gc-ignore-sc
avenger\n--no-trace-memory-reducer\n--trace-gc-verbose\n--no-trace-gc-freelists\n--no-trace-gc-freelists-verbose\n--no-trace-gc-heap-layout\n--trace-gc-heap-layout-ignore-minor-gc\n--no-trace-evacuation-candi
dates\n--no-trace-pending-allocations\n--trace-allocation-stack-interval=-1\n--trace-duplicate-threshold-kb=0\n--no-trace-fragmentation\n--no-trace-fragmentation-verbose\n--no-minor-ms-trace-fragmentation\n--
no-trace-evacuation\n--no-trace-mutator-utilization\n--incremental-marking\n--incremental-marking-task\n--incremental-marking-start-user-visible\n--no-incremental-marking-always-user-visible\n--incremental-ma
rking-soft-trigger=0\n--incremental-marking-hard-trigger=0\n--no-incremental-marking-unified-schedule\n--no-trace-unmapper\n--parallel-scavenge\n--minor-gc-task\n--minor-gc-task-trigger=80\n--minor-gc-task-wi
th-lower-priority\n--no-trace-parallel-scavenge\n--no-cppgc-young-generation\n--no-optimize-gc-for-battery\n--concurrent-marking\n--concurrent-marking-max-worker-num=7\n--concurrent-array-buffer-sweeping\n--n
o-stress-concurrent-allocation\n--parallel-marking\n--ephemeron-fixpoint-iterations=10\n--no-trace-concurrent-marking\n--concurrent-sweeping\n--parallel-compaction\n--parallel-pointer-update\n--parallel-weak-
ref-clearing\n--detect-ineffective-gcs-near-heap-limit\n--no-ineffective-gcs-forces-last-resort\n--ineffective-gc-size-threshold=0.8\n--ineffective-gc-mutator-utilization-threshold=0.4\n--no-trace-incremental
-marking\n--no-trace-stress-marking\n--no-trace-stress-scavenge\n--no-track-gc-object-stats\n--no-trace-gc-object-stats\n--no-trace-zone-stats\n--zone-stats-tolerance=1048576\n--no-trace-zone-type-stats\n--no
-trace-backing-store\n--gc-stats=0\n--track-detached-contexts\n--no-trace-detached-contexts\n--no-verify-heap\n--no-verify-heap-skip-remembered-set\n--verify-write-barriers\n--no-memory-reducer-respects-froze
n-state\n--move-object-start\n--memory-reducer\n--memory-reducer-favors-memory\n--memory-reducer-for-small-heaps\n--memory-reducer-gc-count=2\n--no-external-memory-accounted-in-global-limit\n--external-memory
-max-growing-factor=1.3\n--no-gc-speed-uses-counters\n--heap-growing-percent=0\n--v8-os-page-size=0\n--allocation-buffer-parking\n--compact\n--compact-code-space\n--no-compact-on-every-full-gc\n--compact-with
-stack\n--shortcut-strings-with-stack\n--no-stress-compaction\n--resize-large-object\n--no-stress-compaction-random\n--no-flush-baseline-code\n--flush-bytecode\n--bytecode-old-age=6\n--no-flush-code-based-on-
time\n--no-flush-code-based-on-tab-visibility\n--bytecode-old-time=30\n--no-stress-flush-code\n--no-trace-flush-code\n--use-marking-progress-bar\n--no-stress-per-context-marking-worklist\n--no-stress-incremen
tal-marking\n--memory-pool\n--memory-pool-share-memory-on-teardown\n--memory-pool-release-before-memory-pressure-gcs\n--no-memory-pool-release-on-malloc-failures\n--large-page-pool\n--max-large-page-pool-size
=32\n--large-page-pool-timeout=3\n--no-managed-zone-memory\n--no-fuzzer-gc-analysis\n--stress-marking=0\n--stress-scavenge=0\n--reclaim-unmodified-wrappers\n--parallel-reclaim-unmodified-wrappers\n--no-gc-exp
eriment-less-compaction\n--gc-memory-reducer-start-delay-ms=8000\n--no-concurrent-marking-high-priority-threads\n--no-disable-abortjs\n--no-randomize-all-allocations\n--no-manual-evacuation-candidates-selecti
on\n--no-clear-free-memory\n--idle-gc-on-context-disposal\n--no-trace-context-disposal\n--cppheap-incremental-marking\n--cppheap-concurrent-marking\n--no-memory-balancer\n--memory-balancer-c-value=3e-10\n--no
-trace-memory-balancer\n--late-heap-limit-check\n--reserve-contiguous-compressed-read-only-space\n--debug-code\n--no-trap-on-abort\n--no-slow-debug-code\n--no-code-comments\n--enable-sse3\n--enable-ssse3\n--e
nable-sse4-1\n--enable-sse4-2\n--enable-sahf\n--enable-avx\n--enable-avx2\n--enable-avx-vnni\n--enable-avx-vnni-int8\n--enable-fma3\n--enable-f16c\n--enable-bmi1\n--enable-bmi2\n--enable-lzcnt\n--enable-popcn
t\n--arm-arch=\"armv8\"\n--no-force-long-branches\n--mcpu=\"auto\"\n--partial-constant-pool\n--sim-arm64-optional-features=\"none\"\n--intel-jcc-erratum-mitigation\n--no-enable-source-at-csa-bind\n--enable-ar
mv7=unset\n--enable-vfp3=unset\n--enable-32dregs=unset\n--enable-neon=unset\n--enable-sudiv=unset\n--enable-armv8=unset\n--enable-regexp-unaligned-accesses\n--script-streaming\n--no-stress-background-compile\
n--concurrent-cache-deserialization\n--merge-background-deserialized-script-with-compilation-cache\n--no-verify-code-merge\n--no-experimental-embedder-instance-types\n--no-expose-gc\n--expose-gc-as=\"\"\n--no
-expose-externalize-string\n--no-expose-statistics\n--no-expose-trigger-failure\n--no-expose-ignition-statistics\n--stack-trace-limit=10\n--no-builtins-in-stack-traces\n--no-experimental-stack-trace-frames\n-
-no-disallow-code-generation-from-strings\n--no-expose-async-hooks\n--expose-cputracemark-as=\"\"\n--experimental-report-exceptions-from-callbacks\n--no-allow-unsafe-function-constructor\n--no-force-slow-path
\n--no-test-small-max-function-context-stub-size\n--inline-new\n--switch-table-spread-threshold=3\n--switch-table-min-cases=6\n--stress-lazy-compilation=0\n--no-trace\n--lazy\n--lazy-eval\n--lazy-streaming\n-
-no-max-lazy\n--trace-opt\n--trace-opt-status\n--trace-opt-verbose\n--no-trace-opt-stats\n--trace-deopt\n--no-log-deopt\n--no-trace-deopt-verbose\n--no-trace-file-names\n--no-always-osr\n--no-trace-serializer
\n--no-external-reference-stats\n--compilation-cache\n--cache-prototype-transitions\n--no-lazy-compile-dispatcher\n--lazy-compile-dispatcher-max-threads=0\n--no-trace-compiler-dispatcher\n--no-parallel-compil
e-tasks-for-eager-toplevel\n--no-parallel-compile-tasks-for-lazy\n--cpu-profiler-sampling-interval=1000\n--no-trace-side-effect-free-debug-evaluate\n--hard-abort\n--log-colour\n--no-expose-inspector-scripts\n
--inspector-live-edit\n--stack-size=984\n--max-stack-trace-source-length=300\n--no-clear-exceptions-on-js-entry\n--use-original-message-for-stack-trace\n--histogram-interval=600000\n--no-heap-profiler-trace-o
bjects\n--heap-profiler-use-embedder-graph\n--no-heap-snapshot-on-oom\n--heap-snapshot-on-gc=-1\n--heap-snapshot-string-limit=1024\n--no-heap-profiler-show-hidden-objects\n--no-profile-heap-snapshot\n--no-hea
p-snapshot-verify\n--no-sampling-heap-profiler-suppress-randomness\n--no-log-ic\n--no-fast-map-update\n--max-valid-polymorphic-map-count=4\n--clone-object-sidestep-transitions\n--fast-properties-soft-limit=12
\n--max-fast-properties=128\n--native-code-counters\n--super-ic\n--no-mega-dom-ic\n--no-trace-prototype-users\n--no-trace-for-in-enumerate\n--no-log-maps\n--log-maps-details\n--move-prototype-transitions-firs
t\n--allow-natives-syntax\n--no-allow-natives-for-differential-fuzzing\n--no-parse-only\n--no-enable-parser-ablation\n--no-enable-preparser-ablation\n--no-enable-bytecode-compiler-ablation\n--parser-ablation-
amount=0.8\n--preparser-ablation-amount=0.8\n--bytecode-compiler-ablation-amount=0.8\n--async-stack-traces\n--no-stack-trace-on-illegal\n--no-abort-on-uncaught-exception\n--no-correctness-fuzzer-suppressions\
n--no-rehash-snapshot\n--hash-seed=0\n--random-seed=0\n--fuzzer-random-seed=0\n--no-hashes-collide\n--no-trace-rail\n--no-print-all-exceptions\n--no-detailed-error-stack-trace\n--adjust-os-scheduling-paramete
rs\n--experimental-flush-embedded-blob-icache\n--allow-allocation-in-fast-api-call\n--short-builtin-calls\n--no-trace-code-range-allocation\n--better-code-range-allocation\n--no-abort-on-far-code-range\n--no-
runtime-call-stats\n--no-rcs\n--no-rcs-cpu-time\n--verify-snapshot-checksum\n--no-profile-deserialization\n--no-trace-deserialization\n--no-serialization-statistics\n--regexp-optimization\n--no-regexp-interpr
et-all\n--regexp-tier-up\n--regexp-tier-up-ticks=1\n--regexp-peephole-optimization\n--regexp-results-cache\n--no-regexp-assemble-from-bytecode\n--no-trace-regexp-peephole-optimization\n--no-trace-regexp-bytec
odes\n--no-trace-regexp-assembler\n--no-trace-regexp-parser\n--no-trace-regexp-tier-up\n--no-trace-regexp-graph\n--no-enable-experimental-regexp-engine\n--no-default-to-experimental-regexp-engine\n--no-experi
mental-regexp-engine-capture-group-opt\n--experimental-regexp-engine-capture-group-opt-max-memory-usage=1024\n--no-trace-experimental-regexp-engine\n--no-enable-experimental-regexp-engine-on-excessive-backtra
cks\n--regexp-backtracks-before-fallback=50000\n--regexp-simd\n--no-trace-read-only-promotion\n--no-trace-read-only-promotion-verbose\n--testing-bool-flag\n--testing-maybe-bool-flag=unset\n--testing-int-flag=
13\n--testing-float-flag=2.5\n--testing-string-flag=\"Hello, 
world!\"\n--testing-prng-seed=42\n--no-testing-d8-test-runner\n--no-strict-termination-checks\n--no-fuzzing\n--no-hole-fuzzing\n--no-sandbox-testing\n--no-sandbox-fuzzing\n--no-expose-memory-corruption-api\n-
-freeze-flags-after-init\n--no-cet-compatible\n--embedded-src=\"\"\n--embedded-variant=\"\"\n--startup-src=\"\"\n--startup-blob=\"\"\n--target-arch=\"\"\n--target-os=\"\"\n--no-target-is-simulator\n--turbo-pr
ofiling-input=\"\"\n--turbo-log-builtins-count-input=\"\"\n--text-is-readable\n--no-trace-minor-ms-parallel-marking\n--no-minor-ms\n--concurrent-minor-ms-marking\n--black-allocated-pages\n--no-sticky-mark-bit
s\n--minor-ms-min-new-space-capacity-for-concurrent-marking-mb=0\n--minor-ms-concurrent-marking-trigger=90\n--minor-ms-min-lab-size-kb=0\n--no-handle-weak-ref-weakly-in-minor-gc\n--no-help\n--print-flag-value
s\n--no-print-feature-flags-json\n--no-slow-histograms\n--no-use-external-strings\n--map-counters=\"\"\n--no-mock-arraybuffer-allocator\n--mock-arraybuffer-allocator-limit=0\n--no-multi-mapped-mock-allocator\
n--no-gdbjit\n--no-gdbjit-full\n--no-gdbjit-dump\n--gdbjit-dump-filter=\"\"\n--no-enable-slow-asserts\n--no-print-ast\n--print-scopes\n--no-trace-contexts\n--no-gc-verbose\n--no-code-stats\n--no-print-handles
\n--no-check-handle-count\n--no-print-global-handles\n--trace-turbo-escape\n--no-trace-module-status\n--no-trace-normalization\n--no-trace-lazy\n--no-trace-isolates\n--no-regexp-possessive-quantifier\n--no-pr
int-break-location\n--logfile=\"v8.log\"\n--no-logfile-per-isolate\n--no-log\n--no-log-all\n--no-log-internal-timer-events\n--no-log-timer-events\n--no-log-source-code\n--no-log-source-position\n--no-log-code
\n--no-log-feedback-vector\n--no-log-code-disassemble\n--no-log-function-events\n--no-detailed-line-info\n--no-prof-include-idle\n--no-perfetto-code-logger\n--prof-sampling-interval=1000\n--no-prof-cpp\n--pro
f-browser-mode\n--no-prof\n--no-ll-prof\n--no-perf-basic-prof\n--perf-basic-prof-path=\"/tmp\"\n--no-perf-basic-prof-only-functions\n--no-perf-prof\n--perf-prof-path=\".\"\n--no-perf-prof-annotate-wasm\n--no-
perf-prof-delete-file\n--no-perf-prof-unwinding-info\n--gc-fake-mmap=\"/tmp/__v8_gc__\"\n--no-redirect-code-traces\n--redirect-code-traces-to=\"code.asm\"\n--print-opt-source\n--no-vtune-prof-annotate-wasm\n-
-win64-unwinding-info\n--no-interpreted-frames-native-stack\n--no-enable-etw-stack-walking\n--no-etw-trace-debug\n--no-enable-etw-by-custom-filter-only\n--no-print-builtin-size\n--no-trace-elements-transition
s\n--no-trace-creation-allocation-sites\n--no-print-code\n--no-print-opt-code\n--print-opt-code-filter=\"*\"\n--no-print-code-verbose\n--no-print-builtin-code\n--print-builtin-code-filter=\"*\"\n--no-print-re
gexp-code\n--no-print-regexp-bytecode\n--no-predictable\n--no-predictable-and-random-seed-is-0\n--no-predictable-gc-schedule\n--no-single-threaded\n--no-single-threaded-gc\n--single-threaded-gc-in-background\
n--parallel-pause-for-gc-in-background\n--incremental-marking-for-gc-in-background\n--no-shared-heap\n--no-proto-assign-seq-opt\n--use-libm-trig-functions\n--no-verify-predictable\n--dump-allocations-digest-a
t-alloc=-1\nConcurrent maglev has been disabled for tracing.\n|2247692:0x206400138000] Shrinking page 0x206400004f80: end 0xefd00340000 -> 0xefd00309000\nGlobal scope:\nglobal { // (0x206400644030) (0, 27)\n 
// will be compiled\n  // NormalFunction\n  // 1 stack slots\n  // temporary vars:\n  TEMPORARY .result;  // (0x206400644338) local|0]\n  // local vars:\n  VAR fuzzilli;  // (0x206400644268) \n  // dynamic 
vars:\n  DYNAMIC_GLOBAL native;  // (0x2064006443f8) never assigned\n}\n|generated bytecode for function:  (0x0efd00827475 <SharedFunctionInfo>)]\nBytecode length: 25\nParameter count 1\nRegister count 
3\nFrame size 24\n         0x2c600800074 @    0 : 13 00             LdaConstant |0]\n         0x2c600800076 @    2 : d1                Star1\n         0x2c600800077 @    3 : 1b fe f7          Mov <closure>, 
r2\n    0 E> 0x2c60080007a @    6 : 6e 6b 01 f8 02    CallRuntime |DeclareGlobals], r1-r2\n    7 S> 0x2c60080007f @   11 : 8b 01 00 00       CreateClosure |1], |0], #0\n         0x2c600800083 @   15 : d1     
Star1\n         0x2c600800084 @   16 : 25 02 00          StaGlobal |2], |0]\n         0x2c600800087 @   19 : 1b f8 f9          Mov r1, r0\n         0x2c60080008a @   22 : 0b f9             Ldar r0\n   27 S> 
0x2c60080008c @   24 : b7                Return\nConstant pool (size = 3)\nHandler Table (size = 0)\nSource Position Table (size = 8)\nInner function scope:\nfunction foo () { // (0x206400638220) (180, 272)\n
// NormalFunction\n  // 2 heap slots\n  // local vars:\n  VAR ret;  // (0x20640063d290) never assigned\n  VAR arg;  // (0x20640063d248) never assigned\n\n  function () { // (0x20640063d438) (248, 254)\n    //
NormalFunction\n    // 2 heap slots\n  }\n}\nGlobal scope:\nglobal { // (0x206400638030) (0, 536)\n  // will be compiled\n  // NormalFunction\n  // 1 stack slots\n  // 4 heap slots\n  // temporary vars:\n  
TEMPORARY .result;  // (0x2064006387f8) local|0]\n  // local vars:\n  LET v1;  // (0x206400638540) context|2]\n  VAR foo;  // (0x2064006384e0) \n  LET v2;  // (0x206400638640) context|3]\n\n  function foo () 
{ // (0x206400638220) (180, 272)\n    // lazily parsed\n    // NormalFunction\n    // 2 heap slots\n  }\n}\n|generated bytecode for function:  (0x0efd00827c59 <SharedFunctionInfo>)]\nBytecode length: 
53\nParameter count 1\nRegister count 3\nFrame size 24\n         0x2c600800118 @    0 : 13 00             LdaConstant |0]\n         0x2c60080011a @    2 : d1                Star1\n         0x2c60080011b @    
3 : 1b fe f7          Mov <closure>, r2\n    0 E> 0x2c60080011e @    6 : 6e 6b 01 f8 02    CallRuntime |DeclareGlobals], r1-r2\n  345 S> 0x2c600800123 @   11 : 23 01 00          LdaGlobal |1], |0]\n         
0x2c600800126 @   14 : d1                Star1\n         0x2c600800127 @   15 : 0d 0a             LdaSmi |10]\n         0x2c600800129 @   17 : d0                Star2\n  345 E> 0x2c60080012a @   18 : 6b f8 f7
02       CallUndefinedReceiver1 r1, r2, |2]\n  345 E> 0x2c60080012e @   22 : 29 02             StaCurrentContextSlot |2]\n  363 S> 0x2c600800130 @   24 : 23 01 00          LdaGlobal |1], |0]\n         
0x2c600800133 @   27 : d1                Star1\n         0x2c600800134 @   28 : 13 02             LdaConstant |2]\n         0x2c600800136 @   30 : d0                Star2\n  363 E> 0x2c600800137 @   31 : 6b 
f8 f7 04       CallUndefinedReceiver1 r1, r2, |4]\n  363 E> 0x2c60080013b @   35 : 29 03             StaCurrentContextSlot |3]\n  523 S> 0x2c60080013d @   37 : 18 02             LdaCurrentContextSlot |2]\n   
0x2c60080013f @   39 : d1                Star1\n         0x2c600800140 @   40 : 13 03             LdaConstant |3]\n         0x2c600800142 @   42 : d0                Star2\n  528 E> 0x2c600800143 @   43 : 39 
f8 04 06       SetNamedProperty r1, |4], |6]\n         0x2c600800147 @   47 : 1b f7 f9          Mov r2, r0\n         0x2c60080014a @   50 : 0b f9             Ldar r0\n  536 S> 0x2c60080014c @   52 : b7       
Return\nConstant pool (size = 5)\nHandler Table (size = 0)\nSource Position Table (size = 24)\nGlobal scope:\nfunction foo (arg) { // (0x206400638220) (180, 272)\n  // will be compiled\n  // NormalFunction\n 
// 1 stack slots\n  // local vars:\n  VAR ret;  // (0x2064006384f0) local|0], never assigned\n  VAR arg;  // (0x206400638470) parameter|0], never assigned\n\n  function () { // (0x206400638850) (248, 254)\n  
// lazily parsed\n    // NormalFunction\n    // 2 heap slots\n  }\n}\n|generated bytecode for function: foo (0x0efd00827cc9 <SharedFunctionInfo foo>)]\nBytecode length: 36\nParameter count 2\nRegister count 
5\nFrame size 40\n  200 S> 0x2c6008001c8 @    0 : 87 00 00 29       CreateObjectLiteral |0], |0], #41\n         0x2c6008001cc @    4 : d1                Star1\n         0x2c6008001cd @    5 : 0b 03           
Ldar a0\n  205 E> 0x2c6008001cf @    7 : 3a f8 01 01       DefineNamedOwnProperty r1, |1], |1]\n         0x2c6008001d3 @   11 : 1b f8 f9          Mov r1, r0\n  218 S> 0x2c6008001d6 @   14 : 33 f9 02 03       
GetNamedProperty r0, |2], |3]\n         0x2c6008001da @   18 : d1                Star1\n         0x2c6008001db @   19 : 13 03             LdaConstant |3]\n         0x2c6008001dd @   21 : cf                
Star3\n         0x2c6008001de @   22 : 8b 04 00 02       CreateClosure |4], |0], #2\n         0x2c6008001e2 @   26 : ce                Star4\n  218 E> 0x2c6008001e3 @   27 : 68 f8 f9 f6 f5 05 CallProperty2 
r1, r0, r3, r4, |5]\n  259 S> 0x2c6008001e9 @   33 : 0b f9             Ldar r0\n  270 S> 0x2c6008001eb @   35 : b7                Return\nConstant pool (size = 5)\nHandler Table (size = 0)\nSource Position 
Table (size = 16)\n|generalizing]x:v{None;const}->s{Any;const} (uninitialized field) |~foo+7 at regressions/regress/regress-crbug-977012.js:6]\n|generalizing]x:v{None;const}->s{Any;const} (field type 
generalization) |~foo+7 at regressions/regress/regress-crbug-977012.js:6]\n|generalizing]x:s{Any;const}->d{Any;const} (+1 maps) |~foo+7 at regressions/regress/regress-crbug-977012.js:6]\n|migrating to 
slow]\n"}
[Step 1: Duration 11.07 seconds| Input tokens: 1,428 | Output tokens: 277]
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ Step 2 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'search_js_file_name_by_pattern' with arguments: {'pattern': 'defineSetter'}                                                                                                                   │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
Observations: No results found
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'search_js_file_name_by_pattern' with arguments: {'pattern': 'setter'}                                                                                                                         │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
Observations: setter-on-constructor-prototype
setters-on-elements
regress/setter
regress/regress-freeze-setter
es6/spread-array-prototype-setter1
es6/promise-internal-setter
es6/spread-array-prototype-setter2
es6/promise-lookup-getter-setter
opt-proto-seq/test_has_setters
maglev/api-setter-poly
maglev/api-setter
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'search_js_file_name_by_pattern' with arguments: {'pattern': 'accessor'}                                                                                                                       │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'search_js_file_name_by_pattern' with arguments: {'pattern': 'crbug-977012'}                                                                                                                   │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
Observations: regress/regress-crbug-977012
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'search_js_file_name_by_pattern' with arguments: {'pattern': 'dictionary'}                                                                                                                     │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
Observations: deopt-global-accessor
readonly-accessor
proto-accessor
function-length-accessor
global-accessors
accessor-map-sharing
fuzz-accessors
proto-accessor-not-accessible
element-accessor
indexed-accessors
accessors-no-prototype
error-accessors
accessors-on-global-object
value-wrapper-accessor
decorators/auto-accessors-reparsing
compiler/deopt-accessors5
compiler/deopt-accessors4
compiler/inline-accessors2
compiler/global-accessors
compiler/deopt-accessors3
compiler/serializer-accessors
compiler/inline-accessors1
compiler/deopt-accessors7
compiler/accessor-exceptions2
compiler/deopt-accessors1
compiler/deopt-accessors2
compiler/deopt-accessors6
compiler/accessor-exceptions1
regress/polymorphic-accessor-test-context
harmony/dataview-accessors
harmony/private-accessors
es6/built-in-accessor-names
es6/array-species-constructor-accessor
Observations: store-dictionary
dictionary-properties
keyed-load-dictionary-stub
dictionary-prototypes
wasm/memory-resizable-buffer-array-concat-dictionary-mode
compiler/materialize-dictionary-properties
regress/regress-dictionary-to-fast-arguments
regress/regress-reset-dictionary-elements
shared-memory/shared-external-string-dictionary-lookup
[Step 2: Duration 45.95 seconds| Input tokens: 13,813 | Output tokens: 2,574]
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ Step 3 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'get_js_entry_data_by_name' with arguments: {'file_name': 'regress/regress-crbug-977012'}                                                                                                      │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
Observations: {"js": "// Copyright 2019 the V8 project authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nfunction 
foo(arg) {\n  var ret = { x: arg };\n  ret.__defineSetter__(\"y\", function() { });\n  return ret;\n}\n\n// v1 creates a map with a Smi field, v2 deprecates v1's map.\nlet v1 = foo(10);\nlet v2 = 
foo(10.5);\n\n// Trigger a PrepareForDataProperty on v1, which also triggers an update to\n// dictionary due to the different accessors on v1 and v2's y property.\nv1.x = 20.5;\n", "Fuzzilli": "v0 <- 
BeginPlainFunction -> v1\n    BeginObjectLiteral\n        ObjectLiteralAddProperty `x`, v1\n    v2 <- EndObjectLiteral\n    v3 <- CreateNamedVariable 'ret', 'var', v2\n    v4 <- LoadString 'y'\n    v5 <- 
BeginPlainFunction -> \n    EndPlainFunction\n    v6 <- CallMethod v3, '__defineSetter__', |v4, v5]\n    Return v3\nEndPlainFunction\nv7 <- LoadInteger '10'\nv8 <- CallFunction v0, |v7]\nv9 <- 
CreateNamedVariable 'v1', 'let', v8\nv10 <- LoadFloat '10.5'\nv11 <- CallFunction v0, |v10]\nv12 <- CreateNamedVariable 'v2', 'let', v11\nv13 <- LoadFloat '20.5'\nSetProperty v9, 'x', v13\n\n\nfunction 
foo(a1) {\n    var ret = { x: a1 };\n    function f5() {\n    }\n    ret.__defineSetter__(\"y\", f5);\n    return ret;\n}\nlet v1 = foo(10);\nlet v2 = foo(10.5);\nv1.x = 20.5;", "execution_data": 
"--no-experimental\n--abort-on-contradictory-flags\n--no-exit-on-contradictory-flags\n--no-allow-overwriting-for-next-flag\n--no-use-strict\n--no-trace-temporal\n--no-harmony\n--harmony-shipping\n--no-js-stag
ing\n--js-shipping\n--no-harmony-shadow-realm\n--no-harmony-struct\n--no-js-decorators\n--no-js-source-phase-imports\n--no-harmony-temporal\n--harmony-import-attributes\n--js-regexp-duplicate-named-groups\n--
js-regexp-modifiers\n--js-promise-try\n--js-atomics-pause\n--js-error-iserror\n--js-regexp-escape\n--js-explicit-resource-management\n--js-float16array\n--js-base-64\n--builtin-subclassing\n--no-enable-shared
arraybuffer-per-context\n--no-for-of-optimization\n--no-stress-snapshot\n--no-lite-mode\n--enable-allocation-folding\n--no-disable-write-barriers\n--no-enable-unconditional-write-barriers\n--no-single-generat
ion\n--no-conservative-stack-scanning\n--no-direct-handle\n--no-scavenger-conservative-object-pinning\n--no-stress-scavenger-conservative-object-pinning\n--no-stress-scavenger-conservative-object-pinning-rand
om\n--no-scavenger-precise-object-pinning\n--no-precise-object-pinning\n--scavenger-promote-quarantined-pages\n--no-local-off-stack-check\n--no-experimental-fuzzing\n--no-future\n--no-force-emit-interrupt-bud
get-checks\n--maglev\n--no-maglev-future\n--no-optimize-on-next-call-optimizes-to-maglev\n--no-stress-maglev\n--no-maglev-as-top-tier\n--maglev-inlining\n--maglev-loop-peeling\n--maglev-optimistic-peeled-loop
s\n--maglev-loop-peeling-max-size=400\n--maglev-loop-peeling-max-size-cumulative=900\n--maglev-deopt-data-on-background\n--maglev-build-code-on-background\n--maglev-destroy-on-background\n--no-maglev-inline-a
pi-calls\n--maglev-cons-string-elision\n--maglev-pretenure-store-values\n--maglev-poly-calls\n--maglev-truncation\n--no-maglev-licm\n--concurrent-maglev-max-threads=2\n--no-concurrent-maglev-high-priority-thr
eads\n--max-maglev-inline-depth=1\n--max-maglev-hard-inline-depth=10\n--max-maglev-inlined-bytecode-size=100\n--max-maglev-inlined-bytecode-size-cumulative=920\n--max-maglev-inlined-bytecode-size-small-total=
3000\n--max-maglev-inlined-bytecode-size-small=27\n--max-maglev-inlined-bytecode-size-small-with-heapnum-in-out=75\n--min-maglev-inlining-frequency=0.95\n--maglev-reuse-stack-slots\n--maglev-untagged-phis\n--
maglev-hoist-osr-value-phi-untagging\n--no-maglev-speculative-hoist-phi-untagging\n--maglev-cse\n--no-maglev-non-eager-inlining\n--no-turbolev-non-eager-inlining\n--maglev-filter=\"*\"\n--maglev-print-filter=
\"*\"\n--no-maglev-assert\n--maglev-assert-stack-size\n--no-maglev-break-on-entry\n--maglev-print-bytecode\n--maglev-print-feedback\n--maglev-print-inlined\n--print-maglev-code\n--no-trace-maglev-graph-buildi
ng\n--no-trace-maglev-loop-speeling\n--no-trace-maglev-inlining\n--no-trace-maglev-kna-processor\n--no-print-maglev-deopt-verbose\n--print-maglev-graph\n--print-maglev-graphs\n--no-trace-maglev-phi-untagging\
n--no-trace-maglev-regalloc\n--no-maglev-stats\n--no-maglev-stats-nvp\n--maglev-function-context-specialization\n--no-specialize-code-for-one-byte-seq-strings\n--additive-safe-int-feedback\n--enable-enumerate
d-keyed-access-bytecode\n--no-dict-property-const-tracking\n--script-context-cells\n--function-context-cells\n--function-context-cells-max-size=1\n--empty-context-extension-dep\n--json-stringify-fast-path\n--
cache-property-key-string-adds\n--smi-string-cache-size=8192\n--double-string-cache-size=4096\n--no-trace-number-string-cache\n--maglev-inline-date-accessors\n--turbofan-inline-date-accessors\n--inline-date-a
ccessors\n--extensible-ro-snapshot\n--max-opt=999\n--efficiency-mode=unset\n--battery-saver-mode=unset\n--memory-saver-mode=unset\n--no-efficiency-mode-disable-turbofan\n--efficiency-mode-delay-turbofan-multi
ply=3\n--wasm-trace-native=\"\"\n--no-jitless\n--no-disable-optimizing-compilers\n--memory-protection-keys\n--no-force-memory-protection-keys\n--no-assert-types\n--no-turboshaft-assert-types\n--no-verify-simp
lified-lowering\n--no-trace-compilation-dependencies\n--no-unmap-holes\n--no-assert-hole-checked-by-value\n--allocation-site-tracking\n--allocation-site-pretenuring\n--page-promotion\n--page-promotion-thresho
ld=70\n--minor-ms-page-promotion-threshold=50\n--minor-ms-page-promotion-max-lab-threshold=30\n--minor-ms-max-page-age=4\n--no-trace-page-promotions\n--trace-pretenuring\n--no-trace-pretenuring-statistics\n--
no-trace-resize-large-object\n--track-field-types\n--no-trace-block-coverage\n--trace-protector-invalidation\n--decommit-pooled-pages\n--zero-unused-memory\n--no-high-end-android\n--high-end-android-physical-
memory-threshold=4294967295\n--no-minor-ms-shortcut-strings\n--no-feedback-normalization\n--internalize-on-the-fly\n--unbox-double-arrays\n--string-slices\n--invocation-count-for-feedback-allocation=8\n--invo
cation-count-for-maglev=400\n--invocation-count-for-maglev-osr=100\n--osr-from-maglev\n--osr-from-maglev-interrupt-scale-factor=0.8\n--no-always-osr-from-maglev\n--invocation-count-for-turbofan=16000\n--invoc
ation-count-for-osr=800\n--osr-to-tierup=1\n--minimum-invocations-after-ic-update=500\n--minimum-invocations-before-optimization=2\n--no-jit-fuzzing\n--use-std-math-pow\n--use-ic\n--lazy-feedback-allocation\n
--no-stress-ic\n--ignition-elide-noneffectful-bytecodes\n--ignition-reo\n--ignition-filter-expression-positions\n--ignition-share-named-property-feedback\n--ignition-elide-redundant-tdz-checks\n--print-byteco
de\n--enable-lazy-source-positions\n--no-stress-lazy-source-positions\n--print-bytecode-filter=\"*\"\n--omit-default-ctors\n--no-trace-ignition-codegen\n--trace-ignition-dispatches-output-file=\"\"\n--no-trac
e-track-allocation-sites\n--trace-migration\n--trace-generalization\n--reuse-scope-infos\n--sparkplug\n--no-always-sparkplug\n--baseline-batch-compilation\n--concurrent-sparkplug\n--concurrent-sparkplug-max-t
hreads=1\n--no-concurrent-sparkplug-high-priority-threads\n--sparkplug-filter=\"*\"\n--no-sparkplug-needs-short-builtins\n--baseline-batch-compilation-threshold=4096\n--no-trace-baseline\n--no-trace-baseline-
batch-compilation\n--no-shared-string-table\n--no-always-use-string-forwarding-table\n--no-transition-strings-during-gc-with-stack\n--initial-shared-heap-size=0\n--max-shared-heap-size=0\n--no-concurrent-buil
tin-generation\n--concurrent-recompilation\n--no-trace-concurrent-recompilation\n--concurrent-recompilation-queue-length=8\n--concurrent-recompilation-delay=0\n--concurrent-recompilation-front-running\n--conc
urrent-turbofan-max-threads=4\n--no-stress-concurrent-inlining\n--maglev-overwrite-budget\n--maglev-overwrite-osr-budget\n--no-stress-concurrent-inlining-attach-code\n--max-serializer-nesting=25\n--no-trace-h
eap-broker-verbose\n--no-trace-heap-broker\n--stress-runs=0\n--deopt-every-n-times=0\n--no-print-deopt-stress\n--turbofan\n--opt\n--no-stress-turbo-late-spilling\n--turbo-wasm-address-reassociation\n--no-conc
urrent-turbo-tracing\n--no-optimize-maglev-optimizes-to-turbofan\n--turbo-filter=\"*\"\n--no-trace-turbo\n--trace-turbo-path=\"\"\n--trace-turbo-filter=\"*\"\n--no-trace-turbo-graph\n--no-trace-turbo-schedule
d\n--trace-turbo-file-prefix=\"turbo\"\n--trace-turbo-cfg-file=\"turbo.cfg\"\n--trace-turbo-types\n--no-trace-turbo-scheduler\n--no-trace-turbo-reduction\n--no-trace-turbo-bailouts\n--no-trace-turbo-trimming\
n--no-trace-turbo-jt\n--no-trace-turbo-ceq\n--no-trace-turbo-loop\n--no-trace-turbo-alloc\n--no-trace-all-uses\n--no-trace-representation\n--no-trace-turbo-stack-accesses\n--no-fuzzing-and-concurrent-recompil
ation\n--turbo-verify\n--turbo-verify-machine-graph=\"\"\n--no-verify-csa\n--no-trace-verify-csa\n--csa-trap-on-node=\"\"\n--builtins-effects-src=\"\"\n--fixed-array-bounds-checks\n--no-turbo-stats\n--no-turb
o-stats-nvp\n--no-turbo-stats-wasm\n--turbo-splitting\n--turbo-inlining\n--turbo-elide-frames\n--max-inlined-bytecode-size=460\n--max-inlined-bytecode-size-cumulative=920\n--max-turbolev-inlined-bytecode-size
-cumulative=1840\n--max-inlined-bytecode-size-absolute=4600\n--max-inlined-bytecode-size-small-total=30000\n--reserve-inline-budget-scale-factor=1.2\n--max-inlined-bytecode-size-small=27\n--max-inlined-byteco
de-size-small-with-heapnum-in-out=75\n--max-optimized-bytecode-size=61440\n--min-inlining-frequency=0.05\n--no-stress-inline\n--no-trace-turbo-inlining\n--turbo-inline-array-builtins\n--use-osr\n--maglev-osr\
n--concurrent-osr\n--maglev-allocation-folding=2\n--maglev-escape-analysis\n--no-trace-maglev-escape-analysis\n--no-maglev-object-tracking\n--trace-maglev-object-tracking\n--no-turbo-string-builder\n--trace-o
sr\n--log-or-trace-osr\n--analyze-environment-liveness\n--no-trace-environment-liveness\n--turbo-load-elimination\n--trace-turbo-load-elimination\n--no-turbo-profiling\n--no-turbo-profiling-verbose\n--turbo-p
rofiling-output=\"\"\n--no-reorder-builtins\n--no-abort-on-bad-builtin-profile-data\n--no-warn-about-builtin-profile-data\n--dump-builtins-hashes-to-file=\"\"\n--turbo-verify-allocation\n--turbo-move-optimiza
tion\n--turbo-jt\n--turbo-loop-peeling\n--turbo-loop-variable\n--turbo-loop-rotation\n--turbo-cf-optimization\n--turbo-escape\n--turbo-allocation-folding\n--no-turbo-instruction-scheduling\n--no-turbo-stress-
instruction-scheduling\n--turbo-store-elimination\n--trace-store-elimination\n--turbo-typer-hardening\n--turbo-rewrite-far-jumps\n--no-stress-gc-during-compilation\n--turbo-fast-api-calls\n--no-fast-api-allow
-float-in-sim\n--no-turbo-compress-frame-translations\n--turbo-inline-js-wasm-calls\n--no-turbo-optimize-inlined-js-wasm-wrappers\n--turbo-optimize-apply\n--turbo-optimize-math-minmax\n--turboshaft\n--no-turb
oshaft-enable-debug-features\n--turboshaft-wasm-load-elimination\n--no-turboshaft-wasm-in-js-inlining\n--no-turbolev-inline-js-wasm-wrappers\n--turboshaft-load-elimination\n--turboshaft-loop-unrolling\n--turb
oshaft-string-concat-escape-analysis\n--no-turboshaft-typed-optimizations\n--no-turbolev\n--no-print-turbolev-frontend\n--no-turbolev-future\n--typed-array-length-loading\n--no-deduplicate-heap-number-request
s\n--no-turboshaft-verify-load-elimination\n--turboshaft-opt-bisect-limit=18446744073709551615\n--turboshaft-opt-bisect-break=18446744073709551615\n--no-turboshaft-verify-reductions\n--turboshaft-trace-typing
\n--turboshaft-trace-reduction\n--no-turboshaft-trace-intermediate-reductions\n--turboshaft-trace-emitted\n--no-turboshaft-trace-unrolling\n--no-turboshaft-trace-peeling\n--no-turboshaft-trace-load-eliminatio
n\n--no-turboshaft-trace-if-else-to-switch\n--trace-turbolev-graph-building\n--profile-guided-optimization\n--profile-guided-optimization-for-empty-feedback-vector\n--invocation-count-for-early-optimization=3
0\n--invocation-count-for-maglev-with-delay=600\n--no-optimize-for-size\n--reopt-after-lazy-deopts\n--no-verify-get-js-builtin-state\n--wasm-generic-wrapper\n--wasm-num-compilation-tasks=128\n--no-trace-wasm-
native-heap\n--no-trace-wasm-offheap-memory\n--no-print-wasm-offheap-memory-size\n--no-trace-wasm-serialization\n--wasm-async-compilation\n--no-wasm-test-streaming\n--wasm-native-module-cache\n--wasm-max-mem-
pages=4294967295\n--wasm-max-table-size=10000000\n--wasm-max-committed-code-mb=4095\n--wasm-max-code-space-size-mb=1024\n--wasm-tier-up\n--wasm-dynamic-tiering\n--no-wasm-sync-tier-up\n--wasm-tiering-budget=1
3000000\n--wasm-wrapper-tiering-budget=1000\n--max-wasm-functions=1000000\n--wasm-caching-threshold=1000\n--wasm-caching-hard-threshold=1000000\n--wasm-caching-timeout-ms=2000\n--no-trace-wasm-compilation-tim
es\n--wasm-tier-up-filter=-1\n--wasm-eager-tier-up-function=-1\n--no-trace-wasm-decoder\n--no-trace-wasm-compiler\n--no-trace-wasm-streaming\n--no-trace-wasm-stack-switching\n--no-stress-wasm-stack-switching\
n--wasm-stack-switching-stack-size=984\n--liftoff\n--no-liftoff-only\n--no-enable-testing-opcode-in-wasm\n--no-trace-liftoff\n--no-trace-wasm-memory\n--no-trace-wasm-globals\n--wasm-tier-mask-for-testing=0\n-
-wasm-debug-mask-for-testing=0\n--no-experimental-wasm-pgo-to-file\n--no-experimental-wasm-pgo-from-file\n--validate-asm\n--no-suppress-asm-messages\n--no-trace-asm-time\n--no-trace-asm-scanner\n--no-trace-as
m-parser\n--no-stress-validate-asm\n--no-dump-wasm-module\n--dump-wasm-module-path=\"\"\n--no-wasm-fast-api\n--wasm-deopt\n--wasm-deopts-per-function-limit=10\n--no-experimental-wasm-type-reflection\n--no-exp
erimental-wasm-instruction-tracing\n--no-experimental-wasm-custom-descriptors\n--no-experimental-wasm-shared\n--no-experimental-wasm-fp16\n--no-experimental-wasm-memory-control\n--no-experimental-wasm-wasmfx\
n--no-experimental-wasm-rab-integration\n--no-experimental-wasm-compilation-hints\n--no-experimental-wasm-stringref\n--no-experimental-wasm-imported-strings-utf8\n--no-experimental-wasm-growable-stacks\n--exp
erimental-wasm-legacy-eh\n--experimental-wasm-branch-hinting\n--experimental-wasm-exnref\n--no-experimental-wasm-assume-ref-cast-succeeds\n--no-experimental-wasm-ref-cast-nop\n--no-experimental-wasm-skip-null
-checks\n--no-experimental-wasm-skip-bounds-checks\n--no-experimental-wasm-js-interop\n--no-wasm-staging\n--wasm-opt\n--wasm-bounds-checks\n--wasm-stack-checks\n--no-wasm-enforce-bounds-checks\n--wasm-math-in
trinsics\n--no-wasm-inlining\n--wasm-inlining-budget=5000\n--wasm-inlining-max-size=500\n--wasm-inlining-factor=3\n--wasm-inlining-min-budget=50\n--no-wasm-inlining-ignore-call-counts\n--no-trace-wasm-inlinin
g\n--no-trace-wasm-typer\n--no-wasm-inlining-call-indirect\n--wasm-bulkmem-inlining\n--wasm-loop-unrolling\n--wasm-loop-peeling\n--wasm-loop-peeling-max-size=1000\n--no-trace-wasm-loop-peeling\n--no-wasm-fuzz
er-gen-test\n--no-print-wasm-code\n--print-wasm-code-function-index=-1\n--no-print-wasm-stub-code\n--asm-wasm-lazy-compilation\n--wasm-lazy-compilation\n--no-trace-wasm-lazy-compilation\n--no-wasm-lazy-valida
tion\n--no-wasm-simd-ssse3-codegen\n--wasm-code-gc\n--no-trace-wasm-code-gc\n--no-stress-wasm-code-gc\n--wasm-max-initial-code-space-reservation=0\n--no-stress-wasm-memory-moving\n--flush-liftoff-code\n--no-s
tress-branch-hinting\n--wasm-max-module-size=1073741824\n--wasm-disassembly-max-mb=1000\n--wasm-capi-thread-pool-size=0\n--trace-wasm\n--no-trace-wasm-instances\n--no-experimental-wasm-revectorize\n--no-trace
-wasm-revectorize\n--wasm-memory64-trap-handling\n--no-wasm-jitless\n--no-wasm-jitless-if-available-for-testing\n--no-wasm-allow-mixed-eh-for-testing\n--no-wasm-code-coverage\n--stress-sampling-allocation-pro
filer=0\n--no-lazy-new-space-shrinking\n--min-semi-space-size=0\n--max-semi-space-size=0\n--semi-space-growth-factor=2\n--max-old-space-size=0\n--max-heap-size=0\n--initial-heap-size=0\n--initial-old-space-si
ze=0\n--preconfigured-old-space-size=0\n--no-gc-global\n--random-gc-interval=0\n--gc-interval=-1\n--cppgc-random-gc-interval=0\n--retain-maps-for-n-gc=2\n--trace-gc\n--no-trace-gc-nvp\n--no-trace-gc-ignore-sc
avenger\n--no-trace-memory-reducer\n--trace-gc-verbose\n--no-trace-gc-freelists\n--no-trace-gc-freelists-verbose\n--no-trace-gc-heap-layout\n--trace-gc-heap-layout-ignore-minor-gc\n--no-trace-evacuation-candi
dates\n--no-trace-pending-allocations\n--trace-allocation-stack-interval=-1\n--trace-duplicate-threshold-kb=0\n--no-trace-fragmentation\n--no-trace-fragmentation-verbose\n--no-minor-ms-trace-fragmentation\n--
no-trace-evacuation\n--no-trace-mutator-utilization\n--incremental-marking\n--incremental-marking-task\n--incremental-marking-start-user-visible\n--no-incremental-marking-always-user-visible\n--incremental-ma
rking-soft-trigger=0\n--incremental-marking-hard-trigger=0\n--no-incremental-marking-unified-schedule\n--no-trace-unmapper\n--parallel-scavenge\n--minor-gc-task\n--minor-gc-task-trigger=80\n--minor-gc-task-wi
th-lower-priority\n--no-trace-parallel-scavenge\n--no-cppgc-young-generation\n--no-optimize-gc-for-battery\n--concurrent-marking\n--concurrent-marking-max-worker-num=7\n--concurrent-array-buffer-sweeping\n--n
o-stress-concurrent-allocation\n--parallel-marking\n--ephemeron-fixpoint-iterations=10\n--no-trace-concurrent-marking\n--concurrent-sweeping\n--parallel-compaction\n--parallel-pointer-update\n--parallel-weak-
ref-clearing\n--detect-ineffective-gcs-near-heap-limit\n--no-ineffective-gcs-forces-last-resort\n--ineffective-gc-size-threshold=0.8\n--ineffective-gc-mutator-utilization-threshold=0.4\n--no-trace-incremental
-marking\n--no-trace-stress-marking\n--no-trace-stress-scavenge\n--no-track-gc-object-stats\n--no-trace-gc-object-stats\n--no-trace-zone-stats\n--zone-stats-tolerance=1048576\n--no-trace-zone-type-stats\n--no
-trace-backing-store\n--gc-stats=0\n--track-detached-contexts\n--no-trace-detached-contexts\n--no-verify-heap\n--no-verify-heap-skip-remembered-set\n--verify-write-barriers\n--no-memory-reducer-respects-froze
n-state\n--move-object-start\n--memory-reducer\n--memory-reducer-favors-memory\n--memory-reducer-for-small-heaps\n--memory-reducer-gc-count=2\n--no-external-memory-accounted-in-global-limit\n--external-memory
-max-growing-factor=1.3\n--no-gc-speed-uses-counters\n--heap-growing-percent=0\n--v8-os-page-size=0\n--allocation-buffer-parking\n--compact\n--compact-code-space\n--no-compact-on-every-full-gc\n--compact-with
-stack\n--shortcut-strings-with-stack\n--no-stress-compaction\n--resize-large-object\n--no-stress-compaction-random\n--no-flush-baseline-code\n--flush-bytecode\n--bytecode-old-age=6\n--no-flush-code-based-on-
time\n--no-flush-code-based-on-tab-visibility\n--bytecode-old-time=30\n--no-stress-flush-code\n--no-trace-flush-code\n--use-marking-progress-bar\n--no-stress-per-context-marking-worklist\n--no-stress-incremen
tal-marking\n--memory-pool\n--memory-pool-share-memory-on-teardown\n--memory-pool-release-before-memory-pressure-gcs\n--no-memory-pool-release-on-malloc-failures\n--large-page-pool\n--max-large-page-pool-size
=32\n--large-page-pool-timeout=3\n--no-managed-zone-memory\n--no-fuzzer-gc-analysis\n--stress-marking=0\n--stress-scavenge=0\n--reclaim-unmodified-wrappers\n--parallel-reclaim-unmodified-wrappers\n--no-gc-exp
eriment-less-compaction\n--gc-memory-reducer-start-delay-ms=8000\n--no-concurrent-marking-high-priority-threads\n--no-disable-abortjs\n--no-randomize-all-allocations\n--no-manual-evacuation-candidates-selecti
on\n--no-clear-free-memory\n--idle-gc-on-context-disposal\n--no-trace-context-disposal\n--cppheap-incremental-marking\n--cppheap-concurrent-marking\n--no-memory-balancer\n--memory-balancer-c-value=3e-10\n--no
-trace-memory-balancer\n--late-heap-limit-check\n--reserve-contiguous-compressed-read-only-space\n--debug-code\n--no-trap-on-abort\n--no-slow-debug-code\n--no-code-comments\n--enable-sse3\n--enable-ssse3\n--e
nable-sse4-1\n--enable-sse4-2\n--enable-sahf\n--enable-avx\n--enable-avx2\n--enable-avx-vnni\n--enable-avx-vnni-int8\n--enable-fma3\n--enable-f16c\n--enable-bmi1\n--enable-bmi2\n--enable-lzcnt\n--enable-popcn
t\n--arm-arch=\"armv8\"\n--no-force-long-branches\n--mcpu=\"auto\"\n--partial-constant-pool\n--sim-arm64-optional-features=\"none\"\n--intel-jcc-erratum-mitigation\n--no-enable-source-at-csa-bind\n--enable-ar
mv7=unset\n--enable-vfp3=unset\n--enable-32dregs=unset\n--enable-neon=unset\n--enable-sudiv=unset\n--enable-armv8=unset\n--enable-regexp-unaligned-accesses\n--script-streaming\n--no-stress-background-compile\
n--concurrent-cache-deserialization\n--merge-background-deserialized-script-with-compilation-cache\n--no-verify-code-merge\n--no-experimental-embedder-instance-types\n--no-expose-gc\n--expose-gc-as=\"\"\n--no
-expose-externalize-string\n--no-expose-statistics\n--no-expose-trigger-failure\n--no-expose-ignition-statistics\n--stack-trace-limit=10\n--no-builtins-in-stack-traces\n--no-experimental-stack-trace-frames\n-
-no-disallow-code-generation-from-strings\n--no-expose-async-hooks\n--expose-cputracemark-as=\"\"\n--experimental-report-exceptions-from-callbacks\n--no-allow-unsafe-function-constructor\n--no-force-slow-path
\n--no-test-small-max-function-context-stub-size\n--inline-new\n--switch-table-spread-threshold=3\n--switch-table-min-cases=6\n--stress-lazy-compilation=0\n--no-trace\n--lazy\n--lazy-eval\n--lazy-streaming\n-
-no-max-lazy\n--trace-opt\n--trace-opt-status\n--trace-opt-verbose\n--no-trace-opt-stats\n--trace-deopt\n--no-log-deopt\n--no-trace-deopt-verbose\n--no-trace-file-names\n--no-always-osr\n--no-trace-serializer
\n--no-external-reference-stats\n--compilation-cache\n--cache-prototype-transitions\n--no-lazy-compile-dispatcher\n--lazy-compile-dispatcher-max-threads=0\n--no-trace-compiler-dispatcher\n--no-parallel-compil
e-tasks-for-eager-toplevel\n--no-parallel-compile-tasks-for-lazy\n--cpu-profiler-sampling-interval=1000\n--no-trace-side-effect-free-debug-evaluate\n--hard-abort\n--log-colour\n--no-expose-inspector-scripts\n
--inspector-live-edit\n--stack-size=984\n--max-stack-trace-source-length=300\n--no-clear-exceptions-on-js-entry\n--use-original-message-for-stack-trace\n--histogram-interval=600000\n--no-heap-profiler-trace-o
bjects\n--heap-profiler-use-embedder-graph\n--no-heap-snapshot-on-oom\n--heap-snapshot-on-gc=-1\n--heap-snapshot-string-limit=1024\n--no-heap-profiler-show-hidden-objects\n--no-profile-heap-snapshot\n--no-hea
p-snapshot-verify\n--no-sampling-heap-profiler-suppress-randomness\n--no-log-ic\n--no-fast-map-update\n--max-valid-polymorphic-map-count=4\n--clone-object-sidestep-transitions\n--fast-properties-soft-limit=12
\n--max-fast-properties=128\n--native-code-counters\n--super-ic\n--no-mega-dom-ic\n--no-trace-prototype-users\n--no-trace-for-in-enumerate\n--no-log-maps\n--log-maps-details\n--move-prototype-transitions-firs
t\n--allow-natives-syntax\n--no-allow-natives-for-differential-fuzzing\n--no-parse-only\n--no-enable-parser-ablation\n--no-enable-preparser-ablation\n--no-enable-bytecode-compiler-ablation\n--parser-ablation-
amount=0.8\n--preparser-ablation-amount=0.8\n--bytecode-compiler-ablation-amount=0.8\n--async-stack-traces\n--no-stack-trace-on-illegal\n--no-abort-on-uncaught-exception\n--no-correctness-fuzzer-suppressions\
n--no-rehash-snapshot\n--hash-seed=0\n--random-seed=0\n--fuzzer-random-seed=0\n--no-hashes-collide\n--no-trace-rail\n--no-print-all-exceptions\n--no-detailed-error-stack-trace\n--adjust-os-scheduling-paramete
rs\n--experimental-flush-embedded-blob-icache\n--allow-allocation-in-fast-api-call\n--short-builtin-calls\n--no-trace-code-range-allocation\n--better-code-range-allocation\n--no-abort-on-far-code-range\n--no-
runtime-call-stats\n--no-rcs\n--no-rcs-cpu-time\n--verify-snapshot-checksum\n--no-profile-deserialization\n--no-trace-deserialization\n--no-serialization-statistics\n--regexp-optimization\n--no-regexp-interpr
et-all\n--regexp-tier-up\n--regexp-tier-up-ticks=1\n--regexp-peephole-optimization\n--regexp-results-cache\n--no-regexp-assemble-from-bytecode\n--no-trace-regexp-peephole-optimization\n--no-trace-regexp-bytec
odes\n--no-trace-regexp-assembler\n--no-trace-regexp-parser\n--no-trace-regexp-tier-up\n--no-trace-regexp-graph\n--no-enable-experimental-regexp-engine\n--no-default-to-experimental-regexp-engine\n--no-experi
mental-regexp-engine-capture-group-opt\n--experimental-regexp-engine-capture-group-opt-max-memory-usage=1024\n--no-trace-experimental-regexp-engine\n--no-enable-experimental-regexp-engine-on-excessive-backtra
cks\n--regexp-backtracks-before-fallback=50000\n--regexp-simd\n--no-trace-read-only-promotion\n--no-trace-read-only-promotion-verbose\n--testing-bool-flag\n--testing-maybe-bool-flag=unset\n--testing-int-flag=
13\n--testing-float-flag=2.5\n--testing-string-flag=\"Hello, 
world!\"\n--testing-prng-seed=42\n--no-testing-d8-test-runner\n--no-strict-termination-checks\n--no-fuzzing\n--no-hole-fuzzing\n--no-sandbox-testing\n--no-sandbox-fuzzing\n--no-expose-memory-corruption-api\n-
-freeze-flags-after-init\n--no-cet-compatible\n--embedded-src=\"\"\n--embedded-variant=\"\"\n--startup-src=\"\"\n--startup-blob=\"\"\n--target-arch=\"\"\n--target-os=\"\"\n--no-target-is-simulator\n--turbo-pr
ofiling-input=\"\"\n--turbo-log-builtins-count-input=\"\"\n--text-is-readable\n--no-trace-minor-ms-parallel-marking\n--no-minor-ms\n--concurrent-minor-ms-marking\n--black-allocated-pages\n--no-sticky-mark-bit
s\n--minor-ms-min-new-space-capacity-for-concurrent-marking-mb=0\n--minor-ms-concurrent-marking-trigger=90\n--minor-ms-min-lab-size-kb=0\n--no-handle-weak-ref-weakly-in-minor-gc\n--no-help\n--print-flag-value
s\n--no-print-feature-flags-json\n--no-slow-histograms\n--no-use-external-strings\n--map-counters=\"\"\n--no-mock-arraybuffer-allocator\n--mock-arraybuffer-allocator-limit=0\n--no-multi-mapped-mock-allocator\
n--no-gdbjit\n--no-gdbjit-full\n--no-gdbjit-dump\n--gdbjit-dump-filter=\"\"\n--no-enable-slow-asserts\n--no-print-ast\n--print-scopes\n--no-trace-contexts\n--no-gc-verbose\n--no-code-stats\n--no-print-handles
\n--no-check-handle-count\n--no-print-global-handles\n--trace-turbo-escape\n--no-trace-module-status\n--no-trace-normalization\n--no-trace-lazy\n--no-trace-isolates\n--no-regexp-possessive-quantifier\n--no-pr
int-break-location\n--logfile=\"v8.log\"\n--no-logfile-per-isolate\n--no-log\n--no-log-all\n--no-log-internal-timer-events\n--no-log-timer-events\n--no-log-source-code\n--no-log-source-position\n--no-log-code
\n--no-log-feedback-vector\n--no-log-code-disassemble\n--no-log-function-events\n--no-detailed-line-info\n--no-prof-include-idle\n--no-perfetto-code-logger\n--prof-sampling-interval=1000\n--no-prof-cpp\n--pro
f-browser-mode\n--no-prof\n--no-ll-prof\n--no-perf-basic-prof\n--perf-basic-prof-path=\"/tmp\"\n--no-perf-basic-prof-only-functions\n--no-perf-prof\n--perf-prof-path=\".\"\n--no-perf-prof-annotate-wasm\n--no-
perf-prof-delete-file\n--no-perf-prof-unwinding-info\n--gc-fake-mmap=\"/tmp/__v8_gc__\"\n--no-redirect-code-traces\n--redirect-code-traces-to=\"code.asm\"\n--print-opt-source\n--no-vtune-prof-annotate-wasm\n-
-win64-unwinding-info\n--no-interpreted-frames-native-stack\n--no-enable-etw-stack-walking\n--no-etw-trace-debug\n--no-enable-etw-by-custom-filter-only\n--no-print-builtin-size\n--no-trace-elements-transition
s\n--no-trace-creation-allocation-sites\n--no-print-code\n--no-print-opt-code\n--print-opt-code-filter=\"*\"\n--no-print-code-verbose\n--no-print-builtin-code\n--print-builtin-code-filter=\"*\"\n--no-print-re
gexp-code\n--no-print-regexp-bytecode\n--no-predictable\n--no-predictable-and-random-seed-is-0\n--no-predictable-gc-schedule\n--no-single-threaded\n--no-single-threaded-gc\n--single-threaded-gc-in-background\
n--parallel-pause-for-gc-in-background\n--incremental-marking-for-gc-in-background\n--no-shared-heap\n--no-proto-assign-seq-opt\n--use-libm-trig-functions\n--no-verify-predictable\n--dump-allocations-digest-a
t-alloc=-1\nConcurrent maglev has been disabled for tracing.\n|2247692:0x206400138000] Shrinking page 0x206400004f80: end 0xefd00340000 -> 0xefd00309000\nGlobal scope:\nglobal { // (0x206400644030) (0, 27)\n 
// will be compiled\n  // NormalFunction\n  // 1 stack slots\n  // temporary vars:\n  TEMPORARY .result;  // (0x206400644338) local|0]\n  // local vars:\n  VAR fuzzilli;  // (0x206400644268) \n  // dynamic 
vars:\n  DYNAMIC_GLOBAL native;  // (0x2064006443f8) never assigned\n}\n|generated bytecode for function:  (0x0efd00827475 <SharedFunctionInfo>)]\nBytecode length: 25\nParameter count 1\nRegister count 
3\nFrame size 24\n         0x2c600800074 @    0 : 13 00             LdaConstant |0]\n         0x2c600800076 @    2 : d1                Star1\n         0x2c600800077 @    3 : 1b fe f7          Mov <closure>, 
r2\n    0 E> 0x2c60080007a @    6 : 6e 6b 01 f8 02    CallRuntime |DeclareGlobals], r1-r2\n    7 S> 0x2c60080007f @   11 : 8b 01 00 00       CreateClosure |1], |0], #0\n         0x2c600800083 @   15 : d1     
Star1\n         0x2c600800084 @   16 : 25 02 00          StaGlobal |2], |0]\n         0x2c600800087 @   19 : 1b f8 f9          Mov r1, r0\n         0x2c60080008a @   22 : 0b f9             Ldar r0\n   27 S> 
0x2c60080008c @   24 : b7                Return\nConstant pool (size = 3)\nHandler Table (size = 0)\nSource Position Table (size = 8)\nInner function scope:\nfunction foo () { // (0x206400638220) (180, 272)\n
// NormalFunction\n  // 2 heap slots\n  // local vars:\n  VAR ret;  // (0x20640063d290) never assigned\n  VAR arg;  // (0x20640063d248) never assigned\n\n  function () { // (0x20640063d438) (248, 254)\n    //
NormalFunction\n    // 2 heap slots\n  }\n}\nGlobal scope:\nglobal { // (0x206400638030) (0, 536)\n  // will be compiled\n  // NormalFunction\n  // 1 stack slots\n  // 4 heap slots\n  // temporary vars:\n  
TEMPORARY .result;  // (0x2064006387f8) local|0]\n  // local vars:\n  LET v1;  // (0x206400638540) context|2]\n  VAR foo;  // (0x2064006384e0) \n  LET v2;  // (0x206400638640) context|3]\n\n  function foo () 
{ // (0x206400638220) (180, 272)\n    // lazily parsed\n    // NormalFunction\n    // 2 heap slots\n  }\n}\n|generated bytecode for function:  (0x0efd00827c59 <SharedFunctionInfo>)]\nBytecode length: 
53\nParameter count 1\nRegister count 3\nFrame size 24\n         0x2c600800118 @    0 : 13 00             LdaConstant |0]\n         0x2c60080011a @    2 : d1                Star1\n         0x2c60080011b @    
3 : 1b fe f7          Mov <closure>, r2\n    0 E> 0x2c60080011e @    6 : 6e 6b 01 f8 02    CallRuntime |DeclareGlobals], r1-r2\n  345 S> 0x2c600800123 @   11 : 23 01 00          LdaGlobal |1], |0]\n         
0x2c600800126 @   14 : d1                Star1\n         0x2c600800127 @   15 : 0d 0a             LdaSmi |10]\n         0x2c600800129 @   17 : d0                Star2\n  345 E> 0x2c60080012a @   18 : 6b f8 f7
02       CallUndefinedReceiver1 r1, r2, |2]\n  345 E> 0x2c60080012e @   22 : 29 02             StaCurrentContextSlot |2]\n  363 S> 0x2c600800130 @   24 : 23 01 00          LdaGlobal |1], |0]\n         
0x2c600800133 @   27 : d1                Star1\n         0x2c600800134 @   28 : 13 02             LdaConstant |2]\n         0x2c600800136 @   30 : d0                Star2\n  363 E> 0x2c600800137 @   31 : 6b 
f8 f7 04       CallUndefinedReceiver1 r1, r2, |4]\n  363 E> 0x2c60080013b @   35 : 29 03             StaCurrentContextSlot |3]\n  523 S> 0x2c60080013d @   37 : 18 02             LdaCurrentContextSlot |2]\n   
0x2c60080013f @   39 : d1                Star1\n         0x2c600800140 @   40 : 13 03             LdaConstant |3]\n         0x2c600800142 @   42 : d0                Star2\n  528 E> 0x2c600800143 @   43 : 39 
f8 04 06       SetNamedProperty r1, |4], |6]\n         0x2c600800147 @   47 : 1b f7 f9          Mov r2, r0\n         0x2c60080014a @   50 : 0b f9             Ldar r0\n  536 S> 0x2c60080014c @   52 : b7       
Return\nConstant pool (size = 5)\nHandler Table (size = 0)\nSource Position Table (size = 24)\nGlobal scope:\nfunction foo (arg) { // (0x206400638220) (180, 272)\n  // will be compiled\n  // NormalFunction\n 
// 1 stack slots\n  // local vars:\n  VAR ret;  // (0x2064006384f0) local|0], never assigned\n  VAR arg;  // (0x206400638470) parameter|0], never assigned\n\n  function () { // (0x206400638850) (248, 254)\n  
// lazily parsed\n    // NormalFunction\n    // 2 heap slots\n  }\n}\n|generated bytecode for function: foo (0x0efd00827cc9 <SharedFunctionInfo foo>)]\nBytecode length: 36\nParameter count 2\nRegister count 
5\nFrame size 40\n  200 S> 0x2c6008001c8 @    0 : 87 00 00 29       CreateObjectLiteral |0], |0], #41\n         0x2c6008001cc @    4 : d1                Star1\n         0x2c6008001cd @    5 : 0b 03           
Ldar a0\n  205 E> 0x2c6008001cf @    7 : 3a f8 01 01       DefineNamedOwnProperty r1, |1], |1]\n         0x2c6008001d3 @   11 : 1b f8 f9          Mov r1, r0\n  218 S> 0x2c6008001d6 @   14 : 33 f9 02 03       
GetNamedProperty r0, |2], |3]\n         0x2c6008001da @   18 : d1                Star1\n         0x2c6008001db @   19 : 13 03             LdaConstant |3]\n         0x2c6008001dd @   21 : cf                
Star3\n         0x2c6008001de @   22 : 8b 04 00 02       CreateClosure |4], |0], #2\n         0x2c6008001e2 @   26 : ce                Star4\n  218 E> 0x2c6008001e3 @   27 : 68 f8 f9 f6 f5 05 CallProperty2 
r1, r0, r3, r4, |5]\n  259 S> 0x2c6008001e9 @   33 : 0b f9             Ldar r0\n  270 S> 0x2c6008001eb @   35 : b7                Return\nConstant pool (size = 5)\nHandler Table (size = 0)\nSource Position 
Table (size = 16)\n|generalizing]x:v{None;const}->s{Any;const} (uninitialized field) |~foo+7 at regressions/regress/regress-crbug-977012.js:6]\n|generalizing]x:v{None;const}->s{Any;const} (field type 
generalization) |~foo+7 at regressions/regress/regress-crbug-977012.js:6]\n|generalizing]x:s{Any;const}->d{Any;const} (+1 maps) |~foo+7 at regressions/regress/regress-crbug-977012.js:6]\n|migrating to 
slow]\n"}
[Step 3: Duration 37.85 seconds| Input tokens: 26,726 | Output tokens: 4,146]
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ Step 4 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'search_knowledge_base' with arguments: {'query': 'V8 JSObject::PrepareForDataProperty map transitions dictionary mode NormalizeProperties Accessor vs Data property reconfiguration',         │
│ 'top_k': 5, 'topic_filter': 'v8'}                                                                                                                                                                            │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
Observations: |
  {
    "topic": "V8 JavaScript Engine",
    "file": "v8/v8.dev/docs/hidden-classes.txt",
    "similarity": 0.508,
    "content_preview": "Topic: V8 JavaScript Engine\nFile: v8/v8.dev/docs/hidden-classes.txt\n\nMaps (Hidden Classes) in V8 \u00b7 V8 V8 Show navigation Home Blog Docs Tools JS/Wasm features Research Maps 
(Hidden Classes) in V8 Let's show how V8 builds it's hidden classes. The principal data structures are: Map : the hidden class itself. It's the first pointer value in an object and therefore allows easy 
comparison to see if two objects have the same class. DescriptorArray : The full list of properties that this class has along with information about them. In some cases, the property value is even in this 
array. TransitionArray : An array of \"edges\" from this Map to sibling Maps. Each edge is a property name, and should be thought of as \"if I were to add a property with this name to the current class, what 
class would I transition to?\" Because many Map objects only have one transition to another one (ie, they are \"transitional\" maps, only used on the way to something else), V8 doesn't always create a 
full-blown TransitionArray for it. Instead it'll just link directly to this \"next\" Map . The system has to do a bit of spelunking in the DescriptorArray of the Map being pointed to in order to figure out 
the name attached to the transition. This is an extremely rich subject. It's also subject to change, though, if you understand the concepts in this article future change should be incrementally 
understandable. Why have hidden classes? # V8 could do without hidden classes, sure. It would treat each object as a bag of properties. However, a very useful principle would have been left laying around: the
principal of intelligent design. V8 surmises that you'll only create so many different kinds of objects. And each kind of object will be used in what can eventually be seen to be stereotypical ways. I say 
\"eventually be seen\" because the JavaScript language is a scripting language, not a pre-compiled one. So V8 never knows what will come next. To make use of intelligent design (that is, the assumption that 
there is a mind behind the code coming in), V8 has to watch and wait, letting the sense of structure seep in. The hidden class mechanism is the principal means to do this. Of course, it presupposes a 
sophisticated listening mechanism, and these are the Inline Caches (ICs) about which much has been written. So, if you are convinced this is good and necessary work, follow me! An example # function Peak ( 
name , height , extra ) { this . name = name ; this . height = height ; if ( isNaN ( extra ) ) { this . experience = extra ; } else { this . prominence = extra ; } } m1 = new Peak ( \"Matterhorn\" , 4478 , 
1040 ) ; m2 = new Peak ( \"Wendelstein\" , 1838 , \"good\" ) ; With this code we've already got an interesting map tree from the root map (also known as the initial map) which is attached to the function Peak
: Each blue box is a map, starting with the initial map. This is the map of the object returned if somehow, we managed to run the function Peak without adding a single property. The follow-on maps are the 
ones that result by adding the properties given by the names on the edges between maps. Each map has a list of the properties associated with an object of that map. Furthermore, it describes the exact 
location of each property. Finally, from one of these maps, say, Map3 which is the hidden class of the object you'll get if you passed a number for the extra argument in Peak() , you can follow a back link up
all the way to the initial map. Let's draw it again with this extra information. The annotation (i0), (i1), means in-object field location 0, 1, etc: Now, if you spend time examining these maps before you've 
created at least 7 Peak objects, you'll encounter slack tracking which can be confusing. I have another article about that. Just create 7 more objects and it will be finished. At this point, your Peak objects
will have exactly 3 in-object properties, with no possibility to add more directly in the object. Any additional properties will be offloaded to the object's property backing store. It's just an array of 
property values, whose index comes from the map (Well, technically, from the DescriptorArray attached to the map). Let's add a property to m2 on a new line, and look again at the map tree: m2 . cost = \"one 
arm, one leg\" ; I snuck something in here. Notice that all of the properties are annotated with \"const,\" which means that from V8's point of view, nobody ever changed them since the constructor, so they 
can be considered constants once they've been initialized. TurboFan (the optimizing compiler) loves this. Say m2 is referenced as a constant global by a function. Then the lookup of m2.cost can be done at 
compile time, since the field is marked as constant. I'll return to this later in the article. Notice that property \"cost\" is marked as const p0 , which means it's a constant property stored at index zero 
in the properties backing store rather than in the object directly. This is because we have no more room in the object. This information is visible in %DebugPrint(m2) : d8> %DebugPrint(m2); DebugPrint: 
0x2f9488e9: |JS_OBJECT_TYPE] - map: 0x219473fd <Map(HOLEY_ELEMENTS)> |FastProperties] - prototype: 0x2f94876d <Object map = 0x21947335> - elements: 0x419421a1 <FixedArray|0]> |HOLEY_ELEMENTS] - properties: 
0x2f94aecd <PropertyArray|3]> { 0x419446f9: |String] in ReadOnlySpace: #name: 0x237125e1 <String|11]: #Wendelstein> (const data field 0) 0x23712581: |String] in OldSpace: #height: 1838 (const data field 1) 
0x23712865: |String] in OldSpace: #experience: 0x237125f9 <String|4]: #good> (const data field 2) 0x23714515: |String] in OldSpace: #cost: 0x23714525 <String|16]: #one arm, one leg> (const data field 3) 
properties|0] } ... {name: \"Wendelstein\", height: 1, experience: \"good\", cost: \"one arm, one leg\"} d8> You can see that we have 4 properties, all marked as const. The first 3 in the object, and the last
in properties|0] which means the first slot of the properties backing store. We can look at that: d8> %DebugPrintPtr(0x2f94aecd) DebugPrint: 0x2f94aecd: |PropertyArray] - map: 0x41942be9 <Map> - length: 3 - 
hash: 0 0: 0x23714525 <String|16]: #one arm, one leg> 1-2: 0x41942329 <undefined> The extra properties are there just in case you decide to add more all of a sudden. The real structure # There are different 
things we could do at this point, but since you must really like V8, having read this far, I'd like to try drawing the real data structures we use, the ones mentioned at the beginning of Map , DescriptorArray
, and TransitionArray . Now that you have some idea of the hidden class concept being built up behind the scenes, you may as well bind your thinking more closely to the code through the right names and 
structures. Let me try and reproduce that last figure in V8's representation. First I'm going to draw the DescriptorArrays , which hold the list of properties for a given Map. These arrays can be shared -- 
the key to that is that the Map itself knows how many properties it is allowed to look at in the DescriptorArray. Since the properties are in the order they were added in time, these arrays can be shared by 
several maps. See: Notice that Map1 , Map2 , and Map3 all point to DescriptorArray1 . The number next to the \"descriptors\" field in each Map indicates how many fields over in the DescriptorArray belong to 
the Map. So Map1 , which only knows about the \"name\" property, looks only at the first property listed in DescriptorArray1 . Whereas Map2 has two properties, \"name\" and \"height.\" So it looks at the 
first and second items in DescriptorArray1 (name and height). This kind of sharing saves a lot of space. Naturally, we can't share where there is a split. There is a transition from Map2 over to Map4 if the 
\"experience\" property is added, and over to Map3 if the \"prominence\" property is added. You can see Map4 and Map5 sharing DescriptorArray2 in the same way that DescriptorArray1 was shared among three 
Maps. The only thing missing from our \"true to life\" diagram is the TransitionArray which is still metaphorical at this point. Let's change that. I took the liberty of removing the back pointer lines, which
cleans things up a bit. Just remember that from any Map in the tree, you can walk up the tree, too. The diagram rewards study. Question: what would happen if a new property \"rating\" was added after \"name\"
instead of going on to \"height\" and other properties? Answer : Map1 would get a real TransitionArray so as to keep track of the bifurcation. If property height is added, we should transition to Map2 . 
However, if property rating is added, we should go to a new map, Map6 . This map would need a new DescriptorArray that mentions name and rating . The object has extra free slots at this point in the object 
(only one of three is used), so property rating will be given one of those slots. I checked my answer with the help of %DebugPrintPtr() , and drew the following: No need to beg me to stop, I see that this is 
the upper limit of such diagrams! But I think you can get a sense of how the parts move. Just imagine if after adding this ersatz property rating , we continued on with height , experience and cost . Well, 
we'd have to create maps Map7 , Map8 and Map9 . Because we insisted on adding this property in the middle of an established chain of maps, we will duplicate much structure. I don't have the heart to make that
drawing -- though if you send it to me I will add it to this document :). I used the handy DreamPuf project to make the diagrams easily. Here is a link to the previous diagram. TurboFan and const properties #
Thus far, all these fields are marked in the DescriptorArray as const . Let's play with this. Run the following code on a debug build: // run as: // d8 --allow-natives-syntax --no-lazy-feedback-allocation 
--code-comments --print-opt-code function Peak ( name , height ) { this . name = name ; this . height = height ; } let m1 = new Peak ( \"Matterhorn\" , 4478 ) ; m2 = new Peak ( \"Wendelstein\" , 1838 ) ; // 
Make sure slack tracking finishes. for ( let i = 0 ; i < 7 ; i ++ ) new Peak ( \"blah\" , i ) ; m2 . cost = \"one arm, one leg\" ; function foo ( a ) { return m2 . cost ; } foo ( 3 ) ; foo ( 3 ) ; % 
OptimizeFunctionOnNextCall ( foo ) ; foo ( 3 ) ; You'll get a printout of optimized function foo() . The code is very short. You'll see at the end of the function: ... 40 mov eax,0x2a812499 ;; object: 
0x2a812499 <String|16]: #one arm, one leg> 45 mov esp,ebp 47 pop ebp 48 ret 0x8 ;; return \"one arm, one leg\"! TurboFan, being a cheeky devil, just directly inserted the value of m2.cost . Well how do you 
like that! Of course, after that last call to foo() you could insert this line: m2 . cost = \"priceless\" ; What do you think will happen? One thing for sure, we can't let foo() stay as it is. It would return
the wrong answer. Re-run the program, but add flag --trace-deopt so you'll be told when optimized code is removed from the system. After the printout of the optimized foo() , you'll see these lines: |marking 
dependent code 0x5c684901 0x21e525b9 <SharedFunctionInfo foo> (opt #0) for deoptimization, reason: field-const] |deoptimize marked code in all contexts] Wow. If you force re-optimization you'll get code that 
is not quite as good, but still benefits greatly from the Map structure we've been describing. Remember from our diagrams that property cost is the first property in the properties backing store for an 
object. Well, it may have lost it's const designation, but we still have it's address. Basically, in an object with map Map5 , which we'll certainly verify that global variable m2 still has, we only have to--
load the properties backing store, and read out the first array element. Let's see that. Add this code below the last line: // Force reoptimization of foo(). foo ( 3 ) ; % OptimizeFunctionOnNextCall ( foo ) ;
foo ( 3 ) ; Now have a look at the code produced: ... 40 mov ecx,0x42cc8901 ;; object: 0x42cc8901 <Peak map = 0x3d5873ad> 45 mov ecx,|ecx+0x3] ;; Load the properties backing store 48 mov eax,|ecx+0x7] ;; Get 
the first element. 4b mov esp,ebp 4d pop ebp 4e ret 0x8 ;; return it in register eax! Why heck. That's exactly what we said should happen. Perhaps we are beginning to Know. TurboFan is also smart enough to 
deoptimize if variable m2 ever changes to a different class. You can watch the latest optimized code deoptimize again with something droll like: m2 = 42 ; // heh. Where to go from here # Many options. Map 
migration. Dictionary mode (aka \"slow mode\"). Lots to explore in this area and I hope you enjoy yourself as much as I do -- thanks for reading! Branding Terms Privacy Twitter Edit this page on GitHub Except
as otherwise noted, any code samples from the V8 project are licensed under V8\u2019s BSD-style license . Other content on this page is licensed under the Creative Commons Attribution 3.0 License . For 
details, see our site policies ."
  },
  {
    "topic": "V8 JavaScript Engine",
    "file": "v8/v8.dev/blog/fast-properties.txt",
    "similarity": 0.485,
    "content_preview": "Topic: V8 JavaScript Engine\nFile: v8/v8.dev/blog/fast-properties.txt\n\nFast properties in V8 \u00b7 V8 V8 Show navigation Home Blog Docs Tools JS/Wasm features Research Fast 
properties in V8 Published 30 August 2017 \u00b7 Tagged with internals In this blog post we would like to explain how V8 handles JavaScript properties internally. From a JavaScript point of view there are 
only a few distinctions necessary for properties. JavaScript objects mostly behave like dictionaries, with string keys and arbitrary objects as values. The specification does however treat integer-indexed 
properties and other properties differently during iteration . Other than that, the different properties behave mostly the same, independent of whether they are integer indexed or not. However, under the hood
V8 does rely on several different representations of properties for performance and memory reasons. In this blog post we are going to explain how V8 can provide fast property access while handling 
dynamically-added properties. Understanding how properties work is essential for explaining how optimizations such as inline caches work in V8. This post explains the difference in handling integer-indexed 
and named properties. After that we show how V8 maintains HiddenClasses when adding named properties in order to provide a fast way to identify the shape of an object. We'll then continue giving insights into
how named properties are optimized for fast accesses or fast modification depending on the usage. In the final section we provide details on how V8 handles integer-indexed properties or array indices. Named 
properties vs. elements # Let's start by analysing a very simple object such as {a: \"foo\", b: \"bar\"} . This object has two named properties, \"a\" and \"b\" . It does not have any integer indices for 
property names. Array-indexed properties, more commonly known as elements, are most prominent on arrays. For instance the array |\"foo\", \"bar\"] has two array-indexed properties: 0, with the value \"foo\", 
and 1, with the value \"bar\". This is the first major distinction on how V8 handles properties in general. The following diagram shows what a basic JavaScript object looks like in memory. Elements and 
properties are stored in two separate data structures which makes adding and accessing properties or elements more efficient for different usage patterns. Elements are mainly used for the various 
Array.prototype methods such as pop or slice . Given that these functions access properties in consecutive ranges, V8 also represents them as simple arrays internally \u2014 most of the time. Later in this 
post we will explain how we sometimes switch to a sparse dictionary-based representation to save memory. Named properties are stored in a similar way in a separate array. However, unlike elements, we cannot 
simply use the key to deduce their position within the properties array; we need some additional metadata. In V8 every JavaScript object has a HiddenClass associated. The HiddenClass stores information about 
the shape of an object, and among other things, a mapping from property names to indices into the properties. To complicate things we sometimes use a dictionary for the properties instead of a simple array. 
We will explain this in more detail in a dedicated section. Takeaway from this section: Array-indexed properties are stored in a separate elements store. Named properties are stored in the properties store. 
Elements and properties can either be arrays or dictionaries. Each JavaScript object has a HiddenClass associated that keeps information about the object shape. HiddenClasses and DescriptorArrays # After 
explaining the general distinction of elements and named properties we need to have a look at how HiddenClasses work in V8. This HiddenClass stores meta information about an object, including the number of 
properties on the object and a reference to the object\u2019s prototype. HiddenClasses are conceptually similar to classes in typical object-oriented programming languages. However, in a prototype-based 
language such as JavaScript it is generally not possible to know classes upfront. Hence, in this case V8, HiddenClasses are created on the fly and updated dynamically as objects change. HiddenClasses serve as
an identifier for the shape of an object and as such a very important ingredient for V8's optimizing compiler and inline caches. The optimizing compiler for instance can directly inline property accesses if 
it can ensure a compatible objects structure through the HiddenClass. Let's have a look at the important parts of a HiddenClass. In V8 the first field of a JavaScript object points to a HiddenClass. (In fact,
this is the case for any object that is on the V8 heap and managed by the garbage collector.) In terms of properties, the most important information is the third bit field, which stores the number of 
properties, and a pointer to the descriptor array. The descriptor array contains information about named properties like the name itself and the position where the value is stored. Note that we do not keep 
track of integer indexed properties here, hence there is no entry in the descriptor array. The basic assumption about HiddenClasses is that objects with the same structure \u2014 e.g. the same named 
properties in the same order \u2014 share the same HiddenClass. To achieve that we use a different HiddenClass when a property gets added to an object. In the following example we start from an empty object 
and add three named properties. Every time a new property is added, the object's HiddenClass is changed. In the background V8 creates a transition tree that links the HiddenClasses together. V8 knows which 
HiddenClass to take when you add, for instance, the property \"a\" to an empty object. This transition tree makes sure you end up with the same final HiddenClass if you add the same properties in the same 
order. The following example shows that we would follow the same transition tree even if we add simple indexed properties in between. However, if we create a new object that gets a different property added, 
in this case property \"d\" , V8 creates a separate branch for the new HiddenClasses. Takeaway from this section: Objects with the same structure (same properties in the same order) have the same HiddenClass 
By default every new named property added causes a new HiddenClass to be created. Adding array-indexed properties does not create new HiddenClasses. The three different kinds of named properties # After 
giving an overview on how V8 uses HiddenClasses to track the shape of objects let\u2019s dive into how these properties are actually stored. As explained in the introduction above, there are two fundamental 
kind of properties: named and indexed. The following section covers named properties. A simple object such as {a: 1, b: 2} can have various internal representations in V8. While JavaScript objects behave more
or less like simple dictionaries from the outside, V8 tries to avoid dictionaries because they hamper certain optimizations such as inline caches which we will explain in a separate post. In-object vs. normal
properties: V8 supports so-called in-object properties which are stored directly on the object themselves. These are the fastest properties available in V8 as they are accessible without any indirection. The 
number of in-object properties is predetermined by the initial size of the object. If more properties get added than there is space in the object, they are stored in the properties store. The properties store
adds one level of indirection but can be grown independently. Fast vs. slow properties: The next important distinction is between fast and slow properties. Typically we define the properties stored in the 
linear properties store as \"fast\". Fast properties are simply accessed by index in the properties store. To get from the name of the property to the actual position in the properties store, we have to 
consult the descriptor array on the HiddenClass, as we've outlined before. However, if many properties get added and deleted from an object, it can generate a lot of time and memory overhead to maintain the 
descriptor array and HiddenClasses. Hence, V8 also supports so-called slow properties. An object with slow properties has a self-contained dictionary as a properties store. All the properties meta information
is no longer stored in the descriptor array on the HiddenClass but directly in the properties dictionary. Hence, properties can be added and removed without updating the HiddenClass. Since inline caches 
don\u2019t work with dictionary properties, the latter, are typically slower than fast properties. Takeaway from this section: There are three different named property types: in-object, fast and 
slow/dictionary. In-object properties are stored directly on the object itself and provide the fastest access. Fast properties live in the properties store, all the meta information is stored in the 
descriptor array on the HiddenClass. Slow properties live in a self-contained properties dictionary, meta information is no longer shared through the HiddenClass. Slow properties allow for efficient property 
removal and addition but are slower to access than the other two types. Elements or array-indexed properties # So far we have looked at named properties and ignored integer indexed properties commonly used 
with arrays. Handling of integer indexed properties is no less complex than named properties. Even though all indexed properties are always kept separately in the elements store, there are 20 different types 
of elements! Packed or Holey Elements: The first major distinction V8 makes is whether the elements backing store is packed or has holes in it. You get holes in a backing store if you delete an indexed 
element, or for instance, you don't define it. A simple example is |1,,3] where the second entry is a hole. The following example illustrates this issue: const o = | 'a' , 'b' , 'c' ] ; console . log ( o | 1 
] ) ; // Prints 'b'. delete o | 1 ] ; // Introduces a hole in the elements store. console . log ( o | 1 ] ) ; // Prints 'undefined'; property 1 does not exist. o . __proto__ = { 1 : 'B' } ; // Define property
1 on the prototype. console . log ( o | 0 ] ) ; // Prints 'a'. console . log ( o | 1 ] ) ; // Prints 'B'. console . log ( o | 2 ] ) ; // Prints 'c'. console . log ( o | 3 ] ) ; // Prints undefined In short, 
if a property is not present on the receiver we have to keep on looking on the prototype chain. Given that elements are self-contained, e.g. we don't store information about present indexed properties on the 
HiddenClass, we need a special value, called the_hole, to mark properties that are not present. This is crucial for the performance of Array functions. If we know that there are no holes, i.e. the elements 
store is packed, we can perform local operations without expensive lookups on the prototype chain. Fast or Dictionary Elements: The second major distinction made on elements is whether they are fast or 
dictionary-mode. Fast elements are simple VM-internal arrays where the property index maps to the index in the elements store. However, this simple representation is rather wasteful for very large 
sparse/holey arrays where only few entries are occupied. In this case we used a dictionary-based representation to save memory at the cost of slightly slower access: const sparseArray = | ] ; sparseArray | 
9999 ] = 'foo' ; // Creates an array with dictionary elements. In this example, allocating a full array with 10k entries would be rather wasteful. What happens instead is that V8 creates a dictionary where we
store a key-value-descriptor triplets. The key in this case would be '9999' and the value 'foo' and the default descriptor is used. Given that we don't have a way to store descriptor details on the 
HiddenClass, V8 resorts to slow elements whenever you define an indexed properties with a custom descriptor: const array = | ] ; Object . defineProperty ( array , 0 , { value : 'fixed' configurable : false } 
) ; console . log ( array | 0 ] ) ; // Prints 'fixed'. array | 0 ] = 'other value' ; // Cannot override index 0. console . log ( array | 0 ] ) ; // Still prints 'fixed'. In this example we added a 
non-configurable property on the array. This information is stored in the descriptor part of a slow elements dictionary triplet. It is important to note that Array functions perform considerably slower on 
objects with slow elements. Smi and Double Elements: For fast elements there is another important distinction made in V8. For instance if you only store integers in an Array, a common use-case, the GC does 
not have to look at the array, as integers are directly encoded as so called small integers (Smis) in place. Another special case are Arrays that only contain doubles. Unlike Smis, floating point numbers are 
usually represented as full objects occupying several words. However, V8 stores raw doubles for pure double arrays to avoid memory and performance overhead. The following example lists 4 examples of Smi and 
double elements: const a1 = | 1 , 2 , 3 ] ; // Smi Packed const a2 = | 1 , , 3 ] ; // Smi Holey, a2|1] reads from the prototype const b1 = | 1.1 , 2 , 3 ] ; // Double Packed const b2 = | 1.1 , , 3 ] ; // 
Double Holey, b2|1] reads from the prototype Special Elements: With the information so far we covered 7 out of the 20 different element kinds. For simplicity we excluded 9 element kinds for TypedArrays, two 
more for String wrappers and last but not least, two more special element kinds for arguments objects. The ElementsAccessor: As you can imagine we are not exactly keen on writing Array functions 20 times in 
C++, once for every elements kind . That's where some C++ magic comes into play. Instead of implementing Array functions over and over again, we built the ElementsAccessor where we mostly have to implement 
only simple functions that access elements from the backing store. The ElementsAccessor relies on CRTP to create specialized versions of each Array function. So if you call something like slice on an array, 
V8 internally calls a builtin written in C++ and dispatches through the ElementsAccessor to the specialized version of the function: Takeaway from this section: There are fast and dictionary-mode indexed 
properties and elements. Fast properties can be packed or they can contain holes which indicate that an indexed property has been deleted. Elements are specialized on their content to speed up Array functions
and reduce GC overhead. Understanding how properties work is key to many optimizations in V8. For JavaScript developers many of these internal decisions are not visible directly, but they explain why certain 
code patterns are faster than others. Changing the property or element type typically causes V8 to create a different HiddenClass which can lead to type pollution which prevents V8 from generating optimal 
code . Stay tuned for further posts on how the VM-internals of V8 work. Posted by Camillo Bruni ( @camillobruni ), also author of \u201cFast for - in \u201d . Branding Terms Privacy Twitter Edit this page on 
GitHub Except as otherwise noted, any code samples from the V8 project are licensed under V8\u2019s BSD-style license . Other content on this page is licensed under the Creative Commons Attribution 3.0 
License . For details, see our site policies ."
  },
  {
    "topic": "V8 JavaScript Engine",
    "file": "v8/v8.dev/blog/optimizing-proxies.txt",
    "similarity": 0.458,
    "content_preview": "Topic: V8 JavaScript Engine\nFile: v8/v8.dev/blog/optimizing-proxies.txt\n\nOptimizing ES2015 proxies in V8 \u00b7 V8 V8 Show navigation Home Blog Docs Tools JS/Wasm features Research 
Optimizing ES2015 proxies in V8 Published 05 October 2017 \u00b7 Tagged with ECMAScript benchmarks internals Proxies have been an integral part of JavaScript since ES2015. They allow intercepting fundamental 
operations on objects and customizing their behavior. Proxies form a core part of projects like jsdom and the Comlink RPC library . Recently, we put a lot of effort into improving the performance of proxies 
in V8. This article sheds some light on general performance improvement patterns in V8 and for proxies in particular. Proxies are \u201cobjects used to define custom behavior for fundamental operations (e.g. 
property lookup, assignment, enumeration, function invocation, etc.)\u201d (definition by MDN ). More info can be found in the full specification . For example, the following code snippet adds logging to 
every property access on the object: const target = { } ; const callTracer = new Proxy ( target , { get : ( target , name , receiver ) => { console . log ( ` get was called for: ${ name } ` ) ; return target 
| name ] ; } } ) ; callTracer . property = 'value' ; console . log ( callTracer . property ) ; // get was called for: property // value Constructing proxies # The first feature we'll focus on is the 
construction of proxies. Our original C++ implementation here followed the ECMAScript specification step-by-step, resulting in at least 4 jumps between the C++ and JS runtimes as shown in the following 
figure. We wanted to port this implementation into the platform-agnostic CodeStubAssembler (CSA), which is executed in the JS runtime as opposed to the C++ runtime.This porting minimizes that number of jumps 
between the language runtimes. CEntryStub and JSEntryStub represent the runtimes in the figure below. The dotted lines represent the borders between the JS and C++ runtimes. Luckily, lots of helper predicates
were already implemented in the assembler, which made the initial version concise and readable. The figure below shows the execution flow for calling a Proxy with any proxy trap (in this example apply , which
is being called when the proxy is used as a function) generated by the following sample code: function foo ( \u2026 ) { \u2026 } const g = new Proxy ( { \u2026 } , { apply : foo , } ) ; g ( 1 , 2 ) ; After 
porting the trap execution to CSA all of the execution happens in the JS runtime, reducing the number of jumps between languages from 4 to 0. This change resulted in the following performance improvements:: 
Our JS performance score shows an improvement between 49% and 74% . This score roughly measures how many times the given microbenchmark can be executed in 1000ms. For some tests the code is run multiple times
in order to get an accurate enough measurement given the timer resolution. The code for all of the following benchmarks can be found in our js-perf-test directory . Call and construct traps # The next section
shows the results from optimizing call and construct traps (a.k.a. \"apply\" \" and \"construct\" ). The performance improvements when calling proxies are significant \u2014 up to 500% faster! Still, the 
improvement for proxy construction is quite modest, especially in cases where no actual trap is defined \u2014 only about 25% gain. We investigated this by running the following command with the d8 shell : $ 
out/x64.release/d8 --runtime-call-stats test.js > run: 120.104000 Runtime Function/C++ Builtin Time Count == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == 
== == == == == == == == == == NewObject 59 .16ms 48.47 % 100000 24.94 % JS_Execution 23 .83ms 19.53 % 1 0.00 % RecompileSynchronous 11 .68ms 9.57 % 20 0.00 % AccessorNameGetterCallback 10 .86ms 8.90 % 100000 
24.94 % AccessorNameGetterCallback_FunctionPrototype 5 .79ms 4.74 % 100000 24.94 % Map_SetPrototype 4 .46ms 3.65 % 100203 25.00 % \u2026 SNIPPET \u2026 Where test.js \u2019s source is: function MyClass ( ) { 
} MyClass . prototype = { } ; const P = new Proxy ( MyClass , { } ) ; function run ( ) { return new P ( ) ; } const N = 1e5 ; console . time ( 'run' ) ; for ( let i = 0 ; i < N ; ++ i ) { run ( ) ; } console 
. timeEnd ( 'run' ) ; It turned out most of the time is spent in NewObject and the functions called by it, so we started planning how to speed this up in future releases. Get trap # The next section describes
how we optimized the other most common operations \u2014 getting and setting properties through proxies. It turned out the get trap is more involved than the previous cases, due to the specific behavior of 
V8's inline cache. For a detailed explanation of inline caches, you can watch this talk . Eventually we managed to get a working port to CSA with the following results: After landing the change, we noticed 
the size of the Android .apk for Chrome had grown by ~160KB , which is more than expected for a helper function of roughly 20 lines, but fortunately we track such statistics. It turned out this function is 
called twice from another function, which is called 3 times, from another called 4 times. The cause of the problem turned out to be the aggressive inlining. Eventually we solved the issue by turning the 
inline function into a separate code stub, thus saving precious KBs \u2014 the end version had only ~19KB increase in .apk size. Has trap # The next section shows the results from optimizing the has trap. 
Although at first we thought it would be easier (and reuse most of the code of the get trap), it turned out to have its own peculiarities. A particularly hard-to-track-down problem was the prototype chain 
walking when calling the in operator. The improvement results achieved vary between 71% and 428% . Again the gain is more prominent in cases where the trap is present. Set trap # The next section talks about 
porting the set trap. This time we had to differentiate between named and indexed properties ( elements ). These two main types are not part of the JS language, but are essential for V8's efficient property 
storage. The initial implementation still bailed out to the runtime for elements, which causes crossing the language boundaries again. Nevertheless we achieved improvements between 27% and 438% for cases when
the trap is set, at the cost of a decrease of up to 23% when it's not. This performance regression is due to the overhead of additional check for differentiating between indexed and named properties. For 
indexed properties, there is no improvement yet. Here are the complete results: Real-world usage # Results from jsdom-proxy-benchmark # The jsdom-proxy-benchmark project compiles the ECMAScript specification 
using the Ecmarkup tool. As of v11.2.0 , the jsdom project (which underlies Ecmarkup) uses proxies to implement the common data structures NodeList and HTMLCollection . We used this benchmark to get an 
overview of some more realistic usage than the synthetic micro-benchmarks, and achieved the following results, average of 100 runs: Node v8.4.0 (without Proxy optimizations): 14277 \u00b1 159 ms Node 
v9.0.0-v8-canary-20170924 (with only half of the traps ported): 11789 \u00b1 308 ms Gain in speed around 2.4 seconds which is ~17% better Converting NamedNodeMap to use Proxy increased processing time by 1.9 
s on V8 6.0 (Node v8.4.0) 0.5 s on V8 6.3 (Node v9.0.0-v8-canary-20170910) Note: These results were provided by Timothy Gu . Thanks! Results from Chai.js # Chai.js is a popular assertion library which makes 
heavy use of proxies. We've created a kind of real-world benchmark by running its tests with different versions of V8 an improvement of roughly 1s out of more than 4s , average of 100 runs: Node v8.4.0 
(without Proxy optimizations): 4.2863 \u00b1 0.14 s Node v9.0.0-v8-canary-20170924 (with only half of the traps ported): 3.1809 \u00b1 0.17 s Optimization approach # We often tackle performance issues using a
generic optimization scheme. The main approach that we followed for this particular work included the following steps: Implement performance tests for the particular sub-feature Add more specification 
conformance tests (or write them from scratch) Investigate the original C++ implementation Port the sub-feature to the platform-agnostic CodeStubAssembler Optimize the code even further by hand-crafting a 
TurboFan implementation Measure the performance improvement. This approach can be applied to any general optimization task that you may have. Posted by Maya Armyanova ( @Zmayski ), Optimizer of Proxies. 
Retweet this article! Branding Terms Privacy Twitter Edit this page on GitHub Except as otherwise noted, any code samples from the V8 project are licensed under V8\u2019s BSD-style license . Other content on 
this page is licensed under the Creative Commons Attribution 3.0 License . For details, see our site policies ."
  },
  {
    "topic": "V8 JavaScript Engine",
    "file": "v8/v8.dev/blog/lazy-deserialization.txt",
    "similarity": 0.458,
    "content_preview": "Topic: V8 JavaScript Engine\nFile: v8/v8.dev/blog/lazy-deserialization.txt\n\nLazy deserialization \u00b7 V8 V8 Show navigation Home Blog Docs Tools JS/Wasm features Research Lazy 
deserialization Published 12 February 2018 \u00b7 Tagged with internals TL;DR: Lazy deserialization was recently enabled by default in V8 v6.4 , reducing V8\u2019s memory consumption by over 500 KB per 
browser tab on average. Read on to find out more! Introducing V8 snapshots # But first, let\u2019s take a step back and have a look at how V8 uses heap snapshots to speed up creation of new Isolates (which 
roughly correspond to a browser tab in Chrome). My colleague Yang Guo gave a good introduction on that front in his article on custom startup snapshots : The JavaScript specification includes a lot of 
built-in functionality, from math functions to a full-featured regular expression engine. Every newly-created V8 context has these functions available from the start. For this to work, the global object (for 
example, the window object in a browser) and all the built-in functionality must be set up and initialized into V8\u2019s heap at the time the context is created. It takes quite some time to do this from 
scratch. Fortunately, V8 uses a shortcut to speed things up: just like thawing a frozen pizza for a quick dinner, we deserialize a previously-prepared snapshot directly into the heap to get an initialized 
context. On a regular desktop computer, this can bring the time to create a context from 40 ms down to less than 2 ms. On an average mobile phone, this could mean a difference between 270 ms and 10 ms. To 
recap: snapshots are critical for startup performance, and they are deserialized to create the initial state of V8\u2019s heap for each Isolate. The size of the snapshot thus determines the minimum size of 
the V8 heap, and larger snapshots translate directly into higher memory consumption for each Isolate. A snapshot contains everything needed to fully initialize a new Isolate, including language constants 
(e.g., the undefined value), internal bytecode handlers used by the interpreter, built-in objects (e.g., String ), and the functions installed on built-in objects (e.g., String.prototype.replace ) together 
with their executable Code objects. Startup snapshot size in bytes from 2016-01 to 2017-09. The x-axis shows V8 revision numbers. Over the past two years, the snapshot has nearly tripled in size, going from 
roughly 600 KB in early 2016 to over 1500 KB today. The vast majority of this increase comes from serialized Code objects, which have both increased in count (e.g., through recent additions to the JavaScript 
language as the language specification evolves and grows); and in size (built-ins generated by the new CodeStubAssembler pipeline ship as native code vs. the more compact bytecode or minimized JS formats). 
This is bad news, since we\u2019d like to keep memory consumption as low as possible. Lazy deserialization # One of the major pain points was that we used to copy the entire content of the snapshot into each 
Isolate. Doing so was especially wasteful for built-in functions, which were all loaded unconditionally but may never have ended up being used. This is where lazy deserialization comes in. The concept is 
quite simple: what if we were to only deserialize built-in functions just before they were called? A quick investigation of some of the most popular websites showed this approach to be quite attractive: on 
average, only 30% of all built-in functions were used, with some sites only using 16%. This looked remarkably promising, given that most of these sites are heavy JS users and these numbers can thus be seen as
a (fuzzy) lower bound of potential memory savings for the web in general. As we began working on this direction, it turned out that lazy deserialization integrated very well with V8\u2019s architecture and 
there were only a few, mostly non-invasive design changes necessary to get up and running: Well-known positions within the snapshot. Prior to lazy deserialization, the order of objects within the serialized 
snapshot was irrelevant since we\u2019d only ever deserialize the entire heap at once. Lazy deserialization must be able to deserialize any given built-in function on its own, and therefore has to know where 
it is located within the snapshot. Deserialization of single objects. V8\u2019s snapshots were initially designed for full heap deserialization, and bolting on support for single-object deserialization 
required dealing with a few quirks such as non-contiguous snapshot layout (serialized data for one object could be interspersed with data for other objects) and so-called backreferences (which can directly 
reference objects previously deserialized within the current run). The lazy deserialization mechanism itself. At runtime, the lazy deserialization handler must be able to a) determine which code object to 
deserialize, b) perform the actual deserialization, and c) attach the serialized code object to all relevant functions. Our solution to the first two points was to add a new dedicated built-ins area to the 
snapshot, which may only contain serialized code objects. Serialization occurs in a well-defined order and the starting offset of each Code object is kept in a dedicated section within the built-ins snapshot 
area. Both back-references and interspersed object data are disallowed. Lazy built-in deserialization is handled by the aptly named DeserializeLazy built-in , which is installed on all lazy built-in functions
at deserialization time. When called at runtime, it deserializes the relevant Code object and finally installs it on both the JSFunction (representing the function object) and the SharedFunctionInfo (shared 
between functions created from the same function literal). Each built-in function is deserialized at most once. In addition to built-in functions, we have also implemented lazy deserialization for bytecode 
handlers . Bytecode handlers are code objects that contain the logic to execute each bytecode within V8\u2019s Ignition interpreter. Unlike built-ins, they neither have an attached JSFunction nor a 
SharedFunctionInfo . Instead, their code objects are stored directly in the dispatch table into which the interpreter indexes when dispatching to the next bytecode handler. Lazy deserialization is similar as 
to built-ins: the DeserializeLazy handler determines which handler to deserialize by inspecting the bytecode array, deserializes the code object, and finally stores the deserialized handler in the dispatch 
table. Again, each handler is deserialized at most once. Results # We evaluated memory savings by loading the top 1000 most popular websites using Chrome 65 on an Android device, with and without lazy 
deserialization. On average, V8\u2019s heap size decreased by 540 KB, with 25% of the tested sites saving more than 620 KB, 50% saving more than 540 KB, and 75% saving more than 420 KB. Runtime performance 
(measured on standard JS benchmarks such as Speedometer, as well as a wide selection of popular websites) has remained unaffected by lazy deserialization. Next steps # Lazy deserialization ensures that each 
Isolate only loads the built-in code objects that are actually used. That is already a big win, but we believe it is possible to go one step further and reduce the (built-in-related) cost of each Isolate to 
effectively zero. We hope to bring you updates on this front later this year. Stay tuned! Posted by Jakob Gruber ( @schuay ). Retweet this article! Branding Terms Privacy Twitter Edit this page on GitHub 
Except as otherwise noted, any code samples from the V8 project are licensed under V8\u2019s BSD-style license . Other content on this page is licensed under the Creative Commons Attribution 3.0 License . For
details, see our site policies ."
  },
  {
    "topic": "V8 JavaScript Engine",
    "file": "v8/v8.dev/blog/leaving-the-sea-of-nodes.txt",
    "similarity": 0.457,
    "content_preview": "Topic: V8 JavaScript Engine\nFile: v8/v8.dev/blog/leaving-the-sea-of-nodes.txt\n\nLand ahoy: leaving the Sea of Nodes \u00b7 V8 V8 Show navigation Home Blog Docs Tools JS/Wasm features
Research Land ahoy: leaving the Sea of Nodes Published 25 March 2025 \u00b7 Tagged with JavaScript internals V8\u2019s end-tier optimizing compiler, Turbofan, is famously one of the few large-scale production
compilers to use Sea of Nodes (SoN). However, since almost 3 years ago, we\u2019ve started to get rid of Sea of Nodes and fall back to a more traditional Control-Flow Graph (CFG) Intermediate Representation 
(IR), which we named Turboshaft. By now, the whole JavaScript backend of Turbofan uses Turboshaft instead, and WebAssembly uses Turboshaft throughout its whole pipeline. Two parts of Turbofan still use some 
Sea of Nodes: the builtin pipeline, which we\u2019re slowly replacing by Turboshaft, and the frontend of the JavaScript pipeline, which we\u2019re replacing by Maglev, another CFG-based IR. This blog post 
explains the reasons that led us to move away from Sea of Nodes. The birth of Turbofan and Sea of Nodes # 12 years ago, in 2013, V8 had a single optimizing compiler: Crankshaft . It was using a Control-Flow 
Graph based Intermediate Representation. The initial version of Crankshaft provided significant performance improvements despite still being quite limited in what it supported. Over the next few years, the 
team kept improving it to generate even faster code in ever more situations. However, technical debt was starting to stack up and a number of issues were arising with Crankshaft: It contained too much 
hand-written assembly code. Every time a new operator was added to the IR, its translation to assembly had to be manually written for the four architectures officially supported by V8 (x64, ia32, arm, arm64).
It struggled with optimizing asm.js , which was back then seen as an important step towards high-performance JavaScript. It didn\u2019t allow introducing control flow in lowerings. Put otherwise, control flow
was created at graph building time, and was then final. This was a major limitation, given that a common thing to do when writing compilers is to start with high-level operations, and then lower them to 
low-level operations, often by introducing additional control flow. Consider for instance a high-level operation JSAdd(x,y) , it could make sense to later lower it to something like if (x is String and y is 
String) { StringAdd(x, y) } else { \u2026 } . Well, that wasn\u2019t possible in Crankshaft. Try-catches were not supported, and supporting them was very challenging: multiple engineers had spent months 
trying to support them, without success. It suffered from many performance cliffs and bailouts. Using a specific feature or instruction, or running into a specific edge case of a feature, could cause 
performance to drop by a factor 100. This made it hard for JavaScript developers to write efficient code and to anticipate the performance of their applications. It contained many deoptimization loops : 
Crankshaft would optimize a function using some speculative assumptions, then the function would get deoptimized when those assumptions didn\u2019t hold, but too often, Crankshaft would reoptimize the 
function with the same assumptions, leading to endless optimization-deoptimization loops. Individually, each of these issues could have probably been overcome. However, combined all together, they seemed like
too much. So, the decision was made to replace Crankshaft with a new compiler written from scratch: Turbofan . And, rather than using a traditional CFG IR, Turbofan would use a supposedly more powerful IR: 
Sea of Nodes. At the time, this IR had already been used for more than 10 years in C2, the JIT compiler of the Java HotSpot Virtual Machine. But what is Sea of Nodes, really? # First, a small reminder about 
control-flow graph (CFG): a CFG is a representation of a program as a graph where nodes of the graph represent basic blocks of the program (that is, sequence of instructions without incoming or outgoing 
branches or jumps), and edges represent the control flow of the program. Here is a simple example: Simple CFG graph Instructions within a basic block are implicitly ordered: the first instruction should be 
executed before the second one, and the second one before the third, etc. In the small example above, it feels very natural: v1 == 0 can\u2019t be computed before x % 2 has been computed anyways. However, 
consider CFG graph with arithmetic operations that could be reordered Here, the CFG seemingly imposes that a * 2 be computed before b * 2 , even though we could very well compute them the other way around. 
That\u2019s where Sea of Nodes comes in: Sea of Nodes does not represent basic blocks, but rather only true dependencies between the instructions. Nodes in Sea of Nodes are single instructions (rather than 
basic blocks), and edges represent value uses (meaning: an edge from a to b represents the fact that a uses b ). So, here is how this last example would be represented with Sea of Nodes: Simple Sea of Nodes 
graph with arithmetic operations Eventually, the compiler will need to generate assembly and thus will sequentially schedule these two multiplications, but until then, there is no more dependency between 
them. Now let\u2019s add control flow in the mix. Control nodes (e.g. branch , goto , return ) typically don\u2019t have value dependencies between each other that would force a particular schedule, even 
though they definitely have to be scheduled in a particular order. Thus, in order to represent control-flow, we need a new kind of edge, control edges , which impose some ordering on nodes that don\u2019t 
have value dependency: Sea of Nodes graph with control flow In this example, without control edges, nothing would prevent the return s from being executed before the branch , which would obviously be wrong. 
The crucial thing here is that the control edges only impose an order of the operations that have such incoming or outgoing edges, but not on other operations such as the arithmetic operations. This is the 
main difference between Sea of Nodes and Control flow graphs. Let\u2019s now add effectful operations (eg, loads and stores from and to memory) in the mix. Similarly to control nodes, effectful operations 
often have no value dependencies, but still cannot run in a random order. For instance, a|0] += 42; x = a|0] and x = a|0]; a|0] += 42 are not equivalent. So, we need a way to impose an order (= a schedule) on
effectful operations. We could reuse the control chain for this purpose, but this would be stricter than required. For instance, consider this small snippet: let v = a | 2 ] ; if ( c ) { return v ; } By 
putting a|2] (which reads memory) on the control chain, we would force it to happen before the branch on c , even though, in practice, this load could easily happen after the branch if its result is only used
inside the body of the then-branch. Having lots of nodes in the program on the control chain would defeat the goal of Sea of Nodes, since we would basically end up with a CFG-like IR where only pure 
operations float around. So, to enjoy more freedom and actually benefit from Sea of Nodes, Turbofan has another kind of edge, effect edges , which impose some ordering on nodes that have side effects. 
Let\u2019s ignore control flow for now and look at a small example: Sea of Nodes graph with effectful operations In this example, arr|0] = 42 and let x = arr|a] have no value dependency (ie, the former is not
an input of the latter, and vice versa) . However, because a could be 0 , arr|0] = 42 should be executed before x = arr|a] in order for the latter to always load the correct value from the array. Note that 
while Turbofan has a single effect chain (which splits on branches, and merges back when the control flow merges) which is used for all effectful operations, it\u2019s possible to have multiple effect chains,
where operations that have no dependencies could be on different effect chains, thus relaxing how they can be scheduled (see Chapter 10 of SeaOfNodes/Simple for more details). However, as we\u2019ll explain 
later, maintaining a single effect chain is already very error prone, so we did not attempt in Turbofan to have multiple ones. And, of course, most real programs will contain both control flow and effectful 
operations. Sea of Nodes graph with control flow and effectful operations Note that store and load need control inputs, since they could be protected by various checks (such as type checks or bound checks). 
This example is a good showcase of the power of Sea of Nodes compared to CFG: y = x * c is only used in the else branch thus will freely float to after the branch rather than being computed before as was 
written in the original JavaScript code. This is similar for arr|0] , which is only used in the else branch, and could thus float after the branch (although, in practice, Turbofan will not move down arr|0] , 
for reasons that I\u2019ll explain later). For comparison, here is what the corresponding CFG would look like: CFG graph with control flow and effectful operations Already, we start seeing the main issue with
SoN: it\u2019s much further away from both the input (source code) and the output (assembly) of the compiler than CFG is, which makes it less intuitive to understand. Additionally, having effect and control 
dependencies always explicit makes it hard to quickly reason about the graph, and to write lowerings (since lowerings always have to explicitly maintain the control and effect chain, which are implicit in a 
CFG). And the troubles begin\u2026 # After more than a decade of dealing with Sea of Nodes, we think that it has more downsides than upsides, at least as far as JavaScript and WebAssembly are concerned. 
We\u2019ll go into details in a few of the issues below. Manually/visually inspecting and understanding a Sea of Nodes graph is hard # We\u2019ve already seen that on small programs CFG is easier to read, as 
it is closer to the original source code, which is what developers (including Compiler Engineers!) are used to write. For the unconvinced readers, let me offer a slightly larger example, so that you 
understand the issue better. Consider the following JavaScript function, which concatenates an array of strings: function concat ( arr ) { let res = \"\" ; for ( let i = 0 ; i < arr . length ; i ++ ) { res +=
arr | i ] ; } return res ; } Here is the corresponding Sea of Node graph, in the middle of the Turbofan compilation pipeline (which means that some lowerings have already happened): Sea of Nodes graph for a 
simple array concatenation function Already, this starts looking like a messy soup of nodes. And, as a compiler engineer, a big part of my job is looking at Turbofan graphs to either understand bugs, or to 
find optimization opportunities. Well, it\u2019s not easy to do when the graph looks like this. After all, the input of a compiler is the source code, which is CFG-like (instructions all have a fixed position
in a given block), and the output of the compiler is assembly, which is also CFG-like (instructions also all have a fixed position in a given block). Having a CFG-like IR thus makes it easier for compiler 
engineers to match elements or the IR to either the source or the generated assembly. For comparison, here is the corresponding CFG graph (which we have available because we\u2019ve already started the 
process of replacing sea of nodes with CFG): CFG graph for the same simple array concatenation function Among other things, with the CFG, it\u2019s clear where the loop is, it\u2019s clear what the exit 
condition of the loop is, and it\u2019s easy to find some instructions in the CFG based on where we expect them to be: for instance arr.length can be found in the loop header (it\u2019s v22 = |v0 + 12] ), the
string concatenation can be found towards the end of the loop ( v47 StringConcat(...) ). Arguably, value use-chains are harder to follow in the CFG version, but I would argue that more often than not, 
it\u2019s better to clearly see the control-flow structure of the graph rather than a soup of value nodes. Too many nodes are on the effect chain and/or have a control input # In order to benefit from Sea of 
Nodes, most nodes in the graph should float freely around, without control or effect chain. Unfortunately, that\u2019s not really the case in the typical JavaScript graph, because almost all generic JS 
operations can have arbitrary side effects. They should be rare in Turbofan though, since we have feedback that should allow to lower them to more specific operations. Still, every memory operation needs both
an effect input (since a Load should not float past Stores and vise-versa) and a control input (since there might be a type-check or bound-check before the operation). And even some pure operations like 
division need control inputs because they might have special cases that are protected by checks. Let\u2019s have a look at a concrete example, and start from the following JavaScript function: function foo ( 
a , b ) { // assuming that `a.str` and `b.str` are strings return a . str + b . str ; } Here is the corresponding Turbofan graph. To make things clearer, I\u2019ve highlighted part of the effect chain with 
dashed red lines, and annotated a few nodes with numbers so that I can discuss them below. Sea of Nodes graph for a simple string concatenation function The first observation is that almost all nodes are on 
the effect chain. Let\u2019s go over a few of them, and see if they really need to be: 1 ( CheckedTaggedToTaggedPointer ): this checks that the 1st input of the function is a pointer and not a \u201csmall 
integer\u201d (see Pointer Compression in V8 ). On its own, it wouldn\u2019t really need an effect input, but in practice, it still needs to be on the effect chain, because it guards the following nodes. 2 ( 
CheckMaps ): now that we know that the 1st input is a pointer, this node loads its \u201cmap\u201d (see Maps (Hidden Classes) in V8 ), and checks that it matches what the feedback recorded for this object. 3 
( LoadField ): now that we know that the 1st object is a pointer with the right map, we can load its .str field. 4 , 5 and 6 are a repeat for the second input. 7 ( CheckString ): now that we\u2019ve loaded 
a.str , this node checks that it\u2019s indeed a string. 8 : repeat for the second input. 9 : checks that the combined length of a.str and b.str is less than the maximum size of a String in V8. 10 ( 
StringConcat ): finally concatenates the 2 strings. This graph is very typical of Turbofan graphs for JavaScript programs: checking maps, loading values, checking the maps of the loaded values, and so on, and
eventually doing a few calculations on those values. And like in this example, in a lot of cases, most instructions end up being on the effect or control chain, which imposes a strict order on the operations,
and completely defeats the purpose of Sea of Nodes. Memory operations do not float easily # Let\u2019s consider the following JavaScript program: let x = arr | 0 ] ; let y = arr | 1 ] ; if ( c ) { return x ; 
} else { return y ; } Given that x and y are each only used in a single side of the if - else , we may hope that SoN would allow them to freely float down to inside the \u201cthen\u201d and the 
\u201celse\u201d branches. However, in practice, making this happen in SoN would not be easier than in a CFG. Let\u2019s have a look at the SoN graph to understand why: Sea of Nodes graph where the effect 
chain mirrors the control chain, leading to effectful operations not floating as freely as one may hope When we build the SoN graph, we create the effect chain as we go along, and thus the second Load ends up
being right after the first one, after which the effect chain has to split to reach both return s (if you\u2019re wondering why return s are even on the effect chain, it\u2019s because there could be 
operations with side-effects before, such as Store s, which have to be executed before returning from the function). Given that the second Load is a predecessor to both return s, it has to be scheduled before
the branch , and SoN thus doesn\u2019t allow any of the two Load s to float down freely. In order to move the Load s down the \u201cthen\u201d and \u201celse\u201d branches, we would have to compute that 
there are no side effects in between them, and that there are no side effects in between the second Load and the return s, then we could split the effect chain at the beginning instead of after the second 
Load . Doing this analysis on a SoN graph or on a CFG is extremely similar. Now that we\u2019ve mentioned that a lot of nodes end up on the effect chain, and that effectful nodes often don\u2019t freely float
very far, it\u2019s a good time to realize that in a way, SoN is just CFG where pure nodes are floating . Indeed, in practice, the control nodes and control chain always mirror the structure of the equivalent
CFG. And, when both destinations of a branch have side effects (which is frequent in JavaScript), the effect chain splits and merges exactly where the control chain does (as is the case in the example above: 
the control chain splits on the branch , and the effect chain mirrors this by splitting on the Load ; and if the program would continue after the if - else , both chains would merge around the same place). 
Effectful nodes thus typically end up being constrained to be scheduled in between two control nodes, a.k.a., in a basic block. And within this basic block, the effect chain will constrain effectful nodes to 
be in the same order as they were in the source code. In the end, only pure nodes actually float freely. One way to get more floating nodes is to use multiple effect chains, as mentioned earlier, but this 
comes at a price: first, managing a single effect chain is already hard; managing multiple ones will be much harder. Second, in a dynamic language like JavaScript, we end up with a lot of memory accesses that
could alias, which means that the multiple effect chains would have to all merge very often, thus negating part of the advantages of having multiple effect chains. Managing the effect and control chains 
manually is hard # As mentioned in the previous section, while the effect and control chain are somewhat distinct, in practice, the effect chain typically has the same \u201cshape\u201d as the control chain: 
if the destinations of a branch contain effectful operations (and it\u2019s often the case), then the effect chain will split on the branch and merge back when the control flow merges back. Because we\u2019re
dealing with JavaScript, a lot of nodes have side effects, and we have a lot of branches (typically branching on the type of some objects), which leads to having to keep track of both the effect and control 
chain in parallel, whereas with a CFG, we would only have to keep track of the control chain. History has shown that managing both the effect and control chains manually is error prone, hard to read and hard 
to maintain. Take this sample of code from the JSNativeContextSpecialization phase: JSNativeContextSpecialization :: ReduceNamedAccess ( . . . ) { Effect effect { . . . } ; | . . . ] Node * 
receiverissmi_effect = effect ; | . . . ] Effect this_effect = effect ; | . . . ] this_effect = graph ( ) -> NewNode ( common ( ) -> EffectPhi ( 2 ) , this_effect , receiverissmi_effect , this_control ) ; 
receiverissmi_effect = receiverissmi_control = nullptr ; | . . . ] effect = graph ( ) -> NewNode ( common ( ) -> EffectPhi ( control_count ) , . . . ) ; | . . . ] } Because of the various branches and cases 
that have to be handled here, we end up managing 3 different effect chains. It\u2019s easy to get it wrong and use one effect chain instead of the other. So easy that we indeed got it wrong initially , and 
only realized our mistake after a few months: For this issue, I would place the blame on both Turbofan and Sea of Nodes, rather than only on the latter. Better helpers in Turbofan could have simplified 
managing the effect and control chains, but this would not have been an issue in a CFG. The scheduler is too complex # Eventually, all instructions must be scheduled in order to generate assembly code. The 
theory to schedule instructions is simple enough: each instruction should be scheduled after its value, control and effect inputs (ignoring loops). Let\u2019s have a look at an interesting example: Sea of 
Nodes graph for a simple switch-case You\u2019ll notice that while the source JavaScript program has two identical divisions, the Sea of Node graph only has one. In reality, Sea of Nodes would start with two 
divisions, but since this is a pure operation (assuming double inputs), redundancy elimination would easily deduplicate them into one. Then when reaching the scheduling phase, we would have to find a place to
schedule this division. Clearly, it cannot go after case 1 or case 2 , since it\u2019s used in the other one. Instead, it would have to be scheduled before the switch . The downside is that, now, a / b will 
be computed even when c is 3 , where it doesn\u2019t really need to be computed. This is a real issue that can lead to many deduplicated instructions floating to the common dominator of their users, slowing 
down many paths that don\u2019t need them. There is a fix though: Turbofan\u2019s scheduler will try to identify these cases and duplicate the instructions so that they are only computed on the paths that 
need them. The downside is that this makes the scheduler more complex, requiring additional logic to figure out which nodes could and should be duplicated, and how to duplicate them. So, basically, we started
with 2 divisions, then \u201coptimized\u201d to a single division, and then optimized further to 2 divisions again. And this doesn\u2019t happen just for division: a lot of other operations will go through 
similar cycles. Finding a good order to visit the graph is difficult # All passes of a compiler need to visit the graph, be it to lower nodes, to apply local optimizations, or to run analysis over the whole 
graph. In a CFG, the order in which to visit nodes is usually straightforward: start from the first block (assuming a single-entry function), and iterate through each node of the block, and then move on to 
the successors and so on. In a peephole optimization phase (such as strength reduction ), a nice property of processing the graph in this order is that inputs are always optimized before a node is processed, 
and visiting each node exactly once is thus enough to apply most peephole optimizations. Consider for instance the following sequence of reductions: In total, it took three steps to optimize the whole 
sequence, and each step did useful work. After which, dead code elimination would remove v1 and v2 , resulting in one less instruction than in the initial sequence. With Sea of Nodes, it\u2019s not possible 
to process pure instructions from start to end, since they aren\u2019t on any control or effect chain, and thus there is no pointer to pure roots or anything like that. Instead, the usual way to process a Sea
of Nodes graph for peephole optimizations is to start from the end (e.g., return instructions), and go up the value, effect and control inputs. This has the nice property that we won\u2019t visit any unused 
instruction, but the upsides stop about there, because for peephole optimization, this is about the worst visitation order you could get. On the example above, here are the steps we would take: Start by 
visiting v3 , but can\u2019t lower it at this point, then move on to its inputs Visit v1 , lower it to a << 3 , then move on to its uses, in case the lowering of v1 enables them to be optimized. Visit v3 
again, but can\u2019t lower it yet (this time, we wouldn\u2019t visit its inputs again though) Visit v2 , lower it to b << 3 , then move on to its uses, in case this lowering enables them to be optimized. 
Visit v3 again, lower it to (a & b) << 3 . So, in total, v3 was visited 3 times but only lowered once. We measured this effect on typical JavaScript programs a while ago, and realized that, on average, nodes 
are changed only once every 20 visits! Another consequence of the difficulty to find a good visitation order of the graph is that state tracking is hard and expensive. A lot of optimizations require tracking 
some state along the graph, like Load Elimination or Escape Analysis. However, this is hard to do with Sea of Nodes, because at a given point, it\u2019s hard to know if a given state needs to be kept alive or
not, because it\u2019s hard to figure out if unprocessed nodes would need this state to be processed. As a consequence of this, Turbofan\u2019s Load Elimination phase has a bailout on large graphs to avoid 
taking too long to finish and consuming too much memory. By comparison, we wrote a new Load elimination phase for our new CFG compiler , which we\u2019ve benchmarked to be up to 190 times faster (it has 
better worst-case complexity, so this kind of speedup is easy to achieve on large graphs), while using way less memory. Cache unfriendliness # Almost all phases in Turbofan mutate the graph in-place. Given 
that nodes are fairly large in memory (mostly because each node has pointers to both its inputs and its uses), we try to reuse nodes as much as possible. However, inevitably, when we lower nodes to sequences 
of multiple nodes, we have to introduce new nodes, which will necessarily not be allocated close to the original node in memory. As a result, the deeper we go through the Turbofan pipeline and the more phases
we run, the less cache friendly the graph is. Here is an illustration of this phenomenon: It\u2019s hard to estimate the exact impact of this cache unfriendliness on memory. Still, now that we have our new 
CFG compiler, we can compare the number of cache misses between the two: Sea of Nodes suffers on average from about 3 times more L1 dcache misses compared to our new CFG IR, and up to 7 times more in some 
phases. We estimate that this costs up to 5% of compile time, although this number is a bit handwavy. Still, keep in mind that in a JIT compiler, compiling fast is essential. Control-flow dependent typing is 
limited # Let\u2019s consider the following JavaScript function: function foo ( x ) { if ( x < 42 ) { return x + 1 ; } return x ; } If so far we\u2019ve only seen small integers for x and for the result of 
x+1 (where \u201csmall integers\u201d are 31-bit integers, cf. Value tagging in V8 ), then we\u2019ll speculate that this will remain the case. If we ever see x being larger than a 31-bit integer, then we 
will deoptimize. Similarly, if x+1 produces a result that is larger than 31 bits, we will also deoptimize. This means that we need to check whether x+1 is less or more than the maximum value that fits in 31 
bits. Let\u2019s have a look at corresponding the CFG and SoN graphs: (assuming a CheckedAdd operation that adds its inputs and deoptimizes if the result overflows 31-bits) With a CFG, it\u2019s easy to 
realize that when CheckedAdd(v1, 1) is executed, v1 is guaranteed to be less than 42 , and that there is therefore no need to check for 31-bit overflow. We would thus easily replace the CheckedAdd by a 
regular Add , which would execute faster, and would not require a deoptimization state (which is otherwise required to know how to resume execution after deoptimizing). However, with a SoN graph, CheckedAdd ,
being a pure operation, will flow freely in the graph, and there is thus no way to remove the check until we\u2019ve computed a schedule and decided that we will compute it after the branch (and at this 
point, we are back to a CFG, so this is not a SoN optimization anymore). Such checked operations are frequent in V8 due to this 31-bit small integer optimization, and the ability to replace checked operations
by unchecked operations can have a significant impact on quality of the code generated by Turbofan. So, Turbofan\u2019s SoN puts a control-input on CheckedAdd , which can enable this optimization, but also 
means introducing a scheduling constraint on a pure node, a.k.a., going back to a CFG. And many other issues\u2026 # Propagating deadness is hard. Frequently, during some lowering, we realize that the current
node is actually unreachable. In a CFG, we could just cut the current basic block here, and the following blocks would automatically become obviously unreachable since they would have no predecessors anymore.
In Sea of Nodes, it\u2019s harder, because one has to patch both the control and effect chain. So, when a node on the effect chain is dead, we have to walk forward the effect chain until the next merge, 
killing everything along the way, and carefully handling nodes that are on the control chain. It\u2019s hard to introduce new control flow. Because control flow nodes have to be on the control chain, 
it\u2019s not possible to introduce new control flow during regular lowerings. So, if there is a pure node in the graph, such as Int32Max , which returns the maximum of 2 integers, and which we would 
eventually like to lower to if (x > y) { x } else { y } , this is not easily doable in Sea of Nodes, because we would need a way to figure out where on the control chain to plug this subgraph. One way to 
implement this would be to put Int32Max on the control chain from the beginning, but this feels wasteful: the node is pure and should be allowed to move around freely. So, the canonical Sea of Nodes way to 
solve this, used both in Turbofan, and also by Cliff Click (Sea of Nodes\u2019 inventor), as mentioned in this Coffee Compiler Club chat, is to delay this kind of lowerings until we have a schedule (and thus 
a CFG). As a result, we have a phase around the middle of the pipeline that computes a schedule and lowers the graph, where a lot of random optimizations are packed together because they all require a 
schedule. By comparison, with a CFG, we would be free to do these optimizations earlier or later in the pipeline. Also, remember from the introduction that one of the issues of Crankshaft (Turbofan\u2019s 
predecessor) was that it was virtually impossible to introduce control flow after having built the graph. Turbofan is a slight improvement over this, since lowering of nodes on the control chain can introduce
new control flow, but this is still limited. It\u2019s hard to figure out what is inside of a loop. Because a lot of nodes are floating outside of the control chain, it\u2019s hard to figure out what is 
inside each loop. As a result, basic optimizations such as loop peeling and loop unrolling are hard to implement. Compiling is slow. This is a direct consequence of multiple issues that I\u2019ve already 
mentioned: it\u2019s hard to find a good visitation order for nodes, which leads to many useless revisitation, state tracking is expensive, memory usage is bad, cache locality is bad\u2026 This might not be a
big deal for an ahead of time compiler, but in a JIT compiler, compiling slowly means that we keep executing slow unoptimized code until the optimized code is ready, while taking away resources from other 
tasks (eg, other compilation jobs, or the Garbage Collector). One consequence of this is that we are forced to think very carefully about the compile time - speedup tradeoff of new optimizations, often erring
towards the side of optimizing less to keep optimizing fast. Sea of Nodes destroys any prior scheduling, by construction. JavaScript source code is typically not manually optimized with CPU microarchitecture 
in mind. However, WebAssembly code can be, either at the source level (C++ for instance), or by an ahead-of-time (AOT) compilation toolchain (like Binaryen/Emscripten ). As a result, a WebAssembly code could 
be scheduled in a way that should be good on most architectures (for instance, reducing the need for spilling , assuming 16 registers). However, SoN always discards the initial schedule, and needs to rely on 
its own scheduler only, which, because of the time constraints of JIT compilation, can easily be worse than what an AOT compiler (or a C++ developer carefully thinking about the scheduling of their code) 
could do. We have seen cases where WebAssembly was suffering from this. And, unfortunately, using a CFG compiler for WebAssembly and a SoN compiler for JavaScript in Turbofan was not an option either, since 
using the same compiler for both enables inlining across both languages. Sea of Nodes: elegant but impractical for JavaScript # So, to recapitulate, here are the main problems we have with Sea of Nodes and 
Turbofan: It\u2019s too complex . Effect and control chains are hard to understand, leading to many subtle bugs. Graphs are hard to read and analyze, making new optimizations hard to implement and refine. 
It\u2019s too limited . Too many nodes are on the effect and control chain (because we\u2019re compiling JavaScript code), thus not providing many benefits over a traditional CFG. Additionally, because 
it\u2019s hard to introduce new control-flow in lowerings, even basic optimizations end up being hard to implement. Compiling is too slow . State-tracking is expensive, because it\u2019s hard to find a good 
order in which to visit graphs. Cache locality is bad. And reaching fixpoints during reduction phases takes too long. So, after ten years of dealing with Turbofan and battling Sea of Nodes, we\u2019ve finally
decided to get rid of it, and instead go back to a more traditional CFG IR. Our experience with our new IR has been extremely positive so far, and we are very happy to have gone back to a CFG: compile time 
got divided by 2 compared to SoN, the code of the compiler is a lot simpler and shorter, investigating bugs is usually much easier, etc. Still, this post is already quite long, so I\u2019ll stop here. Stay 
tuned for an upcoming blog post that will explain the design of our new CFG IR, Turboshaft. Posted by Darius Mercadier. Branding Terms Privacy Twitter Edit this page on GitHub Except as otherwise noted, any 
code samples from the V8 project are licensed under V8\u2019s BSD-style license . Other content on this page is licensed under the Creative Commons Attribution 3.0 License . For details, see our site policies
."
  }
]
[Step 4: Duration 23.54 seconds| Input tokens: 50,599 | Output tokens: 5,103]
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ Step 5 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'search_knowledge_base' with arguments: {'query': 'JSObject::PrepareForDataProperty NormalizeProperties MigrateFastToSlow MapUpdater ReconfigureExistingProperty PrepareForDataProperty v8',   │
│ 'top_k': 5, 'topic_filter': 'v8'}                                                                                                                                                                            │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'get_knowledge_doc' with arguments: {'file_path': 'v8/v8.dev/docs/hidden-classes.txt'}                                                                                                         │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
Observations: {
  "topic": "V8 JavaScript Engine",
  "file": "v8/v8.dev/docs/hidden-classes.txt",
  "content": "Topic: V8 JavaScript Engine\nFile: v8/v8.dev/docs/hidden-classes.txt\n\nMaps (Hidden Classes) in V8 \u00b7 V8 V8 Show navigation Home Blog Docs Tools JS/Wasm features Research Maps (Hidden 
Classes) in V8 Let's show how V8 builds it's hidden classes. The principal data structures are: Map : the hidden class itself. It's the first pointer value in an object and therefore allows easy comparison to
see if two objects have the same class. DescriptorArray : The full list of properties that this class has along with information about them. In some cases, the property value is even in this array. 
TransitionArray : An array of \"edges\" from this Map to sibling Maps. Each edge is a property name, and should be thought of as \"if I were to add a property with this name to the current class, what class 
would I transition to?\" Because many Map objects only have one transition to another one (ie, they are \"transitional\" maps, only used on the way to something else), V8 doesn't always create a full-blown 
TransitionArray for it. Instead it'll just link directly to this \"next\" Map . The system has to do a bit of spelunking in the DescriptorArray of the Map being pointed to in order to figure out the name 
attached to the transition. This is an extremely rich subject. It's also subject to change, though, if you understand the concepts in this article future change should be incrementally understandable. Why 
have hidden classes? # V8 could do without hidden classes, sure. It would treat each object as a bag of properties. However, a very useful principle would have been left laying around: the principal of 
intelligent design. V8 surmises that you'll only create so many different kinds of objects. And each kind of object will be used in what can eventually be seen to be stereotypical ways. I say \"eventually be 
seen\" because the JavaScript language is a scripting language, not a pre-compiled one. So V8 never knows what will come next. To make use of intelligent design (that is, the assumption that there is a mind 
behind the code coming in), V8 has to watch and wait, letting the sense of structure seep in. The hidden class mechanism is the principal means to do this. Of course, it presupposes a sophisticated listening 
mechanism, and these are the Inline Caches (ICs) about which much has been written. So, if you are convinced this is good and necessary work, follow me! An example # function Peak ( name , height , extra ) { 
this . name = name ; this . height = height ; if ( isNaN ( extra ) ) { this . experience = extra ; } else { this . prominence = extra ; } } m1 = new Peak ( \"Matterhorn\" , 4478 , 1040 ) ; m2 = new Peak ( 
\"Wendelstein\" , 1838 , \"good\" ) ; With this code we've already got an interesting map tree from the root map (also known as the initial map) which is attached to the function Peak : Each blue box is a 
map, starting with the initial map. This is the map of the object returned if somehow, we managed to run the function Peak without adding a single property. The follow-on maps are the ones that result by 
adding the properties given by the names on the edges between maps. Each map has a list of the properties associated with an object of that map. Furthermore, it describes the exact location of each property. 
Finally, from one of these maps, say, Map3 which is the hidden class of the object you'll get if you passed a number for the extra argument in Peak() , you can follow a back link up all the way to the initial
map. Let's draw it again with this extra information. The annotation (i0), (i1), means in-object field location 0, 1, etc: Now, if you spend time examining these maps before you've created at least 7 Peak 
objects, you'll encounter slack tracking which can be confusing. I have another article about that. Just create 7 more objects and it will be finished. At this point, your Peak objects will have exactly 3 
in-object properties, with no possibility to add more directly in the object. Any additional properties will be offloaded to the object's property backing store. It's just an array of property values, whose 
index comes from the map (Well, technically, from the DescriptorArray attached to the map). Let's add a property to m2 on a new line, and look again at the map tree: m2 . cost = \"one arm, one leg\" ; I snuck
something in here. Notice that all of the properties are annotated with \"const,\" which means that from V8's point of view, nobody ever changed them since the constructor, so they can be considered constants
once they've been initialized. TurboFan (the optimizing compiler) loves this. Say m2 is referenced as a constant global by a function. Then the lookup of m2.cost can be done at compile time, since the field 
is marked as constant. I'll return to this later in the article. Notice that property \"cost\" is marked as const p0 , which means it's a constant property stored at index zero in the properties backing store
rather than in the object directly. This is because we have no more room in the object. This information is visible in %DebugPrint(m2) : d8> %DebugPrint(m2); DebugPrint: 0x2f9488e9: |JS_OBJECT_TYPE] - map: 
0x219473fd <Map(HOLEY_ELEMENTS)> |FastProperties] - prototype: 0x2f94876d <Object map = 0x21947335> - elements: 0x419421a1 <FixedArray|0]> |HOLEY_ELEMENTS] - properties: 0x2f94aecd <PropertyArray|3]> { 
0x419446f9: |String] in ReadOnlySpace: #name: 0x237125e1 <String|11]: #Wendelstein> (const data field 0) 0x23712581: |String] in OldSpace: #height: 1838 (const data field 1) 0x23712865: |String] in OldSpace: 
#experience: 0x237125f9 <String|4]: #good> (const data field 2) 0x23714515: |String] in OldSpace: #cost: 0x23714525 <String|16]: #one arm, one leg> (const data field 3) properties|0] } ... {name: 
\"Wendelstein\", height: 1, experience: \"good\", cost: \"one arm, one leg\"} d8> You can see that we have 4 properties, all marked as const. The first 3 in the object, and the last in properties|0] which 
means the first slot of the properties backing store. We can look at that: d8> %DebugPrintPtr(0x2f94aecd) DebugPrint: 0x2f94aecd: |PropertyArray] - map: 0x41942be9 <Map> - length: 3 - hash: 0 0: 0x23714525 
<String|16]: #one arm, one leg> 1-2: 0x41942329 <undefined> The extra properties are there just in case you decide to add more all of a sudden. The real structure # There are different things we could do at 
this point, but since you must really like V8, having read this far, I'd like to try drawing the real data structures we use, the ones mentioned at the beginning of Map , DescriptorArray , and TransitionArray
. Now that you have some idea of the hidden class concept being built up behind the scenes, you may as well bind your thinking more closely to the code through the right names and structures. Let me try and 
reproduce that last figure in V8's representation. First I'm going to draw the DescriptorArrays , which hold the list of properties for a given Map. These arrays can be shared -- the key to that is that the 
Map itself knows how many properties it is allowed to look at in the DescriptorArray. Since the properties are in the order they were added in time, these arrays can be shared by several maps. See: Notice 
that Map1 , Map2 , and Map3 all point to DescriptorArray1 . The number next to the \"descriptors\" field in each Map indicates how many fields over in the DescriptorArray belong to the Map. So Map1 , which 
only knows about the \"name\" property, looks only at the first property listed in DescriptorArray1 . Whereas Map2 has two properties, \"name\" and \"height.\" So it looks at the first and second items in 
DescriptorArray1 (name and height). This kind of sharing saves a lot of space. Naturally, we can't share where there is a split. There is a transition from Map2 over to Map4 if the \"experience\" property is 
added, and over to Map3 if the \"prominence\" property is added. You can see Map4 and Map5 sharing DescriptorArray2 in the same way that DescriptorArray1 was shared among three Maps. The only thing missing 
from our \"true to life\" diagram is the TransitionArray which is still metaphorical at this point. Let's change that. I took the liberty of removing the back pointer lines, which cleans things up a bit. Just
remember that from any Map in the tree, you can walk up the tree, too. The diagram rewards study. Question: what would happen if a new property \"rating\" was added after \"name\" instead of going on to 
\"height\" and other properties? Answer : Map1 would get a real TransitionArray so as to keep track of the bifurcation. If property height is added, we should transition to Map2 . However, if property rating 
is added, we should go to a new map, Map6 . This map would need a new DescriptorArray that mentions name and rating . The object has extra free slots at this point in the object (only one of three is used), 
so property rating will be given one of those slots. I checked my answer with the help of %DebugPrintPtr() , and drew the following: No need to beg me to stop, I see that this is the upper limit of such 
diagrams! But I think you can get a sense of how the parts move. Just imagine if after adding this ersatz property rating , we continued on with height , experience and cost . Well, we'd have to create maps 
Map7 , Map8 and Map9 . Because we insisted on adding this property in the middle of an established chain of maps, we will duplicate much structure. I don't have the heart to make that drawing -- though if you
send it to me I will add it to this document :). I used the handy DreamPuf project to make the diagrams easily. Here is a link to the previous diagram. TurboFan and const properties # Thus far, all these 
fields are marked in the DescriptorArray as const . Let's play with this. Run the following code on a debug build: // run as: // d8 --allow-natives-syntax --no-lazy-feedback-allocation --code-comments 
--print-opt-code function Peak ( name , height ) { this . name = name ; this . height = height ; } let m1 = new Peak ( \"Matterhorn\" , 4478 ) ; m2 = new Peak ( \"Wendelstein\" , 1838 ) ; // Make sure slack 
tracking finishes. for ( let i = 0 ; i < 7 ; i ++ ) new Peak ( \"blah\" , i ) ; m2 . cost = \"one arm, one leg\" ; function foo ( a ) { return m2 . cost ; } foo ( 3 ) ; foo ( 3 ) ; % 
OptimizeFunctionOnNextCall ( foo ) ; foo ( 3 ) ; You'll get a printout of optimized function foo() . The code is very short. You'll see at the end of the function: ... 40 mov eax,0x2a812499 ;; object: 
0x2a812499 <String|16]: #one arm, one leg> 45 mov esp,ebp 47 pop ebp 48 ret 0x8 ;; return \"one arm, one leg\"! TurboFan, being a cheeky devil, just directly inserted the value of m2.cost . Well how do you 
like that! Of course, after that last call to foo() you could insert this line: m2 . cost = \"priceless\" ; What do you think will happen? One thing for sure, we can't let foo() stay as it is. It would return
the wrong answer. Re-run the program, but add flag --trace-deopt so you'll be told when optimized code is removed from the system. After the printout of the optimized foo() , you'll see these lines: |marking 
dependent code 0x5c684901 0x21e525b9 <SharedFunctionInfo foo> (opt #0) for deoptimization, reason: field-const] |deoptimize marked code in all contexts] Wow. If you force re-optimization you'll get code that 
is not quite as good, but still benefits greatly from the Map structure we've been describing. Remember from our diagrams that property cost is the first property in the properties backing store for an 
object. Well, it may have lost it's const designation, but we still have it's address. Basically, in an object with map Map5 , which we'll certainly verify that global variable m2 still has, we only have to--
load the properties backing store, and read out the first array element. Let's see that. Add this code below the last line: // Force reoptimization of foo(). foo ( 3 ) ; % OptimizeFunctionOnNextCall ( foo ) ;
foo ( 3 ) ; Now have a look at the code produced: ... 40 mov ecx,0x42cc8901 ;; object: 0x42cc8901 <Peak map = 0x3d5873ad> 45 mov ecx,|ecx+0x3] ;; Load the properties backing store 48 mov eax,|ecx+0x7] ;; Get 
the first element. 4b mov esp,ebp 4d pop ebp 4e ret 0x8 ;; return it in register eax! Why heck. That's exactly what we said should happen. Perhaps we are beginning to Know. TurboFan is also smart enough to 
deoptimize if variable m2 ever changes to a different class. You can watch the latest optimized code deoptimize again with something droll like: m2 = 42 ; // heh. Where to go from here # Many options. Map 
migration. Dictionary mode (aka \"slow mode\"). Lots to explore in this area and I hope you enjoy yourself as much as I do -- thanks for reading! Branding Terms Privacy Twitter Edit this page on GitHub Except
as otherwise noted, any code samples from the V8 project are licensed under V8\u2019s BSD-style license . Other content on this page is licensed under the Creative Commons Attribution 3.0 License . For 
details, see our site policies ."
}
Observations: |
  {
    "topic": "V8 JavaScript Engine",
    "file": "v8/v8.dev/blog/leaving-the-sea-of-nodes.txt",
    "similarity": 0.428,
    "content_preview": "Topic: V8 JavaScript Engine\nFile: v8/v8.dev/blog/leaving-the-sea-of-nodes.txt\n\nLand ahoy: leaving the Sea of Nodes \u00b7 V8 V8 Show navigation Home Blog Docs Tools JS/Wasm features
Research Land ahoy: leaving the Sea of Nodes Published 25 March 2025 \u00b7 Tagged with JavaScript internals V8\u2019s end-tier optimizing compiler, Turbofan, is famously one of the few large-scale production
compilers to use Sea of Nodes (SoN). However, since almost 3 years ago, we\u2019ve started to get rid of Sea of Nodes and fall back to a more traditional Control-Flow Graph (CFG) Intermediate Representation 
(IR), which we named Turboshaft. By now, the whole JavaScript backend of Turbofan uses Turboshaft instead, and WebAssembly uses Turboshaft throughout its whole pipeline. Two parts of Turbofan still use some 
Sea of Nodes: the builtin pipeline, which we\u2019re slowly replacing by Turboshaft, and the frontend of the JavaScript pipeline, which we\u2019re replacing by Maglev, another CFG-based IR. This blog post 
explains the reasons that led us to move away from Sea of Nodes. The birth of Turbofan and Sea of Nodes # 12 years ago, in 2013, V8 had a single optimizing compiler: Crankshaft . It was using a Control-Flow 
Graph based Intermediate Representation. The initial version of Crankshaft provided significant performance improvements despite still being quite limited in what it supported. Over the next few years, the 
team kept improving it to generate even faster code in ever more situations. However, technical debt was starting to stack up and a number of issues were arising with Crankshaft: It contained too much 
hand-written assembly code. Every time a new operator was added to the IR, its translation to assembly had to be manually written for the four architectures officially supported by V8 (x64, ia32, arm, arm64).
It struggled with optimizing asm.js , which was back then seen as an important step towards high-performance JavaScript. It didn\u2019t allow introducing control flow in lowerings. Put otherwise, control flow
was created at graph building time, and was then final. This was a major limitation, given that a common thing to do when writing compilers is to start with high-level operations, and then lower them to 
low-level operations, often by introducing additional control flow. Consider for instance a high-level operation JSAdd(x,y) , it could make sense to later lower it to something like if (x is String and y is 
String) { StringAdd(x, y) } else { \u2026 } . Well, that wasn\u2019t possible in Crankshaft. Try-catches were not supported, and supporting them was very challenging: multiple engineers had spent months 
trying to support them, without success. It suffered from many performance cliffs and bailouts. Using a specific feature or instruction, or running into a specific edge case of a feature, could cause 
performance to drop by a factor 100. This made it hard for JavaScript developers to write efficient code and to anticipate the performance of their applications. It contained many deoptimization loops : 
Crankshaft would optimize a function using some speculative assumptions, then the function would get deoptimized when those assumptions didn\u2019t hold, but too often, Crankshaft would reoptimize the 
function with the same assumptions, leading to endless optimization-deoptimization loops. Individually, each of these issues could have probably been overcome. However, combined all together, they seemed like
too much. So, the decision was made to replace Crankshaft with a new compiler written from scratch: Turbofan . And, rather than using a traditional CFG IR, Turbofan would use a supposedly more powerful IR: 
Sea of Nodes. At the time, this IR had already been used for more than 10 years in C2, the JIT compiler of the Java HotSpot Virtual Machine. But what is Sea of Nodes, really? # First, a small reminder about 
control-flow graph (CFG): a CFG is a representation of a program as a graph where nodes of the graph represent basic blocks of the program (that is, sequence of instructions without incoming or outgoing 
branches or jumps), and edges represent the control flow of the program. Here is a simple example: Simple CFG graph Instructions within a basic block are implicitly ordered: the first instruction should be 
executed before the second one, and the second one before the third, etc. In the small example above, it feels very natural: v1 == 0 can\u2019t be computed before x % 2 has been computed anyways. However, 
consider CFG graph with arithmetic operations that could be reordered Here, the CFG seemingly imposes that a * 2 be computed before b * 2 , even though we could very well compute them the other way around. 
That\u2019s where Sea of Nodes comes in: Sea of Nodes does not represent basic blocks, but rather only true dependencies between the instructions. Nodes in Sea of Nodes are single instructions (rather than 
basic blocks), and edges represent value uses (meaning: an edge from a to b represents the fact that a uses b ). So, here is how this last example would be represented with Sea of Nodes: Simple Sea of Nodes 
graph with arithmetic operations Eventually, the compiler will need to generate assembly and thus will sequentially schedule these two multiplications, but until then, there is no more dependency between 
them. Now let\u2019s add control flow in the mix. Control nodes (e.g. branch , goto , return ) typically don\u2019t have value dependencies between each other that would force a particular schedule, even 
though they definitely have to be scheduled in a particular order. Thus, in order to represent control-flow, we need a new kind of edge, control edges , which impose some ordering on nodes that don\u2019t 
have value dependency: Sea of Nodes graph with control flow In this example, without control edges, nothing would prevent the return s from being executed before the branch , which would obviously be wrong. 
The crucial thing here is that the control edges only impose an order of the operations that have such incoming or outgoing edges, but not on other operations such as the arithmetic operations. This is the 
main difference between Sea of Nodes and Control flow graphs. Let\u2019s now add effectful operations (eg, loads and stores from and to memory) in the mix. Similarly to control nodes, effectful operations 
often have no value dependencies, but still cannot run in a random order. For instance, a|0] += 42; x = a|0] and x = a|0]; a|0] += 42 are not equivalent. So, we need a way to impose an order (= a schedule) on
effectful operations. We could reuse the control chain for this purpose, but this would be stricter than required. For instance, consider this small snippet: let v = a | 2 ] ; if ( c ) { return v ; } By 
putting a|2] (which reads memory) on the control chain, we would force it to happen before the branch on c , even though, in practice, this load could easily happen after the branch if its result is only used
inside the body of the then-branch. Having lots of nodes in the program on the control chain would defeat the goal of Sea of Nodes, since we would basically end up with a CFG-like IR where only pure 
operations float around. So, to enjoy more freedom and actually benefit from Sea of Nodes, Turbofan has another kind of edge, effect edges , which impose some ordering on nodes that have side effects. 
Let\u2019s ignore control flow for now and look at a small example: Sea of Nodes graph with effectful operations In this example, arr|0] = 42 and let x = arr|a] have no value dependency (ie, the former is not
an input of the latter, and vice versa) . However, because a could be 0 , arr|0] = 42 should be executed before x = arr|a] in order for the latter to always load the correct value from the array. Note that 
while Turbofan has a single effect chain (which splits on branches, and merges back when the control flow merges) which is used for all effectful operations, it\u2019s possible to have multiple effect chains,
where operations that have no dependencies could be on different effect chains, thus relaxing how they can be scheduled (see Chapter 10 of SeaOfNodes/Simple for more details). However, as we\u2019ll explain 
later, maintaining a single effect chain is already very error prone, so we did not attempt in Turbofan to have multiple ones. And, of course, most real programs will contain both control flow and effectful 
operations. Sea of Nodes graph with control flow and effectful operations Note that store and load need control inputs, since they could be protected by various checks (such as type checks or bound checks). 
This example is a good showcase of the power of Sea of Nodes compared to CFG: y = x * c is only used in the else branch thus will freely float to after the branch rather than being computed before as was 
written in the original JavaScript code. This is similar for arr|0] , which is only used in the else branch, and could thus float after the branch (although, in practice, Turbofan will not move down arr|0] , 
for reasons that I\u2019ll explain later). For comparison, here is what the corresponding CFG would look like: CFG graph with control flow and effectful operations Already, we start seeing the main issue with
SoN: it\u2019s much further away from both the input (source code) and the output (assembly) of the compiler than CFG is, which makes it less intuitive to understand. Additionally, having effect and control 
dependencies always explicit makes it hard to quickly reason about the graph, and to write lowerings (since lowerings always have to explicitly maintain the control and effect chain, which are implicit in a 
CFG). And the troubles begin\u2026 # After more than a decade of dealing with Sea of Nodes, we think that it has more downsides than upsides, at least as far as JavaScript and WebAssembly are concerned. 
We\u2019ll go into details in a few of the issues below. Manually/visually inspecting and understanding a Sea of Nodes graph is hard # We\u2019ve already seen that on small programs CFG is easier to read, as 
it is closer to the original source code, which is what developers (including Compiler Engineers!) are used to write. For the unconvinced readers, let me offer a slightly larger example, so that you 
understand the issue better. Consider the following JavaScript function, which concatenates an array of strings: function concat ( arr ) { let res = \"\" ; for ( let i = 0 ; i < arr . length ; i ++ ) { res +=
arr | i ] ; } return res ; } Here is the corresponding Sea of Node graph, in the middle of the Turbofan compilation pipeline (which means that some lowerings have already happened): Sea of Nodes graph for a 
simple array concatenation function Already, this starts looking like a messy soup of nodes. And, as a compiler engineer, a big part of my job is looking at Turbofan graphs to either understand bugs, or to 
find optimization opportunities. Well, it\u2019s not easy to do when the graph looks like this. After all, the input of a compiler is the source code, which is CFG-like (instructions all have a fixed position
in a given block), and the output of the compiler is assembly, which is also CFG-like (instructions also all have a fixed position in a given block). Having a CFG-like IR thus makes it easier for compiler 
engineers to match elements or the IR to either the source or the generated assembly. For comparison, here is the corresponding CFG graph (which we have available because we\u2019ve already started the 
process of replacing sea of nodes with CFG): CFG graph for the same simple array concatenation function Among other things, with the CFG, it\u2019s clear where the loop is, it\u2019s clear what the exit 
condition of the loop is, and it\u2019s easy to find some instructions in the CFG based on where we expect them to be: for instance arr.length can be found in the loop header (it\u2019s v22 = |v0 + 12] ), the
string concatenation can be found towards the end of the loop ( v47 StringConcat(...) ). Arguably, value use-chains are harder to follow in the CFG version, but I would argue that more often than not, 
it\u2019s better to clearly see the control-flow structure of the graph rather than a soup of value nodes. Too many nodes are on the effect chain and/or have a control input # In order to benefit from Sea of 
Nodes, most nodes in the graph should float freely around, without control or effect chain. Unfortunately, that\u2019s not really the case in the typical JavaScript graph, because almost all generic JS 
operations can have arbitrary side effects. They should be rare in Turbofan though, since we have feedback that should allow to lower them to more specific operations. Still, every memory operation needs both
an effect input (since a Load should not float past Stores and vise-versa) and a control input (since there might be a type-check or bound-check before the operation). And even some pure operations like 
division need control inputs because they might have special cases that are protected by checks. Let\u2019s have a look at a concrete example, and start from the following JavaScript function: function foo ( 
a , b ) { // assuming that `a.str` and `b.str` are strings return a . str + b . str ; } Here is the corresponding Turbofan graph. To make things clearer, I\u2019ve highlighted part of the effect chain with 
dashed red lines, and annotated a few nodes with numbers so that I can discuss them below. Sea of Nodes graph for a simple string concatenation function The first observation is that almost all nodes are on 
the effect chain. Let\u2019s go over a few of them, and see if they really need to be: 1 ( CheckedTaggedToTaggedPointer ): this checks that the 1st input of the function is a pointer and not a \u201csmall 
integer\u201d (see Pointer Compression in V8 ). On its own, it wouldn\u2019t really need an effect input, but in practice, it still needs to be on the effect chain, because it guards the following nodes. 2 ( 
CheckMaps ): now that we know that the 1st input is a pointer, this node loads its \u201cmap\u201d (see Maps (Hidden Classes) in V8 ), and checks that it matches what the feedback recorded for this object. 3 
( LoadField ): now that we know that the 1st object is a pointer with the right map, we can load its .str field. 4 , 5 and 6 are a repeat for the second input. 7 ( CheckString ): now that we\u2019ve loaded 
a.str , this node checks that it\u2019s indeed a string. 8 : repeat for the second input. 9 : checks that the combined length of a.str and b.str is less than the maximum size of a String in V8. 10 ( 
StringConcat ): finally concatenates the 2 strings. This graph is very typical of Turbofan graphs for JavaScript programs: checking maps, loading values, checking the maps of the loaded values, and so on, and
eventually doing a few calculations on those values. And like in this example, in a lot of cases, most instructions end up being on the effect or control chain, which imposes a strict order on the operations,
and completely defeats the purpose of Sea of Nodes. Memory operations do not float easily # Let\u2019s consider the following JavaScript program: let x = arr | 0 ] ; let y = arr | 1 ] ; if ( c ) { return x ; 
} else { return y ; } Given that x and y are each only used in a single side of the if - else , we may hope that SoN would allow them to freely float down to inside the \u201cthen\u201d and the 
\u201celse\u201d branches. However, in practice, making this happen in SoN would not be easier than in a CFG. Let\u2019s have a look at the SoN graph to understand why: Sea of Nodes graph where the effect 
chain mirrors the control chain, leading to effectful operations not floating as freely as one may hope When we build the SoN graph, we create the effect chain as we go along, and thus the second Load ends up
being right after the first one, after which the effect chain has to split to reach both return s (if you\u2019re wondering why return s are even on the effect chain, it\u2019s because there could be 
operations with side-effects before, such as Store s, which have to be executed before returning from the function). Given that the second Load is a predecessor to both return s, it has to be scheduled before
the branch , and SoN thus doesn\u2019t allow any of the two Load s to float down freely. In order to move the Load s down the \u201cthen\u201d and \u201celse\u201d branches, we would have to compute that 
there are no side effects in between them, and that there are no side effects in between the second Load and the return s, then we could split the effect chain at the beginning instead of after the second 
Load . Doing this analysis on a SoN graph or on a CFG is extremely similar. Now that we\u2019ve mentioned that a lot of nodes end up on the effect chain, and that effectful nodes often don\u2019t freely float
very far, it\u2019s a good time to realize that in a way, SoN is just CFG where pure nodes are floating . Indeed, in practice, the control nodes and control chain always mirror the structure of the equivalent
CFG. And, when both destinations of a branch have side effects (which is frequent in JavaScript), the effect chain splits and merges exactly where the control chain does (as is the case in the example above: 
the control chain splits on the branch , and the effect chain mirrors this by splitting on the Load ; and if the program would continue after the if - else , both chains would merge around the same place). 
Effectful nodes thus typically end up being constrained to be scheduled in between two control nodes, a.k.a., in a basic block. And within this basic block, the effect chain will constrain effectful nodes to 
be in the same order as they were in the source code. In the end, only pure nodes actually float freely. One way to get more floating nodes is to use multiple effect chains, as mentioned earlier, but this 
comes at a price: first, managing a single effect chain is already hard; managing multiple ones will be much harder. Second, in a dynamic language like JavaScript, we end up with a lot of memory accesses that
could alias, which means that the multiple effect chains would have to all merge very often, thus negating part of the advantages of having multiple effect chains. Managing the effect and control chains 
manually is hard # As mentioned in the previous section, while the effect and control chain are somewhat distinct, in practice, the effect chain typically has the same \u201cshape\u201d as the control chain: 
if the destinations of a branch contain effectful operations (and it\u2019s often the case), then the effect chain will split on the branch and merge back when the control flow merges back. Because we\u2019re
dealing with JavaScript, a lot of nodes have side effects, and we have a lot of branches (typically branching on the type of some objects), which leads to having to keep track of both the effect and control 
chain in parallel, whereas with a CFG, we would only have to keep track of the control chain. History has shown that managing both the effect and control chains manually is error prone, hard to read and hard 
to maintain. Take this sample of code from the JSNativeContextSpecialization phase: JSNativeContextSpecialization :: ReduceNamedAccess ( . . . ) { Effect effect { . . . } ; | . . . ] Node * 
receiverissmi_effect = effect ; | . . . ] Effect this_effect = effect ; | . . . ] this_effect = graph ( ) -> NewNode ( common ( ) -> EffectPhi ( 2 ) , this_effect , receiverissmi_effect , this_control ) ; 
receiverissmi_effect = receiverissmi_control = nullptr ; | . . . ] effect = graph ( ) -> NewNode ( common ( ) -> EffectPhi ( control_count ) , . . . ) ; | . . . ] } Because of the various branches and cases 
that have to be handled here, we end up managing 3 different effect chains. It\u2019s easy to get it wrong and use one effect chain instead of the other. So easy that we indeed got it wrong initially , and 
only realized our mistake after a few months: For this issue, I would place the blame on both Turbofan and Sea of Nodes, rather than only on the latter. Better helpers in Turbofan could have simplified 
managing the effect and control chains, but this would not have been an issue in a CFG. The scheduler is too complex # Eventually, all instructions must be scheduled in order to generate assembly code. The 
theory to schedule instructions is simple enough: each instruction should be scheduled after its value, control and effect inputs (ignoring loops). Let\u2019s have a look at an interesting example: Sea of 
Nodes graph for a simple switch-case You\u2019ll notice that while the source JavaScript program has two identical divisions, the Sea of Node graph only has one. In reality, Sea of Nodes would start with two 
divisions, but since this is a pure operation (assuming double inputs), redundancy elimination would easily deduplicate them into one. Then when reaching the scheduling phase, we would have to find a place to
schedule this division. Clearly, it cannot go after case 1 or case 2 , since it\u2019s used in the other one. Instead, it would have to be scheduled before the switch . The downside is that, now, a / b will 
be computed even when c is 3 , where it doesn\u2019t really need to be computed. This is a real issue that can lead to many deduplicated instructions floating to the common dominator of their users, slowing 
down many paths that don\u2019t need them. There is a fix though: Turbofan\u2019s scheduler will try to identify these cases and duplicate the instructions so that they are only computed on the paths that 
need them. The downside is that this makes the scheduler more complex, requiring additional logic to figure out which nodes could and should be duplicated, and how to duplicate them. So, basically, we started
with 2 divisions, then \u201coptimized\u201d to a single division, and then optimized further to 2 divisions again. And this doesn\u2019t happen just for division: a lot of other operations will go through 
similar cycles. Finding a good order to visit the graph is difficult # All passes of a compiler need to visit the graph, be it to lower nodes, to apply local optimizations, or to run analysis over the whole 
graph. In a CFG, the order in which to visit nodes is usually straightforward: start from the first block (assuming a single-entry function), and iterate through each node of the block, and then move on to 
the successors and so on. In a peephole optimization phase (such as strength reduction ), a nice property of processing the graph in this order is that inputs are always optimized before a node is processed, 
and visiting each node exactly once is thus enough to apply most peephole optimizations. Consider for instance the following sequence of reductions: In total, it took three steps to optimize the whole 
sequence, and each step did useful work. After which, dead code elimination would remove v1 and v2 , resulting in one less instruction than in the initial sequence. With Sea of Nodes, it\u2019s not possible 
to process pure instructions from start to end, since they aren\u2019t on any control or effect chain, and thus there is no pointer to pure roots or anything like that. Instead, the usual way to process a Sea
of Nodes graph for peephole optimizations is to start from the end (e.g., return instructions), and go up the value, effect and control inputs. This has the nice property that we won\u2019t visit any unused 
instruction, but the upsides stop about there, because for peephole optimization, this is about the worst visitation order you could get. On the example above, here are the steps we would take: Start by 
visiting v3 , but can\u2019t lower it at this point, then move on to its inputs Visit v1 , lower it to a << 3 , then move on to its uses, in case the lowering of v1 enables them to be optimized. Visit v3 
again, but can\u2019t lower it yet (this time, we wouldn\u2019t visit its inputs again though) Visit v2 , lower it to b << 3 , then move on to its uses, in case this lowering enables them to be optimized. 
Visit v3 again, lower it to (a & b) << 3 . So, in total, v3 was visited 3 times but only lowered once. We measured this effect on typical JavaScript programs a while ago, and realized that, on average, nodes 
are changed only once every 20 visits! Another consequence of the difficulty to find a good visitation order of the graph is that state tracking is hard and expensive. A lot of optimizations require tracking 
some state along the graph, like Load Elimination or Escape Analysis. However, this is hard to do with Sea of Nodes, because at a given point, it\u2019s hard to know if a given state needs to be kept alive or
not, because it\u2019s hard to figure out if unprocessed nodes would need this state to be processed. As a consequence of this, Turbofan\u2019s Load Elimination phase has a bailout on large graphs to avoid 
taking too long to finish and consuming too much memory. By comparison, we wrote a new Load elimination phase for our new CFG compiler , which we\u2019ve benchmarked to be up to 190 times faster (it has 
better worst-case complexity, so this kind of speedup is easy to achieve on large graphs), while using way less memory. Cache unfriendliness # Almost all phases in Turbofan mutate the graph in-place. Given 
that nodes are fairly large in memory (mostly because each node has pointers to both its inputs and its uses), we try to reuse nodes as much as possible. However, inevitably, when we lower nodes to sequences 
of multiple nodes, we have to introduce new nodes, which will necessarily not be allocated close to the original node in memory. As a result, the deeper we go through the Turbofan pipeline and the more phases
we run, the less cache friendly the graph is. Here is an illustration of this phenomenon: It\u2019s hard to estimate the exact impact of this cache unfriendliness on memory. Still, now that we have our new 
CFG compiler, we can compare the number of cache misses between the two: Sea of Nodes suffers on average from about 3 times more L1 dcache misses compared to our new CFG IR, and up to 7 times more in some 
phases. We estimate that this costs up to 5% of compile time, although this number is a bit handwavy. Still, keep in mind that in a JIT compiler, compiling fast is essential. Control-flow dependent typing is 
limited # Let\u2019s consider the following JavaScript function: function foo ( x ) { if ( x < 42 ) { return x + 1 ; } return x ; } If so far we\u2019ve only seen small integers for x and for the result of 
x+1 (where \u201csmall integers\u201d are 31-bit integers, cf. Value tagging in V8 ), then we\u2019ll speculate that this will remain the case. If we ever see x being larger than a 31-bit integer, then we 
will deoptimize. Similarly, if x+1 produces a result that is larger than 31 bits, we will also deoptimize. This means that we need to check whether x+1 is less or more than the maximum value that fits in 31 
bits. Let\u2019s have a look at corresponding the CFG and SoN graphs: (assuming a CheckedAdd operation that adds its inputs and deoptimizes if the result overflows 31-bits) With a CFG, it\u2019s easy to 
realize that when CheckedAdd(v1, 1) is executed, v1 is guaranteed to be less than 42 , and that there is therefore no need to check for 31-bit overflow. We would thus easily replace the CheckedAdd by a 
regular Add , which would execute faster, and would not require a deoptimization state (which is otherwise required to know how to resume execution after deoptimizing). However, with a SoN graph, CheckedAdd ,
being a pure operation, will flow freely in the graph, and there is thus no way to remove the check until we\u2019ve computed a schedule and decided that we will compute it after the branch (and at this 
point, we are back to a CFG, so this is not a SoN optimization anymore). Such checked operations are frequent in V8 due to this 31-bit small integer optimization, and the ability to replace checked operations
by unchecked operations can have a significant impact on quality of the code generated by Turbofan. So, Turbofan\u2019s SoN puts a control-input on CheckedAdd , which can enable this optimization, but also 
means introducing a scheduling constraint on a pure node, a.k.a., going back to a CFG. And many other issues\u2026 # Propagating deadness is hard. Frequently, during some lowering, we realize that the current
node is actually unreachable. In a CFG, we could just cut the current basic block here, and the following blocks would automatically become obviously unreachable since they would have no predecessors anymore.
In Sea of Nodes, it\u2019s harder, because one has to patch both the control and effect chain. So, when a node on the effect chain is dead, we have to walk forward the effect chain until the next merge, 
killing everything along the way, and carefully handling nodes that are on the control chain. It\u2019s hard to introduce new control flow. Because control flow nodes have to be on the control chain, 
it\u2019s not possible to introduce new control flow during regular lowerings. So, if there is a pure node in the graph, such as Int32Max , which returns the maximum of 2 integers, and which we would 
eventually like to lower to if (x > y) { x } else { y } , this is not easily doable in Sea of Nodes, because we would need a way to figure out where on the control chain to plug this subgraph. One way to 
implement this would be to put Int32Max on the control chain from the beginning, but this feels wasteful: the node is pure and should be allowed to move around freely. So, the canonical Sea of Nodes way to 
solve this, used both in Turbofan, and also by Cliff Click (Sea of Nodes\u2019 inventor), as mentioned in this Coffee Compiler Club chat, is to delay this kind of lowerings until we have a schedule (and thus 
a CFG). As a result, we have a phase around the middle of the pipeline that computes a schedule and lowers the graph, where a lot of random optimizations are packed together because they all require a 
schedule. By comparison, with a CFG, we would be free to do these optimizations earlier or later in the pipeline. Also, remember from the introduction that one of the issues of Crankshaft (Turbofan\u2019s 
predecessor) was that it was virtually impossible to introduce control flow after having built the graph. Turbofan is a slight improvement over this, since lowering of nodes on the control chain can introduce
new control flow, but this is still limited. It\u2019s hard to figure out what is inside of a loop. Because a lot of nodes are floating outside of the control chain, it\u2019s hard to figure out what is 
inside each loop. As a result, basic optimizations such as loop peeling and loop unrolling are hard to implement. Compiling is slow. This is a direct consequence of multiple issues that I\u2019ve already 
mentioned: it\u2019s hard to find a good visitation order for nodes, which leads to many useless revisitation, state tracking is expensive, memory usage is bad, cache locality is bad\u2026 This might not be a
big deal for an ahead of time compiler, but in a JIT compiler, compiling slowly means that we keep executing slow unoptimized code until the optimized code is ready, while taking away resources from other 
tasks (eg, other compilation jobs, or the Garbage Collector). One consequence of this is that we are forced to think very carefully about the compile time - speedup tradeoff of new optimizations, often erring
towards the side of optimizing less to keep optimizing fast. Sea of Nodes destroys any prior scheduling, by construction. JavaScript source code is typically not manually optimized with CPU microarchitecture 
in mind. However, WebAssembly code can be, either at the source level (C++ for instance), or by an ahead-of-time (AOT) compilation toolchain (like Binaryen/Emscripten ). As a result, a WebAssembly code could 
be scheduled in a way that should be good on most architectures (for instance, reducing the need for spilling , assuming 16 registers). However, SoN always discards the initial schedule, and needs to rely on 
its own scheduler only, which, because of the time constraints of JIT compilation, can easily be worse than what an AOT compiler (or a C++ developer carefully thinking about the scheduling of their code) 
could do. We have seen cases where WebAssembly was suffering from this. And, unfortunately, using a CFG compiler for WebAssembly and a SoN compiler for JavaScript in Turbofan was not an option either, since 
using the same compiler for both enables inlining across both languages. Sea of Nodes: elegant but impractical for JavaScript # So, to recapitulate, here are the main problems we have with Sea of Nodes and 
Turbofan: It\u2019s too complex . Effect and control chains are hard to understand, leading to many subtle bugs. Graphs are hard to read and analyze, making new optimizations hard to implement and refine. 
It\u2019s too limited . Too many nodes are on the effect and control chain (because we\u2019re compiling JavaScript code), thus not providing many benefits over a traditional CFG. Additionally, because 
it\u2019s hard to introduce new control-flow in lowerings, even basic optimizations end up being hard to implement. Compiling is too slow . State-tracking is expensive, because it\u2019s hard to find a good 
order in which to visit graphs. Cache locality is bad. And reaching fixpoints during reduction phases takes too long. So, after ten years of dealing with Turbofan and battling Sea of Nodes, we\u2019ve finally
decided to get rid of it, and instead go back to a more traditional CFG IR. Our experience with our new IR has been extremely positive so far, and we are very happy to have gone back to a CFG: compile time 
got divided by 2 compared to SoN, the code of the compiler is a lot simpler and shorter, investigating bugs is usually much easier, etc. Still, this post is already quite long, so I\u2019ll stop here. Stay 
tuned for an upcoming blog post that will explain the design of our new CFG IR, Turboshaft. Posted by Darius Mercadier. Branding Terms Privacy Twitter Edit this page on GitHub Except as otherwise noted, any 
code samples from the V8 project are licensed under V8\u2019s BSD-style license . Other content on this page is licensed under the Creative Commons Attribution 3.0 License . For details, see our site policies
."
  },
  {
    "topic": "V8 JavaScript Engine",
    "file": "v8/v8.dev/blog/lazy-deserialization.txt",
    "similarity": 0.424,
    "content_preview": "Topic: V8 JavaScript Engine\nFile: v8/v8.dev/blog/lazy-deserialization.txt\n\nLazy deserialization \u00b7 V8 V8 Show navigation Home Blog Docs Tools JS/Wasm features Research Lazy 
deserialization Published 12 February 2018 \u00b7 Tagged with internals TL;DR: Lazy deserialization was recently enabled by default in V8 v6.4 , reducing V8\u2019s memory consumption by over 500 KB per 
browser tab on average. Read on to find out more! Introducing V8 snapshots # But first, let\u2019s take a step back and have a look at how V8 uses heap snapshots to speed up creation of new Isolates (which 
roughly correspond to a browser tab in Chrome). My colleague Yang Guo gave a good introduction on that front in his article on custom startup snapshots : The JavaScript specification includes a lot of 
built-in functionality, from math functions to a full-featured regular expression engine. Every newly-created V8 context has these functions available from the start. For this to work, the global object (for 
example, the window object in a browser) and all the built-in functionality must be set up and initialized into V8\u2019s heap at the time the context is created. It takes quite some time to do this from 
scratch. Fortunately, V8 uses a shortcut to speed things up: just like thawing a frozen pizza for a quick dinner, we deserialize a previously-prepared snapshot directly into the heap to get an initialized 
context. On a regular desktop computer, this can bring the time to create a context from 40 ms down to less than 2 ms. On an average mobile phone, this could mean a difference between 270 ms and 10 ms. To 
recap: snapshots are critical for startup performance, and they are deserialized to create the initial state of V8\u2019s heap for each Isolate. The size of the snapshot thus determines the minimum size of 
the V8 heap, and larger snapshots translate directly into higher memory consumption for each Isolate. A snapshot contains everything needed to fully initialize a new Isolate, including language constants 
(e.g., the undefined value), internal bytecode handlers used by the interpreter, built-in objects (e.g., String ), and the functions installed on built-in objects (e.g., String.prototype.replace ) together 
with their executable Code objects. Startup snapshot size in bytes from 2016-01 to 2017-09. The x-axis shows V8 revision numbers. Over the past two years, the snapshot has nearly tripled in size, going from 
roughly 600 KB in early 2016 to over 1500 KB today. The vast majority of this increase comes from serialized Code objects, which have both increased in count (e.g., through recent additions to the JavaScript 
language as the language specification evolves and grows); and in size (built-ins generated by the new CodeStubAssembler pipeline ship as native code vs. the more compact bytecode or minimized JS formats). 
This is bad news, since we\u2019d like to keep memory consumption as low as possible. Lazy deserialization # One of the major pain points was that we used to copy the entire content of the snapshot into each 
Isolate. Doing so was especially wasteful for built-in functions, which were all loaded unconditionally but may never have ended up being used. This is where lazy deserialization comes in. The concept is 
quite simple: what if we were to only deserialize built-in functions just before they were called? A quick investigation of some of the most popular websites showed this approach to be quite attractive: on 
average, only 30% of all built-in functions were used, with some sites only using 16%. This looked remarkably promising, given that most of these sites are heavy JS users and these numbers can thus be seen as
a (fuzzy) lower bound of potential memory savings for the web in general. As we began working on this direction, it turned out that lazy deserialization integrated very well with V8\u2019s architecture and 
there were only a few, mostly non-invasive design changes necessary to get up and running: Well-known positions within the snapshot. Prior to lazy deserialization, the order of objects within the serialized 
snapshot was irrelevant since we\u2019d only ever deserialize the entire heap at once. Lazy deserialization must be able to deserialize any given built-in function on its own, and therefore has to know where 
it is located within the snapshot. Deserialization of single objects. V8\u2019s snapshots were initially designed for full heap deserialization, and bolting on support for single-object deserialization 
required dealing with a few quirks such as non-contiguous snapshot layout (serialized data for one object could be interspersed with data for other objects) and so-called backreferences (which can directly 
reference objects previously deserialized within the current run). The lazy deserialization mechanism itself. At runtime, the lazy deserialization handler must be able to a) determine which code object to 
deserialize, b) perform the actual deserialization, and c) attach the serialized code object to all relevant functions. Our solution to the first two points was to add a new dedicated built-ins area to the 
snapshot, which may only contain serialized code objects. Serialization occurs in a well-defined order and the starting offset of each Code object is kept in a dedicated section within the built-ins snapshot 
area. Both back-references and interspersed object data are disallowed. Lazy built-in deserialization is handled by the aptly named DeserializeLazy built-in , which is installed on all lazy built-in functions
at deserialization time. When called at runtime, it deserializes the relevant Code object and finally installs it on both the JSFunction (representing the function object) and the SharedFunctionInfo (shared 
between functions created from the same function literal). Each built-in function is deserialized at most once. In addition to built-in functions, we have also implemented lazy deserialization for bytecode 
handlers . Bytecode handlers are code objects that contain the logic to execute each bytecode within V8\u2019s Ignition interpreter. Unlike built-ins, they neither have an attached JSFunction nor a 
SharedFunctionInfo . Instead, their code objects are stored directly in the dispatch table into which the interpreter indexes when dispatching to the next bytecode handler. Lazy deserialization is similar as 
to built-ins: the DeserializeLazy handler determines which handler to deserialize by inspecting the bytecode array, deserializes the code object, and finally stores the deserialized handler in the dispatch 
table. Again, each handler is deserialized at most once. Results # We evaluated memory savings by loading the top 1000 most popular websites using Chrome 65 on an Android device, with and without lazy 
deserialization. On average, V8\u2019s heap size decreased by 540 KB, with 25% of the tested sites saving more than 620 KB, 50% saving more than 540 KB, and 75% saving more than 420 KB. Runtime performance 
(measured on standard JS benchmarks such as Speedometer, as well as a wide selection of popular websites) has remained unaffected by lazy deserialization. Next steps # Lazy deserialization ensures that each 
Isolate only loads the built-in code objects that are actually used. That is already a big win, but we believe it is possible to go one step further and reduce the (built-in-related) cost of each Isolate to 
effectively zero. We hope to bring you updates on this front later this year. Stay tuned! Posted by Jakob Gruber ( @schuay ). Retweet this article! Branding Terms Privacy Twitter Edit this page on GitHub 
Except as otherwise noted, any code samples from the V8 project are licensed under V8\u2019s BSD-style license . Other content on this page is licensed under the Creative Commons Attribution 3.0 License . For
details, see our site policies ."
  },
  {
    "topic": "V8 JavaScript Engine",
    "file": "v8/v8.dev/blog/intl.txt",
    "similarity": 0.419,
    "content_preview": "Topic: V8 JavaScript Engine\nFile: v8/v8.dev/blog/intl.txt\n\nFaster and more feature-rich internationalization APIs \u00b7 V8 V8 Show navigation Home Blog Docs Tools JS/Wasm features 
Research Faster and more feature-rich internationalization APIs Published 25 April 2019 \u00b7 Tagged with ECMAScript Intl The ECMAScript Internationalization API Specification (ECMA-402, or Intl ) provides 
key locale-specific functionality such as date formatting, number formatting, plural form selection, and collation. The Chrome V8 and Google Internationalization teams have been collaborating on adding 
features to V8\u2019s ECMA-402 implementation, while cleaning up technical debt and improving performance and interoperability with other browsers. Underlying architectural improvements # Initially the 
ECMA-402 spec was implemented mostly in JavaScript using V8-extensions and lived outside the V8 codebase. Using the external Extension API meant that several of V8\u2019s internally used APIs for type 
checking, lifetime management of external C++ objects and internal private data storage couldn\u2019t be used. As part of improving startup performance, this implementation was later moved in to the V8 
codebase to enable snapshotting of these builtins. V8 uses specialized JSObject s with custom shapes (hidden classes) to describe built-in JavaScript objects specified by ECMAScript (like Promise s, Map s, 
Set s, etc). With this approach, V8 can pre-allocate the required number of internal slots and generate fast accesses to these, rather than grow the object one property at a time leading to slower performance
and worse memory usage. The Intl implementation was not modeled after such an architecture, as a consequence of the historic split. Instead, all the built-in JavaScript objects as specified by the 
Internationalization spec (like NumberFormat , DateTimeFormat ) were generic JSObject s that had to transition through several property additions for their internal slots. Another artifact of not having a 
specialized JSObject s was that type checking was now more complex. The type information was stored under a private symbol and type-checked on both the JS and C++ side using expensive property access, rather 
than just looking up its shape. Modernizing the codebase # With the current move away from writing self-hosted builtins in V8, it made sense to use this opportunity to modernize the ECMA402 implementation. 
Moving away from self-hosted JS # Although self-hosting lends itself to concise and readable code, the frequent usage of slow runtime calls to access ICU APIs led to performance issues. As a result, a lot of 
ICU functionality was duplicated in JavaScript to reduce the number of such runtime calls. By rewriting the builtins in C++, it became much faster to access the ICU APIs as there is no runtime call overhead 
now. Improving ICU # ICU is a set of C/C++ libraries used by a large set of applications, including all the major JavaScript engines, for providing Unicode and globalization support. As part of switching Intl
to ICU in V8\u2019s implementation, we found and fixed several ICU bugs. As part of implementing new proposals such as Intl.RelativeTimeFormat , Intl.ListFormat and Intl.Locale , we\u2019ve extended ICU by 
adding several new APIs to support these new ECMAScript proposals. All of these additions help other JavaScript engines implement these proposals quicker now, pushing the web forward! For example, development
is in progress in Firefox on implementing several new Intl APIs based on our ICU work. Performance # As a result of this work, we improved the performance of the Internationalization API by optimizing several
fast paths and caching the initialization of the various Intl objects and the toLocaleString methods on Number.prototype , Date.prototype , and String.prototype . For example, creating a new Intl.NumberFormat
object became around 24\u00d7 faster. Microbenchmarks testing the performance of creating various Intl objects Note that for better performance, it\u2019s recommended to explicitly create and reuse an 
Intl.NumberFormat or Intl.DateTimeFormat or Intl.Collator object, rather than calling methods like toLocaleString or localeCompare . New Intl features # All of this work has provided a great foundation to 
build new features on and we\u2019re continuing to ship all the new Internationalization proposals that are in Stage 3. Intl.RelativeTimeFormat has shipped in Chrome 71, Intl.ListFormat has shipped in Chrome 
72, Intl.Locale has shipped in Chrome 74, and dateStyle and timeStyle options for Intl.DateTimeFormat and BigInt support for Intl.DateTimeFormat are shipping in Chrome 76. Intl.DateTimeFormat#formatRange , 
Intl.Segmenter , and additional options for Intl.NumberFormat are currently under development in V8, and we hope to ship them soon! Many of these new APIs, and others further down the pipeline, are due to our
work on standardizing new features to help developers with internationalization. Intl.DisplayNames is a Stage 1 proposal that allows users to localize the display names of language, region or script display 
names. Intl.DateTimeFormat#formatRange is a Stage 3 proposal that specifies a way to format date ranges in a concise and locale-aware manner. The unified Intl.NumberFormat API proposal is a Stage 3 proposal 
that improves Intl.NumberFormat by adding support for measurement units, currency and sign display policies, and scientific and compact notation. You can get involved in the future of ECMA-402 as well, by 
contributing at its GitHub repository . Conclusion # Intl provides a feature-rich API for several operations needed in internationalizing your web app, leaving the heavy lifting to the browser, without 
shipping as much data or code over the wire. Thinking through the proper use of these APIs can lead your UI to work better in different locales. Due to the work by the Google V8 and i18n teams in 
collaboration with TC39 and its ECMA-402 subgroup, you can now access more functionality with better performance, and expect further improvements over time. Posted by \u0b9a\u0ba4\u0bcd\u0baf\u0bbe 
\u0b95\u0bc1\u0ba3\u0b9a\u0bc7\u0b95\u0bb0\u0ba9\u0bcd (Sathya Gunasekaran) . Retweet this article! Branding Terms Privacy Twitter Edit this page on GitHub Except as otherwise noted, any code samples from the
V8 project are licensed under V8\u2019s BSD-style license . Other content on this page is licensed under the Creative Commons Attribution 3.0 License . For details, see our site policies ."
  },
  {
    "topic": "V8 JavaScript Engine",
    "file": "v8/v8.dev/blog/faster-class-features.txt",
    "similarity": 0.418,
    "content_preview": "Topic: V8 JavaScript Engine\nFile: v8/v8.dev/blog/faster-class-features.txt\n\nFaster initialization of instances with new class features \u00b7 V8 V8 Show navigation Home Blog Docs 
Tools JS/Wasm features Research Faster initialization of instances with new class features Published 20 April 2022 \u00b7 Tagged with internals Class fields have been shipped in V8 since v7.2 and private 
class methods have been shipped since v8.4. After the proposals reached stage 4 in 2021, work had begun to improve the support of the new class features in V8 - until then, there had been two main issues 
affecting their adoption: The initialization of class fields and private methods was much slower than the assignment of ordinary properties. The class field initializers were broken in startup snapshots used 
by embedders like Node.js and Deno to speed up the bootstrapping of themselves or user applications. The first issue has been fixed in V8 v9.7 and the fix for the second issue has been released in V8 v10.0. 
This post covers how the first issue was fixed, for another read about the fix of the snapshot issue, check out this post . Optimizing class fields # To get rid of the performance gap between the assignment 
of ordinary properties and the initialization of class fields, we updated the existing inline cache (IC) system to work with the latter. Before v9.7, V8 always used a costly runtime call for class field 
initializations. With v9.7, when V8 considers the pattern of the initialization to be predictable enough, it uses a new IC to speed up the operation just like what it does for assignments of ordinary 
properties. Performance of initializations, optimized Performance of initializations, interpreted The original implementation of class fields # To implement private fields, V8 makes use of the internal 
private symbols \u2014 they are an internal V8 data structure similar to standard Symbol s, except not enumerable when used as a property key. Take this class for an example: class A { #a = 0 ; b = this . #a 
; } V8 would collect the class field initializers ( #a = 0 and b = this.#a ) and generate a synthetic instance member function with the initializers as the function body. The bytecode generated for this 
synthetic function used to be something like this: // Load the private name symbol for `#a` into r1 LdaImmutableCurrentContextSlot | 2 ] Star r1 // Load 0 into r2 LdaZero Star r2 // Move the target into r0 
Mov < this > , r0 // Use the %AddPrivateField() runtime function to store 0 as the value of // the property keyed by the private name symbol `#a` in the instance, // that is, `#a = 0`. CallRuntime | 
AddPrivateField ] , r0 - r2 // Load the property name `b` into r1 LdaConstant | 0 ] Star r1 // Load the private name symbol for `#a` LdaImmutableCurrentContextSlot | 2 ] // Load the value of the property 
keyed by `#a` from the instance into r2 LdaKeyedProperty < this > , | 0 ] Star r2 // Move the target into r0 Mov < this > , r0 // Use the %CreateDataProperty() runtime function to store the property keyed // 
by `#a` as the value of the property keyed by `b`, that is, `b = this.#a` CallRuntime | CreateDataProperty ] , r0 - r2 Compare the class in the previous snippet to a class like this: class A { constructor ( )
{ this . _a = 0 ; this . b = this . _a ; } } Technically these two classes are not equivalent, even ignoring the difference in visibility between this.#a and this._a . The specification mandates \"define\" 
semantics instead of \"set\" semantics. That is, the initialization of class fields does not trigger setters or set Proxy traps. So an approximation of the first class should use Object.defineProperty() 
instead of simple assignments to initialize the properties. In addition, it should throw if the private field already exists in the instance (in case the target being initialized is overridden in the base 
constructor to be another instance): class A { constructor ( ) { // What the %AddPrivateField() call roughly translates to: const _a = % PrivateSymbol ( '#a' ) if ( _a in this ) { throw TypeError ( 'Cannot 
initialize #a twice on the same object' ) ; } Object . defineProperty ( this , _a , { writable : true , configurable : false , enumerable : false , value : 0 } ) ; // What the %CreateDataProperty() call 
roughly translates to: Object . defineProperty ( this , 'b' , { writable : true , configurable : true , enumerable : true , value : this | _a ] } ) ; } } To implement the specified semantics before the 
proposal finalized, V8 used calls to runtime functions since they are more flexible. As shown in the bytecode above, the initialization of public fields was implemented with %CreateDataProperty() runtime 
calls, while the initialization of private fields was implemented with %AddPrivateField() . Since calling into the runtime incurs a significant overhead, the initialization of class fields was much slower 
compared to the assignment of ordinary object properties. In most use cases, however, the semantic differences are insignificant. It would be nice to have the performance of the optimized assignments of 
properties in these cases \u2014 so a more optimal implementation was created after the proposal finalized. Optimizing private class fields and computed public class fields # To speed up initialization of 
private class fields and computed public class fields, the implementation introduced a new machinery to plug into the inline cache (IC) system when handling these operations. This new machinery comes in three
cooperating pieces: In the bytecode generator, a new bytecode DefineKeyedOwnProperty . This gets emitted when generating code for the ClassLiteral::Property AST nodes representing class field initializers. In
the TurboFan JIT, a corresponding IR opcode JSDefineKeyedOwnProperty , which can be compiled from the new bytecode. In the IC system, a new DefineKeyedOwnIC that is used in the interpreter handler of the new 
bytecode as well as the code compiled from the new IR opcode. To simplify the implementation, the new IC reuses some of the code in KeyedStoreIC which was intended for ordinary property stores. Now when V8 
encounters this class: class A { #a = 0 ; } It generates the following bytecode for the initializer #a = 0 : // Load the private name symbol for `#a` into r1 LdaImmutableCurrentContextSlot | 2 ] Star0 // Use 
the DefineKeyedOwnProperty bytecode to store 0 as the value of // the property keyed by the private name symbol `#a` in the instance, // that is, `#a = 0`. LdaZero DefineKeyedOwnProperty < this > , r0 , | 0 ]
When the initializer is executed enough times, V8 allocates one feedback vector slot for each field being initialized. The slot contains the key of the field being added (in the case of the private field, the
private name symbol) and a pair of hidden classes between which the instance has been transitioning as the result of field initialization. In subsequent initializations, the IC uses the feedback to see if the
fields are initialized in the same order on instances with the same hidden classes. If the initialization matches the pattern that V8 has seen before (which is usually the case), V8 takes the fast path and 
performs the initialization with pre-generated code instead of calling into the runtime, thus speeding up the operation. If the initialization does not match a pattern that V8 has seen before, it falls back 
to a runtime call to deal with the slow cases. Optimizing named public class fields # To speed up initialization of named public class fields, we reused the existing DefineNamedOwnProperty bytecode which 
calls into DefineNamedOwnIC either in the interpreter or through the code compiled from the JSDefineNamedOwnProperty IR opcode. Now when V8 encounters this class: class A { #a = 0 ; b = this . #a ; } It 
generates the following bytecode for the b = this.#a initializer: // Load the private name symbol for `#a` LdaImmutableCurrentContextSlot | 2 ] // Load the value of the property keyed by `#a` from the 
instance into r2 // Note: LdaKeyedProperty is renamed to GetKeyedProperty in the refactoring GetKeyedProperty < this > , | 2 ] // Use the DefineKeyedOwnProperty bytecode to store the property keyed // by `#a`
as the value of the property keyed by `b`, that is, `b = this.#a;` DefineNamedOwnProperty < this > , | 0 ] , | 4 ] The original DefineNamedOwnIC machinery could not be simply plugged into the handling of the 
named public class fields, since it was originally intended only for object literal initialization. Previously it expected the target being initialized to be an object that has not yet been touched by the 
user since its creation, which was always true for object literals, but the class fields can be initialized on user-defined objects when the class extends a base class whose constructor overrides the target: 
class A { constructor ( ) { return new Proxy ( { a : 1 } , { defineProperty ( object , key , desc ) { console . log ( 'object:' , object ) ; console . log ( 'key:' , key ) ; console . log ( 'desc:' , desc ) ;
return true ; } } ) ; } } class B extends A { a = 2 ; #b = 3 ; // Not observable. } // object: { a: 1 }, // key: 'a', // desc: {value: 2, writable: true, enumerable: true, configurable: true} new B ( ) ; To 
deal with these targets, we patched the IC to fall back to the runtime when it sees that the object being initialized is a proxy, if the field being defined already exists on the object, or if the object just
has a hidden class that the IC has not seen before. It is still possible to optimize the edge cases if they become common enough, but so far it seems better to trade the performance of them for simplicity of 
the implementation. Optimizing private methods # The implementation of private methods # In the specification , the private methods are described as if they are installed on the instances but not on the 
class. In order to save memory, however, V8's implementation stores the private methods along with a private brand symbol in a context associated with the class. When the constructor is invoked, V8 only 
stores a reference to that context in the instance, with the private brand symbol as the key. Evaluation and instantiation of classes with private methods When the private methods are accessed, V8 walks the 
context chain starting from the execution context to find the class context, reads a statically known slot from the found context to get the private brand symbol for the class, then checks if the instance has
a property keyed by this brand symbol to see if the instance is created from this class. If the brand check passes, V8 loads the private method from another known slot in the same context and completes the 
access. Access of private methods Take this snippet as an example: class A { #a ( ) { } } V8 used to generate the following bytecode for the constructor of A : // Load the private brand symbol for class A 
from the context // and store it into r1. LdaImmutableCurrentContextSlot | 3 ] Star r1 // Load the target into r0. Mov < this > , r0 // Load the current context into r2. Mov < context > , r2 // Call the 
runtime %AddPrivateBrand() function to store the context in // the instance with the private brand as key. CallRuntime | AddPrivateBrand ] , r0 - r2 Since there was also a call to the runtime function 
%AddPrivateBrand() , the overhead made the constructor much slower than constructors of classes with only public methods. Optimizing initialization of private brands # To speed up the installation of the 
private brands, in most cases we just reuse the DefineKeyedOwnProperty machinery added for the optimization of private fields: // Load the private brand symbol for class A from the context // and store it 
into r1 LdaImmutableCurrentContextSlot | 3 ] Star0 // Use the DefineKeyedOwnProperty bytecode to store the // context in the instance with the private brand as key Ldar < context > DefineKeyedOwnProperty < 
this > , r0 , | 0 ] Performance of instance initializations of classes with different methods There is a caveat, however: if the class is a derived class whose constructor calls super() , the initialization 
of the private methods - and in our case, the installation of the private brand symbol - has to happen after super() returns: class A { constructor ( ) { // This throws from a new B() call because super() has
not yet returned. this . callMethod ( ) ; } } class B extends A { #method ( ) { } callMethod ( ) { return this . #method ( ) ; } constructor ( o ) { super ( ) ; } } ; As described before, when initializing 
the brand, V8 also stores a reference to the class context in the instance. This reference isn't used in brand checks, but is instead intended for the debugger to retrieve a list of private methods from the 
instance without knowing which class it is constructed from. When super() is invoked directly in the constructor, V8 can simply load the context from the context register (which is what Mov <context>, r2 or 
Ldar <context> in the bytecodes above does) to perform the initialization, but super() can also be invoked from a nested arrow function, which in turn can be invoked from a different context. In this case, V8
falls back to a runtime function (still named %AddPrivateBrand() ) to look for the class context in the context chain instead of relying on the context register. For example, for the callSuper function below:
class A extends class { } { #method ( ) { } constructor ( run ) { const callSuper = ( ) => super ( ) ; // ...do something run ( callSuper ) } } ; new A ( ( fn ) => fn ( ) ) ; V8 now generates the following 
bytecode: // Invoke the super constructor to construct the instance // and store it into r3. . . . // Load the private brand symbol from the class context at // depth 1 from the current context and store it 
into r4 LdaImmutableContextSlot < context > , | 3 ] , | 1 ] Star4 // Load the depth 1 as an Smi into r6 LdaSmi | 1 ] Star6 // Load the current context into r5 Mov < context > , r5 // Use the 
%AddPrivateBrand() to locate the class context at // depth 1 from the current context and store it in the instance // with the private brand symbol as key CallRuntime | AddPrivateBrand ] , r3 - r6 In this 
case the cost of the runtime call is back so initializing instances of this class is still going to be slower compared to initializing instances of classes with only public methods. It is possible to use a 
dedicated bytecode to implement what %AddPrivateBrand() does, but since invoking super() in a nested arrow function is quite rare, we again traded the performance for simplicity of the implementation. Final 
notes # The work mentioned in this blog post is also included in the Node.js 18.0.0 release . Previously, Node.js switched to symbol properties in a few built-in classes that had been using private fields in 
order to include them into the embedded bootstrap snapshot as well as to improve the performance of the constructors (see this blog post for more context). With the improved support of class features in V8, 
Node.js switched back to private class fields in these classes and Node.js's benchmarks showed that these changes did not introduce any performance regressions . Thanks to Igalia and Bloomberg for 
contributing this implementation! Posted by Joyee Cheung , instance initializer. Retweet this article! Branding Terms Privacy Twitter Edit this page on GitHub Except as otherwise noted, any code samples from 
the V8 project are licensed under V8\u2019s BSD-style license . Other content on this page is licensed under the Creative Commons Attribution 3.0 License . For details, see our site policies ."
  },
  {
    "topic": "V8 JavaScript Engine",
    "file": "v8/v8.dev/docs/wasm-shipping-checklist.txt",
    "similarity": 0.416,
    "content_preview": "Topic: V8 JavaScript Engine\nFile: v8/v8.dev/docs/wasm-shipping-checklist.txt\n\nChecklist for staging, experimenting with, and shipping WebAssembly features \u00b7 V8 V8 Show 
navigation Home Blog Docs Tools JS/Wasm features Research Checklist for staging, experimenting with, and shipping WebAssembly features This document provides checklists of engineering requirements for 
staging, experimenting with, and shipping WebAssembly features in V8. These checklists are meant as a guideline and may not be applicable to all features. The actual launch process is described in the V8 
Launch process . Overview # A feature can be anything from a visible addition to the WebAssembly API which is driven by a W3C WebAssembly community group proposal to a larger architectural change that 
improves performance, stability or user experience. For W3C WebAssembly proposals, we always follow this process even if the proposal is comparably small. In that case, the trials can be skipped if there is 
enough confidence in the design. But all other requirements are mandatory. For non-proposals, the application of this process depends on the complexity and the risk associated with it. E.g., a simple compiler
optimization would not require going through the steps while adding a new compiler all together certainly would. As a rule of thumb, if a feature is complex enough to require adding a feature flag during 
development, then it's likely worth following this process. If an optimization can be merged in a few CLs during one milestone development phase, it's small enough to ship directly. Features of this 
complexity start off behind an experimental flag which enables the feature for developers that would like to try it out and provide feedback and allows us to test the feature in a limited capacity. As these 
features require explicit command line arguments, we don't expect users to enable them and if they do, it's at their own risk. Once we consider a feature sufficiently stable that we consider experimentation 
or even shipping, we (pre-)stage it. This enables the feature on our fuzzers, test and benchmarking infrastructure and allows us to detect issues early on. Once it has shown to be sufficiently stable (usually
after ~2 weeks without major incidents), we open it to the Vulnerability Reward Program (VRP) to allow external security researchers to test it too and file bugs on it. Some features might ship directly from 
this phase, if we don't expect to gain any insights from further experimentation. Others will go through one or more phases of experimentation, e.g. developer trial, origin trial or Finch trial where we 
collect data from partners or in-the-wild usage. An overview over the shipping phases together with their respective requirements is shown here: Overview of WebAssembly shipping phases Flags # We usually 
define one or more command line flags that guard the feature from being active in production environments before it's ready for general use. These flags allow fine-grained control for testing and debugging 
and can be kept beyond the release of a feature to switch it off when needed. This is mostly not necessary and not worth maintaining the alternative code path, but can sometimes be useful (e.g. we kept the 
flags for lazy compilation and dynamic tiering). Wasm feature flags vs. V8 flags # In WebAssembly, we have the option of using a Wasm feature flag ( --experimental-wasm-* ) which is defined via a macro in 
src/wasm/wasm-feature-flags.h (different macros for different phases of development). These flags are usually used for new functionality, e.g. related to a new WebAssembly proposal. Alternatively, one can use
a regular V8 flag as defined in src/flags/flag-definitions.h . These flags are commonly used for architectural changes or optimizations. In early stages, you should use DEFINE_EXPERIMENTAL_FEATURE() . Flags 
for (pre-)staging # There are also common flags which bundle multiple experimental flags together through implications. --experimental-fuzzing is for enabling experimental features on our fuzzers in the 
pre-staging phase. Wasm feature flags defined in the FOREACH_WASM_PRE_STAGING_FEATURE_FLAG macro are automatically implied by this flag. V8 flags for pre-staged features require an explicit implication in 
src/flags/flag-definitions.h . Wasm feature flags also require a use counter to be added (or explicitly disabled this using kIntentionallyNoUseCounter ). It's generally advisable to add a use counter to track
adoption. You can pick a WebFeature or a WebDXFeature for your implementation. If it's linked to a W3C WebAssembly proposal, WebDXFeature is recommended. Otherwise, a WebFeature can be used which requires no 
approval process. For staged features, that are ready for public evaluation (including the VRP) before their launch, we have the --wasm-staging flag which implies all Wasm feature flags defined in the 
FOREACH_WASM_STAGING_FEATURE_FLAG and covers new functionality about to be launched in the near future. For features that are non-functional like optimizations, one can add an explicit implication from 
--future . This flag is also used for benchmarking the performance of upcoming V8 versions. Phases # Inception # This is the phase in which implementation in V8 is starting, but there might not be a Chrome 
feature entry or even a proper name for the feature. Code might be in local branches only or submitted to the main branch, guarded behind a feature flag. Developer trial (optional) # We can optionally ask 
external partners for feedback on the scope, interface or performance of the feature. During the developer trial, they can only test locally, because enabling the feature requires explicitly enabling the 
feature flag via the command line. A developer trial may start before staging and can continue until shipping. (Pre-)Staged # Once we believe the feature is mature enough to consider user testing or even 
shipping, we stage it for at least one milestone. This increases coverage on our test and fuzzing infrastructure. The pre-staging phase is enabled by adding the feature flag as an implication to 
--experimental-fuzzing . After a short time in this stage, we will move the implication to --wasm-staging or --future depending on whether it's a feature or an optimization/architectural change respectively. 
This will open it for the VRP to encourage external researchers to find issues with the code. During this phase, we usually hold a shipping review where the development team assesses the test and fuzzer 
coverage and decides on requirements for the following phases. Origin/field trial # If we need more data to decide on the readiness of a feature, we can schedule a trial. This can either be an origin trial in
tight collaboration with partners or a broader field trial (Finch). Origin trials tend to run for longer than field trials, but complex features might also spend several months in a field trial until they are
sufficiently mature. Shipped # Once a feature is stable, complete and fully spec'd (phase 4 in the WebAssembly Community Group), we can ship it. This enables the feature for all users, even though only a tiny
fraction of websites might use it in the beginning. We keep the flag around for 1-2 more milestones to be able to switch the feature off in case of unexpected side-effects. Clean up # After 1-2 milestones, we
can remove the flag, outdated code and do other clean-up work. For some features, it might be worth keeping the flag around to allow easier debugging, A/B comparisons, etc. Staging # When to stage a 
WebAssembly feature # The staging of a WebAssembly feature defines the end of its implementation phase. The implementation phase is finished when the following checklist is done: The implementation in V8 is 
complete. This includes: Implementation in Turbofan/Turboshaft (if applicable) Implementation in Liftoff (if applicable) Basic fuzzer coverage (if applicable) Tests in V8 are available. Spec tests are rolled 
into V8 by running tools/wasm/update-wasm-spec-tests.sh . All existing proposal spec tests pass. Missing spec tests are unfortunate but should not block staging. Note that the stage of the feature proposal in
the standardization process does not matter for staging the feature in V8. The proposal should, however, be mostly stable. How to stage a WebAssembly feature # Staging Wasm feature flags # Pre-stage the 
feature to collect fuzzer coverage for two weeks In src/wasm/wasm-feature-flags.h , move the feature flag from the FOREACH_WASM_EXPERIMENTAL_FEATURE_FLAG macro list to the 
FOREACH_WASM_PRE_STAGING_FEATURE_FLAG macro list. In tools/wasm/update-wasm-spec-tests.sh , add the proposal repository name to the repos list of repositories. Run tools/wasm/update-wasm-spec-tests.sh to 
create and upload the spec tests of the new proposal. In test/wasm-spec-tests/testcfg.py , add the proposal repository name and the feature flag to the proposal_flags list. In test/wasm-js/testcfg.py , add 
the proposal repository name and the feature flag to the proposal_flags list. After two weeks of fuzzer coverage, we can open the feature to the VRP to encourage external bug reporting. In 
src/wasm/wasm-feature-flags.h , move the feature flag from the FOREACH_WASM_PRE_STAGING_FEATURE_FLAG macro list to the FOREACH_WASM_STAGING_FEATURE_FLAG macro list. Staging other feature flags # Pre-stage the
feature to collect fuzzer coverage for two weeks In src/flags/flag-definitions.h add an implication from experimental_fuzzing to the feature flag using DEFINE_WEAK_IMPLICATION() . After two weeks of fuzzer 
coverage, we can open the feature to the VRP to encourage external bug reporting. Switch the flag definition from DEFINE_EXPERIMENTAL_FEATURE to DEFINE_BOOL with a false default. In 
src/flags/flag-definitions.h , move the feature flag implication from the experimental_fuzzing to future (performance optimizations) or wasm_staging (other architectural changes). Either implication will 
continue fuzzing coverage, but an implication from future will also enable it for benchmarking which might or might not be desired. Experimentation (optional) # There are multiple ways of experimenting with a
new feature and gathering information on its stability and viability. The successful completion of the staging phase ensures that our users are not exposed to experimental code that might be harmful to them. 
However, full stability is not always guaranteed which is why such experimentation must be executed with great care. Developer trial # This is the easiest trial to run. It often does not require any changes 
to the code, but developers are encouraged to try it out. This can happen via the existing command line flag, by adding a Chrome flag that developers can enable via the chrome://flags or by staging a Wasm 
feature flag which automatically adds it to the existing Experimental WebAssembly option there ( chrome://flags#enable-experimental-webassembly-features ). Because the latter option might be switched on by 
users accidentally (e.g. because they tried another feature earlier and forgot to disable it afterwards), the bar for adding features there is higher and one should carefully evaluate if the feature meets the
criteria for staging before choosing this option. Steps to enable a developer trial # Reach out to partners and collect feedback (direct communication, issues or polls). Origin trial # Features that web 
developers want to try out with their own users are ideal for an origin trial. This is often a new WebAssembly proposal that requires feedback from real-world scenarios to evaluate its shape and potential 
readiness for publication. Developers can set up their own trials where they compare different populations that have the feature enabled or disabled. Sometimes, even different versions of an API can be 
compared against each other. The feedback can be collected from partners or via Chrome's metric collection. It is usually reported back to the W3C WebAssembly community group and to the Blink API owners. 
Steps to launch an origin trial # To get the experiment going, do the following Inform the Chrome Security Team about the pending experiment (tracking sheet or email). Request all required reviews for 
experimentation on the Chrome Feature entry. Send Intent to Experiment (up to 6 months/milestones) to Blink API Owners and get one LGTM. Inform the OT team and wait for the resolution. Distribute the signup 
link to interested partners. To get an extension (up to 3 months/milestones) Summarize feedback of the experiment so far. Motivate extension and summarize progress in an Intent to Extend Experiment to the 
Blink API Owners and get one LGTM. Update Chrome Status entry and wait for its resolution. Ask partners to update their tokens. Finch trial # When a feature does not require any changes to user code, Chrome 
can decide to run a trial without partner engagement. Such trials are ideal for performance improvements or larger architectural changes. Chrome's metric collection can then be used to compare different 
configurations and their impact on common performance and stability metrics. Steps to launch a Finch trial # Make the Chrome Security Team aware of the pending experiment (tracking sheet or email). Consider 
adding GWS ids and inform partners of the experiment to track any changes in application metrics that are not covered by Chrome (e.g. performance metrics). Submit a configuration to be tested in the Chrome 
repo. Enable the Finch experiment, starting with 50% of dev users. Regularly check metrics and follow up on alerts. After at least 2 weeks of stable experimentation, advance the experiment to 50% of beta 
users. After at least 2 weeks of stable experimentation, advance the experiment to 1% of stable users. After at least 2 weeks of stable experimentation, advance the experiment to 10% of stable users. After at
least 4 weeks of stable experimentation, advance the experiment to 50% of stable users (in case WebView is not part of the trial, one can jump straight to shipping from here, but it's recommended to include 
WebView into each trial). After at least 2 weeks of stable experimentation, you can consider shipping. The longer experimentation time at 10% of stable users is to accommodate for manually detected bugs and 
reporting which tend to have a longer lead time than signals gathered from metrics and automated testing. At 10% the impact of the experiment is still limited while providing good visibility for partners to 
identify issues. Shipping # When is a WebAssembly feature ready to be shipped? # The V8 Launch process is satisfied. The implementation is covered by a fuzzer (if applicable). The feature has been staged and 
opened to the VRP for several weeks to get fuzzer coverage and feedback. The feature proposal is stage 4 (if applicable). All spec tests pass. The Chromium DevTools checklist for new WebAssembly features is 
satisfied. How to ship a WebAssembly feature # Prerequisites # Request all required reviews for shipping on the Chrome Feature entry. Send Intent to Ship to Blink API Owners and get three LGTMs. Ship Wasm 
feature flags # In src/wasm/wasm-feature-flags.h , move the feature flag from the FOREACH_WASM_STAGING_FEATURE_FLAG macro list to the FOREACH_WASM_SHIPPED_FEATURE_FLAG macro list. Additionally, enable the 
feature by default by changing the third parameter in FOREACH_WASM_SHIPPED_FEATURE_FLAG to true . Ship other feature flags # In src/flags/flag-definitions.h , remove any implication from future and 
wasm-staging . Set the default value of the feature in src/flags/flag-definitions.h to true . After enabling the feature # Ensure to add a blink CQ bot on the CL to check for blink web test failures caused by
enabling the feature (add this line to the footer of the CL description: Cq-Include-Trybots: luci.v8.try:v8_linux_blink_rel ). If the feature has been tried in a Finch experiment, you can soft-launch the 
feature via Finch by setting its experiment to 100% of users. This allows faster shipping and can be rolled back easily. Set a reminder to remove the feature flag, the Finch configuration and outdated code 
after two milestones. Disabling an already shipped feature # If there are any issues during early stages, a reverse Finch trial can disable the feature if the flag has not been removed yet and the Finch 
config is still there. After a prolonged time, this might not be a viable option anymore even if the feature flag is still active, because the alternative code path is no longer tested. Branding Terms Privacy
Twitter Edit this page on GitHub Except as otherwise noted, any code samples from the V8 project are licensed under V8\u2019s BSD-style license . Other content on this page is licensed under the Creative 
Commons Attribution 3.0 License . For details, see our site policies ."
  }
]
[Step 5: Duration 23.01 seconds| Input tokens: 92,549 | Output tokens: 6,103]
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ Step 6 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'search_knowledge_base' with arguments: {'query': 'JSObject::PrepareForDataProperty MapUpdater ReconfigureExistingProperty NormalizeProperties dictionary mode accessor to data property V8',  │
│ 'top_k': 5, 'topic_filter': 'v8'}                                                                                                                                                                            │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
Observations: |
  {
    "topic": "V8 JavaScript Engine",
    "file": "v8/v8.dev/blog/fast-properties.txt",
    "similarity": 0.433,
    "content_preview": "Topic: V8 JavaScript Engine\nFile: v8/v8.dev/blog/fast-properties.txt\n\nFast properties in V8 \u00b7 V8 V8 Show navigation Home Blog Docs Tools JS/Wasm features Research Fast 
properties in V8 Published 30 August 2017 \u00b7 Tagged with internals In this blog post we would like to explain how V8 handles JavaScript properties internally. From a JavaScript point of view there are 
only a few distinctions necessary for properties. JavaScript objects mostly behave like dictionaries, with string keys and arbitrary objects as values. The specification does however treat integer-indexed 
properties and other properties differently during iteration . Other than that, the different properties behave mostly the same, independent of whether they are integer indexed or not. However, under the hood
V8 does rely on several different representations of properties for performance and memory reasons. In this blog post we are going to explain how V8 can provide fast property access while handling 
dynamically-added properties. Understanding how properties work is essential for explaining how optimizations such as inline caches work in V8. This post explains the difference in handling integer-indexed 
and named properties. After that we show how V8 maintains HiddenClasses when adding named properties in order to provide a fast way to identify the shape of an object. We'll then continue giving insights into
how named properties are optimized for fast accesses or fast modification depending on the usage. In the final section we provide details on how V8 handles integer-indexed properties or array indices. Named 
properties vs. elements # Let's start by analysing a very simple object such as {a: \"foo\", b: \"bar\"} . This object has two named properties, \"a\" and \"b\" . It does not have any integer indices for 
property names. Array-indexed properties, more commonly known as elements, are most prominent on arrays. For instance the array |\"foo\", \"bar\"] has two array-indexed properties: 0, with the value \"foo\", 
and 1, with the value \"bar\". This is the first major distinction on how V8 handles properties in general. The following diagram shows what a basic JavaScript object looks like in memory. Elements and 
properties are stored in two separate data structures which makes adding and accessing properties or elements more efficient for different usage patterns. Elements are mainly used for the various 
Array.prototype methods such as pop or slice . Given that these functions access properties in consecutive ranges, V8 also represents them as simple arrays internally \u2014 most of the time. Later in this 
post we will explain how we sometimes switch to a sparse dictionary-based representation to save memory. Named properties are stored in a similar way in a separate array. However, unlike elements, we cannot 
simply use the key to deduce their position within the properties array; we need some additional metadata. In V8 every JavaScript object has a HiddenClass associated. The HiddenClass stores information about 
the shape of an object, and among other things, a mapping from property names to indices into the properties. To complicate things we sometimes use a dictionary for the properties instead of a simple array. 
We will explain this in more detail in a dedicated section. Takeaway from this section: Array-indexed properties are stored in a separate elements store. Named properties are stored in the properties store. 
Elements and properties can either be arrays or dictionaries. Each JavaScript object has a HiddenClass associated that keeps information about the object shape. HiddenClasses and DescriptorArrays # After 
explaining the general distinction of elements and named properties we need to have a look at how HiddenClasses work in V8. This HiddenClass stores meta information about an object, including the number of 
properties on the object and a reference to the object\u2019s prototype. HiddenClasses are conceptually similar to classes in typical object-oriented programming languages. However, in a prototype-based 
language such as JavaScript it is generally not possible to know classes upfront. Hence, in this case V8, HiddenClasses are created on the fly and updated dynamically as objects change. HiddenClasses serve as
an identifier for the shape of an object and as such a very important ingredient for V8's optimizing compiler and inline caches. The optimizing compiler for instance can directly inline property accesses if 
it can ensure a compatible objects structure through the HiddenClass. Let's have a look at the important parts of a HiddenClass. In V8 the first field of a JavaScript object points to a HiddenClass. (In fact,
this is the case for any object that is on the V8 heap and managed by the garbage collector.) In terms of properties, the most important information is the third bit field, which stores the number of 
properties, and a pointer to the descriptor array. The descriptor array contains information about named properties like the name itself and the position where the value is stored. Note that we do not keep 
track of integer indexed properties here, hence there is no entry in the descriptor array. The basic assumption about HiddenClasses is that objects with the same structure \u2014 e.g. the same named 
properties in the same order \u2014 share the same HiddenClass. To achieve that we use a different HiddenClass when a property gets added to an object. In the following example we start from an empty object 
and add three named properties. Every time a new property is added, the object's HiddenClass is changed. In the background V8 creates a transition tree that links the HiddenClasses together. V8 knows which 
HiddenClass to take when you add, for instance, the property \"a\" to an empty object. This transition tree makes sure you end up with the same final HiddenClass if you add the same properties in the same 
order. The following example shows that we would follow the same transition tree even if we add simple indexed properties in between. However, if we create a new object that gets a different property added, 
in this case property \"d\" , V8 creates a separate branch for the new HiddenClasses. Takeaway from this section: Objects with the same structure (same properties in the same order) have the same HiddenClass 
By default every new named property added causes a new HiddenClass to be created. Adding array-indexed properties does not create new HiddenClasses. The three different kinds of named properties # After 
giving an overview on how V8 uses HiddenClasses to track the shape of objects let\u2019s dive into how these properties are actually stored. As explained in the introduction above, there are two fundamental 
kind of properties: named and indexed. The following section covers named properties. A simple object such as {a: 1, b: 2} can have various internal representations in V8. While JavaScript objects behave more
or less like simple dictionaries from the outside, V8 tries to avoid dictionaries because they hamper certain optimizations such as inline caches which we will explain in a separate post. In-object vs. normal
properties: V8 supports so-called in-object properties which are stored directly on the object themselves. These are the fastest properties available in V8 as they are accessible without any indirection. The 
number of in-object properties is predetermined by the initial size of the object. If more properties get added than there is space in the object, they are stored in the properties store. The properties store
adds one level of indirection but can be grown independently. Fast vs. slow properties: The next important distinction is between fast and slow properties. Typically we define the properties stored in the 
linear properties store as \"fast\". Fast properties are simply accessed by index in the properties store. To get from the name of the property to the actual position in the properties store, we have to 
consult the descriptor array on the HiddenClass, as we've outlined before. However, if many properties get added and deleted from an object, it can generate a lot of time and memory overhead to maintain the 
descriptor array and HiddenClasses. Hence, V8 also supports so-called slow properties. An object with slow properties has a self-contained dictionary as a properties store. All the properties meta information
is no longer stored in the descriptor array on the HiddenClass but directly in the properties dictionary. Hence, properties can be added and removed without updating the HiddenClass. Since inline caches 
don\u2019t work with dictionary properties, the latter, are typically slower than fast properties. Takeaway from this section: There are three different named property types: in-object, fast and 
slow/dictionary. In-object properties are stored directly on the object itself and provide the fastest access. Fast properties live in the properties store, all the meta information is stored in the 
descriptor array on the HiddenClass. Slow properties live in a self-contained properties dictionary, meta information is no longer shared through the HiddenClass. Slow properties allow for efficient property 
removal and addition but are slower to access than the other two types. Elements or array-indexed properties # So far we have looked at named properties and ignored integer indexed properties commonly used 
with arrays. Handling of integer indexed properties is no less complex than named properties. Even though all indexed properties are always kept separately in the elements store, there are 20 different types 
of elements! Packed or Holey Elements: The first major distinction V8 makes is whether the elements backing store is packed or has holes in it. You get holes in a backing store if you delete an indexed 
element, or for instance, you don't define it. A simple example is |1,,3] where the second entry is a hole. The following example illustrates this issue: const o = | 'a' , 'b' , 'c' ] ; console . log ( o | 1 
] ) ; // Prints 'b'. delete o | 1 ] ; // Introduces a hole in the elements store. console . log ( o | 1 ] ) ; // Prints 'undefined'; property 1 does not exist. o . __proto__ = { 1 : 'B' } ; // Define property
1 on the prototype. console . log ( o | 0 ] ) ; // Prints 'a'. console . log ( o | 1 ] ) ; // Prints 'B'. console . log ( o | 2 ] ) ; // Prints 'c'. console . log ( o | 3 ] ) ; // Prints undefined In short, 
if a property is not present on the receiver we have to keep on looking on the prototype chain. Given that elements are self-contained, e.g. we don't store information about present indexed properties on the 
HiddenClass, we need a special value, called the_hole, to mark properties that are not present. This is crucial for the performance of Array functions. If we know that there are no holes, i.e. the elements 
store is packed, we can perform local operations without expensive lookups on the prototype chain. Fast or Dictionary Elements: The second major distinction made on elements is whether they are fast or 
dictionary-mode. Fast elements are simple VM-internal arrays where the property index maps to the index in the elements store. However, this simple representation is rather wasteful for very large 
sparse/holey arrays where only few entries are occupied. In this case we used a dictionary-based representation to save memory at the cost of slightly slower access: const sparseArray = | ] ; sparseArray | 
9999 ] = 'foo' ; // Creates an array with dictionary elements. In this example, allocating a full array with 10k entries would be rather wasteful. What happens instead is that V8 creates a dictionary where we
store a key-value-descriptor triplets. The key in this case would be '9999' and the value 'foo' and the default descriptor is used. Given that we don't have a way to store descriptor details on the 
HiddenClass, V8 resorts to slow elements whenever you define an indexed properties with a custom descriptor: const array = | ] ; Object . defineProperty ( array , 0 , { value : 'fixed' configurable : false } 
) ; console . log ( array | 0 ] ) ; // Prints 'fixed'. array | 0 ] = 'other value' ; // Cannot override index 0. console . log ( array | 0 ] ) ; // Still prints 'fixed'. In this example we added a 
non-configurable property on the array. This information is stored in the descriptor part of a slow elements dictionary triplet. It is important to note that Array functions perform considerably slower on 
objects with slow elements. Smi and Double Elements: For fast elements there is another important distinction made in V8. For instance if you only store integers in an Array, a common use-case, the GC does 
not have to look at the array, as integers are directly encoded as so called small integers (Smis) in place. Another special case are Arrays that only contain doubles. Unlike Smis, floating point numbers are 
usually represented as full objects occupying several words. However, V8 stores raw doubles for pure double arrays to avoid memory and performance overhead. The following example lists 4 examples of Smi and 
double elements: const a1 = | 1 , 2 , 3 ] ; // Smi Packed const a2 = | 1 , , 3 ] ; // Smi Holey, a2|1] reads from the prototype const b1 = | 1.1 , 2 , 3 ] ; // Double Packed const b2 = | 1.1 , , 3 ] ; // 
Double Holey, b2|1] reads from the prototype Special Elements: With the information so far we covered 7 out of the 20 different element kinds. For simplicity we excluded 9 element kinds for TypedArrays, two 
more for String wrappers and last but not least, two more special element kinds for arguments objects. The ElementsAccessor: As you can imagine we are not exactly keen on writing Array functions 20 times in 
C++, once for every elements kind . That's where some C++ magic comes into play. Instead of implementing Array functions over and over again, we built the ElementsAccessor where we mostly have to implement 
only simple functions that access elements from the backing store. The ElementsAccessor relies on CRTP to create specialized versions of each Array function. So if you call something like slice on an array, 
V8 internally calls a builtin written in C++ and dispatches through the ElementsAccessor to the specialized version of the function: Takeaway from this section: There are fast and dictionary-mode indexed 
properties and elements. Fast properties can be packed or they can contain holes which indicate that an indexed property has been deleted. Elements are specialized on their content to speed up Array functions
and reduce GC overhead. Understanding how properties work is key to many optimizations in V8. For JavaScript developers many of these internal decisions are not visible directly, but they explain why certain 
code patterns are faster than others. Changing the property or element type typically causes V8 to create a different HiddenClass which can lead to type pollution which prevents V8 from generating optimal 
code . Stay tuned for further posts on how the VM-internals of V8 work. Posted by Camillo Bruni ( @camillobruni ), also author of \u201cFast for - in \u201d . Branding Terms Privacy Twitter Edit this page on 
GitHub Except as otherwise noted, any code samples from the V8 project are licensed under V8\u2019s BSD-style license . Other content on this page is licensed under the Creative Commons Attribution 3.0 
License . For details, see our site policies ."
  },
  {
    "topic": "V8 JavaScript Engine",
    "file": "v8/v8.dev/docs/hidden-classes.txt",
    "similarity": 0.425,
    "content_preview": "Topic: V8 JavaScript Engine\nFile: v8/v8.dev/docs/hidden-classes.txt\n\nMaps (Hidden Classes) in V8 \u00b7 V8 V8 Show navigation Home Blog Docs Tools JS/Wasm features Research Maps 
(Hidden Classes) in V8 Let's show how V8 builds it's hidden classes. The principal data structures are: Map : the hidden class itself. It's the first pointer value in an object and therefore allows easy 
comparison to see if two objects have the same class. DescriptorArray : The full list of properties that this class has along with information about them. In some cases, the property value is even in this 
array. TransitionArray : An array of \"edges\" from this Map to sibling Maps. Each edge is a property name, and should be thought of as \"if I were to add a property with this name to the current class, what 
class would I transition to?\" Because many Map objects only have one transition to another one (ie, they are \"transitional\" maps, only used on the way to something else), V8 doesn't always create a 
full-blown TransitionArray for it. Instead it'll just link directly to this \"next\" Map . The system has to do a bit of spelunking in the DescriptorArray of the Map being pointed to in order to figure out 
the name attached to the transition. This is an extremely rich subject. It's also subject to change, though, if you understand the concepts in this article future change should be incrementally 
understandable. Why have hidden classes? # V8 could do without hidden classes, sure. It would treat each object as a bag of properties. However, a very useful principle would have been left laying around: the
principal of intelligent design. V8 surmises that you'll only create so many different kinds of objects. And each kind of object will be used in what can eventually be seen to be stereotypical ways. I say 
\"eventually be seen\" because the JavaScript language is a scripting language, not a pre-compiled one. So V8 never knows what will come next. To make use of intelligent design (that is, the assumption that 
there is a mind behind the code coming in), V8 has to watch and wait, letting the sense of structure seep in. The hidden class mechanism is the principal means to do this. Of course, it presupposes a 
sophisticated listening mechanism, and these are the Inline Caches (ICs) about which much has been written. So, if you are convinced this is good and necessary work, follow me! An example # function Peak ( 
name , height , extra ) { this . name = name ; this . height = height ; if ( isNaN ( extra ) ) { this . experience = extra ; } else { this . prominence = extra ; } } m1 = new Peak ( \"Matterhorn\" , 4478 , 
1040 ) ; m2 = new Peak ( \"Wendelstein\" , 1838 , \"good\" ) ; With this code we've already got an interesting map tree from the root map (also known as the initial map) which is attached to the function Peak
: Each blue box is a map, starting with the initial map. This is the map of the object returned if somehow, we managed to run the function Peak without adding a single property. The follow-on maps are the 
ones that result by adding the properties given by the names on the edges between maps. Each map has a list of the properties associated with an object of that map. Furthermore, it describes the exact 
location of each property. Finally, from one of these maps, say, Map3 which is the hidden class of the object you'll get if you passed a number for the extra argument in Peak() , you can follow a back link up
all the way to the initial map. Let's draw it again with this extra information. The annotation (i0), (i1), means in-object field location 0, 1, etc: Now, if you spend time examining these maps before you've 
created at least 7 Peak objects, you'll encounter slack tracking which can be confusing. I have another article about that. Just create 7 more objects and it will be finished. At this point, your Peak objects
will have exactly 3 in-object properties, with no possibility to add more directly in the object. Any additional properties will be offloaded to the object's property backing store. It's just an array of 
property values, whose index comes from the map (Well, technically, from the DescriptorArray attached to the map). Let's add a property to m2 on a new line, and look again at the map tree: m2 . cost = \"one 
arm, one leg\" ; I snuck something in here. Notice that all of the properties are annotated with \"const,\" which means that from V8's point of view, nobody ever changed them since the constructor, so they 
can be considered constants once they've been initialized. TurboFan (the optimizing compiler) loves this. Say m2 is referenced as a constant global by a function. Then the lookup of m2.cost can be done at 
compile time, since the field is marked as constant. I'll return to this later in the article. Notice that property \"cost\" is marked as const p0 , which means it's a constant property stored at index zero 
in the properties backing store rather than in the object directly. This is because we have no more room in the object. This information is visible in %DebugPrint(m2) : d8> %DebugPrint(m2); DebugPrint: 
0x2f9488e9: |JS_OBJECT_TYPE] - map: 0x219473fd <Map(HOLEY_ELEMENTS)> |FastProperties] - prototype: 0x2f94876d <Object map = 0x21947335> - elements: 0x419421a1 <FixedArray|0]> |HOLEY_ELEMENTS] - properties: 
0x2f94aecd <PropertyArray|3]> { 0x419446f9: |String] in ReadOnlySpace: #name: 0x237125e1 <String|11]: #Wendelstein> (const data field 0) 0x23712581: |String] in OldSpace: #height: 1838 (const data field 1) 
0x23712865: |String] in OldSpace: #experience: 0x237125f9 <String|4]: #good> (const data field 2) 0x23714515: |String] in OldSpace: #cost: 0x23714525 <String|16]: #one arm, one leg> (const data field 3) 
properties|0] } ... {name: \"Wendelstein\", height: 1, experience: \"good\", cost: \"one arm, one leg\"} d8> You can see that we have 4 properties, all marked as const. The first 3 in the object, and the last
in properties|0] which means the first slot of the properties backing store. We can look at that: d8> %DebugPrintPtr(0x2f94aecd) DebugPrint: 0x2f94aecd: |PropertyArray] - map: 0x41942be9 <Map> - length: 3 - 
hash: 0 0: 0x23714525 <String|16]: #one arm, one leg> 1-2: 0x41942329 <undefined> The extra properties are there just in case you decide to add more all of a sudden. The real structure # There are different 
things we could do at this point, but since you must really like V8, having read this far, I'd like to try drawing the real data structures we use, the ones mentioned at the beginning of Map , DescriptorArray
, and TransitionArray . Now that you have some idea of the hidden class concept being built up behind the scenes, you may as well bind your thinking more closely to the code through the right names and 
structures. Let me try and reproduce that last figure in V8's representation. First I'm going to draw the DescriptorArrays , which hold the list of properties for a given Map. These arrays can be shared -- 
the key to that is that the Map itself knows how many properties it is allowed to look at in the DescriptorArray. Since the properties are in the order they were added in time, these arrays can be shared by 
several maps. See: Notice that Map1 , Map2 , and Map3 all point to DescriptorArray1 . The number next to the \"descriptors\" field in each Map indicates how many fields over in the DescriptorArray belong to 
the Map. So Map1 , which only knows about the \"name\" property, looks only at the first property listed in DescriptorArray1 . Whereas Map2 has two properties, \"name\" and \"height.\" So it looks at the 
first and second items in DescriptorArray1 (name and height). This kind of sharing saves a lot of space. Naturally, we can't share where there is a split. There is a transition from Map2 over to Map4 if the 
\"experience\" property is added, and over to Map3 if the \"prominence\" property is added. You can see Map4 and Map5 sharing DescriptorArray2 in the same way that DescriptorArray1 was shared among three 
Maps. The only thing missing from our \"true to life\" diagram is the TransitionArray which is still metaphorical at this point. Let's change that. I took the liberty of removing the back pointer lines, which
cleans things up a bit. Just remember that from any Map in the tree, you can walk up the tree, too. The diagram rewards study. Question: what would happen if a new property \"rating\" was added after \"name\"
instead of going on to \"height\" and other properties? Answer : Map1 would get a real TransitionArray so as to keep track of the bifurcation. If property height is added, we should transition to Map2 . 
However, if property rating is added, we should go to a new map, Map6 . This map would need a new DescriptorArray that mentions name and rating . The object has extra free slots at this point in the object 
(only one of three is used), so property rating will be given one of those slots. I checked my answer with the help of %DebugPrintPtr() , and drew the following: No need to beg me to stop, I see that this is 
the upper limit of such diagrams! But I think you can get a sense of how the parts move. Just imagine if after adding this ersatz property rating , we continued on with height , experience and cost . Well, 
we'd have to create maps Map7 , Map8 and Map9 . Because we insisted on adding this property in the middle of an established chain of maps, we will duplicate much structure. I don't have the heart to make that
drawing -- though if you send it to me I will add it to this document :). I used the handy DreamPuf project to make the diagrams easily. Here is a link to the previous diagram. TurboFan and const properties #
Thus far, all these fields are marked in the DescriptorArray as const . Let's play with this. Run the following code on a debug build: // run as: // d8 --allow-natives-syntax --no-lazy-feedback-allocation 
--code-comments --print-opt-code function Peak ( name , height ) { this . name = name ; this . height = height ; } let m1 = new Peak ( \"Matterhorn\" , 4478 ) ; m2 = new Peak ( \"Wendelstein\" , 1838 ) ; // 
Make sure slack tracking finishes. for ( let i = 0 ; i < 7 ; i ++ ) new Peak ( \"blah\" , i ) ; m2 . cost = \"one arm, one leg\" ; function foo ( a ) { return m2 . cost ; } foo ( 3 ) ; foo ( 3 ) ; % 
OptimizeFunctionOnNextCall ( foo ) ; foo ( 3 ) ; You'll get a printout of optimized function foo() . The code is very short. You'll see at the end of the function: ... 40 mov eax,0x2a812499 ;; object: 
0x2a812499 <String|16]: #one arm, one leg> 45 mov esp,ebp 47 pop ebp 48 ret 0x8 ;; return \"one arm, one leg\"! TurboFan, being a cheeky devil, just directly inserted the value of m2.cost . Well how do you 
like that! Of course, after that last call to foo() you could insert this line: m2 . cost = \"priceless\" ; What do you think will happen? One thing for sure, we can't let foo() stay as it is. It would return
the wrong answer. Re-run the program, but add flag --trace-deopt so you'll be told when optimized code is removed from the system. After the printout of the optimized foo() , you'll see these lines: |marking 
dependent code 0x5c684901 0x21e525b9 <SharedFunctionInfo foo> (opt #0) for deoptimization, reason: field-const] |deoptimize marked code in all contexts] Wow. If you force re-optimization you'll get code that 
is not quite as good, but still benefits greatly from the Map structure we've been describing. Remember from our diagrams that property cost is the first property in the properties backing store for an 
object. Well, it may have lost it's const designation, but we still have it's address. Basically, in an object with map Map5 , which we'll certainly verify that global variable m2 still has, we only have to--
load the properties backing store, and read out the first array element. Let's see that. Add this code below the last line: // Force reoptimization of foo(). foo ( 3 ) ; % OptimizeFunctionOnNextCall ( foo ) ;
foo ( 3 ) ; Now have a look at the code produced: ... 40 mov ecx,0x42cc8901 ;; object: 0x42cc8901 <Peak map = 0x3d5873ad> 45 mov ecx,|ecx+0x3] ;; Load the properties backing store 48 mov eax,|ecx+0x7] ;; Get 
the first element. 4b mov esp,ebp 4d pop ebp 4e ret 0x8 ;; return it in register eax! Why heck. That's exactly what we said should happen. Perhaps we are beginning to Know. TurboFan is also smart enough to 
deoptimize if variable m2 ever changes to a different class. You can watch the latest optimized code deoptimize again with something droll like: m2 = 42 ; // heh. Where to go from here # Many options. Map 
migration. Dictionary mode (aka \"slow mode\"). Lots to explore in this area and I hope you enjoy yourself as much as I do -- thanks for reading! Branding Terms Privacy Twitter Edit this page on GitHub Except
as otherwise noted, any code samples from the V8 project are licensed under V8\u2019s BSD-style license . Other content on this page is licensed under the Creative Commons Attribution 3.0 License . For 
details, see our site policies ."
  },
  {
    "topic": "V8 JavaScript Engine",
    "file": "v8/v8.dev/blog/hash-code.txt",
    "similarity": 0.419,
    "content_preview": "Topic: V8 JavaScript Engine\nFile: v8/v8.dev/blog/hash-code.txt\n\nOptimizing hash tables: hiding the hash code \u00b7 V8 V8 Show navigation Home Blog Docs Tools JS/Wasm features 
Research Optimizing hash tables: hiding the hash code Published 29 January 2018 \u00b7 Tagged with internals ECMAScript 2015 introduced several new data structures such as Map, Set, WeakSet, and WeakMap, all 
of which use hash tables under the hood. This post details the recent improvements in how V8 v6.3+ stores the keys in hash tables. Hash code # A hash function is used to map a given key to a location in the 
hash table. A hash code is the result of running this hash function over a given key. In V8, the hash code is just a random number, independent of the object value. Therefore, we can\u2019t recompute it, 
meaning we must store it. For JavaScript objects that were used as keys, previously, the hash code was stored as a private symbol on the object. A private symbol in V8 is similar to a Symbol , except that 
it\u2019s not enumerable and doesn\u2019t leak to userspace JavaScript. function GetObjectHash ( key ) { let hash = key | hashCodeSymbol ] ; if ( IS_UNDEFINED ( hash ) ) { hash = ( MathRandom ( ) * 0x40000000
) | 0 ; if ( hash === 0 ) hash = 1 ; key | hashCodeSymbol ] = hash ; } return hash ; } This worked well because we didn\u2019t have to reserve memory for a hash code field until the object was added to a hash
table, at which point a new private symbol was stored on the object. V8 could also optimize the hash code symbol lookup just like any other property lookup using the IC system, providing very fast lookups for
the hash code. This works well for monomorphic IC lookups , when the keys have the same hidden class . However, most real-world code doesn\u2019t follow this pattern, and often keys have different hidden 
classes, leading to slow megamorphic IC lookups of the hash code. Another problem with the private symbol approach was that it triggered a hidden class transition in the key on storing the hash code. This 
resulted in poor polymorphic code not just for the hash code lookup but also for other property lookups on the key and deoptimization from optimized code. JavaScript object backing stores # A JavaScript 
object ( JSObject ) in V8 uses two words (apart from its header): one word for storing a pointer to the elements backing store, and another word for storing a pointer to the properties backing store. The 
elements backing store is used for storing properties that look like array indices , whereas the properties backing store is used for storing properties whose keys are strings or symbols. See this V8 blog 
post by Camillo Bruni for more information about these backing stores. const x = { } ; x | 1 ] = 'bar' ; // \u2190 stored in elements x | 'foo' ] = 'bar' ; // \u2190 stored in properties Hiding the hash code 
# The easiest solution to storing the hash code would be to extend the size of a JavaScript object by one word and store the hash code directly on the object. However, this would waste memory for objects that
aren\u2019t added to a hash table. Instead, we could try to store the hash code in the elements store or properties store. The elements backing store is an array containing its length and all the elements. 
There\u2019s not much to be done here, as storing the hashcode in a reserved slot (like the 0th index) would still waste memory when we don\u2019t use the object as a key in a hash table. Let\u2019s look at 
the properties backing store. There are two kinds of data structures used as a properties backing store: arrays and dictionaries. Unlike the array used in the elements backing store which does not have an 
upper limit, the array used in the properties backing store has an upper limit of 1022 values. V8 transitions to using a dictionary on exceeding this limit for performance reasons. (I\u2019m slightly 
simplifying this \u2014 V8 can also use a dictionary in other cases, but there is a fixed upper limit on the number of values that can be stored in the array.) So, there are three possible states for the 
properties backing store: empty (no properties) array (can store up to 1022 values) dictionary Let\u2019s discuss each of these. The properties backing store is empty # For the empty case, we can directly 
store the hash code in this offset on the JSObject . The properties backing store is an array # V8 represents integers less than 2 31 (on 32-bit systems) unboxed, as Smi s. In a Smi, the least significant bit
is a tag used to distinguish it from pointers, while the remaining 31 bits hold the actual integer value. Normally, arrays store their length as a Smi. Since we know that the maximum capacity of this array is
only 1022, we only need 10 bits to store the length. We can use the remaining 21 bits to store the hash code! The properties backing store is a dictionary # For the dictionary case, we increase the dictionary
size by 1 word to store the hashcode in a dedicated slot at the beginning of the dictionary. We get away with potentially wasting a word of memory in this case, because the proportional increase in size 
isn\u2019t as big as in the array case. With these changes, the hash code lookup no longer has to go through the complex JavaScript property lookup machinery. Performance improvements # The SixSpeed benchmark
tracks the performance of Map and Set, and these changes resulted in a ~500% improvement. This change caused a 5% improvement on the Basic benchmark in ARES6 as well. This also resulted in an 18% improvement 
in one of the benchmarks in the Emberperf benchmark suite that tests Ember.js. Posted by Sathya Gunasekaran , keeper of hash codes. Retweet this article! Branding Terms Privacy Twitter Edit this page on 
GitHub Except as otherwise noted, any code samples from the V8 project are licensed under V8\u2019s BSD-style license . Other content on this page is licensed under the Creative Commons Attribution 3.0 
License . For details, see our site policies ."
  },
  {
    "topic": "V8 JavaScript Engine",
    "file": "v8/v8.dev/blog/faster-class-features.txt",
    "similarity": 0.415,
    "content_preview": "Topic: V8 JavaScript Engine\nFile: v8/v8.dev/blog/faster-class-features.txt\n\nFaster initialization of instances with new class features \u00b7 V8 V8 Show navigation Home Blog Docs 
Tools JS/Wasm features Research Faster initialization of instances with new class features Published 20 April 2022 \u00b7 Tagged with internals Class fields have been shipped in V8 since v7.2 and private 
class methods have been shipped since v8.4. After the proposals reached stage 4 in 2021, work had begun to improve the support of the new class features in V8 - until then, there had been two main issues 
affecting their adoption: The initialization of class fields and private methods was much slower than the assignment of ordinary properties. The class field initializers were broken in startup snapshots used 
by embedders like Node.js and Deno to speed up the bootstrapping of themselves or user applications. The first issue has been fixed in V8 v9.7 and the fix for the second issue has been released in V8 v10.0. 
This post covers how the first issue was fixed, for another read about the fix of the snapshot issue, check out this post . Optimizing class fields # To get rid of the performance gap between the assignment 
of ordinary properties and the initialization of class fields, we updated the existing inline cache (IC) system to work with the latter. Before v9.7, V8 always used a costly runtime call for class field 
initializations. With v9.7, when V8 considers the pattern of the initialization to be predictable enough, it uses a new IC to speed up the operation just like what it does for assignments of ordinary 
properties. Performance of initializations, optimized Performance of initializations, interpreted The original implementation of class fields # To implement private fields, V8 makes use of the internal 
private symbols \u2014 they are an internal V8 data structure similar to standard Symbol s, except not enumerable when used as a property key. Take this class for an example: class A { #a = 0 ; b = this . #a 
; } V8 would collect the class field initializers ( #a = 0 and b = this.#a ) and generate a synthetic instance member function with the initializers as the function body. The bytecode generated for this 
synthetic function used to be something like this: // Load the private name symbol for `#a` into r1 LdaImmutableCurrentContextSlot | 2 ] Star r1 // Load 0 into r2 LdaZero Star r2 // Move the target into r0 
Mov < this > , r0 // Use the %AddPrivateField() runtime function to store 0 as the value of // the property keyed by the private name symbol `#a` in the instance, // that is, `#a = 0`. CallRuntime | 
AddPrivateField ] , r0 - r2 // Load the property name `b` into r1 LdaConstant | 0 ] Star r1 // Load the private name symbol for `#a` LdaImmutableCurrentContextSlot | 2 ] // Load the value of the property 
keyed by `#a` from the instance into r2 LdaKeyedProperty < this > , | 0 ] Star r2 // Move the target into r0 Mov < this > , r0 // Use the %CreateDataProperty() runtime function to store the property keyed // 
by `#a` as the value of the property keyed by `b`, that is, `b = this.#a` CallRuntime | CreateDataProperty ] , r0 - r2 Compare the class in the previous snippet to a class like this: class A { constructor ( )
{ this . _a = 0 ; this . b = this . _a ; } } Technically these two classes are not equivalent, even ignoring the difference in visibility between this.#a and this._a . The specification mandates \"define\" 
semantics instead of \"set\" semantics. That is, the initialization of class fields does not trigger setters or set Proxy traps. So an approximation of the first class should use Object.defineProperty() 
instead of simple assignments to initialize the properties. In addition, it should throw if the private field already exists in the instance (in case the target being initialized is overridden in the base 
constructor to be another instance): class A { constructor ( ) { // What the %AddPrivateField() call roughly translates to: const _a = % PrivateSymbol ( '#a' ) if ( _a in this ) { throw TypeError ( 'Cannot 
initialize #a twice on the same object' ) ; } Object . defineProperty ( this , _a , { writable : true , configurable : false , enumerable : false , value : 0 } ) ; // What the %CreateDataProperty() call 
roughly translates to: Object . defineProperty ( this , 'b' , { writable : true , configurable : true , enumerable : true , value : this | _a ] } ) ; } } To implement the specified semantics before the 
proposal finalized, V8 used calls to runtime functions since they are more flexible. As shown in the bytecode above, the initialization of public fields was implemented with %CreateDataProperty() runtime 
calls, while the initialization of private fields was implemented with %AddPrivateField() . Since calling into the runtime incurs a significant overhead, the initialization of class fields was much slower 
compared to the assignment of ordinary object properties. In most use cases, however, the semantic differences are insignificant. It would be nice to have the performance of the optimized assignments of 
properties in these cases \u2014 so a more optimal implementation was created after the proposal finalized. Optimizing private class fields and computed public class fields # To speed up initialization of 
private class fields and computed public class fields, the implementation introduced a new machinery to plug into the inline cache (IC) system when handling these operations. This new machinery comes in three
cooperating pieces: In the bytecode generator, a new bytecode DefineKeyedOwnProperty . This gets emitted when generating code for the ClassLiteral::Property AST nodes representing class field initializers. In
the TurboFan JIT, a corresponding IR opcode JSDefineKeyedOwnProperty , which can be compiled from the new bytecode. In the IC system, a new DefineKeyedOwnIC that is used in the interpreter handler of the new 
bytecode as well as the code compiled from the new IR opcode. To simplify the implementation, the new IC reuses some of the code in KeyedStoreIC which was intended for ordinary property stores. Now when V8 
encounters this class: class A { #a = 0 ; } It generates the following bytecode for the initializer #a = 0 : // Load the private name symbol for `#a` into r1 LdaImmutableCurrentContextSlot | 2 ] Star0 // Use 
the DefineKeyedOwnProperty bytecode to store 0 as the value of // the property keyed by the private name symbol `#a` in the instance, // that is, `#a = 0`. LdaZero DefineKeyedOwnProperty < this > , r0 , | 0 ]
When the initializer is executed enough times, V8 allocates one feedback vector slot for each field being initialized. The slot contains the key of the field being added (in the case of the private field, the
private name symbol) and a pair of hidden classes between which the instance has been transitioning as the result of field initialization. In subsequent initializations, the IC uses the feedback to see if the
fields are initialized in the same order on instances with the same hidden classes. If the initialization matches the pattern that V8 has seen before (which is usually the case), V8 takes the fast path and 
performs the initialization with pre-generated code instead of calling into the runtime, thus speeding up the operation. If the initialization does not match a pattern that V8 has seen before, it falls back 
to a runtime call to deal with the slow cases. Optimizing named public class fields # To speed up initialization of named public class fields, we reused the existing DefineNamedOwnProperty bytecode which 
calls into DefineNamedOwnIC either in the interpreter or through the code compiled from the JSDefineNamedOwnProperty IR opcode. Now when V8 encounters this class: class A { #a = 0 ; b = this . #a ; } It 
generates the following bytecode for the b = this.#a initializer: // Load the private name symbol for `#a` LdaImmutableCurrentContextSlot | 2 ] // Load the value of the property keyed by `#a` from the 
instance into r2 // Note: LdaKeyedProperty is renamed to GetKeyedProperty in the refactoring GetKeyedProperty < this > , | 2 ] // Use the DefineKeyedOwnProperty bytecode to store the property keyed // by `#a`
as the value of the property keyed by `b`, that is, `b = this.#a;` DefineNamedOwnProperty < this > , | 0 ] , | 4 ] The original DefineNamedOwnIC machinery could not be simply plugged into the handling of the 
named public class fields, since it was originally intended only for object literal initialization. Previously it expected the target being initialized to be an object that has not yet been touched by the 
user since its creation, which was always true for object literals, but the class fields can be initialized on user-defined objects when the class extends a base class whose constructor overrides the target: 
class A { constructor ( ) { return new Proxy ( { a : 1 } , { defineProperty ( object , key , desc ) { console . log ( 'object:' , object ) ; console . log ( 'key:' , key ) ; console . log ( 'desc:' , desc ) ;
return true ; } } ) ; } } class B extends A { a = 2 ; #b = 3 ; // Not observable. } // object: { a: 1 }, // key: 'a', // desc: {value: 2, writable: true, enumerable: true, configurable: true} new B ( ) ; To 
deal with these targets, we patched the IC to fall back to the runtime when it sees that the object being initialized is a proxy, if the field being defined already exists on the object, or if the object just
has a hidden class that the IC has not seen before. It is still possible to optimize the edge cases if they become common enough, but so far it seems better to trade the performance of them for simplicity of 
the implementation. Optimizing private methods # The implementation of private methods # In the specification , the private methods are described as if they are installed on the instances but not on the 
class. In order to save memory, however, V8's implementation stores the private methods along with a private brand symbol in a context associated with the class. When the constructor is invoked, V8 only 
stores a reference to that context in the instance, with the private brand symbol as the key. Evaluation and instantiation of classes with private methods When the private methods are accessed, V8 walks the 
context chain starting from the execution context to find the class context, reads a statically known slot from the found context to get the private brand symbol for the class, then checks if the instance has
a property keyed by this brand symbol to see if the instance is created from this class. If the brand check passes, V8 loads the private method from another known slot in the same context and completes the 
access. Access of private methods Take this snippet as an example: class A { #a ( ) { } } V8 used to generate the following bytecode for the constructor of A : // Load the private brand symbol for class A 
from the context // and store it into r1. LdaImmutableCurrentContextSlot | 3 ] Star r1 // Load the target into r0. Mov < this > , r0 // Load the current context into r2. Mov < context > , r2 // Call the 
runtime %AddPrivateBrand() function to store the context in // the instance with the private brand as key. CallRuntime | AddPrivateBrand ] , r0 - r2 Since there was also a call to the runtime function 
%AddPrivateBrand() , the overhead made the constructor much slower than constructors of classes with only public methods. Optimizing initialization of private brands # To speed up the installation of the 
private brands, in most cases we just reuse the DefineKeyedOwnProperty machinery added for the optimization of private fields: // Load the private brand symbol for class A from the context // and store it 
into r1 LdaImmutableCurrentContextSlot | 3 ] Star0 // Use the DefineKeyedOwnProperty bytecode to store the // context in the instance with the private brand as key Ldar < context > DefineKeyedOwnProperty < 
this > , r0 , | 0 ] Performance of instance initializations of classes with different methods There is a caveat, however: if the class is a derived class whose constructor calls super() , the initialization 
of the private methods - and in our case, the installation of the private brand symbol - has to happen after super() returns: class A { constructor ( ) { // This throws from a new B() call because super() has
not yet returned. this . callMethod ( ) ; } } class B extends A { #method ( ) { } callMethod ( ) { return this . #method ( ) ; } constructor ( o ) { super ( ) ; } } ; As described before, when initializing 
the brand, V8 also stores a reference to the class context in the instance. This reference isn't used in brand checks, but is instead intended for the debugger to retrieve a list of private methods from the 
instance without knowing which class it is constructed from. When super() is invoked directly in the constructor, V8 can simply load the context from the context register (which is what Mov <context>, r2 or 
Ldar <context> in the bytecodes above does) to perform the initialization, but super() can also be invoked from a nested arrow function, which in turn can be invoked from a different context. In this case, V8
falls back to a runtime function (still named %AddPrivateBrand() ) to look for the class context in the context chain instead of relying on the context register. For example, for the callSuper function below:
class A extends class { } { #method ( ) { } constructor ( run ) { const callSuper = ( ) => super ( ) ; // ...do something run ( callSuper ) } } ; new A ( ( fn ) => fn ( ) ) ; V8 now generates the following 
bytecode: // Invoke the super constructor to construct the instance // and store it into r3. . . . // Load the private brand symbol from the class context at // depth 1 from the current context and store it 
into r4 LdaImmutableContextSlot < context > , | 3 ] , | 1 ] Star4 // Load the depth 1 as an Smi into r6 LdaSmi | 1 ] Star6 // Load the current context into r5 Mov < context > , r5 // Use the 
%AddPrivateBrand() to locate the class context at // depth 1 from the current context and store it in the instance // with the private brand symbol as key CallRuntime | AddPrivateBrand ] , r3 - r6 In this 
case the cost of the runtime call is back so initializing instances of this class is still going to be slower compared to initializing instances of classes with only public methods. It is possible to use a 
dedicated bytecode to implement what %AddPrivateBrand() does, but since invoking super() in a nested arrow function is quite rare, we again traded the performance for simplicity of the implementation. Final 
notes # The work mentioned in this blog post is also included in the Node.js 18.0.0 release . Previously, Node.js switched to symbol properties in a few built-in classes that had been using private fields in 
order to include them into the embedded bootstrap snapshot as well as to improve the performance of the constructors (see this blog post for more context). With the improved support of class features in V8, 
Node.js switched back to private class fields in these classes and Node.js's benchmarks showed that these changes did not introduce any performance regressions . Thanks to Igalia and Bloomberg for 
contributing this implementation! Posted by Joyee Cheung , instance initializer. Retweet this article! Branding Terms Privacy Twitter Edit this page on GitHub Except as otherwise noted, any code samples from 
the V8 project are licensed under V8\u2019s BSD-style license . Other content on this page is licensed under the Creative Commons Attribution 3.0 License . For details, see our site policies ."
  },
  {
    "topic": "V8 JavaScript Engine",
    "file": "v8/v8.dev/blog/intl.txt",
    "similarity": 0.415,
    "content_preview": "Topic: V8 JavaScript Engine\nFile: v8/v8.dev/blog/intl.txt\n\nFaster and more feature-rich internationalization APIs \u00b7 V8 V8 Show navigation Home Blog Docs Tools JS/Wasm features 
Research Faster and more feature-rich internationalization APIs Published 25 April 2019 \u00b7 Tagged with ECMAScript Intl The ECMAScript Internationalization API Specification (ECMA-402, or Intl ) provides 
key locale-specific functionality such as date formatting, number formatting, plural form selection, and collation. The Chrome V8 and Google Internationalization teams have been collaborating on adding 
features to V8\u2019s ECMA-402 implementation, while cleaning up technical debt and improving performance and interoperability with other browsers. Underlying architectural improvements # Initially the 
ECMA-402 spec was implemented mostly in JavaScript using V8-extensions and lived outside the V8 codebase. Using the external Extension API meant that several of V8\u2019s internally used APIs for type 
checking, lifetime management of external C++ objects and internal private data storage couldn\u2019t be used. As part of improving startup performance, this implementation was later moved in to the V8 
codebase to enable snapshotting of these builtins. V8 uses specialized JSObject s with custom shapes (hidden classes) to describe built-in JavaScript objects specified by ECMAScript (like Promise s, Map s, 
Set s, etc). With this approach, V8 can pre-allocate the required number of internal slots and generate fast accesses to these, rather than grow the object one property at a time leading to slower performance
and worse memory usage. The Intl implementation was not modeled after such an architecture, as a consequence of the historic split. Instead, all the built-in JavaScript objects as specified by the 
Internationalization spec (like NumberFormat , DateTimeFormat ) were generic JSObject s that had to transition through several property additions for their internal slots. Another artifact of not having a 
specialized JSObject s was that type checking was now more complex. The type information was stored under a private symbol and type-checked on both the JS and C++ side using expensive property access, rather 
than just looking up its shape. Modernizing the codebase # With the current move away from writing self-hosted builtins in V8, it made sense to use this opportunity to modernize the ECMA402 implementation. 
Moving away from self-hosted JS # Although self-hosting lends itself to concise and readable code, the frequent usage of slow runtime calls to access ICU APIs led to performance issues. As a result, a lot of 
ICU functionality was duplicated in JavaScript to reduce the number of such runtime calls. By rewriting the builtins in C++, it became much faster to access the ICU APIs as there is no runtime call overhead 
now. Improving ICU # ICU is a set of C/C++ libraries used by a large set of applications, including all the major JavaScript engines, for providing Unicode and globalization support. As part of switching Intl
to ICU in V8\u2019s implementation, we found and fixed several ICU bugs. As part of implementing new proposals such as Intl.RelativeTimeFormat , Intl.ListFormat and Intl.Locale , we\u2019ve extended ICU by 
adding several new APIs to support these new ECMAScript proposals. All of these additions help other JavaScript engines implement these proposals quicker now, pushing the web forward! For example, development
is in progress in Firefox on implementing several new Intl APIs based on our ICU work. Performance # As a result of this work, we improved the performance of the Internationalization API by optimizing several
fast paths and caching the initialization of the various Intl objects and the toLocaleString methods on Number.prototype , Date.prototype , and String.prototype . For example, creating a new Intl.NumberFormat
object became around 24\u00d7 faster. Microbenchmarks testing the performance of creating various Intl objects Note that for better performance, it\u2019s recommended to explicitly create and reuse an 
Intl.NumberFormat or Intl.DateTimeFormat or Intl.Collator object, rather than calling methods like toLocaleString or localeCompare . New Intl features # All of this work has provided a great foundation to 
build new features on and we\u2019re continuing to ship all the new Internationalization proposals that are in Stage 3. Intl.RelativeTimeFormat has shipped in Chrome 71, Intl.ListFormat has shipped in Chrome 
72, Intl.Locale has shipped in Chrome 74, and dateStyle and timeStyle options for Intl.DateTimeFormat and BigInt support for Intl.DateTimeFormat are shipping in Chrome 76. Intl.DateTimeFormat#formatRange , 
Intl.Segmenter , and additional options for Intl.NumberFormat are currently under development in V8, and we hope to ship them soon! Many of these new APIs, and others further down the pipeline, are due to our
work on standardizing new features to help developers with internationalization. Intl.DisplayNames is a Stage 1 proposal that allows users to localize the display names of language, region or script display 
names. Intl.DateTimeFormat#formatRange is a Stage 3 proposal that specifies a way to format date ranges in a concise and locale-aware manner. The unified Intl.NumberFormat API proposal is a Stage 3 proposal 
that improves Intl.NumberFormat by adding support for measurement units, currency and sign display policies, and scientific and compact notation. You can get involved in the future of ECMA-402 as well, by 
contributing at its GitHub repository . Conclusion # Intl provides a feature-rich API for several operations needed in internationalizing your web app, leaving the heavy lifting to the browser, without 
shipping as much data or code over the wire. Thinking through the proper use of these APIs can lead your UI to work better in different locales. Due to the work by the Google V8 and i18n teams in 
collaboration with TC39 and its ECMA-402 subgroup, you can now access more functionality with better performance, and expect further improvements over time. Posted by \u0b9a\u0ba4\u0bcd\u0baf\u0bbe 
\u0b95\u0bc1\u0ba3\u0b9a\u0bc7\u0b95\u0bb0\u0ba9\u0bcd (Sathya Gunasekaran) . Retweet this article! Branding Terms Privacy Twitter Edit this page on GitHub Except as otherwise noted, any code samples from the
V8 project are licensed under V8\u2019s BSD-style license . Other content on this page is licensed under the Creative Commons Attribution 3.0 License . For details, see our site policies ."
  }
]
[Step 6: Duration 29.24 seconds| Input tokens: 155,554 | Output tokens: 7,509]
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ Step 7 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'final_answer' with arguments: {'answer': '### 1. Task outcome (short version):\nPicked code region: JSObject::PrepareForDataProperty → MapUpdater reconfiguration → migration to dictionary   │
│ mode during named property stores, including the StoreIC update path. Concretely: src/objects/js-objects.cc (PrepareForDataProperty, NormalizeProperties/MigrateFastToSlow), src/objects/map-updater.cc      │
│ (MapUpdater reconfigure accessor↔data, representation changes), src/ic/store-ic.cc (StoreIC::UpdateCaches) and related NameDictionary code.\n\n### 2. Task outcome (extremely detailed version):\n- Why this │
│ region:\n  - From Stage 0–2 regression entry regress/regress-crbug-977012: setting v1.x = 20.5 after creating two objects with an accessor on y triggers:\n    - “[generalizing] x: … Smi→Double … (+1       │
│ maps)” and then “migrating to slow” (from execution flags --trace-migration --trace-generalization). The in-engine comment describes exactly: “Trigger a PrepareForDataProperty on v1, which also triggers   │
│ an update to dictionary due to the different accessors on v1 and v2’s y property.”\n  - This pinpoints the execution path where a named store (SetNamedProperty) must prepare the receiver’s map for a data  │
│ property, while maps along the transition tree differ by having accessors on another property (y). The engine then generalizes representation for x (Smi→Double→Any) and ultimately normalizes               │
│ (fast→dictionary) properties.\n  - That path sits at the intersection of IC feedback, map transitions, field representation generalization, and slow/fast property migration — a historically fragile,       │
│ security-relevant area in V8 (object shapes, hidden classes, property dictionaries, and IC state transitions).\n\n- Concrete code region and files:\n  - Property store preparation and normalization:\n     │
│ - src/objects/js-objects.cc\n      - JSObject::PrepareForDataProperty (prepares maps for defining/overwriting a named data property; may deprecate current map, run MapUpdater, and force                    │
│ NormalizeProperties/MigrateFastToSlow).\n      - JSObject::NormalizeProperties / JSObject::MigrateFastToSlow (switches to NameDictionary for slow properties).\n      - Related helpers for SetNamedProperty │
│ paths that consult PrepareForDataProperty.\n    - src/objects/property-details.h and representation utilities: where representation generalization (Smi→Double→Any) and constness/attributes are handled.\n  │
│ - Map transition machinery (reconfiguration & deprecation):\n    - src/objects/map-updater.cc\n      - MapUpdater state machine handling reconfigure of an existing property when kind changes               │
│ (Accessor↔Data), attribute changes, or representation transitions; drives map deprecation and selection of a new target map.\n    - src/objects/transitions.cc (transition arrays; deprecations when shapes  │
│ diverge).\n  - IC update path participating in this flow:\n    - src/ic/store-ic.cc (StoreIC::UpdateCaches / StoreIC::Store): consults feedback, builds handlers for monomorphic/polymorphic stores, and may │
│ fall back to runtime where PrepareForDataProperty is invoked; handler compilers reference the chosen transition map.\n    - src/ic/ic.cc (IC state transitions, FeedbackNexus plumbing) for named store      │
│ feedback that flips mono→poly→mega when maps diverge due to accessor differences.\n  - Dictionary representation details (destination when migrating to slow):\n    - src/objects/name-dictionary-inl.h,     │
│ src/objects/dictionary.h (NameDictionary/GlobalDictionary mechanics for slow properties).\n\n- How this matches the execution data (Stage 1–3 to code):\n  - Bytecode: the function uses SetNamedProperty    │
│ for x, and the log shows generalization and migration. This corresponds to the named-store IC path (StoreIC) plus the slow-path call into PrepareForDataProperty.\n  - The “different accessors on v1 and    │
│ v2’s y property” is a classic trigger for map deprecation and reconfiguration via MapUpdater; if no compatible fast transition exists, the object normalizes to dictionary mode.\n  - The representation     │
│ change Smi→Double→Any for x aligns with PropertyDetails/Representation generalization. When constness/attributes or accessor/data kind conflict, MapUpdater attempts a precise reconfigure but often ends    │
│ with NormalizeProperties when shapes diverge.\n\n- Why it’s an impactful fuzz target for JIT/IC stability/security:\n  - It exercises inline caches + map transitions + property representation changes      │
│ together, which historically lead to:\n    - stale map assumptions in generated code, miscompiled IC handlers, or missed barriers when maps are deprecated/migrate to slow.\n    - tricky aliasing of        │
│ accessors vs data properties and attribute flags that can desynchronize handler expectations.\n  - It crosses tiers (Ignition → Sparkplug/Sparkplug ICs → Maglev/TurboFan optimized code) because            │
│ feedback/handlers created here are consumed by higher tiers; inconsistent feedback or racy/rare transitions can crash or miscompile.\n  - It touches NameDictionary slow-path code, a separate set of        │
│ lookups/defines not exercised by many IC fast paths; toggling fast↔slow repeatedly can reveal state leaks in FeedbackVector/handlers.\n  - The regression demonstrates small, realistic JS patterns (mixing  │
│ __defineSetter__, smi/double stores) that force these code paths; fuzzing can systematically vary:\n    - order and interleaving of accessor installation vs data writes;\n    - attribute changes           │
│ (configurable/writable/enumerable), prototype adjustments, and protector invalidations;\n    - numeric representations (smi/double/heap number), boxed/unboxed transitions, and const fields;\n    -         │
│ oscillation between fast and dictionary properties.\n\n- Signals from the RAG knowledge base supporting this choice:\n  - Hidden classes/fast properties docs explain fast vs slow (dictionary) transitions  │
│ and their performance/IC implications.\n  - “Fast properties in V8” details named property encodings, hidden classes, and the cost of switching to dictionary mode, which disables many IC fast paths —      │
│ precisely the pivot we’re targeting.\n\n- Example trigger patterns for the fuzzer (derived from the regression and docs):\n  - Create two objects sharing a constructor/prototype; install different         │
│ accessors on the same name on one vs the other; then perform mixed smi/double writes to another property to force representation generalization on one object; finally, perform further defines that flip    │
│ attributes or convert accessor↔data on pre-existing name; repeat across prototype chain or after changing __proto__.\n  - Rapidly add/delete properties to tease the NormalizeProperties threshold, then     │
│ flip back to fast via MigrateSlowToFast by forcing stable shapes.\n\n- Expected observable effects (for triage/assertions):\n  - IC state churn (mono→poly→mega) in feedback; deopts or handler patching in  │
│ tiers; “trace-generalization” and “trace-migration” lines; map deprecations; NameDictionary growth; SetNamedProperty fallback counts.\n\n### 3. Additional context (if relevant):\n{\n    CODE REGION:       │
│ "Property store reconfiguration and normalization pipeline during named stores: JSObject::PrepareForDataProperty → MapUpdater (accessor↔data, representation generalization) →                               │
│ JSObject::NormalizeProperties/MigrateFastToSlow; IC glue in StoreIC::UpdateCaches; NameDictionary slow path. Files: src/objects/js-objects.cc, src/objects/map-updater.cc, src/ic/store-ic.cc,               │
│ src/objects/name-dictionary-inl.h, src/objects/dictionary.h, src/objects/property-details.h, src/objects/transitions.cc."\n    SUMMARY_OF_CODE_REGION: "This region governs how V8 updates an object’s       │
│ hidden class (Map) and backing store when a named property write occurs that requires changing property kind (accessor↔data), attributes, or value representation (Smi/Double/Any). The StoreIC supplies     │
│ feedback and may install handlers for fast transitions; otherwise the runtime slow path invokes JSObject::PrepareForDataProperty. PrepareForDataProperty coordinates with MapUpdater                         │
│ (src/objects/map-updater.cc), which attempts to reconfigure existing properties on the transition tree, deprecates incompatible maps, and selects or creates a new target map. When maps diverge too far     │
│ (e.g., conflicting accessor pairs across objects), the object normalizes to dictionary mode via JSObject::NormalizeProperties/MigrateFastToSlow, switching named properties to a NameDictionary.             │
│ Representation changes (e.g., Smi→Double) are handled via PropertyDetails/Representation generalization, potentially adding transition maps (+1 maps) and invalidating prior IC handlers.                    │
│ StoreIC::UpdateCaches (src/ic/store-ic.cc) must stay coherent with these changes, re-materializing handlers or bailing out. This boundary is sensitive because IC-generated code embeds map/field/offset     │
│ assumptions; mis-synchronized transitions or normalization can break those assumptions."\n    REASONING: "The regression regress-crbug-977012 exactly triggers this path: SetNamedProperty on x logs         │
│ representation generalization and then \'migrating to slow\' due to differing accessors on y between otherwise-related objects. That is a hallmark of PrepareForDataProperty + MapUpdater reconfiguration    │
│ followed by NormalizeProperties. It’s a high-value fuzz target because it spans IC state transitions, map deprecation, representation generalization, and slow/fast property migration, all of which have    │
│ historically produced correctness and security issues when combined. The path is tightly coupled to the JIT/IC pipeline (Ignition/Sparkplug/Maglev/TurboFan consume the StoreIC feedback and handlers), so   │
│ stressing it yields impactful stability/security coverage."\n}\n'}                                                                                                                                           │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
Observations: ### 1. Task outcome (short version):
Picked code region: JSObject::PrepareForDataProperty → MapUpdater reconfiguration → migration to dictionary mode during named property stores, including the StoreIC update path. Concretely: 
src/objects/js-objects.cc (PrepareForDataProperty, NormalizeProperties/MigrateFastToSlow), src/objects/map-updater.cc (MapUpdater reconfigure accessor↔data, representation changes), src/ic/store-ic.cc 
(StoreIC::UpdateCaches) and related NameDictionary code.

### 2. Task outcome (extremely detailed version):
- Why this region:
  - From Stage 0–2 regression entry regress/regress-crbug-977012: setting v1.x = 20.5 after creating two objects with an accessor on y triggers:
    - “|generalizing] x: … Smi→Double … (+1 maps)” and then “migrating to slow” (from execution flags --trace-migration --trace-generalization). The in-engine comment describes exactly: “Trigger a 
PrepareForDataProperty on v1, which also triggers an update to dictionary due to the different accessors on v1 and v2’s y property.”
  - This pinpoints the execution path where a named store (SetNamedProperty) must prepare the receiver’s map for a data property, while maps along the transition tree differ by having accessors on another 
property (y). The engine then generalizes representation for x (Smi→Double→Any) and ultimately normalizes (fast→dictionary) properties.
  - That path sits at the intersection of IC feedback, map transitions, field representation generalization, and slow/fast property migration — a historically fragile, security-relevant area in V8 (object 
shapes, hidden classes, property dictionaries, and IC state transitions).

- Concrete code region and files:
  - Property store preparation and normalization:
    - src/objects/js-objects.cc
      - JSObject::PrepareForDataProperty (prepares maps for defining/overwriting a named data property; may deprecate current map, run MapUpdater, and force NormalizeProperties/MigrateFastToSlow).
      - JSObject::NormalizeProperties / JSObject::MigrateFastToSlow (switches to NameDictionary for slow properties).
      - Related helpers for SetNamedProperty paths that consult PrepareForDataProperty.
    - src/objects/property-details.h and representation utilities: where representation generalization (Smi→Double→Any) and constness/attributes are handled.
  - Map transition machinery (reconfiguration & deprecation):
    - src/objects/map-updater.cc
      - MapUpdater state machine handling reconfigure of an existing property when kind changes (Accessor↔Data), attribute changes, or representation transitions; drives map deprecation and selection of a new
target map.
    - src/objects/transitions.cc (transition arrays; deprecations when shapes diverge).
  - IC update path participating in this flow:
    - src/ic/store-ic.cc (StoreIC::UpdateCaches / StoreIC::Store): consults feedback, builds handlers for monomorphic/polymorphic stores, and may fall back to runtime where PrepareForDataProperty is invoked; 
handler compilers reference the chosen transition map.
    - src/ic/ic.cc (IC state transitions, FeedbackNexus plumbing) for named store feedback that flips mono→poly→mega when maps diverge due to accessor differences.
  - Dictionary representation details (destination when migrating to slow):
    - src/objects/name-dictionary-inl.h, src/objects/dictionary.h (NameDictionary/GlobalDictionary mechanics for slow properties).

- How this matches the execution data (Stage 1–3 to code):
  - Bytecode: the function uses SetNamedProperty for x, and the log shows generalization and migration. This corresponds to the named-store IC path (StoreIC) plus the slow-path call into 
PrepareForDataProperty.
  - The “different accessors on v1 and v2’s y property” is a classic trigger for map deprecation and reconfiguration via MapUpdater; if no compatible fast transition exists, the object normalizes to 
dictionary mode.
  - The representation change Smi→Double→Any for x aligns with PropertyDetails/Representation generalization. When constness/attributes or accessor/data kind conflict, MapUpdater attempts a precise 
reconfigure but often ends with NormalizeProperties when shapes diverge.

- Why it’s an impactful fuzz target for JIT/IC stability/security:
  - It exercises inline caches + map transitions + property representation changes together, which historically lead to:
    - stale map assumptions in generated code, miscompiled IC handlers, or missed barriers when maps are deprecated/migrate to slow.
    - tricky aliasing of accessors vs data properties and attribute flags that can desynchronize handler expectations.
  - It crosses tiers (Ignition → Sparkplug/Sparkplug ICs → Maglev/TurboFan optimized code) because feedback/handlers created here are consumed by higher tiers; inconsistent feedback or racy/rare transitions 
can crash or miscompile.
  - It touches NameDictionary slow-path code, a separate set of lookups/defines not exercised by many IC fast paths; toggling fast↔slow repeatedly can reveal state leaks in FeedbackVector/handlers.
  - The regression demonstrates small, realistic JS patterns (mixing __defineSetter__, smi/double stores) that force these code paths; fuzzing can systematically vary:
    - order and interleaving of accessor installation vs data writes;
    - attribute changes (configurable/writable/enumerable), prototype adjustments, and protector invalidations;
    - numeric representations (smi/double/heap number), boxed/unboxed transitions, and const fields;
    - oscillation between fast and dictionary properties.

- Signals from the RAG knowledge base supporting this choice:
  - Hidden classes/fast properties docs explain fast vs slow (dictionary) transitions and their performance/IC implications.
  - “Fast properties in V8” details named property encodings, hidden classes, and the cost of switching to dictionary mode, which disables many IC fast paths — precisely the pivot we’re targeting.

- Example trigger patterns for the fuzzer (derived from the regression and docs):
  - Create two objects sharing a constructor/prototype; install different accessors on the same name on one vs the other; then perform mixed smi/double writes to another property to force representation 
generalization on one object; finally, perform further defines that flip attributes or convert accessor↔data on pre-existing name; repeat across prototype chain or after changing __proto__.
  - Rapidly add/delete properties to tease the NormalizeProperties threshold, then flip back to fast via MigrateSlowToFast by forcing stable shapes.

- Expected observable effects (for triage/assertions):
  - IC state churn (mono→poly→mega) in feedback; deopts or handler patching in tiers; “trace-generalization” and “trace-migration” lines; map deprecations; NameDictionary growth; SetNamedProperty fallback 
counts.

### 3. Additional context (if relevant):
{
    CODE REGION: "Property store reconfiguration and normalization pipeline during named stores: JSObject::PrepareForDataProperty → MapUpdater (accessor↔data, representation generalization) → 
JSObject::NormalizeProperties/MigrateFastToSlow; IC glue in StoreIC::UpdateCaches; NameDictionary slow path. Files: src/objects/js-objects.cc, src/objects/map-updater.cc, src/ic/store-ic.cc, 
src/objects/name-dictionary-inl.h, src/objects/dictionary.h, src/objects/property-details.h, src/objects/transitions.cc."
    SUMMARY_OF_CODE_REGION: "This region governs how V8 updates an object’s hidden class (Map) and backing store when a named property write occurs that requires changing property kind (accessor↔data), 
attributes, or value representation (Smi/Double/Any). The StoreIC supplies feedback and may install handlers for fast transitions; otherwise the runtime slow path invokes JSObject::PrepareForDataProperty. 
PrepareForDataProperty coordinates with MapUpdater (src/objects/map-updater.cc), which attempts to reconfigure existing properties on the transition tree, deprecates incompatible maps, and selects or creates 
a new target map. When maps diverge too far (e.g., conflicting accessor pairs across objects), the object normalizes to dictionary mode via JSObject::NormalizeProperties/MigrateFastToSlow, switching named 
properties to a NameDictionary. Representation changes (e.g., Smi→Double) are handled via PropertyDetails/Representation generalization, potentially adding transition maps (+1 maps) and invalidating prior IC 
handlers. StoreIC::UpdateCaches (src/ic/store-ic.cc) must stay coherent with these changes, re-materializing handlers or bailing out. This boundary is sensitive because IC-generated code embeds 
map/field/offset assumptions; mis-synchronized transitions or normalization can break those assumptions."
    REASONING: "The regression regress-crbug-977012 exactly triggers this path: SetNamedProperty on x logs representation generalization and then 'migrating to slow' due to differing accessors on y between 
otherwise-related objects. That is a hallmark of PrepareForDataProperty + MapUpdater reconfiguration followed by NormalizeProperties. It’s a high-value fuzz target because it spans IC state transitions, map 
deprecation, representation generalization, and slow/fast property migration, all of which have historically produced correctness and security issues when combined. The path is tightly coupled to the JIT/IC 
pipeline (Ignition/Sparkplug/Maglev/TurboFan consume the StoreIC feedback and handlers), so stressing it yields impactful stability/security coverage."
}
Final answer: ### 1. Task outcome (short version):
Picked code region: JSObject::PrepareForDataProperty → MapUpdater reconfiguration → migration to dictionary mode during named property stores, including the StoreIC update path. Concretely: 
src/objects/js-objects.cc (PrepareForDataProperty, NormalizeProperties/MigrateFastToSlow), src/objects/map-updater.cc (MapUpdater reconfigure accessor↔data, representation changes), src/ic/store-ic.cc 
(StoreIC::UpdateCaches) and related NameDictionary code.

### 2. Task outcome (extremely detailed version):
- Why this region:
  - From Stage 0–2 regression entry regress/regress-crbug-977012: setting v1.x = 20.5 after creating two objects with an accessor on y triggers:
    - “[generalizing] x: … Smi→Double … (+1 maps)” and then “migrating to slow” (from execution flags --trace-migration --trace-generalization). The in-engine comment describes exactly: “Trigger a 
PrepareForDataProperty on v1, which also triggers an update to dictionary due to the different accessors on v1 and v2’s y property.”
  - This pinpoints the execution path where a named store (SetNamedProperty) must prepare the receiver’s map for a data property, while maps along the transition tree differ by having accessors on another 
property (y). The engine then generalizes representation for x (Smi→Double→Any) and ultimately normalizes (fast→dictionary) properties.
  - That path sits at the intersection of IC feedback, map transitions, field representation generalization, and slow/fast property migration — a historically fragile, security-relevant area in V8 (object 
shapes, hidden classes, property dictionaries, and IC state transitions).

- Concrete code region and files:
  - Property store preparation and normalization:
    - src/objects/js-objects.cc
      - JSObject::PrepareForDataProperty (prepares maps for defining/overwriting a named data property; may deprecate current map, run MapUpdater, and force NormalizeProperties/MigrateFastToSlow).
      - JSObject::NormalizeProperties / JSObject::MigrateFastToSlow (switches to NameDictionary for slow properties).
      - Related helpers for SetNamedProperty paths that consult PrepareForDataProperty.
    - src/objects/property-details.h and representation utilities: where representation generalization (Smi→Double→Any) and constness/attributes are handled.
  - Map transition machinery (reconfiguration & deprecation):
    - src/objects/map-updater.cc
      - MapUpdater state machine handling reconfigure of an existing property when kind changes (Accessor↔Data), attribute changes, or representation transitions; drives map deprecation and selection of a new
target map.
    - src/objects/transitions.cc (transition arrays; deprecations when shapes diverge).
  - IC update path participating in this flow:
    - src/ic/store-ic.cc (StoreIC::UpdateCaches / StoreIC::Store): consults feedback, builds handlers for monomorphic/polymorphic stores, and may fall back to runtime where PrepareForDataProperty is invoked; 
handler compilers reference the chosen transition map.
    - src/ic/ic.cc (IC state transitions, FeedbackNexus plumbing) for named store feedback that flips mono→poly→mega when maps diverge due to accessor differences.
  - Dictionary representation details (destination when migrating to slow):
    - src/objects/name-dictionary-inl.h, src/objects/dictionary.h (NameDictionary/GlobalDictionary mechanics for slow properties).

- How this matches the execution data (Stage 1–3 to code):
  - Bytecode: the function uses SetNamedProperty for x, and the log shows generalization and migration. This corresponds to the named-store IC path (StoreIC) plus the slow-path call into 
PrepareForDataProperty.
  - The “different accessors on v1 and v2’s y property” is a classic trigger for map deprecation and reconfiguration via MapUpdater; if no compatible fast transition exists, the object normalizes to 
dictionary mode.
  - The representation change Smi→Double→Any for x aligns with PropertyDetails/Representation generalization. When constness/attributes or accessor/data kind conflict, MapUpdater attempts a precise 
reconfigure but often ends with NormalizeProperties when shapes diverge.

- Why it’s an impactful fuzz target for JIT/IC stability/security:
  - It exercises inline caches + map transitions + property representation changes together, which historically lead to:
    - stale map assumptions in generated code, miscompiled IC handlers, or missed barriers when maps are deprecated/migrate to slow.
    - tricky aliasing of accessors vs data properties and attribute flags that can desynchronize handler expectations.
  - It crosses tiers (Ignition → Sparkplug/Sparkplug ICs → Maglev/TurboFan optimized code) because feedback/handlers created here are consumed by higher tiers; inconsistent feedback or racy/rare transitions 
can crash or miscompile.
  - It touches NameDictionary slow-path code, a separate set of lookups/defines not exercised by many IC fast paths; toggling fast↔slow repeatedly can reveal state leaks in FeedbackVector/handlers.
  - The regression demonstrates small, realistic JS patterns (mixing __defineSetter__, smi/double stores) that force these code paths; fuzzing can systematically vary:
    - order and interleaving of accessor installation vs data writes;
    - attribute changes (configurable/writable/enumerable), prototype adjustments, and protector invalidations;
    - numeric representations (smi/double/heap number), boxed/unboxed transitions, and const fields;
    - oscillation between fast and dictionary properties.

- Signals from the RAG knowledge base supporting this choice:
  - Hidden classes/fast properties docs explain fast vs slow (dictionary) transitions and their performance/IC implications.
  - “Fast properties in V8” details named property encodings, hidden classes, and the cost of switching to dictionary mode, which disables many IC fast paths — precisely the pivot we’re targeting.

- Example trigger patterns for the fuzzer (derived from the regression and docs):
  - Create two objects sharing a constructor/prototype; install different accessors on the same name on one vs the other; then perform mixed smi/double writes to another property to force representation 
generalization on one object; finally, perform further defines that flip attributes or convert accessor↔data on pre-existing name; repeat across prototype chain or after changing __proto__.
  - Rapidly add/delete properties to tease the NormalizeProperties threshold, then flip back to fast via MigrateSlowToFast by forcing stable shapes.

- Expected observable effects (for triage/assertions):
  - IC state churn (mono→poly→mega) in feedback; deopts or handler patching in tiers; “trace-generalization” and “trace-migration” lines; map deprecations; NameDictionary growth; SetNamedProperty fallback 
counts.

### 3. Additional context (if relevant):
{
    CODE REGION: "Property store reconfiguration and normalization pipeline during named stores: JSObject::PrepareForDataProperty → MapUpdater (accessor↔data, representation generalization) → 
JSObject::NormalizeProperties/MigrateFastToSlow; IC glue in StoreIC::UpdateCaches; NameDictionary slow path. Files: src/objects/js-objects.cc, src/objects/map-updater.cc, src/ic/store-ic.cc, 
src/objects/name-dictionary-inl.h, src/objects/dictionary.h, src/objects/property-details.h, src/objects/transitions.cc."
    SUMMARY_OF_CODE_REGION: "This region governs how V8 updates an object’s hidden class (Map) and backing store when a named property write occurs that requires changing property kind (accessor↔data), 
attributes, or value representation (Smi/Double/Any). The StoreIC supplies feedback and may install handlers for fast transitions; otherwise the runtime slow path invokes JSObject::PrepareForDataProperty. 
PrepareForDataProperty coordinates with MapUpdater (src/objects/map-updater.cc), which attempts to reconfigure existing properties on the transition tree, deprecates incompatible maps, and selects or creates 
a new target map. When maps diverge too far (e.g., conflicting accessor pairs across objects), the object normalizes to dictionary mode via JSObject::NormalizeProperties/MigrateFastToSlow, switching named 
properties to a NameDictionary. Representation changes (e.g., Smi→Double) are handled via PropertyDetails/Representation generalization, potentially adding transition maps (+1 maps) and invalidating prior IC 
handlers. StoreIC::UpdateCaches (src/ic/store-ic.cc) must stay coherent with these changes, re-materializing handlers or bailing out. This boundary is sensitive because IC-generated code embeds 
map/field/offset assumptions; mis-synchronized transitions or normalization can break those assumptions."
    REASONING: "The regression regress-crbug-977012 exactly triggers this path: SetNamedProperty on x logs representation generalization and then 'migrating to slow' due to differing accessors on y between 
otherwise-related objects. That is a hallmark of PrepareForDataProperty + MapUpdater reconfiguration followed by NormalizeProperties. It’s a high-value fuzz target because it spans IC state transitions, map 
deprecation, representation generalization, and slow/fast property migration, all of which have historically produced correctness and security issues when combined. The path is tightly coupled to the JIT/IC 
pipeline (Ignition/Sparkplug/Maglev/TurboFan consume the StoreIC feedback and handlers), so stressing it yields impactful stability/security coverage."
}

[Step 7: Duration 116.01 seconds| Input tokens: 231,403 | Output tokens: 11,057]
Observations: Here is the final answer from your managed agent 'PickSection':
### 1. Task outcome (short version):
Picked code region: JSObject::PrepareForDataProperty → MapUpdater reconfiguration → migration to dictionary mode during named property stores, including the StoreIC update path. Concretely: 
src/objects/js-objects.cc (PrepareForDataProperty, NormalizeProperties/MigrateFastToSlow), src/objects/map-updater.cc (MapUpdater reconfigure accessor↔data, representation changes), src/ic/store-ic.cc 
(StoreIC::UpdateCaches) and related NameDictionary code.

### 2. Task outcome (extremely detailed version):
- Why this region:
  - From Stage 0–2 regression entry regress/regress-crbug-977012: setting v1.x = 20.5 after creating two objects with an accessor on y triggers:
    - “|generalizing] x: … Smi→Double … (+1 maps)” and then “migrating to slow” (from execution flags --trace-migration --trace-generalization). The in-engine comment describes exactly: “Trigger a 
PrepareForDataProperty on v1, which also triggers an update to dictionary due to the different accessors on v1 and v2’s y property.”
  - This pinpoints the execution path where a named store (SetNamedProperty) must prepare the receiver’s map for a data property, while maps along the transition tree differ by having accessors on another 
property (y). The engine then generalizes representation for x (Smi→Double→Any) and ultimately normalizes (fast→dictionary) properties.
  - That path sits at the intersection of IC feedback, map transitions, field representation generalization, and slow/fast property migration — a historically fragile, security-relevant area in V8 (object 
shapes, hidden classes, property dictionaries, and IC state transitions).

- Concrete code region and files:
  - Property store preparation and normalization:
    - src/objects/js-objects.cc
      - JSObject::PrepareForDataProperty (prepares maps for defining/overwriting a named data property; may deprecate current map, run MapUpdater, and force NormalizeProperties/MigrateFastToSlow).
      - JSObject::NormalizeProperties / JSObject::MigrateFastToSlow (switches to NameDictionary for slow properties).
      - Related helpers for SetNamedProperty paths that consult PrepareForDataProperty.
    - src/objects/property-details.h and representation utilities: where representation generalization (Smi→Double→Any) and constness/attributes are handled.
  - Map transition machinery (reconfiguration & deprecation):
    - src/objects/map-updater.cc
      - MapUpdater state machine handling reconfigure of an existing property when kind changes (Accessor↔Data), attribute changes, or representation transitions; drives map deprecation and selection of a new
target map.
    - src/objects/transitions.cc (transition arrays; deprecations when shapes diverge).
  - IC update path participating in this flow:
    - src/ic/store-ic.cc (StoreIC::UpdateCaches / StoreIC::Store): consults feedback, builds handlers for monomorphic/polymorphic stores, and may fall back to runtime where PrepareForDataProperty is invoked; 
handler compilers reference the chosen transition map.
    - src/ic/ic.cc (IC state transitions, FeedbackNexus plumbing) for named store feedback that flips mono→poly→mega when maps diverge due to accessor differences.
  - Dictionary representation details (destination when migrating to slow):
    - src/objects/name-dictionary-inl.h, src/objects/dictionary.h (NameDictionary/GlobalDictionary mechanics for slow properties).

- How this matches the execution data (Stage 1–3 to code):
  - Bytecode: the function uses SetNamedProperty for x, and the log shows generalization and migration. This corresponds to the named-store IC path (StoreIC) plus the slow-path call into 
PrepareForDataProperty.
  - The “different accessors on v1 and v2’s y property” is a classic trigger for map deprecation and reconfiguration via MapUpdater; if no compatible fast transition exists, the object normalizes to 
dictionary mode.
  - The representation change Smi→Double→Any for x aligns with PropertyDetails/Representation generalization. When constness/attributes or accessor/data kind conflict, MapUpdater attempts a precise 
reconfigure but often ends with NormalizeProperties when shapes diverge.

- Why it’s an impactful fuzz target for JIT/IC stability/security:
  - It exercises inline caches + map transitions + property representation changes together, which historically lead to:
    - stale map assumptions in generated code, miscompiled IC handlers, or missed barriers when maps are deprecated/migrate to slow.
    - tricky aliasing of accessors vs data properties and attribute flags that can desynchronize handler expectations.
  - It crosses tiers (Ignition → Sparkplug/Sparkplug ICs → Maglev/TurboFan optimized code) because feedback/handlers created here are consumed by higher tiers; inconsistent feedback or racy/rare transitions 
can crash or miscompile.
  - It touches NameDictionary slow-path code, a separate set of lookups/defines not exercised by many IC fast paths; toggling fast↔slow repeatedly can reveal state leaks in FeedbackVector/handlers.
  - The regression demonstrates small, realistic JS patterns (mixing __defineSetter__, smi/double stores) that force these code paths; fuzzing can systematically vary:
    - order and interleaving of accessor installation vs data writes;
    - attribute changes (configurable/writable/enumerable), prototype adjustments, and protector invalidations;
    - numeric representations (smi/double/heap number), boxed/unboxed transitions, and const fields;
    - oscillation between fast and dictionary properties.

- Signals from the RAG knowledge base supporting this choice:
  - Hidden classes/fast properties docs explain fast vs slow (dictionary) transitions and their performance/IC implications.
  - “Fast properties in V8” details named property encodings, hidden classes, and the cost of switching to dictionary mode, which disables many IC fast paths — precisely the pivot we’re targeting.

- Example trigger patterns for the fuzzer (derived from the regression and docs):
  - Create two objects sharing a constructor/prototype; install different accessors on the same name on one vs the other; then perform mixed smi/double writes to another property to force representation 
generalization on one object; finally, perform further defines that flip attributes or convert accessor↔data on pre-existing name; repeat across prototype chain or after changing __proto__.
  - Rapidly add/delete properties to tease the NormalizeProperties threshold, then flip back to fast via MigrateSlowToFast by forcing stable shapes.

- Expected observable effects (for triage/assertions):
  - IC state churn (mono→poly→mega) in feedback; deopts or handler patching in tiers; “trace-generalization” and “trace-migration” lines; map deprecations; NameDictionary growth; SetNamedProperty fallback 
counts.

### 3. Additional context (if relevant):
{
    CODE REGION: "Property store reconfiguration and normalization pipeline during named stores: JSObject::PrepareForDataProperty → MapUpdater (accessor↔data, representation generalization) → 
JSObject::NormalizeProperties/MigrateFastToSlow; IC glue in StoreIC::UpdateCaches; NameDictionary slow path. Files: src/objects/js-objects.cc, src/objects/map-updater.cc, src/ic/store-ic.cc, 
src/objects/name-dictionary-inl.h, src/objects/dictionary.h, src/objects/property-details.h, src/objects/transitions.cc."
    SUMMARY_OF_CODE_REGION: "This region governs how V8 updates an object’s hidden class (Map) and backing store when a named property write occurs that requires changing property kind (accessor↔data), 
attributes, or value representation (Smi/Double/Any). The StoreIC supplies feedback and may install handlers for fast transitions; otherwise the runtime slow path invokes JSObject::PrepareForDataProperty. 
PrepareForDataProperty coordinates with MapUpdater (src/objects/map-updater.cc), which attempts to reconfigure existing properties on the transition tree, deprecates incompatible maps, and selects or creates 
a new target map. When maps diverge too far (e.g., conflicting accessor pairs across objects), the object normalizes to dictionary mode via JSObject::NormalizeProperties/MigrateFastToSlow, switching named 
properties to a NameDictionary. Representation changes (e.g., Smi→Double) are handled via PropertyDetails/Representation generalization, potentially adding transition maps (+1 maps) and invalidating prior IC 
handlers. StoreIC::UpdateCaches (src/ic/store-ic.cc) must stay coherent with these changes, re-materializing handlers or bailing out. This boundary is sensitive because IC-generated code embeds 
map/field/offset assumptions; mis-synchronized transitions or normalization can break those assumptions."
    REASONING: "The regression regress-crbug-977012 exactly triggers this path: SetNamedProperty on x logs representation generalization and then 'migrating to slow' due to differing accessors on y between 
otherwise-related objects. That is a hallmark of PrepareForDataProperty + MapUpdater reconfiguration followed by NormalizeProperties. It’s a high-value fuzz target because it spans IC state transitions, map 
deprecation, representation generalization, and slow/fast property migration, all of which have historically produced correctness and security issues when combined. The path is tightly coupled to the JIT/IC 
pipeline (Ignition/Sparkplug/Maglev/TurboFan consume the StoreIC feedback and handlers), so stressing it yields impactful stability/security coverage."
}
[Step 2: Duration 309.67 seconds| Input tokens: 13,405 | Output tokens: 1,546]
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ Step 3 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'CodeAnalyzer' with arguments: {'task': 'Stage 1 request. Analyze the following V8 code region chosen by PickSection and produce a structured breakdown for later program-template targeting.  │
│ Code region scope:\n\nCore store reconfiguration/normalization pipeline during named property stores:\n- src/objects/js-objects.cc: JSObject::PrepareForDataProperty, JSObject::NormalizeProperties,         │
│ JSObject::MigrateFastToSlow, SetNamedProperty slow-path helpers.\n- src/objects/map-updater.cc: MapUpdater (reconfigure property kind accessor↔data, attribute/constness changes, representation             │
│ generalization), map deprecations and target map selection.\n- src/ic/store-ic.cc: StoreIC::Store / StoreIC::UpdateCaches, handler installation paths (monomorphic/polymorphic/megamorphic), runtime         │
│ fallback triggers.\n- src/objects/name-dictionary-inl.h and src/objects/dictionary.h: NameDictionary mechanics for slow properties.\n- src/objects/property-details.h: Representation generalization         │
│ (Smi→Double→Any), property attributes, constness.\n- src/objects/transitions.cc: TransitionArray map transitions, deprecations when shapes diverge.\n\nWhat to deliver (store each result as separate DB     │
│ entries with clear titles and tags, and include a master index entry):\n1) Call-flow diagram and stepwise narrative for a named store on a JSObject from the bytecode/IC to runtime slow path, including     │
│ when and how JSObject::PrepareForDataProperty is reached, and the role of StoreIC feedback (Mono→Poly→Mega) and handler types.\n2) MapUpdater state machine: inputs, transitions (accessor↔data, attributes, │
│ field kind/representation, elements kind interactions), deprecation criteria, target map selection, and bailout criteria that force normalization.\n3) Representation generalization rules: where/when       │
│ Smi→Double→Any occurs, how PropertyDetails encodes it, and how that influences transition map creation (+1 maps) and IC handler invalidation.\n4) NormalizeProperties/MigrateFastToSlow pivot: thresholds    │
│ and conditions that move a JSObject to NameDictionary, how fields/attributes are preserved, how lookups/defines change semantics/perf, and how ICs are affected.\n5) StoreIC::UpdateCaches critical          │
│ invariants: assumptions embedded in handlers (map, descriptors, field offsets, representation), synchronization points when maps are deprecated or object migrates to slow, and feedback vector updates.\n6) │
│ Known tricky/bug-prone edge cases to test: mixed accessor/data on the same name across instances, prototype chain accessors, configurable/non-configurable flips, deletions + redefines, smi/double          │
│ oscillation, adding/removing elements kinds interactions, protector invalidations (e.g., array species, string length), and __proto__ / setPrototypeOf churn.\n7) Security/stability risk assessment: where  │
│ stale assumptions or missing write barriers could cause use-after-free, type confusion, or miscompile in ICs or optimized code; reference any historical bugs if available.\n\nPlease:\n- Cross-reference    │
│ relevant code snippets and exact function names/lines if available in the RAG (approx OK).\n- Produce concise summaries per entry plus a detailed section.\n- Return a short overall summary and enumerate   │
│ the created runtime DB IDs so they can be fetched in Stage 2.\n- Tag entries with: [v8, ic, store, map-updater, normalization, dictionary, representation].\n'}                                              │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────────────────────────────────────────────────────────────────── New run - CodeAnalyzer ───────────────────────────────────────────────────────────────────────────────────────────╮
│                                                                                                                                                                                                              │
│ You're a helpful agent named 'CodeAnalyzer'.                                                                                                                                                                 │
│ You have been submitted this task by your manager.                                                                                                                                                           │
│ ---                                                                                                                                                                                                          │
│ Task:                                                                                                                                                                                                        │
│ Stage 1 request. Analyze the following V8 code region chosen by PickSection and produce a structured breakdown for later program-template targeting. Code region scope:                                      │
│                                                                                                                                                                                                              │
│ Core store reconfiguration/normalization pipeline during named property stores:                                                                                                                              │
│ - src/objects/js-objects.cc: JSObject::PrepareForDataProperty, JSObject::NormalizeProperties, JSObject::MigrateFastToSlow, SetNamedProperty slow-path helpers.                                               │
│ - src/objects/map-updater.cc: MapUpdater (reconfigure property kind accessor↔data, attribute/constness changes, representation generalization), map deprecations and target map selection.                   │
│ - src/ic/store-ic.cc: StoreIC::Store / StoreIC::UpdateCaches, handler installation paths (monomorphic/polymorphic/megamorphic), runtime fallback triggers.                                                   │
│ - src/objects/name-dictionary-inl.h and src/objects/dictionary.h: NameDictionary mechanics for slow properties.                                                                                              │
│ - src/objects/property-details.h: Representation generalization (Smi→Double→Any), property attributes, constness.                                                                                            │
│ - src/objects/transitions.cc: TransitionArray map transitions, deprecations when shapes diverge.                                                                                                             │
│                                                                                                                                                                                                              │
│ What to deliver (store each result as separate DB entries with clear titles and tags, and include a master index entry):                                                                                     │
│ 1) Call-flow diagram and stepwise narrative for a named store on a JSObject from the bytecode/IC to runtime slow path, including when and how JSObject::PrepareForDataProperty is reached, and the role of   │
│ StoreIC feedback (Mono→Poly→Mega) and handler types.                                                                                                                                                         │
│ 2) MapUpdater state machine: inputs, transitions (accessor↔data, attributes, field kind/representation, elements kind interactions), deprecation criteria, target map selection, and bailout criteria that   │
│ force normalization.                                                                                                                                                                                         │
│ 3) Representation generalization rules: where/when Smi→Double→Any occurs, how PropertyDetails encodes it, and how that influences transition map creation (+1 maps) and IC handler invalidation.             │
│ 4) NormalizeProperties/MigrateFastToSlow pivot: thresholds and conditions that move a JSObject to NameDictionary, how fields/attributes are preserved, how lookups/defines change semantics/perf, and how    │
│ ICs are affected.                                                                                                                                                                                            │
│ 5) StoreIC::UpdateCaches critical invariants: assumptions embedded in handlers (map, descriptors, field offsets, representation), synchronization points when maps are deprecated or object migrates to      │
│ slow, and feedback vector updates.                                                                                                                                                                           │
│ 6) Known tricky/bug-prone edge cases to test: mixed accessor/data on the same name across instances, prototype chain accessors, configurable/non-configurable flips, deletions + redefines, smi/double       │
│ oscillation, adding/removing elements kinds interactions, protector invalidations (e.g., array species, string length), and __proto__ / setPrototypeOf churn.                                                │
│ 7) Security/stability risk assessment: where stale assumptions or missing write barriers could cause use-after-free, type confusion, or miscompile in ICs or optimized code; reference any historical bugs   │
│ if available.                                                                                                                                                                                                │
│                                                                                                                                                                                                              │
│ Please:                                                                                                                                                                                                      │
│ - Cross-reference relevant code snippets and exact function names/lines if available in the RAG (approx OK).                                                                                                 │
│ - Produce concise summaries per entry plus a detailed section.                                                                                                                                               │
│ - Return a short overall summary and enumerate the created runtime DB IDs so they can be fetched in Stage 2.                                                                                                 │
│ - Tag entries with: [v8, ic, store, map-updater, normalization, dictionary, representation\].                                                                                                                │
│                                                                                                                                                                                                              │
│ ---                                                                                                                                                                                                          │
│ You're helping your manager solve a wider task: so make sure to not provide a one-line answer, but give as much information as possible to give them a clear understanding of the answer.                    │
│                                                                                                                                                                                                              │
│ Your final_answer WILL HAVE to contain these parts:                                                                                                                                                          │
│ ### 1. Task outcome (short version):                                                                                                                                                                         │
│ ### 2. Task outcome (extremely detailed version):                                                                                                                                                            │
│ ### 3. Additional context (if relevant):                                                                                                                                                                     │
│                                                                                                                                                                                                              │
│ Put all these in your final_answer tool, everything that you do not pass as an argument to final_answer will be lost.                                                                                        │
│ And even if your task resolution is not successful, please return as much context as possible, so that your manager can act upon this feedback.                                                              │
│                                                                                                                                                                                                              │
╰─ LiteLLMModel - gpt-5 ───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ Step 1 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'set_rag_collection' with arguments: {'name': 'rev-v8-store-normalization'}                                                                                                                    │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'V8Search' with arguments: {'task': 'In src/objects/map-updater.cc, extract the MapUpdater class core logic: constructor inputs, Update() or equivalent driver, cases for reconfiguring        │
│ properties (accessor<->data, attribute/constness changes), representation generalization, field kind transitions, deprecation criteria, target map selection or normalization bailout. Provide               │
│ representative code blocks and function names with paths/lines.'}                                                                                                                                            │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────── New run - V8Search ─────────────────────────────────────────────────────────────────────────────────────────────╮
│                                                                                                                                                                                                              │
│ You're a helpful agent named 'V8Search'.                                                                                                                                                                     │
│ ---                                                                                                                                                                                                          │
│ Task:                                                                                                                                                                                                        │
│ In src/objects/map-updater.cc, extract the MapUpdater class core logic: constructor inputs, Update() or equivalent driver, cases for reconfiguring properties (accessor<->data, attribute/constness          │
│ changes), representation generalization, field kind transitions, deprecation criteria, target map selection or normalization bailout. Provide representative code blocks and function names with             │
│ paths/lines.                                                                                                                                                                                                 │
│ ---                                                                                                                                                                                                          │
│ You're helping your manager solve a wider task: so make sure to not provide a one-line answer, but give as much information as possible to give them a clear understanding of the answer.                    │
│                                                                                                                                                                                                              │
│ Your final_answer WILL HAVE to contain these parts:                                                                                                                                                          │
│ ### 1. Task outcome (short version):                                                                                                                                                                         │
│ ### 2. Task outcome (extremely detailed version):                                                                                                                                                            │
│ ### 3. Additional context (if relevant):                                                                                                                                                                     │
│                                                                                                                                                                                                              │
│ Put all these in your final_answer tool, everything that you do not pass as an argument to final_answer will be lost.                                                                                        │
│ And even if your task resolution is not successful, please return as much context as possible, so that your manager can act upon this feedback.                                                              │
│                                                                                                                                                                                                              │
╰─ LiteLLMModel - gpt-5 ───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'V8Search' with arguments: {'task': 'In src/ic/store-ic.cc, find StoreIC::Store and StoreIC::UpdateCaches implementations, all handler installation code paths                                 │
│ (monomorphic/polymorphic/megamorphic), runtime fallback triggers (misses, deoptimizing conditions), and any dictionary/slow handler paths for named property stores. Return code excerpts with file paths    │
│ and approximate line numbers.'}                                                                                                                                                                              │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ Step 1 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
│ You have been submitted this task by your manager.                                                                                                                                                           │
╭───────────────────────────────────────────────────────────────────────────────────────────── New run - V8Search ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ You're a helpful agent named 'V8Search'.                                                                                                                                                                     │
│ You have been submitted this task by your manager.                                                                                                                                                           │
│ ---                                                                                                                                                                                                          │
│ Task:                                                                                                                                                                                                        │
│ In src/ic/store-ic.cc, find StoreIC::Store and StoreIC::UpdateCaches implementations, all handler installation code paths (monomorphic/polymorphic/megamorphic), runtime fallback triggers (misses,          │
│ deoptimizing conditions), and any dictionary/slow handler paths for named property stores. Return code excerpts with file paths and approximate line numbers.                                                │
│ ---                                                                                                                                                                                                          │
│ You're helping your manager solve a wider task: so make sure to not provide a one-line answer, but give as much information as possible to give them a clear understanding of the answer.                    │
│                                                                                                                                                                                                              │
│ Your final_answer WILL HAVE to contain these parts:                                                                                                                                                          │
│ ### 1. Task outcome (short version):                                                                                                                                                                         │
│ ### 2. Task outcome (extremely detailed version):                                                                                                                                                            │
│ ### 3. Additional context (if relevant):                                                                                                                                                                     │
│                                                                                                                                                                                                              │
│ Put all these in your final_answer tool, everything that you do not pass as an argument to final_answer will be lost.                                                                                        │
│ And even if your task resolution is not successful, please return as much context as possible, so that your manager can act upon this feedback.                                                              │
│                                                                                                                                                                                                              │
╰─ LiteLLMModel - gpt-5 ───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'V8Search' with arguments: {'task': 'Locate in V8 source the exact implementations and nearby helpers for named property stores fast/slow paths in src/objects/js-objects.cc. Specifically     │
│ retrieve code and surrounding context (signatures + key branches) for: JSObject::PrepareForDataProperty, JSObject::NormalizeProperties, JSObject::MigrateFastToSlow, and slow-path SetNamedProperty/Define   │
│ semantics used when installing/reconfiguring a data property on a JSObject. Include line numbers and file paths if available.'}                                                                              │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ Step 1 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
│                                                                                                                                                                                                              │
╭───────────────────────────────────────────────────────────────────────────────────────────── New run - V8Search ─────────────────────────────────────────────────────────────────────────────────────────────╮
│                                                                                                                                                                                                              │
│ You're a helpful agent named 'V8Search'.                                                                                                                                                                     │
│ You have been submitted this task by your manager.                                                                                                                                                           │
│ ---                                                                                                                                                                                                          │
│ Task:                                                                                                                                                                                                        │
│ Locate in V8 source the exact implementations and nearby helpers for named property stores fast/slow paths in src/objects/js-objects.cc. Specifically retrieve code and surrounding context (signatures +    │
│ key branches) for: JSObject::PrepareForDataProperty, JSObject::NormalizeProperties, JSObject::MigrateFastToSlow, and slow-path SetNamedProperty/Define semantics used when installing/reconfiguring a data   │
│ property on a JSObject. Include line numbers and file paths if available.                                                                                                                                    │
│ ---                                                                                                                                                                                                          │
│ You're helping your manager solve a wider task: so make sure to not provide a one-line answer, but give as much information as possible to give them a clear understanding of the answer.                    │
│                                                                                                                                                                                                              │
│ Your final_answer WILL HAVE to contain these parts:                                                                                                                                                          │
│ ### 1. Task outcome (short version):                                                                                                                                                                         │
│ ### 2. Task outcome (extremely detailed version):                                                                                                                                                            │
│ ### 3. Additional context (if relevant):                                                                                                                                                                     │
│                                                                                                                                                                                                              │
│ Put all these in your final_answer tool, everything that you do not pass as an argument to final_answer will be lost.                                                                                        │
│ And even if your task resolution is not successful, please return as much context as possible, so that your manager can act upon this feedback.                                                              │
│                                                                                                                                                                                                              │
╰─ LiteLLMModel - gpt-5 ───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ Step 1 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
Observations: Active RAG collection set to: rev-v8-store-normalization
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'V8Search' with arguments: {'task': 'In src/objects/property-details.h, extract the encoding of PropertyDetails and Representation/FieldType, including representation generalization rules    │
│ (Smi -> Double -> Tagged/Any), attributes, constness, and helper methods that determine transitionability. Include any constants or enums defining representation lattice.'}                                 │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────── New run - V8Search ─────────────────────────────────────────────────────────────────────────────────────────────╮
│                                                                                                                                                                                                              │
│ You're a helpful agent named 'V8Search'.                                                                                                                                                                     │
│ You have been submitted this task by your manager.                                                                                                                                                           │
│ Task:                                                                                                                                                                                                        │
│ In src/objects/property-details.h, extract the encoding of PropertyDetails and Representation/FieldType, including representation generalization rules (Smi -> Double -> Tagged/Any), attributes, constness, │
│ and helper methods that determine transitionability. Include any constants or enums defining representation lattice.                                                                                         │
│ ---                                                                                                                                                                                                          │
│ You're helping your manager solve a wider task: so make sure to not provide a one-line answer, but give as much information as possible to give them a clear understanding of the answer.                    │
│                                                                                                                                                                                                              │
│ Your final_answer WILL HAVE to contain these parts:                                                                                                                                                          │
│ ### 1. Task outcome (short version):                                                                                                                                                                         │
│ ### 2. Task outcome (extremely detailed version):                                                                                                                                                            │
│ ### 3. Additional context (if relevant):                                                                                                                                                                     │
│                                                                                                                                                                                                              │
│ Put all these in your final_answer tool, everything that you do not pass as an argument to final_answer will be lost.                                                                                        │
│ And even if your task resolution is not successful, please return as much context as possible, so that your manager can act upon this feedback.                                                              │
│                                                                                                                                                                                                              │
╰─ LiteLLMModel - gpt-5 ───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'V8Search' with arguments: {'task': 'In src/objects/name-dictionary-inl.h and src/objects/dictionary.h, retrieve NameDictionary mechanics relevant to slow properties: Lookup, Add,            │
│ EnsureCapacity, FindEntry, Set, DetailsAt, and any helpers used by JSObject slow property defines. Include inline details showing how PropertyDetails are stored and probed.'}                               │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ Step 1 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
│ ---                                                                                                                                                                                                          │
╭───────────────────────────────────────────────────────────────────────────────────────────── New run - V8Search ─────────────────────────────────────────────────────────────────────────────────────────────╮
│ You're a helpful agent named 'V8Search'.                                                                                                                                                                     │
│ You have been submitted this task by your manager.                                                                                                                                                           │
│ ---                                                                                                                                                                                                          │
│ Task:                                                                                                                                                                                                        │
│ In src/objects/name-dictionary-inl.h and src/objects/dictionary.h, retrieve NameDictionary mechanics relevant to slow properties: Lookup, Add, EnsureCapacity, FindEntry, Set, DetailsAt, and any helpers    │
│ used by JSObject slow property defines. Include inline details showing how PropertyDetails are stored and probed.                                                                                            │
│ ---                                                                                                                                                                                                          │
│ You're helping your manager solve a wider task: so make sure to not provide a one-line answer, but give as much information as possible to give them a clear understanding of the answer.                    │
│                                                                                                                                                                                                              │
│ Your final_answer WILL HAVE to contain these parts:                                                                                                                                                          │
│ ### 1. Task outcome (short version):                                                                                                                                                                         │
│ ### 2. Task outcome (extremely detailed version):                                                                                                                                                            │
│ ### 3. Additional context (if relevant):                                                                                                                                                                     │
│                                                                                                                                                                                                              │
│ Put all these in your final_answer tool, everything that you do not pass as an argument to final_answer will be lost.                                                                                        │
│ And even if your task resolution is not successful, please return as much context as possible, so that your manager can act upon this feedback.                                                              │
│                                                                                                                                                                                                              │
╰─ LiteLLMModel - gpt-5 ───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'V8Search' with arguments: {'task': 'In src/objects/transitions.cc (and related headers), retrieve TransitionArray and map transitions relevant to named property changes:                     │
│ FindTransitionToField/Accessor, DeprecateTransition(s), NewField/NewDataProperty transitions, handling when shapes diverge leading to deprecation and +1 map creation.'}                                     │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ Step 1 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
│                                                                                                                                                                                                              │
╭───────────────────────────────────────────────────────────────────────────────────────────── New run - V8Search ─────────────────────────────────────────────────────────────────────────────────────────────╮
│                                                                                                                                                                                                              │
│ You're a helpful agent named 'V8Search'.                                                                                                                                                                     │
│ You have been submitted this task by your manager.                                                                                                                                                           │
│ ---                                                                                                                                                                                                          │
│ Task:                                                                                                                                                                                                        │
│ In src/objects/transitions.cc (and related headers), retrieve TransitionArray and map transitions relevant to named property changes: FindTransitionToField/Accessor, DeprecateTransition(s),                │
│ NewField/NewDataProperty transitions, handling when shapes diverge leading to deprecation and +1 map creation.                                                                                               │
│ ---                                                                                                                                                                                                          │
│ You're helping your manager solve a wider task: so make sure to not provide a one-line answer, but give as much information as possible to give them a clear understanding of the answer.                    │
│                                                                                                                                                                                                              │
│ Your final_answer WILL HAVE to contain these parts:                                                                                                                                                          │
│ ### 1. Task outcome (short version):                                                                                                                                                                         │
│ ### 2. Task outcome (extremely detailed version):                                                                                                                                                            │
│ ### 3. Additional context (if relevant):                                                                                                                                                                     │
│                                                                                                                                                                                                              │
│ Put all these in your final_answer tool, everything that you do not pass as an argument to final_answer will be lost.                                                                                        │
│ And even if your task resolution is not successful, please return as much context as possible, so that your manager can act upon this feedback.                                                              │
│                                                                                                                                                                                                              │
╰─ LiteLLMModel - gpt-5 ───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ Step 1 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'fuzzy_finder' with arguments: {'pattern': 'store-ic.cc', 'options': "--filter='store-ic.cc'"}                                                                                                 │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
Command: cd /Users/tarun/v8/v8/src && rg --hidden --no-follow --no-ignore-vcs --files 2>/dev/null | fzf --filter='store-ic.cc' 'store-ic.cc' | head -n 1000
Observations: unknown option: store-ic.cc
[Step 1: Duration 4.34 seconds| Input tokens: 2,151 | Output tokens: 231]
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ Step 2 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'fuzzy_finder' with arguments: {'pattern': 'property-details.h', 'options': "--filter='property-details.h'"}                                                                                   │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'tree' with arguments: {'options': '-L 2 ./objects'}                                                                                                                                           │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
Command: cd /Users/tarun/v8/v8/src && rg --hidden --no-follow --no-ignore-vcs --files 2>/dev/null | fzf --filter='property-details.h' 'property-details.h' | head -n 1000
Observations: unknown option: property-details.h
Command: cd /Users/tarun/v8/v8/src && tree -L 2 ./objects | head -n 1000
Observations: ./objects
├── abstract-code-inl.h
├── abstract-code.cc
├── abstract-code.h
├── all-objects-inl.h
├── allocation-site-inl.h
├── allocation-site-scopes-inl.h
├── allocation-site-scopes.h
├── allocation-site.h
├── allocation-site.tq
├── api-callbacks-inl.h
├── api-callbacks.h
├── api-callbacks.tq
├── arguments-inl.h
├── arguments.h
├── arguments.tq
├── backing-store.cc
├── backing-store.h
├── bigint.cc
├── bigint.h
├── bigint.tq
├── bytecode-array-inl.h
├── bytecode-array.cc
├── bytecode-array.h
├── bytecode-array.tq
├── call-site-info-inl.h
├── call-site-info.cc
├── call-site-info.h
├── call-site-info.tq
├── casting-inl.h
├── casting.h
├── cell-inl.h
├── cell.h
├── cell.tq
├── code-inl.h
├── code-kind.cc
├── code-kind.h
├── code.cc
├── code.h
├── compilation-cache-table-inl.h
├── compilation-cache-table.cc
├── compilation-cache-table.h
├── compressed-slots-inl.h
├── compressed-slots.h
├── contexts-inl.h
├── contexts.cc
├── contexts.h
├── contexts.tq
├── data-handler-inl.h
├── data-handler.h
├── data-handler.tq
├── debug-objects-inl.h
├── debug-objects.cc
├── debug-objects.h
├── debug-objects.tq
├── deoptimization-data-inl.h
├── deoptimization-data.cc
├── deoptimization-data.h
├── dependent-code-inl.h
├── dependent-code.cc
├── dependent-code.h
├── DEPS
├── descriptor-array-inl.h
├── descriptor-array.h
├── descriptor-array.tq
├── dictionary-inl.h
├── dictionary.h
├── DIR_METADATA
├── elements-inl.h
├── elements-kind.cc
├── elements-kind.h
├── elements.cc
├── elements.h
├── embedder-data-array-inl.h
├── embedder-data-array.cc
├── embedder-data-array.h
├── embedder-data-array.tq
├── embedder-data-slot-inl.h
├── embedder-data-slot.h
├── feedback-cell-inl.h
├── feedback-cell.h
├── feedback-cell.tq
├── feedback-vector-inl.h
├── feedback-vector.cc
├── feedback-vector.h
├── feedback-vector.tq
├── field-index-inl.h
├── field-index.h
├── field-type.cc
├── field-type.h
├── fixed-array-inl.h
├── fixed-array.cc
├── fixed-array.h
├── fixed-array.tq
├── foreign-inl.h
├── foreign.h
├── foreign.tq
├── free-space-inl.h
├── free-space.h
├── free-space.tq
├── function-kind.h
├── function-syntax-kind.h
├── hash-table-inl.h
├── hash-table.h
├── heap-number-inl.h
├── heap-number.h
├── heap-number.tq
├── heap-object-inl.h
├── heap-object.h
├── heap-object.tq
├── hole-inl.h
├── hole.h
├── hole.tq
├── instance-type-checker.h
├── instance-type-inl.h
├── instance-type.h
├── instruction-stream-inl.h
├── instruction-stream.cc
├── instruction-stream.h
├── internal-index.h
├── intl-objects.cc
├── intl-objects.h
├── intl-objects.tq
├── js-array-buffer-inl.h
├── js-array-buffer.cc
├── js-array-buffer.h
├── js-array-buffer.tq
├── js-array-inl.h
├── js-array.h
├── js-array.tq
├── js-atomics-synchronization-inl.h
├── js-atomics-synchronization.cc
├── js-atomics-synchronization.h
├── js-atomics-synchronization.tq
├── js-break-iterator-inl.h
├── js-break-iterator.cc
├── js-break-iterator.h
├── js-break-iterator.tq
├── js-collator-inl.h
├── js-collator.cc
├── js-collator.h
├── js-collator.tq
├── js-collection-inl.h
├── js-collection-iterator-inl.h
├── js-collection-iterator.h
├── js-collection-iterator.tq
├── js-collection.h
├── js-collection.tq
├── js-date-time-format-inl.h
├── js-date-time-format.cc
├── js-date-time-format.h
├── js-date-time-format.tq
├── js-display-names-inl.h
├── js-display-names.cc
├── js-display-names.h
├── js-display-names.tq
├── js-disposable-stack-inl.h
├── js-disposable-stack.cc
├── js-disposable-stack.h
├── js-disposable-stack.tq
├── js-duration-format-inl.h
├── js-duration-format.cc
├── js-duration-format.h
├── js-duration-format.tq
├── js-function-inl.h
├── js-function.cc
├── js-function.h
├── js-function.tq
├── js-generator-inl.h
├── js-generator.h
├── js-generator.tq
├── js-iterator-helpers-inl.h
├── js-iterator-helpers.h
├── js-iterator-helpers.tq
├── js-list-format-inl.h
├── js-list-format.cc
├── js-list-format.h
├── js-list-format.tq
├── js-locale-inl.h
├── js-locale.cc
├── js-locale.h
├── js-locale.tq
├── js-number-format-inl.h
├── js-number-format.cc
├── js-number-format.h
├── js-number-format.tq
├── js-objects-inl.h
├── js-objects.cc
├── js-objects.h
├── js-objects.tq
├── js-plural-rules-inl.h
├── js-plural-rules.cc
├── js-plural-rules.h
├── js-plural-rules.tq
├── js-promise-inl.h
├── js-promise.h
├── js-promise.tq
├── js-proxy-inl.h
├── js-proxy.h
├── js-proxy.tq
├── js-raw-json-inl.h
├── js-raw-json.cc
├── js-raw-json.h
├── js-raw-json.tq
├── js-regexp-inl.h
├── js-regexp-string-iterator-inl.h
├── js-regexp-string-iterator.h
├── js-regexp-string-iterator.tq
├── js-regexp.cc
├── js-regexp.h
├── js-regexp.tq
├── js-relative-time-format-inl.h
├── js-relative-time-format.cc
├── js-relative-time-format.h
├── js-relative-time-format.tq
├── js-segment-iterator-inl.h
├── js-segment-iterator.cc
├── js-segment-iterator.h
├── js-segment-iterator.tq
├── js-segmenter-inl.h
├── js-segmenter.cc
├── js-segmenter.h
├── js-segmenter.tq
├── js-segments-inl.h
├── js-segments.cc
├── js-segments.h
├── js-segments.tq
├── js-shadow-realm-inl.h
├── js-shadow-realm.h
├── js-shadow-realm.tq
├── js-shared-array-inl.h
├── js-shared-array.h
├── js-shared-array.tq
├── js-struct-inl.h
├── js-struct.cc
├── js-struct.h
├── js-struct.tq
├── js-temporal-objects-inl.h
├── js-temporal-objects.cc
├── js-temporal-objects.h
├── js-temporal-objects.tq
├── js-weak-refs-inl.h
├── js-weak-refs.cc
├── js-weak-refs.h
├── js-weak-refs.tq
├── keys.cc
├── keys.h
├── literal-objects-inl.h
├── literal-objects.cc
├── literal-objects.h
├── literal-objects.tq
├── lookup-cache-inl.h
├── lookup-cache.cc
├── lookup-cache.h
├── lookup-inl.h
├── lookup.cc
├── lookup.h
├── managed-inl.h
├── managed.cc
├── managed.h
├── map-inl.h
├── map-updater.cc
├── map-updater.h
├── map.cc
├── map.h
├── map.tq
├── maybe-object-inl.h
├── maybe-object.h
├── megadom-handler-inl.h
├── megadom-handler.h
├── megadom-handler.tq
├── microtask-inl.h
├── microtask.h
├── microtask.tq
├── module-inl.h
├── module.cc
├── module.h
├── module.tq
├── name-inl.h
├── name.h
├── name.tq
├── object-list-macros.h
├── object-macros-undef.h
├── object-macros.h
├── object-type.cc
├── object-type.h
├── objects-body-descriptors-inl.h
├── objects-body-descriptors.h
├── objects-definitions.h
├── objects-inl.h
├── objects.cc
├── objects.h
├── oddball-inl.h
├── oddball.h
├── oddball.tq
├── off-heap-hash-table-inl.h
├── off-heap-hash-table.h
├── option-utils.cc
├── option-utils.h
├── ordered-hash-table-inl.h
├── ordered-hash-table.cc
├── ordered-hash-table.h
├── ordered-hash-table.tq
├── OWNERS
├── primitive-heap-object-inl.h
├── primitive-heap-object.h
├── primitive-heap-object.tq
├── promise-inl.h
├── promise.h
├── promise.tq
├── property-array-inl.h
├── property-array.h
├── property-array.tq
├── property-cell-inl.h
├── property-cell.h
├── property-cell.tq
├── property-descriptor-object-inl.h
├── property-descriptor-object.h
├── property-descriptor-object.tq
├── property-descriptor.cc
├── property-descriptor.h
├── property-details.h
├── property.cc
├── property.h
├── prototype-info-inl.h
├── prototype-info.h
├── prototype-info.tq
├── prototype-inl.h
├── prototype.h
├── regexp-match-info-inl.h
├── regexp-match-info.cc
├── regexp-match-info.h
├── regexp-match-info.tq
├── scope-info-inl.h
├── scope-info.cc
├── scope-info.h
├── scope-info.tq
├── script-inl.h
├── script.h
├── script.tq
├── shared-function-info-inl.h
├── shared-function-info.cc
├── shared-function-info.h
├── shared-function-info.tq
├── simd.cc
├── simd.h
├── slots-atomic-inl.h
├── slots-inl.h
├── slots.h
├── smi-inl.h
├── smi.h
├── source-text-module-inl.h
├── source-text-module.cc
├── source-text-module.h
├── source-text-module.tq
├── string-comparator.cc
├── string-comparator.h
├── string-forwarding-table-inl.h
├── string-forwarding-table.cc
├── string-forwarding-table.h
├── string-inl.h
├── string-set-inl.h
├── string-set.h
├── string-table-inl.h
├── string-table.cc
├── string-table.h
├── string.cc
├── string.h
├── string.tq
├── struct-inl.h
├── struct.h
├── struct.tq
├── swiss-hash-table-helpers.h
├── swiss-hash-table-helpers.tq
├── swiss-name-dictionary-inl.h
├── swiss-name-dictionary.cc
├── swiss-name-dictionary.h
├── swiss-name-dictionary.tq
├── symbol-table.cc
├── synthetic-module-inl.h
├── synthetic-module.cc
├── synthetic-module.h
├── synthetic-module.tq
├── tagged-field-inl.h
├── tagged-field.h
├── tagged-impl-inl.h
├── tagged-impl.cc
├── tagged-impl.h
├── tagged-index.h
├── tagged-value-inl.h
├── tagged-value.h
├── tagged.h
├── template-objects-inl.h
├── template-objects.cc
├── template-objects.h
├── template-objects.tq
├── templates-inl.h
├── templates.cc
├── templates.h
├── templates.tq
├── torque-defined-classes-inl.h
├── torque-defined-classes.h
├── torque-defined-classes.tq
├── transitions-inl.h
├── transitions.cc
├── transitions.h
├── trusted-object-inl.h
├── trusted-object.h
├── trusted-object.tq
├── turbofan-types-inl.h
├── turbofan-types.h
├── turbofan-types.tq
├── turboshaft-types-inl.h
├── turboshaft-types.h
├── turboshaft-types.tq
├── type-hints.cc
├── type-hints.h
├── union.h
├── value-serializer.cc
├── value-serializer.h
├── visitors-inl.h
├── visitors.cc
├── visitors.h
├── waiter-queue-node.cc
└── waiter-queue-node.h

1 directory, 424 files
[Step 2: Duration 7.52 seconds| Input tokens: 4,287 | Output tokens: 558]
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ Step 3 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'fuzzy_finder' with arguments: {'pattern': 'map-updater', 'options': "--filter='map-updater'"}                                                                                                 │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
Command: cd /Users/tarun/v8/v8/src && rg --hidden --no-follow --no-ignore-vcs --files 2>/dev/null | fzf --filter='map-updater' 'map-updater' | head -n 1000
Observations: unknown option: map-updater
[Step 3: Duration 7.66 seconds| Input tokens: 6,442 | Output tokens: 788]
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ Step 4 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'fuzzy_finder' with arguments: {'pattern': 'name-dictionary-inl.h', 'options': '--filter="name-dictionary-inl.h"'}                                                                             │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'tree' with arguments: {'options': '-L 2 objects'}                                                                                                                                             │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
Command: cd /Users/tarun/v8/v8/src && rg --hidden --no-follow --no-ignore-vcs --files 2>/dev/null | fzf --filter="name-dictionary-inl.h" 'name-dictionary-inl.h' | head -n 1000
Observations: unknown option: name-dictionary-inl.h
Command: cd /Users/tarun/v8/v8/src && tree -L 2 objects | head -n 1000
Observations: objects
├── abstract-code-inl.h
├── abstract-code.cc
├── abstract-code.h
├── all-objects-inl.h
├── allocation-site-inl.h
├── allocation-site-scopes-inl.h
├── allocation-site-scopes.h
├── allocation-site.h
├── allocation-site.tq
├── api-callbacks-inl.h
├── api-callbacks.h
├── api-callbacks.tq
├── arguments-inl.h
├── arguments.h
├── arguments.tq
├── backing-store.cc
├── backing-store.h
├── bigint.cc
├── bigint.h
├── bigint.tq
├── bytecode-array-inl.h
├── bytecode-array.cc
├── bytecode-array.h
├── bytecode-array.tq
├── call-site-info-inl.h
├── call-site-info.cc
├── call-site-info.h
├── call-site-info.tq
├── casting-inl.h
├── casting.h
├── cell-inl.h
├── cell.h
├── cell.tq
├── code-inl.h
├── code-kind.cc
├── code-kind.h
├── code.cc
├── code.h
├── compilation-cache-table-inl.h
├── compilation-cache-table.cc
├── compilation-cache-table.h
├── compressed-slots-inl.h
├── compressed-slots.h
├── contexts-inl.h
├── contexts.cc
├── contexts.h
├── contexts.tq
├── data-handler-inl.h
├── data-handler.h
├── data-handler.tq
├── debug-objects-inl.h
├── debug-objects.cc
├── debug-objects.h
├── debug-objects.tq
├── deoptimization-data-inl.h
├── deoptimization-data.cc
├── deoptimization-data.h
├── dependent-code-inl.h
├── dependent-code.cc
├── dependent-code.h
├── DEPS
├── descriptor-array-inl.h
├── descriptor-array.h
├── descriptor-array.tq
├── dictionary-inl.h
├── dictionary.h
├── DIR_METADATA
├── elements-inl.h
├── elements-kind.cc
├── elements-kind.h
├── elements.cc
├── elements.h
├── embedder-data-array-inl.h
├── embedder-data-array.cc
├── embedder-data-array.h
├── embedder-data-array.tq
├── embedder-data-slot-inl.h
├── embedder-data-slot.h
├── feedback-cell-inl.h
├── feedback-cell.h
├── feedback-cell.tq
├── feedback-vector-inl.h
├── feedback-vector.cc
├── feedback-vector.h
├── feedback-vector.tq
├── field-index-inl.h
├── field-index.h
├── field-type.cc
├── field-type.h
├── fixed-array-inl.h
├── fixed-array.cc
├── fixed-array.h
├── fixed-array.tq
├── foreign-inl.h
├── foreign.h
├── foreign.tq
├── free-space-inl.h
├── free-space.h
├── free-space.tq
├── function-kind.h
├── function-syntax-kind.h
├── hash-table-inl.h
├── hash-table.h
├── heap-number-inl.h
├── heap-number.h
├── heap-number.tq
├── heap-object-inl.h
├── heap-object.h
├── heap-object.tq
├── hole-inl.h
├── hole.h
├── hole.tq
├── instance-type-checker.h
├── instance-type-inl.h
├── instance-type.h
├── instruction-stream-inl.h
├── instruction-stream.cc
├── instruction-stream.h
├── internal-index.h
├── intl-objects.cc
├── intl-objects.h
├── intl-objects.tq
├── js-array-buffer-inl.h
├── js-array-buffer.cc
├── js-array-buffer.h
├── js-array-buffer.tq
├── js-array-inl.h
├── js-array.h
├── js-array.tq
├── js-atomics-synchronization-inl.h
├── js-atomics-synchronization.cc
├── js-atomics-synchronization.h
├── js-atomics-synchronization.tq
├── js-break-iterator-inl.h
├── js-break-iterator.cc
├── js-break-iterator.h
├── js-break-iterator.tq
├── js-collator-inl.h
├── js-collator.cc
├── js-collator.h
├── js-collator.tq
├── js-collection-inl.h
├── js-collection-iterator-inl.h
├── js-collection-iterator.h
├── js-collection-iterator.tq
├── js-collection.h
├── js-collection.tq
├── js-date-time-format-inl.h
├── js-date-time-format.cc
├── js-date-time-format.h
├── js-date-time-format.tq
├── js-display-names-inl.h
├── js-display-names.cc
├── js-display-names.h
├── js-display-names.tq
├── js-disposable-stack-inl.h
├── js-disposable-stack.cc
├── js-disposable-stack.h
├── js-disposable-stack.tq
├── js-duration-format-inl.h
├── js-duration-format.cc
├── js-duration-format.h
├── js-duration-format.tq
├── js-function-inl.h
├── js-function.cc
├── js-function.h
├── js-function.tq
├── js-generator-inl.h
├── js-generator.h
├── js-generator.tq
├── js-iterator-helpers-inl.h
├── js-iterator-helpers.h
├── js-iterator-helpers.tq
├── js-list-format-inl.h
├── js-list-format.cc
├── js-list-format.h
├── js-list-format.tq
├── js-locale-inl.h
├── js-locale.cc
├── js-locale.h
├── js-locale.tq
├── js-number-format-inl.h
├── js-number-format.cc
├── js-number-format.h
├── js-number-format.tq
├── js-objects-inl.h
├── js-objects.cc
├── js-objects.h
├── js-objects.tq
├── js-plural-rules-inl.h
├── js-plural-rules.cc
├── js-plural-rules.h
├── js-plural-rules.tq
├── js-promise-inl.h
├── js-promise.h
├── js-promise.tq
├── js-proxy-inl.h
├── js-proxy.h
├── js-proxy.tq
├── js-raw-json-inl.h
├── js-raw-json.cc
├── js-raw-json.h
├── js-raw-json.tq
├── js-regexp-inl.h
├── js-regexp-string-iterator-inl.h
├── js-regexp-string-iterator.h
├── js-regexp-string-iterator.tq
├── js-regexp.cc
├── js-regexp.h
├── js-regexp.tq
├── js-relative-time-format-inl.h
├── js-relative-time-format.cc
├── js-relative-time-format.h
├── js-relative-time-format.tq
├── js-segment-iterator-inl.h
├── js-segment-iterator.cc
├── js-segment-iterator.h
├── js-segment-iterator.tq
├── js-segmenter-inl.h
├── js-segmenter.cc
├── js-segmenter.h
├── js-segmenter.tq
├── js-segments-inl.h
├── js-segments.cc
├── js-segments.h
├── js-segments.tq
├── js-shadow-realm-inl.h
├── js-shadow-realm.h
├── js-shadow-realm.tq
├── js-shared-array-inl.h
├── js-shared-array.h
├── js-shared-array.tq
├── js-struct-inl.h
├── js-struct.cc
├── js-struct.h
├── js-struct.tq
├── js-temporal-objects-inl.h
├── js-temporal-objects.cc
├── js-temporal-objects.h
├── js-temporal-objects.tq
├── js-weak-refs-inl.h
├── js-weak-refs.cc
├── js-weak-refs.h
├── js-weak-refs.tq
├── keys.cc
├── keys.h
├── literal-objects-inl.h
├── literal-objects.cc
├── literal-objects.h
├── literal-objects.tq
├── lookup-cache-inl.h
├── lookup-cache.cc
├── lookup-cache.h
├── lookup-inl.h
├── lookup.cc
├── lookup.h
├── managed-inl.h
├── managed.cc
├── managed.h
├── map-inl.h
├── map-updater.cc
├── map-updater.h
├── map.cc
├── map.h
├── map.tq
├── maybe-object-inl.h
├── maybe-object.h
├── megadom-handler-inl.h
├── megadom-handler.h
├── megadom-handler.tq
├── microtask-inl.h
├── microtask.h
├── microtask.tq
├── module-inl.h
├── module.cc
├── module.h
├── module.tq
├── name-inl.h
├── name.h
├── name.tq
├── object-list-macros.h
├── object-macros-undef.h
├── object-macros.h
├── object-type.cc
├── object-type.h
├── objects-body-descriptors-inl.h
├── objects-body-descriptors.h
├── objects-definitions.h
├── objects-inl.h
├── objects.cc
├── objects.h
├── oddball-inl.h
├── oddball.h
├── oddball.tq
├── off-heap-hash-table-inl.h
├── off-heap-hash-table.h
├── option-utils.cc
├── option-utils.h
├── ordered-hash-table-inl.h
├── ordered-hash-table.cc
├── ordered-hash-table.h
├── ordered-hash-table.tq
├── OWNERS
├── primitive-heap-object-inl.h
├── primitive-heap-object.h
├── primitive-heap-object.tq
├── promise-inl.h
├── promise.h
├── promise.tq
├── property-array-inl.h
├── property-array.h
├── property-array.tq
├── property-cell-inl.h
├── property-cell.h
├── property-cell.tq
├── property-descriptor-object-inl.h
├── property-descriptor-object.h
├── property-descriptor-object.tq
├── property-descriptor.cc
├── property-descriptor.h
├── property-details.h
├── property.cc
├── property.h
├── prototype-info-inl.h
├── prototype-info.h
├── prototype-info.tq
├── prototype-inl.h
├── prototype.h
├── regexp-match-info-inl.h
├── regexp-match-info.cc
├── regexp-match-info.h
├── regexp-match-info.tq
├── scope-info-inl.h
├── scope-info.cc
├── scope-info.h
├── scope-info.tq
├── script-inl.h
├── script.h
├── script.tq
├── shared-function-info-inl.h
├── shared-function-info.cc
├── shared-function-info.h
├── shared-function-info.tq
├── simd.cc
├── simd.h
├── slots-atomic-inl.h
├── slots-inl.h
├── slots.h
├── smi-inl.h
├── smi.h
├── source-text-module-inl.h
├── source-text-module.cc
├── source-text-module.h
├── source-text-module.tq
├── string-comparator.cc
├── string-comparator.h
├── string-forwarding-table-inl.h
├── string-forwarding-table.cc
├── string-forwarding-table.h
├── string-inl.h
├── string-set-inl.h
├── string-set.h
├── string-table-inl.h
├── string-table.cc
├── string-table.h
├── string.cc
├── string.h
├── string.tq
├── struct-inl.h
├── struct.h
├── struct.tq
├── swiss-hash-table-helpers.h
├── swiss-hash-table-helpers.tq
├── swiss-name-dictionary-inl.h
├── swiss-name-dictionary.cc
├── swiss-name-dictionary.h
├── swiss-name-dictionary.tq
├── symbol-table.cc
├── synthetic-module-inl.h
├── synthetic-module.cc
├── synthetic-module.h
├── synthetic-module.tq
├── tagged-field-inl.h
├── tagged-field.h
├── tagged-impl-inl.h
├── tagged-impl.cc
├── tagged-impl.h
├── tagged-index.h
├── tagged-value-inl.h
├── tagged-value.h
├── tagged.h
├── template-objects-inl.h
├── template-objects.cc
├── template-objects.h
├── template-objects.tq
├── templates-inl.h
├── templates.cc
├── templates.h
├── templates.tq
├── torque-defined-classes-inl.h
├── torque-defined-classes.h
├── torque-defined-classes.tq
├── transitions-inl.h
├── transitions.cc
├── transitions.h
├── trusted-object-inl.h
├── trusted-object.h
├── trusted-object.tq
├── turbofan-types-inl.h
├── turbofan-types.h
├── turbofan-types.tq
├── turboshaft-types-inl.h
├── turboshaft-types.h
├── turboshaft-types.tq
├── type-hints.cc
├── type-hints.h
├── union.h
├── value-serializer.cc
├── value-serializer.h
├── visitors-inl.h
├── visitors.cc
├── visitors.h
├── waiter-queue-node.cc
└── waiter-queue-node.h

1 directory, 424 files
[Step 4: Duration 7.76 seconds| Input tokens: 8,587 | Output tokens: 1,056]
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ Step 5 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'fuzzy_finder' with arguments: {'pattern': 'objects/js-objects.cc', 'options': "--filter='objects/js-objects.cc'"}                                                                             │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'tree' with arguments: {'options': '-L 2 -f ./objects'}                                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
Command: cd /Users/tarun/v8/v8/src && rg --hidden --no-follow --no-ignore-vcs --files 2>/dev/null | fzf --filter='objects/js-objects.cc' 'objects/js-objects.cc' | head -n 1000
Observations: unknown option: objects/js-objects.cc
Command: cd /Users/tarun/v8/v8/src && tree -L 2 -f ./objects | head -n 1000
Observations: ./objects
├── ./objects/abstract-code-inl.h
├── ./objects/abstract-code.cc
├── ./objects/abstract-code.h
├── ./objects/all-objects-inl.h
├── ./objects/allocation-site-inl.h
├── ./objects/allocation-site-scopes-inl.h
├── ./objects/allocation-site-scopes.h
├── ./objects/allocation-site.h
├── ./objects/allocation-site.tq
├── ./objects/api-callbacks-inl.h
├── ./objects/api-callbacks.h
├── ./objects/api-callbacks.tq
├── ./objects/arguments-inl.h
├── ./objects/arguments.h
├── ./objects/arguments.tq
├── ./objects/backing-store.cc
├── ./objects/backing-store.h
├── ./objects/bigint.cc
├── ./objects/bigint.h
├── ./objects/bigint.tq
├── ./objects/bytecode-array-inl.h
├── ./objects/bytecode-array.cc
├── ./objects/bytecode-array.h
├── ./objects/bytecode-array.tq
├── ./objects/call-site-info-inl.h
├── ./objects/call-site-info.cc
├── ./objects/call-site-info.h
├── ./objects/call-site-info.tq
├── ./objects/casting-inl.h
├── ./objects/casting.h
├── ./objects/cell-inl.h
├── ./objects/cell.h
├── ./objects/cell.tq
├── ./objects/code-inl.h
├── ./objects/code-kind.cc
├── ./objects/code-kind.h
├── ./objects/code.cc
├── ./objects/code.h
├── ./objects/compilation-cache-table-inl.h
├── ./objects/compilation-cache-table.cc
├── ./objects/compilation-cache-table.h
├── ./objects/compressed-slots-inl.h
├── ./objects/compressed-slots.h
├── ./objects/contexts-inl.h
├── ./objects/contexts.cc
├── ./objects/contexts.h
├── ./objects/contexts.tq
├── ./objects/data-handler-inl.h
├── ./objects/data-handler.h
├── ./objects/data-handler.tq
├── ./objects/debug-objects-inl.h
├── ./objects/debug-objects.cc
├── ./objects/debug-objects.h
├── ./objects/debug-objects.tq
├── ./objects/deoptimization-data-inl.h
├── ./objects/deoptimization-data.cc
├── ./objects/deoptimization-data.h
├── ./objects/dependent-code-inl.h
├── ./objects/dependent-code.cc
├── ./objects/dependent-code.h
├── ./objects/DEPS
├── ./objects/descriptor-array-inl.h
├── ./objects/descriptor-array.h
├── ./objects/descriptor-array.tq
├── ./objects/dictionary-inl.h
├── ./objects/dictionary.h
├── ./objects/DIR_METADATA
├── ./objects/elements-inl.h
├── ./objects/elements-kind.cc
├── ./objects/elements-kind.h
├── ./objects/elements.cc
├── ./objects/elements.h
├── ./objects/embedder-data-array-inl.h
├── ./objects/embedder-data-array.cc
├── ./objects/embedder-data-array.h
├── ./objects/embedder-data-array.tq
├── ./objects/embedder-data-slot-inl.h
├── ./objects/embedder-data-slot.h
├── ./objects/feedback-cell-inl.h
├── ./objects/feedback-cell.h
├── ./objects/feedback-cell.tq
├── ./objects/feedback-vector-inl.h
├── ./objects/feedback-vector.cc
├── ./objects/feedback-vector.h
├── ./objects/feedback-vector.tq
├── ./objects/field-index-inl.h
├── ./objects/field-index.h
├── ./objects/field-type.cc
├── ./objects/field-type.h
├── ./objects/fixed-array-inl.h
├── ./objects/fixed-array.cc
├── ./objects/fixed-array.h
├── ./objects/fixed-array.tq
├── ./objects/foreign-inl.h
├── ./objects/foreign.h
├── ./objects/foreign.tq
├── ./objects/free-space-inl.h
├── ./objects/free-space.h
├── ./objects/free-space.tq
├── ./objects/function-kind.h
├── ./objects/function-syntax-kind.h
├── ./objects/hash-table-inl.h
├── ./objects/hash-table.h
├── ./objects/heap-number-inl.h
├── ./objects/heap-number.h
├── ./objects/heap-number.tq
├── ./objects/heap-object-inl.h
├── ./objects/heap-object.h
├── ./objects/heap-object.tq
├── ./objects/hole-inl.h
├── ./objects/hole.h
├── ./objects/hole.tq
├── ./objects/instance-type-checker.h
├── ./objects/instance-type-inl.h
├── ./objects/instance-type.h
├── ./objects/instruction-stream-inl.h
├── ./objects/instruction-stream.cc
├── ./objects/instruction-stream.h
├── ./objects/internal-index.h
├── ./objects/intl-objects.cc
├── ./objects/intl-objects.h
├── ./objects/intl-objects.tq
├── ./objects/js-array-buffer-inl.h
├── ./objects/js-array-buffer.cc
├── ./objects/js-array-buffer.h
├── ./objects/js-array-buffer.tq
├── ./objects/js-array-inl.h
├── ./objects/js-array.h
├── ./objects/js-array.tq
├── ./objects/js-atomics-synchronization-inl.h
├── ./objects/js-atomics-synchronization.cc
├── ./objects/js-atomics-synchronization.h
├── ./objects/js-atomics-synchronization.tq
├── ./objects/js-break-iterator-inl.h
├── ./objects/js-break-iterator.cc
├── ./objects/js-break-iterator.h
├── ./objects/js-break-iterator.tq
├── ./objects/js-collator-inl.h
├── ./objects/js-collator.cc
├── ./objects/js-collator.h
├── ./objects/js-collator.tq
├── ./objects/js-collection-inl.h
├── ./objects/js-collection-iterator-inl.h
├── ./objects/js-collection-iterator.h
├── ./objects/js-collection-iterator.tq
├── ./objects/js-collection.h
├── ./objects/js-collection.tq
├── ./objects/js-date-time-format-inl.h
├── ./objects/js-date-time-format.cc
├── ./objects/js-date-time-format.h
├── ./objects/js-date-time-format.tq
├── ./objects/js-display-names-inl.h
├── ./objects/js-display-names.cc
├── ./objects/js-display-names.h
├── ./objects/js-display-names.tq
├── ./objects/js-disposable-stack-inl.h
├── ./objects/js-disposable-stack.cc
├── ./objects/js-disposable-stack.h
├── ./objects/js-disposable-stack.tq
├── ./objects/js-duration-format-inl.h
├── ./objects/js-duration-format.cc
├── ./objects/js-duration-format.h
├── ./objects/js-duration-format.tq
├── ./objects/js-function-inl.h
├── ./objects/js-function.cc
├── ./objects/js-function.h
├── ./objects/js-function.tq
├── ./objects/js-generator-inl.h
├── ./objects/js-generator.h
├── ./objects/js-generator.tq
├── ./objects/js-iterator-helpers-inl.h
├── ./objects/js-iterator-helpers.h
├── ./objects/js-iterator-helpers.tq
├── ./objects/js-list-format-inl.h
├── ./objects/js-list-format.cc
├── ./objects/js-list-format.h
├── ./objects/js-list-format.tq
├── ./objects/js-locale-inl.h
├── ./objects/js-locale.cc
├── ./objects/js-locale.h
├── ./objects/js-locale.tq
├── ./objects/js-number-format-inl.h
├── ./objects/js-number-format.cc
├── ./objects/js-number-format.h
├── ./objects/js-number-format.tq
├── ./objects/js-objects-inl.h
├── ./objects/js-objects.cc
├── ./objects/js-objects.h
├── ./objects/js-objects.tq
├── ./objects/js-plural-rules-inl.h
├── ./objects/js-plural-rules.cc
├── ./objects/js-plural-rules.h
├── ./objects/js-plural-rules.tq
├── ./objects/js-promise-inl.h
├── ./objects/js-promise.h
├── ./objects/js-promise.tq
├── ./objects/js-proxy-inl.h
├── ./objects/js-proxy.h
├── ./objects/js-proxy.tq
├── ./objects/js-raw-json-inl.h
├── ./objects/js-raw-json.cc
├── ./objects/js-raw-json.h
├── ./objects/js-raw-json.tq
├── ./objects/js-regexp-inl.h
├── ./objects/js-regexp-string-iterator-inl.h
├── ./objects/js-regexp-string-iterator.h
├── ./objects/js-regexp-string-iterator.tq
├── ./objects/js-regexp.cc
├── ./objects/js-regexp.h
├── ./objects/js-regexp.tq
├── ./objects/js-relative-time-format-inl.h
├── ./objects/js-relative-time-format.cc
├── ./objects/js-relative-time-format.h
├── ./objects/js-relative-time-format.tq
├── ./objects/js-segment-iterator-inl.h
├── ./objects/js-segment-iterator.cc
├── ./objects/js-segment-iterator.h
├── ./objects/js-segment-iterator.tq
├── ./objects/js-segmenter-inl.h
├── ./objects/js-segmenter.cc
├── ./objects/js-segmenter.h
├── ./objects/js-segmenter.tq
├── ./objects/js-segments-inl.h
├── ./objects/js-segments.cc
├── ./objects/js-segments.h
├── ./objects/js-segments.tq
├── ./objects/js-shadow-realm-inl.h
├── ./objects/js-shadow-realm.h
├── ./objects/js-shadow-realm.tq
├── ./objects/js-shared-array-inl.h
├── ./objects/js-shared-array.h
├── ./objects/js-shared-array.tq
├── ./objects/js-struct-inl.h
├── ./objects/js-struct.cc
├── ./objects/js-struct.h
├── ./objects/js-struct.tq
├── ./objects/js-temporal-objects-inl.h
├── ./objects/js-temporal-objects.cc
├── ./objects/js-temporal-objects.h
├── ./objects/js-temporal-objects.tq
├── ./objects/js-weak-refs-inl.h
├── ./objects/js-weak-refs.cc
├── ./objects/js-weak-refs.h
├── ./objects/js-weak-refs.tq
├── ./objects/keys.cc
├── ./objects/keys.h
├── ./objects/literal-objects-inl.h
├── ./objects/literal-objects.cc
├── ./objects/literal-objects.h
├── ./objects/literal-objects.tq
├── ./objects/lookup-cache-inl.h
├── ./objects/lookup-cache.cc
├── ./objects/lookup-cache.h
├── ./objects/lookup-inl.h
├── ./objects/lookup.cc
├── ./objects/lookup.h
├── ./objects/managed-inl.h
├── ./objects/managed.cc
├── ./objects/managed.h
├── ./objects/map-inl.h
├── ./objects/map-updater.cc
├── ./objects/map-updater.h
├── ./objects/map.cc
├── ./objects/map.h
├── ./objects/map.tq
├── ./objects/maybe-object-inl.h
├── ./objects/maybe-object.h
├── ./objects/megadom-handler-inl.h
├── ./objects/megadom-handler.h
├── ./objects/megadom-handler.tq
├── ./objects/microtask-inl.h
├── ./objects/microtask.h
├── ./objects/microtask.tq
├── ./objects/module-inl.h
├── ./objects/module.cc
├── ./objects/module.h
├── ./objects/module.tq
├── ./objects/name-inl.h
├── ./objects/name.h
├── ./objects/name.tq
├── ./objects/object-list-macros.h
├── ./objects/object-macros-undef.h
├── ./objects/object-macros.h
├── ./objects/object-type.cc
├── ./objects/object-type.h
├── ./objects/objects-body-descriptors-inl.h
├── ./objects/objects-body-descriptors.h
├── ./objects/objects-definitions.h
├── ./objects/objects-inl.h
├── ./objects/objects.cc
├── ./objects/objects.h
├── ./objects/oddball-inl.h
├── ./objects/oddball.h
├── ./objects/oddball.tq
├── ./objects/off-heap-hash-table-inl.h
├── ./objects/off-heap-hash-table.h
├── ./objects/option-utils.cc
├── ./objects/option-utils.h
├── ./objects/ordered-hash-table-inl.h
├── ./objects/ordered-hash-table.cc
├── ./objects/ordered-hash-table.h
├── ./objects/ordered-hash-table.tq
├── ./objects/OWNERS
├── ./objects/primitive-heap-object-inl.h
├── ./objects/primitive-heap-object.h
├── ./objects/primitive-heap-object.tq
├── ./objects/promise-inl.h
├── ./objects/promise.h
├── ./objects/promise.tq
├── ./objects/property-array-inl.h
├── ./objects/property-array.h
├── ./objects/property-array.tq
├── ./objects/property-cell-inl.h
├── ./objects/property-cell.h
├── ./objects/property-cell.tq
├── ./objects/property-descriptor-object-inl.h
├── ./objects/property-descriptor-object.h
├── ./objects/property-descriptor-object.tq
├── ./objects/property-descriptor.cc
├── ./objects/property-descriptor.h
├── ./objects/property-details.h
├── ./objects/property.cc
├── ./objects/property.h
├── ./objects/prototype-info-inl.h
├── ./objects/prototype-info.h
├── ./objects/prototype-info.tq
├── ./objects/prototype-inl.h
├── ./objects/prototype.h
├── ./objects/regexp-match-info-inl.h
├── ./objects/regexp-match-info.cc
├── ./objects/regexp-match-info.h
├── ./objects/regexp-match-info.tq
├── ./objects/scope-info-inl.h
├── ./objects/scope-info.cc
├── ./objects/scope-info.h
├── ./objects/scope-info.tq
├── ./objects/script-inl.h
├── ./objects/script.h
├── ./objects/script.tq
├── ./objects/shared-function-info-inl.h
├── ./objects/shared-function-info.cc
├── ./objects/shared-function-info.h
├── ./objects/shared-function-info.tq
├── ./objects/simd.cc
├── ./objects/simd.h
├── ./objects/slots-atomic-inl.h
├── ./objects/slots-inl.h
├── ./objects/slots.h
├── ./objects/smi-inl.h
├── ./objects/smi.h
├── ./objects/source-text-module-inl.h
├── ./objects/source-text-module.cc
├── ./objects/source-text-module.h
├── ./objects/source-text-module.tq
├── ./objects/string-comparator.cc
├── ./objects/string-comparator.h
├── ./objects/string-forwarding-table-inl.h
├── ./objects/string-forwarding-table.cc
├── ./objects/string-forwarding-table.h
├── ./objects/string-inl.h
├── ./objects/string-set-inl.h
├── ./objects/string-set.h
├── ./objects/string-table-inl.h
├── ./objects/string-table.cc
├── ./objects/string-table.h
├── ./objects/string.cc
├── ./objects/string.h
├── ./objects/string.tq
├── ./objects/struct-inl.h
├── ./objects/struct.h
├── ./objects/struct.tq
├── ./objects/swiss-hash-table-helpers.h
├── ./objects/swiss-hash-table-helpers.tq
├── ./objects/swiss-name-dictionary-inl.h
├── ./objects/swiss-name-dictionary.cc
├── ./objects/swiss-name-dictionary.h
├── ./objects/swiss-name-dictionary.tq
├── ./objects/symbol-table.cc
├── ./objects/synthetic-module-inl.h
├── ./objects/synthetic-module.cc
├── ./objects/synthetic-module.h
├── ./objects/synthetic-module.tq
├── ./objects/tagged-field-inl.h
├── ./objects/tagged-field.h
├── ./objects/tagged-impl-inl.h
├── ./objects/tagged-impl.cc
├── ./objects/tagged-impl.h
├── ./objects/tagged-index.h
├── ./objects/tagged-value-inl.h
├── ./objects/tagged-value.h
├── ./objects/tagged.h
├── ./objects/template-objects-inl.h
├── ./objects/template-objects.cc
├── ./objects/template-objects.h
├── ./objects/template-objects.tq
├── ./objects/templates-inl.h
├── ./objects/templates.cc
├── ./objects/templates.h
├── ./objects/templates.tq
├── ./objects/torque-defined-classes-inl.h
├── ./objects/torque-defined-classes.h
├── ./objects/torque-defined-classes.tq
├── ./objects/transitions-inl.h
├── ./objects/transitions.cc
├── ./objects/transitions.h
├── ./objects/trusted-object-inl.h
├── ./objects/trusted-object.h
├── ./objects/trusted-object.tq
├── ./objects/turbofan-types-inl.h
├── ./objects/turbofan-types.h
├── ./objects/turbofan-types.tq
├── ./objects/turboshaft-types-inl.h
├── ./objects/turboshaft-types.h
├── ./objects/turboshaft-types.tq
├── ./objects/type-hints.cc
├── ./objects/type-hints.h
├── ./objects/union.h
├── ./objects/value-serializer.cc
├── ./objects/value-serializer.h
├── ./objects/visitors-inl.h
├── ./objects/visitors.cc
├── ./objects/visitors.h
├── ./objects/waiter-queue-node.cc
└── ./objects/waiter-queue-node.h

1 directory, 424 files
[Step 5: Duration 8.14 seconds| Input tokens: 10,764 | Output tokens: 1,389]
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ Step 6 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'fuzzy_finder' with arguments: {'pattern': 'transitions', 'options': '--filter transitions'}                                                                                                   │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
Command: cd /Users/tarun/v8/v8/src && rg --hidden --no-follow --no-ignore-vcs --files 2>/dev/null | fzf --filter transitions 'transitions' | head -n 1000
Observations: unknown option: transitions
[Step 6: Duration 12.08 seconds| Input tokens: 12,902 | Output tokens: 1,678]
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ Step 7 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'fuzzy_finder' with arguments: {'pattern': 'transitions.cc', 'options': "--filter='transitions.cc'"}                                                                                           │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
Command: cd /Users/tarun/v8/v8/src && rg --hidden --no-follow --no-ignore-vcs --files 2>/dev/null | fzf --filter='transitions.cc' 'transitions.cc' | head -n 1000
Observations: unknown option: transitions.cc
[Step 7: Duration 9.32 seconds| Input tokens: 15,093 | Output tokens: 1,843]
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ Step 8 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'fuzzy_finder' with arguments: {'pattern': 'transitions.cc', 'options': "--filter='objects/transitions.cc'"}                                                                                   │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'fuzzy_finder' with arguments: {'pattern': 'map-inl.h', 'options': "--filter='objects/map-inl.h'"}                                                                                             │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'fuzzy_finder' with arguments: {'pattern': 'map.cc', 'options': "--filter='objects/map.cc'"}                                                                                                   │
Command: cd /Users/tarun/v8/v8/src && rg --hidden --no-follow --no-ignore-vcs --files 2>/dev/null | fzf --filter='objects/transitions.cc' 'transitions.cc' | head -n 1000
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯

Command: cd /Users/tarun/v8/v8/src && rg --hidden --no-follow --no-ignore-vcs --files 2>/dev/null | fzf --filter='objects/map-inl.h' 'map-inl.h' | head -n 1000
│ Calling tool: 'fuzzy_finder' with arguments: {'pattern': 'transitions-inl.h', 'options': "--filter='objects/transitions-inl.h'"}                                                                             │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'fuzzy_finder' with arguments: {'pattern': 'transitions.h', 'options': "--filter='objects/transitions.h'"}                                                                                     │
Command: cd /Users/tarun/v8/v8/src && rg --hidden --no-follow --no-ignore-vcs --files 2>/dev/null | fzf --filter='objects/map.cc' 'map.cc' | head -n 1000
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯

│ Calling tool: 'fuzzy_finder' with arguments: {'pattern': 'map.h', 'options': "--filter='objects/map.h'"}                                                                                                     │
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
Command: cd /Users/tarun/v8/v8/src && rg --hidden --no-follow --no-ignore-vcs --files 2>/dev/null | fzf --filter='objects/transitions-inl.h' 'transitions-inl.h' | head -n 1000
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯

│ Calling tool: 'fuzzy_finder' with arguments: {'pattern': 'descriptor-array', 'options': "--filter='objects/descriptor-array*'"}                                                                              │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
Command: cd /Users/tarun/v8/v8/src && rg --hidden --no-follow --no-ignore-vcs --files 2>/dev/null | fzf --filter='objects/transitions.h' 'transitions.h' | head -n 1000
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
Observations: unknown option: transitions.cc
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
Command: cd /Users/tarun/v8/v8/src && rg --hidden --no-follow --no-ignore-vcs --files 2>/dev/null | fzf --filter='objects/map.h' 'map.h' | head -n 1000
│ Calling tool: 'fuzzy_finder' with arguments: {'pattern': 'property-details.h', 'options': "--filter='objects/property-details.h'"}                                                                           │

Command: cd /Users/tarun/v8/v8/src && rg --hidden --no-follow --no-ignore-vcs --files 2>/dev/null | fzf --filter='objects/descriptor-array*' 'descriptor-array' | head -n 1000
Observations: unknown option: map-inl.h
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'fuzzy_finder' with arguments: {'pattern': 'js-objects.cc', 'options': "--filter='objects/js-objects.cc'"}                                                                                     │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
Observations: unknown option: map.cc
Command: cd /Users/tarun/v8/v8/src && rg --hidden --no-follow --no-ignore-vcs --files 2>/dev/null | fzf --filter='objects/property-details.h' 'property-details.h' | head -n 1000
Observations: unknown option: transitions-inl.h
Observations: unknown option: transitions.h
Observations: unknown option: map.h
Observations: unknown option: descriptor-array
Observations: unknown option: property-details.h
Command: cd /Users/tarun/v8/v8/src && rg --hidden --no-follow --no-ignore-vcs --files 2>/dev/null | fzf --filter='objects/js-objects.cc' 'js-objects.cc' | head -n 1000
Observations: unknown option: js-objects.cc
[Step 8: Duration 9.29 seconds| Input tokens: 23,517 | Output tokens: 2,325]
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ Step 9 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'fuzzy_finder' with arguments: {'pattern': 'transitions', 'options': '--filter transitions'}                                                                                                   │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'ripgrep' with arguments: {'pattern': 'FindTransitionToField|FindTransitionToAccessor|DeprecateTransition|DeprecateTransitions|NewField|NewDataProperty|shape|+1 map', 'options': '-n --hidden │
│ --no-ignore-vcs ./objects ./ic ./heap ./common ./operators ./runtime ./compiler ./d8 ./execution ./codegen ./init ./diagnostics ./api ./handles ./deoptimizer ./deoptimize-reason ./flags ./parsing ./wasm   │
│ ./torque ./base ./regexp ./root ./deps ./libsampler ./inspector ./utils ./sandbox ./snapshot ./interpreter ./builtins ./zone'}                                                                               │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
Command: cd /Users/tarun/v8/v8/src && rg --hidden --no-follow --no-ignore-vcs --files 2>/dev/null | fzf --filter transitions 'transitions' | head -n 1000
Observations: unknown option: transitions
Command: cd /Users/tarun/v8/v8/src && rg -n --hidden --no-ignore-vcs ./objects ./ic ./heap ./common ./operators ./runtime ./compiler ./d8 ./execution ./codegen ./init ./diagnostics ./api ./handles ./deoptimizer ./deoptimize-reason ./flags ./parsing ./wasm ./torque ./base ./regexp ./root ./deps ./libsampler ./inspector ./utils ./sandbox ./snapshot ./interpreter ./builtins ./zone 'FindTransitionToField|FindTransitionToAccessor|DeprecateTransition|DeprecateTransitions|NewField|NewDataProperty|shape|+1 map' | head -n 1000
Observations: ./runtime/runtime-strings.cc:8:#include "src/objects/js-array-inl.h"
./runtime/runtime-strings.cc:9:#include "src/objects/objects-inl.h"
./runtime/runtime-strings.cc:10:#include "src/objects/slots.h"
./runtime/runtime-strings.cc:11:#include "src/objects/smi.h"
./common/code-memory-access.cc:10:#include "src/objects/instruction-stream-inl.h"
./api/api-natives.cc:14:#include "src/objects/api-callbacks.h"
./api/api-natives.cc:15:#include "src/objects/lookup.h"
./api/api-natives.cc:16:#include "src/objects/templates.h"
./heap/mark-sweep-utilities.h:16:#include "src/objects/string-forwarding-table.h"
./heap/mark-sweep-utilities.h:17:#include "src/objects/visitors.h"
./ic/stub-cache.h:9:#include "src/objects/name.h"
./ic/stub-cache.h:10:#include "src/objects/tagged-value.h"
./codegen/compiler.cc:53:#include "src/objects/feedback-cell-inl.h"
./codegen/compiler.cc:54:#include "src/objects/js-function-inl.h"
./codegen/compiler.cc:55:#include "src/objects/js-function.h"
./codegen/compiler.cc:56:#include "src/objects/map.h"
./codegen/compiler.cc:57:#include "src/objects/object-list-macros.h"
./codegen/compiler.cc:58:#include "src/objects/objects-body-descriptors-inl.h"
./codegen/compiler.cc:59:#include "src/objects/shared-function-info.h"
./codegen/compiler.cc:60:#include "src/objects/string.h"
./api/api-inl.h:15:#include "src/objects/foreign-inl.h"
./api/api-inl.h:16:#include "src/objects/objects-inl.h"
./runtime/runtime-utils.h:8:#include "src/objects/objects.h"
./heap/heap-layout.cc:8:#include "src/objects/objects-inl.h"
./execution/microtask-queue.cc:15:#include "src/objects/microtask-inl.h"
./execution/microtask-queue.cc:16:#include "src/objects/visitors.h"
./handles/persistent-handles.h:14:#include "src/objects/visitors.h"
./runtime/runtime-futex.cc:8:#include "src/objects/js-array-buffer-inl.h"
./ic/binary-op-assembler.cc:9:#include "src/objects/property-cell.h"
./api/api-natives.h:11:#include "src/objects/objects.h"
./api/api-natives.h:12:#include "src/objects/property-details.h"
./init/bootstrapper.cc:26:#include "src/objects/instance-type.h"
./init/bootstrapper.cc:27:#include "src/objects/js-array.h"
./init/bootstrapper.cc:28:#include "src/objects/objects.h"
./init/bootstrapper.cc:37:#include "src/objects/api-callbacks.h"
./init/bootstrapper.cc:38:#include "src/objects/arguments.h"
./init/bootstrapper.cc:39:#include "src/objects/function-kind.h"
./init/bootstrapper.cc:40:#include "src/objects/hash-table-inl.h"
./init/bootstrapper.cc:42:#include "src/objects/intl-objects.h"
./init/bootstrapper.cc:44:#include "src/objects/js-array-buffer-inl.h"
./init/bootstrapper.cc:45:#include "src/objects/js-array-inl.h"
./init/bootstrapper.cc:46:#include "src/objects/js-atomics-synchronization.h"
./init/bootstrapper.cc:47:#include "src/objects/js-disposable-stack.h"
./init/bootstrapper.cc:48:#include "src/objects/js-iterator-helpers.h"
./init/bootstrapper.cc:50:#include "src/objects/js-break-iterator.h"
./init/bootstrapper.cc:51:#include "src/objects/js-collator.h"
./init/bootstrapper.cc:52:#include "src/objects/js-date-time-format.h"
./init/bootstrapper.cc:53:#include "src/objects/js-display-names.h"
./init/bootstrapper.cc:54:#include "src/objects/js-duration-format.h"
./init/bootstrapper.cc:55:#include "src/objects/js-list-format.h"
./init/bootstrapper.cc:56:#include "src/objects/js-locale.h"
./init/bootstrapper.cc:57:#include "src/objects/js-number-format.h"
./init/bootstrapper.cc:58:#include "src/objects/js-plural-rules.h"
./init/bootstrapper.cc:60:#include "src/objects/js-regexp-string-iterator.h"
./init/bootstrapper.cc:61:#include "src/objects/js-regexp.h"
./init/bootstrapper.cc:62:#include "src/objects/js-shadow-realm.h"
./init/bootstrapper.cc:64:#include "src/objects/js-relative-time-format.h"
./init/bootstrapper.cc:65:#include "src/objects/js-segment-iterator.h"
./init/bootstrapper.cc:66:#include "src/objects/js-segmenter.h"
./init/bootstrapper.cc:67:#include "src/objects/js-segments.h"
./init/bootstrapper.cc:70:#include "src/objects/js-raw-json.h"
./init/bootstrapper.cc:71:#include "src/objects/js-shared-array.h"
./init/bootstrapper.cc:72:#include "src/objects/js-struct.h"
./init/bootstrapper.cc:73:#include "src/objects/js-temporal-objects-inl.h"
./init/bootstrapper.cc:74:#include "src/objects/js-weak-refs.h"
./init/bootstrapper.cc:75:#include "src/objects/ordered-hash-table.h"
./init/bootstrapper.cc:76:#include "src/objects/property-cell.h"
./init/bootstrapper.cc:77:#include "src/objects/property-descriptor.h"
./init/bootstrapper.cc:78:#include "src/objects/slots-inl.h"
./init/bootstrapper.cc:79:#include "src/objects/swiss-name-dictionary-inl.h"
./init/bootstrapper.cc:80:#include "src/objects/templates.h"
./handles/handles-inl.h:13:#include "src/objects/casting.h"
./handles/handles-inl.h:14:#include "src/objects/objects.h"
./heap/safepoint.h:15:#include "src/objects/visitors.h"
./ic/call-optimization.h:11:#include "src/objects/objects.h"
./handles/handles.cc:15:#include "src/objects/objects-inl.h"
./runtime/runtime-object.cc:15:#include "src/objects/map-updater.h"
./runtime/runtime-object.cc:16:#include "src/objects/property-descriptor-object.h"
./runtime/runtime-object.cc:17:#include "src/objects/property-descriptor.h"
./runtime/runtime-object.cc:18:#include "src/objects/property-details.h"
./runtime/runtime-object.cc:19:#include "src/objects/swiss-name-dictionary-inl.h"
./compiler/turbofan-graph-visualizer.cc:28:#include "src/objects/script-inl.h"
./compiler/turbofan-graph-visualizer.cc:29:#include "src/objects/shared-function-info.h"
./api/api.h:18:#include "src/objects/bigint.h"
./api/api.h:19:#include "src/objects/contexts.h"
./api/api.h:20:#include "src/objects/js-array-buffer.h"
./api/api.h:21:#include "src/objects/js-collection.h"
./api/api.h:22:#include "src/objects/js-generator.h"
./api/api.h:23:#include "src/objects/js-promise.h"
./api/api.h:24:#include "src/objects/js-proxy.h"
./api/api.h:25:#include "src/objects/objects.h"
./api/api.h:26:#include "src/objects/shared-function-info.h"
./api/api.h:27:#include "src/objects/source-text-module.h"
./api/api.h:28:#include "src/objects/templates.h"
./handles/shared-object-conveyor-handles.cc:7:#include "src/objects/objects-inl.h"
./runtime/runtime-weak-refs.cc:6:#include "src/objects/js-weak-refs-inl.h"
./d8/async-hooks-wrapper.cc:15:#include "src/objects/managed-inl.h"
./heap/heap-write-barrier-inl.h:15:#include "src/objects/compressed-slots-inl.h"
./heap/heap-write-barrier-inl.h:16:#include "src/objects/maybe-object-inl.h"
./handles/traced-handles-inl.h:11:#include "src/objects/slots-inl.h"
./runtime/runtime-literals.cc:9:#include "src/objects/allocation-site-scopes-inl.h"
./runtime/runtime-literals.cc:10:#include "src/objects/hash-table-inl.h"
./runtime/runtime-literals.cc:11:#include "src/objects/heap-number-inl.h"
./runtime/runtime-literals.cc:12:#include "src/objects/js-regexp-inl.h"
./runtime/runtime-literals.cc:13:#include "src/objects/literal-objects-inl.h"
./heap/scavenger.cc:38:#include "src/objects/data-handler-inl.h"
./heap/scavenger.cc:39:#include "src/objects/embedder-data-array-inl.h"
./heap/scavenger.cc:40:#include "src/objects/js-array-buffer-inl.h"
./heap/scavenger.cc:41:#include "src/objects/objects-body-descriptors-inl.h"
./heap/scavenger.cc:42:#include "src/objects/slots.h"
./heap/scavenger.cc:43:#include "src/objects/transitions-inl.h"
./ic/stub-cache.cc:12:#include "src/objects/tagged-value-inl.h"
./handles/maybe-handles-inl.h:11:#include "src/objects/casting.h"
./handles/maybe-handles-inl.h:12:#include "src/objects/maybe-object-inl.h"
./diagnostics/etw-isolate-load-script-data-win.cc:30:#include "src/objects/shared-function-info.h"
./compiler/heap-refs.cc:10:#include "src/objects/elements-kind.h"
./compiler/heap-refs.cc:21:#include "src/objects/allocation-site-inl.h"
./compiler/heap-refs.cc:22:#include "src/objects/descriptor-array.h"
./compiler/heap-refs.cc:23:#include "src/objects/heap-number-inl.h"
./compiler/heap-refs.cc:24:#include "src/objects/js-array-buffer-inl.h"
./compiler/heap-refs.cc:25:#include "src/objects/literal-objects-inl.h"
./compiler/heap-refs.cc:26:#include "src/objects/property-cell.h"
./compiler/heap-refs.cc:27:#include "src/objects/template-objects-inl.h"
./compiler/heap-refs.cc:2161:  // smi/objects elements kinds.
./execution/arm64/simulator-arm64.cc:26:#include "src/objects/objects-inl.h"
./init/bootstrapper.h:12:#include "src/objects/fixed-array.h"
./init/bootstrapper.h:13:#include "src/objects/shared-function-info.h"
./init/bootstrapper.h:14:#include "src/objects/visitors.h"
./ic/ic-stats.cc:9:#include "src/objects/objects-inl.h"
./runtime/runtime-classes.cc:15:#include "src/objects/hash-table-inl.h"
./runtime/runtime-classes.cc:16:#include "src/objects/literal-objects-inl.h"
./runtime/runtime-classes.cc:17:#include "src/objects/lookup-inl.h"
./runtime/runtime-classes.cc:18:#include "src/objects/smi.h"
./heap/factory.h:20:#include "src/objects/feedback-cell.h"
./heap/factory.h:21:#include "src/objects/property-cell.h"
./heap/factory.h:23:#include "src/objects/js-regexp.h"
./ic/handler-configuration.h:11:#include "src/objects/data-handler.h"
./ic/handler-configuration.h:12:#include "src/objects/elements-kind.h"
./ic/handler-configuration.h:13:#include "src/objects/field-index.h"
./ic/handler-configuration.h:14:#include "src/objects/objects.h"
./ic/handler-configuration.h:18:#include "src/objects/object-macros.h"
./ic/handler-configuration.h:397:#include "src/objects/object-macros-undef.h"
./api/api.cc:86:#include "src/objects/api-callbacks.h"
./api/api.cc:87:#include "src/objects/backing-store.h"
./api/api.cc:88:#include "src/objects/contexts.h"
./api/api.cc:89:#include "src/objects/embedder-data-array-inl.h"
./api/api.cc:90:#include "src/objects/embedder-data-slot-inl.h"
./api/api.cc:91:#include "src/objects/hash-table-inl.h"
./api/api.cc:92:#include "src/objects/heap-object.h"
./api/api.cc:93:#include "src/objects/instance-type-inl.h"
./api/api.cc:94:#include "src/objects/instance-type.h"
./api/api.cc:95:#include "src/objects/js-array-buffer-inl.h"
./api/api.cc:96:#include "src/objects/js-array-inl.h"
./api/api.cc:97:#include "src/objects/js-collection-inl.h"
./api/api.cc:98:#include "src/objects/js-objects.h"
./api/api.cc:99:#include "src/objects/js-promise-inl.h"
./api/api.cc💯#include "src/objects/js-regexp-inl.h"
./api/api.cc:101:#include "src/objects/js-weak-refs-inl.h"
./api/api.cc:102:#include "src/objects/module-inl.h"
./api/api.cc:103:#include "src/objects/objects-inl.h"
./api/api.cc:104:#include "src/objects/oddball.h"
./api/api.cc:105:#include "src/objects/ordered-hash-table-inl.h"
./api/api.cc:106:#include "src/objects/primitive-heap-object.h"
./api/api.cc:107:#include "src/objects/property-descriptor.h"
./api/api.cc:108:#include "src/objects/property-details.h"
./api/api.cc:109:#include "src/objects/property.h"
./api/api.cc:110:#include "src/objects/prototype.h"
./api/api.cc:111:#include "src/objects/shared-function-info.h"
./api/api.cc:112:#include "src/objects/slots.h"
./api/api.cc:113:#include "src/objects/smi.h"
./api/api.cc:114:#include "src/objects/string.h"
./api/api.cc:115:#include "src/objects/synthetic-module-inl.h"
./api/api.cc:116:#include "src/objects/templates.h"
./api/api.cc:117:#include "src/objects/value-serializer.h"
./diagnostics/objects-debug.cc:18:#include "src/objects/allocation-site-inl.h"
./diagnostics/objects-debug.cc:19:#include "src/objects/arguments-inl.h"
./diagnostics/objects-debug.cc:20:#include "src/objects/bigint.h"
./diagnostics/objects-debug.cc:21:#include "src/objects/call-site-info-inl.h"
./diagnostics/objects-debug.cc:22:#include "src/objects/cell-inl.h"
./diagnostics/objects-debug.cc:23:#include "src/objects/code-inl.h"
./diagnostics/objects-debug.cc:24:#include "src/objects/data-handler-inl.h"
./diagnostics/objects-debug.cc:25:#include "src/objects/debug-objects-inl.h"
./diagnostics/objects-debug.cc:26:#include "src/objects/elements.h"
./diagnostics/objects-debug.cc:27:#include "src/objects/embedder-data-array-inl.h"
./diagnostics/objects-debug.cc:28:#include "src/objects/embedder-data-slot-inl.h"
./diagnostics/objects-debug.cc:29:#include "src/objects/feedback-cell-inl.h"
./diagnostics/objects-debug.cc:30:#include "src/objects/field-type.h"
./diagnostics/objects-debug.cc:31:#include "src/objects/foreign-inl.h"
./diagnostics/objects-debug.cc:32:#include "src/objects/free-space-inl.h"
./diagnostics/objects-debug.cc:33:#include "src/objects/function-kind.h"
./diagnostics/objects-debug.cc:34:#include "src/objects/hash-table-inl.h"
./diagnostics/objects-debug.cc:35:#include "src/objects/instance-type.h"
./diagnostics/objects-debug.cc:36:#include "src/objects/js-array-buffer-inl.h"
./diagnostics/objects-debug.cc:37:#include "src/objects/js-array-inl.h"
./diagnostics/objects-debug.cc:38:#include "src/objects/js-atomics-synchronization-inl.h"
./diagnostics/objects-debug.cc:39:#include "src/objects/js-disposable-stack.h"
./diagnostics/objects-debug.cc:40:#include "src/objects/objects-inl.h"
./diagnostics/objects-debug.cc:41:#include "src/objects/objects.h"
./diagnostics/objects-debug.cc:42:#include "src/objects/trusted-object.h"
./diagnostics/objects-debug.cc:43:#include "src/objects/turbofan-types-inl.h"
./diagnostics/objects-debug.cc:44:#include "src/objects/turboshaft-types-inl.h"
./diagnostics/objects-debug.cc:47:#include "src/objects/js-break-iterator-inl.h"
./diagnostics/objects-debug.cc:48:#include "src/objects/js-collator-inl.h"
./diagnostics/objects-debug.cc:50:#include "src/objects/js-collection-inl.h"
./diagnostics/objects-debug.cc:52:#include "src/objects/js-date-time-format-inl.h"
./diagnostics/objects-debug.cc:53:#include "src/objects/js-display-names-inl.h"
./diagnostics/objects-debug.cc:54:#include "src/objects/js-duration-format-inl.h"
./diagnostics/objects-debug.cc:56:#include "src/objects/js-disposable-stack-inl.h"
./diagnostics/objects-debug.cc:57:#include "src/objects/js-generator-inl.h"
./diagnostics/objects-debug.cc:58:#include "src/objects/js-iterator-helpers-inl.h"
./diagnostics/objects-debug.cc:60:#include "src/objects/js-list-format-inl.h"
./diagnostics/objects-debug.cc:61:#include "src/objects/js-locale-inl.h"
./diagnostics/objects-debug.cc:62:#include "src/objects/js-number-format-inl.h"
./diagnostics/objects-debug.cc:63:#include "src/objects/js-plural-rules-inl.h"
./diagnostics/objects-debug.cc:65:#include "src/objects/js-regexp-inl.h"
./diagnostics/objects-debug.cc:66:#include "src/objects/js-regexp-string-iterator-inl.h"
./diagnostics/objects-debug.cc:67:#include "src/objects/js-shadow-realm-inl.h"
./diagnostics/objects-debug.cc:69:#include "src/objects/js-relative-time-format-inl.h"
./diagnostics/objects-debug.cc:70:#include "src/objects/js-segment-iterator-inl.h"
./diagnostics/objects-debug.cc:71:#include "src/objects/js-segmenter-inl.h"
./diagnostics/objects-debug.cc:72:#include "src/objects/js-segments-inl.h"
./diagnostics/objects-debug.cc:74:#include "src/objects/hole-inl.h"
./diagnostics/objects-debug.cc:75:#include "src/objects/js-raw-json-inl.h"
./diagnostics/objects-debug.cc:76:#include "src/objects/js-shared-array-inl.h"
./diagnostics/objects-debug.cc:77:#include "src/objects/js-struct-inl.h"
./diagnostics/objects-debug.cc:78:#include "src/objects/js-temporal-objects-inl.h"
./diagnostics/objects-debug.cc:79:#include "src/objects/js-weak-refs-inl.h"
./diagnostics/objects-debug.cc:80:#include "src/objects/literal-objects-inl.h"
./diagnostics/objects-debug.cc:81:#include "src/objects/maybe-object.h"
./diagnostics/objects-debug.cc:82:#include "src/objects/megadom-handler-inl.h"
./diagnostics/objects-debug.cc:83:#include "src/objects/microtask-inl.h"
./diagnostics/objects-debug.cc:84:#include "src/objects/module-inl.h"
./diagnostics/objects-debug.cc:85:#include "src/objects/oddball-inl.h"
./diagnostics/objects-debug.cc:86:#include "src/objects/promise-inl.h"
./diagnostics/objects-debug.cc:87:#include "src/objects/property-descriptor-object-inl.h"
./diagnostics/objects-debug.cc:88:#include "src/objects/struct-inl.h"
./diagnostics/objects-debug.cc:89:#include "src/objects/swiss-name-dictionary-inl.h"
./diagnostics/objects-debug.cc:90:#include "src/objects/synthetic-module-inl.h"
./diagnostics/objects-debug.cc:91:#include "src/objects/template-objects-inl.h"
./diagnostics/objects-debug.cc:92:#include "src/objects/torque-defined-classes-inl.h"
./diagnostics/objects-debug.cc:93:#include "src/objects/transitions-inl.h"
./init/v8.cc:26:#include "src/objects/elements.h"
./init/v8.cc:27:#include "src/objects/objects-inl.h"
./handles/traced-handles.cc:19:#include "src/objects/objects.h"
./handles/traced-handles.cc:20:#include "src/objects/slots.h"
./handles/traced-handles.cc:21:#include "src/objects/visitors.h"
./runtime/runtime-shadow-realm.cc:6:#include "src/objects/js-function.h"
./compiler/js-call-reducer.cc:38:#include "src/objects/elements-kind.h"
./compiler/js-call-reducer.cc:39:#include "src/objects/instance-type.h"
./compiler/js-call-reducer.cc:40:#include "src/objects/js-function.h"
./compiler/js-call-reducer.cc:41:#include "src/objects/objects-inl.h"
./compiler/js-call-reducer.cc:42:#include "src/objects/ordered-hash-table.h"
./compiler/js-call-reducer.cc:46:#include "src/objects/intl-objects.h"
./heap/factory-inl.h:18:#include "src/objects/feedback-cell.h"
./heap/factory-inl.h:19:#include "src/objects/heap-number-inl.h"
./heap/factory-inl.h:20:#include "src/objects/heap-object.h"
./heap/factory-inl.h:21:#include "src/objects/objects-inl.h"
./heap/factory-inl.h:22:#include "src/objects/oddball.h"
./heap/factory-inl.h:23:#include "src/objects/string-inl.h"
./heap/factory-inl.h:24:#include "src/objects/string-table-inl.h"
./api/api-arguments-inl.h:13:#include "src/objects/api-callbacks.h"
./api/api-arguments-inl.h:14:#include "src/objects/instance-type.h"
./api/api-arguments-inl.h:15:#include "src/objects/slots-inl.h"
./d8/d8.cc:63:#include "src/objects/managed-inl.h"
./d8/d8.cc:64:#include "src/objects/objects-inl.h"
./d8/d8.cc:65:#include "src/objects/objects.h"
./handles/global-handles.cc:28:#include "src/objects/objects-inl.h"
./handles/global-handles.cc:29:#include "src/objects/slots.h"
./handles/global-handles.cc:30:#include "src/objects/visitors.h"
./ic/accessor-assembler.cc:19:#include "src/objects/cell.h"
./ic/accessor-assembler.cc:20:#include "src/objects/dictionary.h"
./ic/accessor-assembler.cc:21:#include "src/objects/feedback-vector.h"
./ic/accessor-assembler.cc:22:#include "src/objects/foreign.h"
./ic/accessor-assembler.cc:23:#include "src/objects/heap-number.h"
./ic/accessor-assembler.cc:24:#include "src/objects/megadom-handler.h"
./ic/accessor-assembler.cc:25:#include "src/objects/module.h"
./ic/accessor-assembler.cc:26:#include "src/objects/objects-inl.h"
./ic/accessor-assembler.cc:27:#include "src/objects/property-details.h"
./ic/accessor-assembler.cc:28:#include "src/objects/smi.h"
./heap/live-object-range.h:11:#include "src/objects/heap-object.h"
./runtime/runtime-scopes.cc:17:#include "src/objects/arguments-inl.h"
./runtime/runtime-scopes.cc:18:#include "src/objects/fixed-array.h"
./runtime/runtime-scopes.cc:19:#include "src/objects/heap-object.h"
./runtime/runtime-scopes.cc:20:#include "src/objects/js-disposable-stack-inl.h"
./runtime/runtime-scopes.cc:21:#include "src/objects/js-disposable-stack.h"
./runtime/runtime-scopes.cc:22:#include "src/objects/objects.h"
./runtime/runtime-scopes.cc:23:#include "src/objects/oddball.h"
./runtime/runtime-scopes.cc:24:#include "src/objects/smi.h"
./runtime/runtime-scopes.cc:25:#include "src/objects/tagged.h"
./codegen/arm64/macro-assembler-arm64.h:18:#include "src/objects/tagged-index.h"
./api/api-arguments.h:11:#include "src/objects/slots.h"
./api/api-arguments.h:12:#include "src/objects/visitors.h"
./handles/global-handles-inl.h:10:#include "src/objects/heap-object-inl.h"
./handles/global-handles-inl.h:11:#include "src/objects/tagged.h"
./ic/handler-configuration-inl.h:12:#include "src/objects/data-handler-inl.h"
./ic/handler-configuration-inl.h:13:#include "src/objects/field-index-inl.h"
./ic/handler-configuration-inl.h:14:#include "src/objects/objects-inl.h"
./ic/handler-configuration-inl.h:15:#include "src/objects/smi.h"
./ic/handler-configuration-inl.h:18:#include "src/objects/object-macros.h"
./ic/handler-configuration-inl.h:309:#include "src/objects/object-macros-undef.h"
./diagnostics/objects-printer.cc:23:#include "src/objects/all-objects-inl.h"
./diagnostics/objects-printer.cc:24:#include "src/objects/code-kind.h"
./diagnostics/objects-printer.cc:25:#include "src/objects/instance-type.h"
./diagnostics/objects-printer.cc:26:#include "src/objects/js-function-inl.h"
./diagnostics/objects-printer.cc:27:#include "src/objects/js-objects.h"
./heap/array-buffer-sweeper.cc:18:#include "src/objects/js-array-buffer.h"
./ic/accessor-assembler.h:12:#include "src/objects/dictionary.h"
./runtime/runtime-compiler.cc:17:#include "src/objects/js-array-buffer-inl.h"
./runtime/runtime-compiler.cc:18:#include "src/objects/objects-inl.h"
./runtime/runtime-compiler.cc:19:#include "src/objects/shared-function-info.h"
./handles/global-handles.h:18:#include "src/objects/heap-object.h"
./handles/global-handles.h:19:#include "src/objects/objects.h"
./ic/ic-inl.h:14:#include "src/objects/prototype.h"
./execution/frames.h:14:#include "src/objects/code.h"
./execution/frames.h:15:#include "src/objects/deoptimization-data.h"
./execution/frames.h:16:#include "src/objects/objects.h"
./handles/traced-handles.h:15:#include "src/objects/objects.h"
./handles/traced-handles.h:16:#include "src/objects/visitors.h"
./ic/unary-op-assembler.cc:8:#include "torque-generated/src/objects/oddball-tq-csa.h"
./common/code-memory-access-inl.h:10:#include "src/objects/instruction-stream.h"
./common/code-memory-access-inl.h:11:#include "src/objects/slots-inl.h"
./common/code-memory-access-inl.h:12:#include "src/objects/tagged.h"
./ic/handler-configuration.cc:9:#include "src/objects/data-handler-inl.h"
./ic/handler-configuration.cc:10:#include "src/objects/maybe-object.h"
./ic/handler-configuration.cc:11:#include "src/objects/transitions.h"
./runtime/runtime-wasm.cc:18:#include "src/objects/objects-inl.h"
./diagnostics/perf-jit.cc:46:#include "src/objects/code-kind.h"
./diagnostics/perf-jit.cc:47:#include "src/objects/objects-inl.h"
./diagnostics/perf-jit.cc:48:#include "src/objects/shared-function-info.h"
./compiler/frame-states.cc:15:#include "src/objects/objects-inl.h"
./runtime/runtime-bigint.cc:6:#include "src/objects/bigint.h"
./runtime/runtime-bigint.cc:7:#include "src/objects/objects-inl.h"
./handles/handles.h:15:#include "src/objects/casting.h"
./handles/handles.h:16:#include "src/objects/tagged.h"
./ic/keyed-store-generic.cc:14:#include "src/objects/contexts.h"
./ic/keyed-store-generic.cc:15:#include "src/objects/feedback-vector.h"
./ic/keyed-store-generic.cc:16:#include "src/objects/objects-inl.h"
./utils/ostreams.cc:10:#include "src/objects/string.h"
./runtime/runtime-symbol.cc:8:#include "src/objects/objects-inl.h"
./codegen/optimized-compilation-info.cc:12:#include "src/objects/objects-inl.h"
./codegen/optimized-compilation-info.cc:13:#include "src/objects/shared-function-info.h"
./ic/ic.h:14:#include "src/objects/feedback-vector.h"
./ic/ic.h:15:#include "src/objects/map.h"
./ic/ic.h:16:#include "src/objects/maybe-object.h"
./ic/ic.h:17:#include "src/objects/smi.h"
./runtime/runtime-collections.cc:8:#include "src/objects/hash-table-inl.h"
./runtime/runtime-collections.cc:9:#include "src/objects/js-collection-inl.h"
./parsing/parsing.cc:12:#include "src/objects/objects-inl.h"
./runtime/runtime-typedarray.cc:9:#include "src/objects/elements.h"
./runtime/runtime-typedarray.cc:10:#include "src/objects/js-array-buffer-inl.h"
./runtime/runtime-typedarray.cc:11:#include "src/objects/objects-inl.h"
./parsing/func-name-inferrer.cc:9:#include "src/objects/objects-inl.h"
./codegen/compilation-cache.h:9:#include "src/objects/compilation-cache-table.h"
./runtime/runtime-temporal.cc:6:#include "src/objects/js-temporal-objects.h"
./ic/call-optimization.cc:9:#include "src/objects/objects-inl.h"
./diagnostics/basic-block-profiler.cc:14:#include "src/objects/shared-function-info-inl.h"
./runtime/runtime-proxy.cc:9:#include "src/objects/objects-inl.h"
./codegen/arm64/assembler-arm64-inl.h:16:#include "src/objects/objects-inl.h"
./codegen/arm64/assembler-arm64-inl.h:17:#include "src/objects/smi.h"
./codegen/arm64/assembler-arm64-inl.h:18:#include "src/objects/tagged.h"
./parsing/rewriter.cc:12:#include "src/objects/objects-inl.h"
./ic/ic.cc:33:#include "src/objects/api-callbacks.h"
./ic/ic.cc:34:#include "src/objects/field-type.h"
./ic/ic.cc:35:#include "src/objects/instance-type.h"
./ic/ic.cc:36:#include "src/objects/js-array-buffer-inl.h"
./ic/ic.cc:37:#include "src/objects/js-array-inl.h"
./ic/ic.cc:38:#include "src/objects/megadom-handler.h"
./ic/ic.cc:39:#include "src/objects/property-descriptor.h"
./ic/ic.cc:40:#include "src/objects/prototype.h"
./compiler/map-inference.cc:11:#include "src/objects/map-inl.h"
./runtime/runtime-internal.cc:18:#include "src/objects/template-objects-inl.h"
./codegen/x64/macro-assembler-x64.cc:35:#include "src/objects/instance-type-inl.h"
./codegen/x64/macro-assembler-x64.cc:36:#include "src/objects/objects-inl.h"
./codegen/x64/macro-assembler-x64.cc:37:#include "src/objects/smi.h"
./execution/isolate.h:42:#include "src/objects/code.h"
./execution/isolate.h:43:#include "src/objects/contexts.h"
./execution/isolate.h:44:#include "src/objects/debug-objects.h"
./execution/isolate.h:45:#include "src/objects/js-objects.h"
./execution/isolate.h:46:#include "src/objects/tagged.h"
./parsing/scanner.cc:18:#include "src/objects/bigint.h"
./runtime/runtime-generator.cc:7:#include "src/objects/js-generator-inl.h"
./compiler/allocation-builder-inl.h:11:#include "src/objects/arguments-inl.h"
./diagnostics/basic-block-profiler.h:17:#include "src/objects/shared-function-info.h"
./runtime/runtime-debug.cc:17:#include "src/objects/js-array-buffer-inl.h"
./runtime/runtime-debug.cc:18:#include "src/objects/js-collection-inl.h"
./runtime/runtime-debug.cc:19:#include "src/objects/js-generator-inl.h"
./runtime/runtime-debug.cc:20:#include "src/objects/js-promise-inl.h"
./runtime/runtime-debug.cc:21:#include "src/objects/js-weak-refs-inl.h"
./deoptimizer/translated-state.h:14:#include "src/objects/deoptimization-data.h"
./deoptimizer/translated-state.h:15:#include "src/objects/feedback-vector.h"
./deoptimizer/translated-state.h:16:#include "src/objects/heap-object.h"
./deoptimizer/translated-state.h:17:#include "src/objects/shared-function-info.h"
./sandbox/external-pointer-inl.h:10:#include "src/objects/slots-inl.h"
./diagnostics/disassembler.cc:27:#include "src/objects/objects-inl.h"
./base/ubsan.cc:17:// in src/objects/bigint.cc).
./deoptimizer/deoptimized-frame-info.cc:8:#include "src/objects/js-function-inl.h"
./deoptimizer/deoptimized-frame-info.cc:9:#include "src/objects/oddball.h"
./compiler/turbofan-enabled.cc:11:#include "src/objects/code-kind.h"
./codegen/x64/macro-assembler-x64.h:19:#include "src/objects/contexts.h"
./codegen/x64/macro-assembler-x64.h:20:#include "src/objects/tagged-index.h"
./diagnostics/etw-jit-win.cc:21:#include "src/objects/shared-function-info.h"
./utils/address-map.h:10:#include "src/objects/heap-object.h"
./sandbox/isolate-inl.h:10:#include "src/objects/heap-object.h"
./execution/arm/simulator-arm.cc:29:#include "src/objects/objects-inl.h"
./sandbox/js-dispatch-table-inl.h:10:#include "src/objects/objects-inl.h"
./deoptimizer/frame-translation-builder.cc:11:#include "src/objects/fixed-array-inl.h"
./utils/identity-map.h:12:#include "src/objects/tagged.h"
./runtime/runtime-regexp.cc:15:#include "src/objects/js-array-inl.h"
./runtime/runtime-regexp.cc:16:#include "src/objects/js-regexp-inl.h"
./sandbox/indirect-pointer-tag.h:9:#include "src/objects/instance-type.h"
./codegen/x64/assembler-x64.h:54:#include "src/objects/smi.h"
./execution/isolate-inl.h:9:#include "src/objects/contexts-inl.h"
./execution/isolate-inl.h:10:#include "src/objects/js-function.h"
./execution/isolate-inl.h:11:#include "src/objects/objects-inl.h"
./execution/isolate-inl.h:12:#include "src/objects/oddball.h"
./execution/isolate-inl.h:13:#include "src/objects/property-cell.h"
./execution/isolate-inl.h:14:#include "src/objects/regexp-match-info.h"
./execution/isolate-inl.h:15:#include "src/objects/shared-function-info.h"
./execution/isolate-inl.h:16:#include "src/objects/source-text-module-inl.h"
./runtime/runtime-test.cc:32:#include "src/objects/bytecode-array.h"
./runtime/runtime-test.cc:33:#include "src/objects/js-collection-inl.h"
./runtime/runtime-test.cc:39:#include "src/objects/js-array-buffer-inl.h"
./runtime/runtime-test.cc:40:#include "src/objects/js-atomics-synchronization-inl.h"
./runtime/runtime-test.cc:41:#include "src/objects/js-function-inl.h"
./runtime/runtime-test.cc:42:#include "src/objects/js-regexp-inl.h"
./runtime/runtime-test.cc:43:#include "src/objects/smi.h"
./runtime/runtime-forin.cc:8:#include "src/objects/keys.h"
./runtime/runtime-forin.cc:9:#include "src/objects/module.h"
./runtime/runtime-forin.cc:10:#include "src/objects/objects-inl.h"
./parsing/parse-info.cc:17:#include "src/objects/objects-inl.h"
./parsing/parse-info.cc:18:#include "src/objects/scope-info.h"
./deoptimizer/deoptimizer.cc:26:#include "src/objects/deoptimization-data.h"
./deoptimizer/deoptimizer.cc:27:#include "src/objects/js-function-inl.h"
./deoptimizer/deoptimizer.cc:28:#include "src/objects/oddball.h"
./execution/tiering-manager.cc:23:#include "src/objects/code-kind.h"
./execution/tiering-manager.cc:24:#include "src/objects/code.h"
./parsing/parse-info.h:16:#include "src/objects/function-kind.h"
./parsing/parse-info.h:17:#include "src/objects/function-syntax-kind.h"
./parsing/parse-info.h:18:#include "src/objects/script.h"
./codegen/x64/assembler-x64-inl.h:14:#include "src/objects/objects-inl.h"
./runtime/runtime-atomics.cc:11:#include "src/objects/js-array-buffer-inl.h"
./runtime/runtime-atomics.cc:12:#include "src/objects/js-shared-array-inl.h"
./runtime/runtime-atomics.cc:13:#include "src/objects/js-struct-inl.h"
./execution/v8threads.cc:14:#include "src/objects/visitors.h"
./codegen/reloc-info.h:11:#include "src/objects/code.h"
./codegen/reloc-info.h:12:#include "src/objects/instruction-stream.h"
./runtime/runtime-intl.cc:13:#include "src/objects/intl-objects.h"
./runtime/runtime-intl.cc:14:#include "src/objects/js-collator-inl.h"
./runtime/runtime-intl.cc:15:#include "src/objects/js-date-time-format-inl.h"
./runtime/runtime-intl.cc:16:#include "src/objects/js-list-format-inl.h"
./runtime/runtime-intl.cc:17:#include "src/objects/js-list-format.h"
./runtime/runtime-intl.cc:18:#include "src/objects/js-number-format-inl.h"
./runtime/runtime-intl.cc:19:#include "src/objects/js-plural-rules-inl.h"
./compiler/js-intrinsic-lowering.cc:16:#include "src/objects/js-generator.h"
./compiler/js-intrinsic-lowering.cc:17:#include "src/objects/objects-inl.h"
./codegen/reloc-info.cc:15:#include "src/objects/code-inl.h"
./execution/stack-guard.cc:14:#include "src/objects/backing-store.h"
./runtime/runtime-test-wasm.cc:15:#include "src/objects/property-descriptor.h"
./runtime/runtime-test-wasm.cc:16:#include "src/objects/smi.h"
./deoptimizer/translated-state.cc:22:#include "src/objects/arguments.h"
./deoptimizer/translated-state.cc:23:#include "src/objects/deoptimization-data.h"
./deoptimizer/translated-state.cc:24:#include "src/objects/heap-number-inl.h"
./deoptimizer/translated-state.cc:25:#include "src/objects/heap-object.h"
./deoptimizer/translated-state.cc:26:#include "src/objects/oddball.h"
./deoptimizer/translated-state.cc:29:#include "src/objects/object-macros.h"
./deoptimizer/translated-state.cc:30:#include "src/objects/string.h"
./deoptimizer/translated-state.cc:2877:#include "src/objects/object-macros-undef.h"
./execution/frames-inl.h:15:#include "src/objects/objects-inl.h"
./parsing/parser-base.h:25:#include "src/objects/function-kind.h"
./runtime/runtime-array.cc:10:#include "src/objects/allocation-site-inl.h"
./runtime/runtime-array.cc:11:#include "src/objects/elements.h"
./runtime/runtime-array.cc:12:#include "src/objects/js-array-inl.h"
./compiler/compilation-dependencies.cc:14:#include "src/objects/allocation-site-inl.h"
./compiler/compilation-dependencies.cc:15:#include "src/objects/internal-index.h"
./compiler/compilation-dependencies.cc:16:#include "src/objects/js-array-inl.h"
./compiler/compilation-dependencies.cc:17:#include "src/objects/js-function-inl.h"
./compiler/compilation-dependencies.cc:18:#include "src/objects/objects-inl.h"
./compiler/compilation-dependencies.cc:19:#include "src/objects/property-cell.h"
./codegen/riscv/macro-assembler-riscv.h:21:#include "src/objects/tagged-index.h"
./runtime/runtime-module.cc:6:#include "src/objects/js-promise.h"
./runtime/runtime-module.cc:7:#include "src/objects/source-text-module.h"
./parsing/scanner-character-streams.cc:17:#include "src/objects/objects-inl.h"
./diagnostics/gdb-jit.cc:27:#include "src/objects/code-inl.h"
./diagnostics/gdb-jit.cc:28:#include "src/objects/objects.h"
./runtime/runtime-promise.cc:9:#include "src/objects/js-promise-inl.h"
./compiler/js-heap-broker.cc:17:#include "src/objects/allocation-site-inl.h"
./compiler/js-heap-broker.cc:18:#include "src/objects/js-array-inl.h"
./compiler/js-heap-broker.cc:19:#include "src/objects/literal-objects-inl.h"
./compiler/js-heap-broker.cc:20:#include "src/objects/map-updater.h"
./compiler/js-heap-broker.cc:21:#include "src/objects/megadom-handler-inl.h"
./compiler/js-heap-broker.cc:22:#include "src/objects/objects-inl.h"
./compiler/js-heap-broker.cc:23:#include "src/objects/property-cell.h"
./codegen/code-stub-assembler.cc:26:#include "src/objects/api-callbacks.h"
./codegen/code-stub-assembler.cc:27:#include "src/objects/cell.h"
./codegen/code-stub-assembler.cc:28:#include "src/objects/descriptor-array.h"
./codegen/code-stub-assembler.cc:29:#include "src/objects/function-kind.h"
./codegen/code-stub-assembler.cc:30:#include "src/objects/heap-number.h"
./codegen/code-stub-assembler.cc:31:#include "src/objects/instance-type-checker.h"
./codegen/code-stub-assembler.cc:32:#include "src/objects/instance-type-inl.h"
./codegen/code-stub-assembler.cc:33:#include "src/objects/instance-type.h"
./codegen/code-stub-assembler.cc:34:#include "src/objects/js-generator.h"
./codegen/code-stub-assembler.cc:35:#include "src/objects/oddball.h"
./codegen/code-stub-assembler.cc:36:#include "src/objects/ordered-hash-table-inl.h"
./codegen/code-stub-assembler.cc:37:#include "src/objects/property-cell.h"
./codegen/code-stub-assembler.cc:38:#include "src/objects/property-descriptor-object.h"
./codegen/code-stub-assembler.cc:39:#include "src/objects/tagged-field.h"
./compiler/bytecode-graph-builder.h:10:#include "src/objects/code-kind.h"
./codegen/source-position.cc:9:#include "src/objects/objects-inl.h"
./sandbox/cppheap-pointer-inl.h:10:#include "src/objects/slots-inl.h"
./parsing/parser.cc:28:#include "src/objects/scope-info.h"
./wasm/wasm-engine.cc:22:#include "src/objects/heap-number.h"
./wasm/wasm-engine.cc:23:#include "src/objects/managed-inl.h"
./wasm/wasm-engine.cc:24:#include "src/objects/objects-inl.h"
./wasm/wasm-engine.cc:25:#include "src/objects/objects.h"
./wasm/wasm-engine.cc:26:#include "src/objects/primitive-heap-object.h"
./codegen/riscv/assembler-riscv.h:63:#include "src/objects/contexts.h"
./codegen/riscv/assembler-riscv.h:64:#include "src/objects/smi.h"
./codegen/riscv/base-assembler-riscv.h:50:#include "src/objects/contexts.h"
./codegen/riscv/base-assembler-riscv.h:51:#include "src/objects/smi.h"
./parsing/pending-compilation-error-handler.cc:15:#include "src/objects/objects-inl.h"
./deoptimizer/materialized-object-store.cc:9:#include "src/objects/fixed-array-inl.h"
./deoptimizer/materialized-object-store.cc:10:#include "src/objects/oddball.h"
./codegen/tnode.h:12:#include "src/objects/tagged.h"
./deoptimizer/frame-translation-builder.h:12:#include "src/objects/deoptimization-data.h"
./codegen/turboshaft-builtins-assembler-inl.h:18:#include "src/objects/elements-kind.h"
./execution/protectors.cc:10:#include "src/objects/contexts.h"
./execution/protectors.cc:11:#include "src/objects/property-cell.h"
./execution/protectors.cc:12:#include "src/objects/smi.h"
./compiler/escape-analysis.h:13:#include "src/objects/name.h"
./execution/simulator.h:9:#include "src/objects/code.h"
./deoptimizer/deoptimizer.h:17:#include "src/objects/js-function.h"
./codegen/pending-optimization-table.cc:10:#include "src/objects/hash-table.h"
./codegen/pending-optimization-table.cc:11:#include "src/objects/js-objects.h"
./compiler/access-builder.cc:9:#include "src/objects/arguments.h"
./compiler/access-builder.cc:10:#include "src/objects/contexts.h"
./compiler/access-builder.cc:11:#include "src/objects/heap-number.h"
./compiler/access-builder.cc:12:#include "src/objects/js-collection.h"
./compiler/access-builder.cc:13:#include "src/objects/js-generator.h"
./compiler/access-builder.cc:14:#include "src/objects/js-objects.h"
./compiler/access-builder.cc:15:#include "src/objects/objects-inl.h"
./compiler/access-builder.cc:16:#include "src/objects/ordered-hash-table.h"
./compiler/access-builder.cc:17:#include "src/objects/source-text-module.h"
./compiler/access-builder.cc:18:#include "src/objects/tagged-field.h"
./parsing/preparse-data.cc:13:#include "src/objects/objects-inl.h"
./parsing/preparse-data.cc:14:#include "src/objects/shared-function-info.h"
./codegen/assembler.h:59:#include "src/objects/objects.h"
./codegen/loong64/assembler-loong64.h:19:#include "src/objects/contexts.h"
./codegen/loong64/assembler-loong64.h:20:#include "src/objects/smi.h"
./snapshot/read-only-serializer.cc:11:#include "src/objects/objects-inl.h"
./snapshot/read-only-serializer.cc:12:#include "src/objects/slots.h"
./parsing/expression-scope.h:12:#include "src/objects/function-kind.h"
./compiler/turbofan-types.h:13:#include "src/objects/objects.h"
./sandbox/testing.cc:12:#include "src/objects/backing-store.h"
./sandbox/testing.cc:13:#include "src/objects/js-objects.h"
./sandbox/testing.cc:14:#include "src/objects/templates.h"
./codegen/loong64/assembler-loong64.cc:15:#include "src/objects/heap-number-inl.h"
./sandbox/js-dispatch-table.cc:10:#include "src/objects/code-inl.h"
./snapshot/serializer-deserializer.cc:7:#include "src/objects/embedder-data-array-inl.h"
./snapshot/serializer-deserializer.cc:8:#include "src/objects/objects-inl.h"
./sandbox/testing.h:11:#include "src/objects/instance-type.h"
./compiler/property-access-builder.cc:15:#include "src/objects/heap-number.h"
./compiler/property-access-builder.cc:16:#include "src/objects/internal-index.h"
./compiler/property-access-builder.cc:17:#include "src/objects/js-function.h"
./compiler/property-access-builder.cc:18:#include "src/objects/map-inl.h"
./compiler/property-access-builder.cc:19:#include "src/objects/property-details.h"
./codegen/compiler.h:22:#include "src/objects/contexts.h"
./codegen/compiler.h:23:#include "src/objects/debug-objects.h"
./snapshot/static-roots-gen.cc:12:#include "src/objects/instance-type-inl.h"
./snapshot/static-roots-gen.cc:13:#include "src/objects/instance-type.h"
./snapshot/static-roots-gen.cc:14:#include "src/objects/objects-definitions.h"
./snapshot/static-roots-gen.cc:15:#include "src/objects/visitors.h"
./codegen/loong64/macro-assembler-loong64.h:19:#include "src/objects/tagged-index.h"
./execution/s390/simulator-s390.cc:26:#include "src/objects/objects-inl.h"
./codegen/handler-table.cc:12:#include "src/objects/code-inl.h"
./codegen/handler-table.cc:13:#include "src/objects/objects-inl.h"
./builtins/builtins-collections.cc:8:#include "src/objects/js-collection-inl.h"
./builtins/builtins-collections.cc:9:#include "src/objects/objects-inl.h"
./codegen/unoptimized-compilation-info.h:13:#include "src/objects/feedback-vector.h"
./codegen/unoptimized-compilation-info.h:14:#include "src/objects/objects.h"
./wasm/wasm-result.cc:10:#include "src/objects/objects.h"
./compiler/js-type-hint-lowering.cc:12:#include "src/objects/type-hints.h"
./codegen/loong64/assembler-loong64-inl.h:14:#include "src/objects/objects-inl.h"
./execution/arguments-inl.h:11:#include "src/objects/objects-inl.h"  // TODO(jkummerow): Just smi-inl.h.
./execution/arguments-inl.h:12:#include "src/objects/tagged-index.h"
./builtins/builtins-async-disposable-stack.cc:12:#include "src/objects/heap-object.h"
./builtins/builtins-async-disposable-stack.cc:13:#include "src/objects/js-disposable-stack-inl.h"
./builtins/builtins-async-disposable-stack.cc:14:#include "src/objects/js-disposable-stack.h"
./builtins/builtins-async-disposable-stack.cc:15:#include "src/objects/js-objects.h"
./builtins/builtins-async-disposable-stack.cc:16:#include "src/objects/js-promise-inl.h"
./builtins/builtins-async-disposable-stack.cc:17:#include "src/objects/js-promise.h"
./builtins/builtins-async-disposable-stack.cc:18:#include "src/objects/objects.h"
./codegen/loong64/macro-assembler-loong64.cc:27:#include "src/objects/heap-number.h"
./execution/messages.cc:19:#include "src/objects/call-site-info-inl.h"
./execution/messages.cc:20:#include "src/objects/foreign-inl.h"
./execution/messages.cc:21:#include "src/objects/js-array-inl.h"
./execution/messages.cc:22:#include "src/objects/property-descriptor.h"
./execution/messages.cc:23:#include "src/objects/struct-inl.h"
./compiler/js-create-lowering.cc:22:#include "src/objects/arguments.h"
./compiler/js-create-lowering.cc:23:#include "src/objects/contexts.h"
./compiler/js-create-lowering.cc:24:#include "src/objects/hash-table-inl.h"
./compiler/js-create-lowering.cc:25:#include "src/objects/heap-number.h"
./compiler/js-create-lowering.cc:26:#include "src/objects/js-collection-iterator.h"
./compiler/js-create-lowering.cc:27:#include "src/objects/js-generator.h"
./compiler/js-create-lowering.cc:28:#include "src/objects/js-promise.h"
./compiler/js-create-lowering.cc:29:#include "src/objects/js-regexp-inl.h"
./compiler/js-create-lowering.cc:30:#include "src/objects/objects-inl.h"
./snapshot/embedded/embedded-file-writer.cc:12:#include "src/objects/code-inl.h"
./wasm/turboshaft-graph-interface.cc:20:#include "src/objects/object-list-macros.h"
./wasm/turboshaft-graph-interface.cc:21:#include "src/objects/torque-defined-classes.h"
./codegen/riscv/macro-assembler-riscv.cc:25:#include "src/objects/heap-number.h"
./codegen/source-position-table.cc:11:#include "src/objects/objects-inl.h"
./codegen/source-position-table.cc:12:#include "src/objects/objects.h"
./execution/isolate.cc:85:#include "src/objects/backing-store.h"
./execution/isolate.cc:86:#include "src/objects/call-site-info-inl.h"
./execution/isolate.cc:87:#include "src/objects/call-site-info.h"
./execution/isolate.cc:88:#include "src/objects/elements.h"
./execution/isolate.cc:89:#include "src/objects/feedback-vector.h"
./execution/isolate.cc:90:#include "src/objects/hash-table-inl.h"
./execution/isolate.cc:91:#include "src/objects/instance-type-inl.h"
./execution/isolate.cc:92:#include "src/objects/js-array-buffer-inl.h"
./execution/isolate.cc:93:#include "src/objects/js-array-inl.h"
./execution/isolate.cc:94:#include "src/objects/js-atomics-synchronization-inl.h"
./execution/isolate.cc:95:#include "src/objects/js-function.h"
./execution/isolate.cc:96:#include "src/objects/js-generator-inl.h"
./execution/isolate.cc:97:#include "src/objects/js-struct-inl.h"
./execution/isolate.cc:98:#include "src/objects/js-weak-refs-inl.h"
./execution/isolate.cc:99:#include "src/objects/managed-inl.h"
./execution/isolate.cc💯#include "src/objects/module-inl.h"
./execution/isolate.cc:101:#include "src/objects/promise-inl.h"
./execution/isolate.cc:102:#include "src/objects/property-descriptor.h"
./execution/isolate.cc:103:#include "src/objects/prototype.h"
./execution/isolate.cc:104:#include "src/objects/slots.h"
./execution/isolate.cc:105:#include "src/objects/smi.h"
./execution/isolate.cc:106:#include "src/objects/source-text-module-inl.h"
./execution/isolate.cc:107:#include "src/objects/string-set-inl.h"
./execution/isolate.cc:108:#include "src/objects/visitors.h"
./execution/isolate.cc:109:#include "src/objects/waiter-queue-node.h"
./execution/isolate.cc:137:#include "src/objects/intl-objects.h"
./builtins/promise-all-element-closure.tq:7:#include 'src/objects/property-array.h'
./codegen/optimized-compilation-info.h:19:#include "src/objects/objects.h"
./codegen/optimized-compilation-info.h:20:#include "src/objects/tagged.h"
./codegen/arm/assembler-arm-inl.h:44:#include "src/objects/objects-inl.h"
./codegen/arm/assembler-arm-inl.h:45:#include "src/objects/smi.h"
./compiler/type-cache.h:11:#include "src/objects/js-array-buffer.h"
./compiler/type-cache.h:12:#include "src/objects/string.h"
./snapshot/embedded/platform-embedded-file-writer-mac.cc:7:#include "src/objects/instruction-stream.h"
./execution/ppc/simulator-ppc.cc:27:#include "src/objects/objects-inl.h"
./snapshot/embedded/embedded-data.h:13:#include "src/objects/instruction-stream.h"
./snapshot/embedded/platform-embedded-file-writer-aix.cc:7:#include "src/objects/instruction-stream.h"
./wasm/c-api.cc:34:#include "src/objects/call-site-info-inl.h"
./wasm/c-api.cc:35:#include "src/objects/js-collection-inl.h"
./wasm/c-api.cc:36:#include "src/objects/managed-inl.h"
./codegen/riscv/assembler-riscv.cc:45:#include "src/objects/heap-number-inl.h"
./builtins/builtins-promise.h:8:#include "src/objects/contexts.h"
./execution/thread-local-top.h:14:#include "src/objects/contexts.h"
./snapshot/embedded/platform-embedded-file-writer-generic.cc:10:#include "src/objects/instruction-stream.h"
./codegen/mips64/assembler-mips64.cc:45:#include "src/objects/heap-number-inl.h"
./codegen/arm/macro-assembler-arm.cc:28:#include "src/objects/objects-inl.h"
./codegen/riscv/assembler-riscv-inl.h:45:#include "src/objects/objects-inl.h"
./builtins/accessors.cc:17:#include "src/objects/api-callbacks.h"
./builtins/accessors.cc:18:#include "src/objects/contexts.h"
./builtins/accessors.cc:19:#include "src/objects/field-index-inl.h"
./builtins/accessors.cc:20:#include "src/objects/js-array-inl.h"
./builtins/accessors.cc:21:#include "src/objects/js-shared-array-inl.h"
./builtins/accessors.cc:22:#include "src/objects/module-inl.h"
./builtins/accessors.cc:23:#include "src/objects/property-details.h"
./builtins/accessors.cc:24:#include "src/objects/prototype.h"
./codegen/maglev-safepoint-table.cc:10:#include "src/objects/code-inl.h"
./compiler/pipeline.h:14:#include "src/objects/code.h"
./codegen/mips64/macro-assembler-mips64.h:18:#include "src/objects/tagged-index.h"
./codegen/arm/macro-assembler-arm.h:19:#include "src/objects/tagged-index.h"
./execution/frames.cc:29:#include "src/objects/casting-inl.h"
./execution/frames.cc:30:#include "src/objects/code.h"
./execution/frames.cc:31:#include "src/objects/instance-type-checker.h"
./execution/frames.cc:32:#include "src/objects/slots.h"
./execution/frames.cc:33:#include "src/objects/smi.h"
./execution/frames.cc:34:#include "src/objects/visitors.h"
./wasm/function-compiler.cc:16:#include "src/objects/code-inl.h"
./codegen/arm/assembler-arm.cc:51:#include "src/objects/objects-inl.h"
./codegen/mips64/assembler-mips64.h:49:#include "src/objects/contexts.h"
./codegen/mips64/assembler-mips64.h:50:#include "src/objects/smi.h"
./execution/arguments.h:11:#include "src/objects/objects.h"
./execution/arguments.h:12:#include "src/objects/slots.h"
./codegen/mips64/assembler-mips64-inl.h:43:#include "src/objects/objects-inl.h"
./wasm/wasm-objects.h:19:#include "src/objects/backing-store.h"
./wasm/wasm-objects.h:20:#include "src/objects/casting.h"
./wasm/wasm-objects.h:21:#include "src/objects/foreign.h"
./wasm/wasm-objects.h:22:#include "src/objects/js-function.h"
./wasm/wasm-objects.h:23:#include "src/objects/js-objects.h"
./wasm/wasm-objects.h:24:#include "src/objects/objects-body-descriptors.h"
./wasm/wasm-objects.h:25:#include "src/objects/objects.h"
./wasm/wasm-objects.h:26:#include "src/objects/struct.h"
./wasm/wasm-objects.h:27:#include "src/objects/trusted-object.h"
./wasm/wasm-objects.h:36:#include "src/objects/object-macros.h"
./wasm/wasm-objects.h:1554:#include "src/objects/object-macros-undef.h"
./snapshot/deserializer.cc:23:#include "src/objects/backing-store.h"
./snapshot/deserializer.cc:24:#include "src/objects/js-array-buffer-inl.h"
./snapshot/deserializer.cc:25:#include "src/objects/maybe-object.h"
./snapshot/deserializer.cc:26:#include "src/objects/objects-body-descriptors-inl.h"
./snapshot/deserializer.cc:27:#include "src/objects/objects.h"
./snapshot/deserializer.cc:28:#include "src/objects/slots.h"
./snapshot/deserializer.cc:29:#include "src/objects/string.h"
./snapshot/deserializer.cc:40:#include "src/objects/object-macros.h"
./snapshot/deserializer.cc:1662:#include "src/objects/object-macros-undef.h"
./snapshot/read-only-deserializer.cc:11:#include "src/objects/objects-inl.h"
./snapshot/read-only-deserializer.cc:12:#include "src/objects/slots.h"
./execution/protectors-inl.h:9:#include "src/objects/property-cell-inl.h"
./execution/protectors-inl.h:10:#include "src/objects/smi.h"
./builtins/builtins-proxy-gen.cc:13:#include "src/objects/js-proxy.h"
./builtins/builtins-proxy-gen.cc:14:#include "src/objects/objects-inl.h"
./codegen/s390/assembler-s390.h:59:#include "src/objects/smi.h"
./builtins/builtins-intl-gen.cc:12:#include "src/objects/js-list-format-inl.h"
./builtins/builtins-intl-gen.cc:13:#include "src/objects/js-list-format.h"
./builtins/builtins-intl-gen.cc:14:#include "src/objects/objects-inl.h"
./builtins/builtins-intl-gen.cc:15:#include "src/objects/objects.h"
./builtins/builtins-atomics-synchronization.cc:6:#include "src/objects/js-atomics-synchronization-inl.h"
./builtins/builtins-atomics-synchronization.cc:7:#include "src/objects/promise-inl.h"
./codegen/s390/macro-assembler-s390.h:18:#include "src/objects/contexts.h"
./codegen/code-stub-assembler.h:19:#include "src/objects/api-callbacks.h"
./codegen/code-stub-assembler.h:20:#include "src/objects/arguments.h"
./codegen/code-stub-assembler.h:21:#include "src/objects/bigint.h"
./codegen/code-stub-assembler.h:22:#include "src/objects/cell.h"
./codegen/code-stub-assembler.h:23:#include "src/objects/dictionary.h"
./codegen/code-stub-assembler.h:24:#include "src/objects/feedback-vector.h"
./codegen/code-stub-assembler.h:25:#include "src/objects/foreign.h"
./codegen/code-stub-assembler.h:26:#include "src/objects/heap-number.h"
./codegen/code-stub-assembler.h:27:#include "src/objects/hole.h"
./codegen/code-stub-assembler.h:28:#include "src/objects/js-function.h"
./codegen/code-stub-assembler.h:29:#include "src/objects/js-objects.h"
./codegen/code-stub-assembler.h:30:#include "src/objects/js-promise.h"
./codegen/code-stub-assembler.h:31:#include "src/objects/js-proxy.h"
./codegen/code-stub-assembler.h:32:#include "src/objects/objects.h"
./codegen/code-stub-assembler.h:33:#include "src/objects/oddball.h"
./codegen/code-stub-assembler.h:34:#include "src/objects/shared-function-info.h"
./codegen/code-stub-assembler.h:35:#include "src/objects/smi.h"
./codegen/code-stub-assembler.h:36:#include "src/objects/string.h"
./codegen/code-stub-assembler.h:37:#include "src/objects/swiss-name-dictionary.h"
./codegen/code-stub-assembler.h:38:#include "src/objects/tagged-index.h"
./codegen/code-stub-assembler.h:39:#include "src/objects/tagged.h"
./codegen/code-stub-assembler.h:40:#include "src/objects/templates.h"
./codegen/s390/assembler-s390-inl.h:44:#include "src/objects/objects-inl.h"
./codegen/mips64/macro-assembler-mips64.cc:25:#include "src/objects/heap-number.h"
./codegen/code-factory.cc:11:#include "src/objects/allocation-site-inl.h"
./codegen/code-factory.cc:12:#include "src/objects/objects-inl.h"
./codegen/ppc/assembler-ppc-inl.h:45:#include "src/objects/objects-inl.h"
./codegen/compilation-cache.cc:11:#include "src/objects/compilation-cache-table-inl.h"
./codegen/compilation-cache.cc:12:#include "src/objects/objects-inl.h"
./codegen/compilation-cache.cc:13:#include "src/objects/objects.h"
./codegen/compilation-cache.cc:14:#include "src/objects/slots.h"
./codegen/compilation-cache.cc:15:#include "src/objects/visitors.h"
./snapshot/shared-heap-serializer.cc:8:#include "src/objects/objects-inl.h"
./codegen/code-reference.h:10:#include "src/objects/code.h"
./wasm/object-access.h:13:#include "src/objects/fixed-array.h"
./wasm/object-access.h:14:#include "src/objects/js-function.h"
./wasm/object-access.h:15:#include "src/objects/shared-function-info.h"
./codegen/unoptimized-compilation-info.cc:12:#include "src/objects/objects-inl.h"
./heap/pretenuring-handler.cc:13:#include "src/objects/allocation-site-inl.h"
./execution/futex-emulation.cc:18:#include "src/objects/js-array-buffer-inl.h"
./execution/futex-emulation.cc:19:#include "src/objects/js-promise-inl.h"
./execution/futex-emulation.cc:20:#include "src/objects/objects-inl.h"
./builtins/arm64/builtins-arm64.cc:21:#include "src/objects/cell.h"
./builtins/arm64/builtins-arm64.cc:22:#include "src/objects/foreign.h"
./builtins/arm64/builtins-arm64.cc:23:#include "src/objects/heap-number.h"
./builtins/arm64/builtins-arm64.cc:24:#include "src/objects/instance-type.h"
./builtins/arm64/builtins-arm64.cc:25:#include "src/objects/js-generator.h"
./builtins/arm64/builtins-arm64.cc:26:#include "src/objects/objects-inl.h"
./builtins/arm64/builtins-arm64.cc:27:#include "src/objects/smi.h"
./codegen/code-reference.cc:10:#include "src/objects/objects-inl.h"
./wasm/wasm-code-manager.cc:31:#include "src/objects/objects-inl.h"
./builtins/builtins-data-view-gen.h:9:#include "src/objects/bigint.h"
./builtins/builtins-data-view-gen.h:10:#include "src/objects/elements-kind.h"
./codegen/ppc/macro-assembler-ppc.h:19:#include "src/objects/contexts.h"
./heap/mark-compact.cc:79:#include "src/objects/embedder-data-array-inl.h"
./heap/mark-compact.cc:80:#include "src/objects/foreign.h"
./heap/mark-compact.cc:81:#include "src/objects/hash-table-inl.h"
./heap/mark-compact.cc:82:#include "src/objects/heap-object-inl.h"
./heap/mark-compact.cc:83:#include "src/objects/heap-object.h"
./heap/mark-compact.cc:84:#include "src/objects/instance-type.h"
./heap/mark-compact.cc:85:#include "src/objects/js-array-buffer-inl.h"
./heap/mark-compact.cc:86:#include "src/objects/js-objects-inl.h"
./heap/mark-compact.cc:87:#include "src/objects/maybe-object.h"
./heap/mark-compact.cc:88:#include "src/objects/objects.h"
./heap/mark-compact.cc:89:#include "src/objects/slots-inl.h"
./heap/mark-compact.cc:90:#include "src/objects/smi.h"
./heap/mark-compact.cc:91:#include "src/objects/string-forwarding-table-inl.h"
./heap/mark-compact.cc:92:#include "src/objects/transitions-inl.h"
./heap/mark-compact.cc:93:#include "src/objects/visitors.h"
./snapshot/serializer.h:13:#include "src/objects/abstract-code.h"
./snapshot/serializer.h:14:#include "src/objects/bytecode-array.h"
./snapshot/serializer.h:15:#include "src/objects/instruction-stream.h"
./snapshot/serializer.h:16:#include "src/objects/objects.h"
./codegen/s390/macro-assembler-s390.cc:26:#include "src/objects/smi.h"
./compiler/js-native-context-specialization.cc:37:#include "src/objects/elements-kind.h"
./compiler/js-native-context-specialization.cc:38:#include "src/objects/feedback-vector.h"
./compiler/js-native-context-specialization.cc:39:#include "src/objects/heap-number.h"
./compiler/js-native-context-specialization.cc:40:#include "src/objects/string.h"
./codegen/ia32/macro-assembler-ia32.cc:43:#include "src/objects/code.h"
./codegen/ia32/macro-assembler-ia32.cc:44:#include "src/objects/contexts.h"
./codegen/ia32/macro-assembler-ia32.cc:45:#include "src/objects/fixed-array.h"
./codegen/ia32/macro-assembler-ia32.cc:46:#include "src/objects/heap-object.h"
./codegen/ia32/macro-assembler-ia32.cc:47:#include "src/objects/js-function.h"
./codegen/ia32/macro-assembler-ia32.cc:48:#include "src/objects/map.h"
./codegen/ia32/macro-assembler-ia32.cc:49:#include "src/objects/objects.h"
./codegen/ia32/macro-assembler-ia32.cc:50:#include "src/objects/oddball.h"
./codegen/ia32/macro-assembler-ia32.cc:51:#include "src/objects/shared-function-info.h"
./codegen/ia32/macro-assembler-ia32.cc:52:#include "src/objects/slots-inl.h"
./codegen/ia32/macro-assembler-ia32.cc:53:#include "src/objects/smi.h"
./snapshot/roots-serializer.h:10:#include "src/objects/visitors.h"
./regexp/regexp-bytecode-generator.cc:8:#include "src/objects/fixed-array-inl.h"
./heap/mutable-page-metadata.cc:20:#include "src/objects/heap-object.h"
./builtins/builtins-reflect.cc:8:#include "src/objects/keys.h"
./builtins/builtins-reflect.cc:9:#include "src/objects/lookup.h"
./builtins/builtins-reflect.cc:10:#include "src/objects/objects-inl.h"
./builtins/builtins-reflect.cc:11:#include "src/objects/property-descriptor.h"
./snapshot/object-deserializer.cc:10:#include "src/objects/allocation-site-inl.h"
./snapshot/object-deserializer.cc:11:#include "src/objects/objects.h"
./builtins/builtins-bigint.cc:9:#include "src/objects/objects-inl.h"
./builtins/builtins-bigint.cc:11:#include "src/objects/intl-objects.h"
./compiler/basic-block-instrumentor.cc:20:#include "src/objects/objects-inl.h"
./builtins/builtins-symbol.cc:9:#include "src/objects/objects-inl.h"
./snapshot/startup-deserializer.cc:14:#include "src/objects/oddball.h"
./codegen/ppc/assembler-ppc.h:54:#include "src/objects/smi.h"
./codegen/script-details.h:10:#include "src/objects/fixed-array.h"
./codegen/script-details.h:11:#include "src/objects/objects.h"
./heap/heap.cc:105:#include "src/objects/data-handler.h"
./heap/heap.cc:106:#include "src/objects/free-space-inl.h"
./heap/heap.cc:107:#include "src/objects/hash-table-inl.h"
./heap/heap.cc:108:#include "src/objects/hash-table.h"
./heap/heap.cc:109:#include "src/objects/instance-type.h"
./heap/heap.cc:110:#include "src/objects/maybe-object.h"
./heap/heap.cc:111:#include "src/objects/objects.h"
./heap/heap.cc:112:#include "src/objects/slots-atomic-inl.h"
./heap/heap.cc:113:#include "src/objects/slots-inl.h"
./heap/heap.cc:114:#include "src/objects/slots.h"
./heap/heap.cc:115:#include "src/objects/visitors.h"
./heap/heap.cc:137:#include "src/objects/object-macros.h"
./heap/heap.cc:7477:#include "src/objects/object-macros-undef.h"
./regexp/arm64/regexp-macro-assembler-arm64.cc:12:#include "src/objects/objects-inl.h"
./codegen/external-reference.cc:32:#include "src/objects/elements-kind.h"
./codegen/external-reference.cc:33:#include "src/objects/elements.h"
./codegen/external-reference.cc:34:#include "src/objects/object-type.h"
./codegen/external-reference.cc:35:#include "src/objects/objects-inl.h"
./codegen/external-reference.cc:36:#include "src/objects/ordered-hash-table.h"
./codegen/external-reference.cc:37:#include "src/objects/simd.h"
./codegen/external-reference.cc:53:#include "src/objects/intl-objects.h"
./wasm/wasm-module.cc:12:#include "src/objects/js-array-inl.h"
./wasm/wasm-module.cc:13:#include "src/objects/objects.h"
./codegen/ia32/assembler-ia32.h:50:#include "src/objects/smi.h"
./snapshot/serializer.cc:15:#include "src/objects/code.h"
./snapshot/serializer.cc:16:#include "src/objects/descriptor-array.h"
./snapshot/serializer.cc:17:#include "src/objects/instance-type-checker.h"
./snapshot/serializer.cc:18:#include "src/objects/instance-type.h"
./snapshot/serializer.cc:19:#include "src/objects/js-array-buffer-inl.h"
./snapshot/serializer.cc:20:#include "src/objects/map.h"
./snapshot/serializer.cc:21:#include "src/objects/objects-body-descriptors-inl.h"
./snapshot/serializer.cc:22:#include "src/objects/slots-inl.h"
./snapshot/serializer.cc:23:#include "src/objects/slots.h"
./snapshot/serializer.cc:24:#include "src/objects/smi.h"
./codegen/ia32/macro-assembler-ia32.h:32:#include "src/objects/heap-object.h"
./codegen/ia32/macro-assembler-ia32.h:33:#include "src/objects/smi.h"
./codegen/ia32/assembler-ia32-inl.h:45:#include "src/objects/objects-inl.h"
./snapshot/deserializer.h:15:#include "src/objects/allocation-site.h"
./snapshot/deserializer.h:16:#include "src/objects/api-callbacks.h"
./snapshot/deserializer.h:17:#include "src/objects/backing-store.h"
./snapshot/deserializer.h:18:#include "src/objects/code.h"
./snapshot/deserializer.h:19:#include "src/objects/map.h"
./snapshot/deserializer.h:20:#include "src/objects/objects.h"
./snapshot/deserializer.h:21:#include "src/objects/string-table.h"
./snapshot/deserializer.h:22:#include "src/objects/string.h"
./regexp/ppc/regexp-macro-assembler-ppc.cc:13:#include "src/objects/code-inl.h"
./builtins/builtins-bigint-gen.h:9:#include "src/objects/bigint.h"
./snapshot/snapshot-source-sink.cc:11:#include "src/objects/objects-inl.h"
./regexp/regexp-bytecode-peephole.cc:8:#include "src/objects/fixed-array-inl.h"
./compiler/bytecode-graph-builder.cc:30:#include "src/objects/elements-kind.h"
./compiler/bytecode-graph-builder.cc:31:#include "src/objects/js-generator.h"
./compiler/bytecode-graph-builder.cc:32:#include "src/objects/literal-objects-inl.h"
./compiler/bytecode-graph-builder.cc:33:#include "src/objects/scope-info.h"
./compiler/bytecode-graph-builder.cc:34:#include "src/objects/template-objects-inl.h"
./regexp/riscv/regexp-macro-assembler-riscv.cc:10:#include "src/objects/objects-inl.h"
./regexp/x64/regexp-macro-assembler-x64.cc:13:#include "src/objects/code-inl.h"
./builtins/builtins-constructor.h:8:#include "src/objects/contexts.h"
./builtins/builtins-constructor.h:9:#include "src/objects/dictionary.h"
./builtins/builtins-constructor.h:10:#include "src/objects/js-array.h"
./builtins/builtins-constructor.h:11:#include "src/objects/objects.h"
./regexp/regexp.cc:12:#include "src/objects/js-regexp-inl.h"
./wasm/wasm-objects.cc:24:#include "src/objects/managed-inl.h"
./wasm/wasm-objects.cc:25:#include "src/objects/objects-inl.h"
./wasm/wasm-objects.cc:26:#include "src/objects/oddball.h"
./wasm/wasm-objects.cc:27:#include "src/objects/shared-function-info.h"
./wasm/wasm-objects.cc:53:#include "src/objects/object-macros.h"
./wasm/wasm-objects.cc:3304:#include "src/objects/object-macros-undef.h"
./builtins/builtins-number.cc:10:#include "src/objects/objects-inl.h"
./builtins/builtins-number.cc:12:#include "src/objects/intl-objects.h"
./snapshot/roots-serializer.cc:9:#include "src/objects/slots.h"
./regexp/regexp-parser.cc:8:#include "src/objects/string-inl.h"
./regexp/regexp-macro-assembler-tracer.cc:7:#include "src/objects/fixed-array-inl.h"
./regexp/regexp-macro-assembler-tracer.cc:8:#include "src/objects/string.h"
./snapshot/serializer-deserializer.h:8:#include "src/objects/visitors.h"
./regexp/regexp-compiler-tonode.cc:7:#include "src/objects/string.h"
./wasm/module-instantiate.cc:15:#include "src/objects/descriptor-array-inl.h"
./wasm/module-instantiate.cc:16:#include "src/objects/property-descriptor.h"
./wasm/module-instantiate.cc:17:#include "src/objects/torque-defined-classes.h"
./regexp/mips64/regexp-macro-assembler-mips64.cc:13:#include "src/objects/code-inl.h"
./regexp/arm/regexp-macro-assembler-arm.cc:13:#include "src/objects/code-inl.h"
./regexp/loong64/regexp-macro-assembler-loong64.cc:12:#include "src/objects/code-inl.h"
./builtins/riscv/builtins-riscv.cc:19:#include "src/objects/cell.h"
./builtins/riscv/builtins-riscv.cc:20:#include "src/objects/foreign.h"
./builtins/riscv/builtins-riscv.cc:21:#include "src/objects/heap-number.h"
./builtins/riscv/builtins-riscv.cc:22:#include "src/objects/js-generator.h"
./builtins/riscv/builtins-riscv.cc:23:#include "src/objects/objects-inl.h"
./builtins/riscv/builtins-riscv.cc:24:#include "src/objects/smi.h"
./regexp/experimental/experimental.cc:10:#include "src/objects/js-regexp-inl.h"
./regexp/regexp-interpreter.cc:13:#include "src/objects/js-regexp-inl.h"
./regexp/regexp-interpreter.cc:14:#include "src/objects/string-inl.h"
./builtins/builtins-handler-gen.cc:10:#include "src/objects/objects-inl.h"
./regexp/s390/regexp-macro-assembler-s390.cc:13:#include "src/objects/code-inl.h"
./regexp/regexp-macro-assembler.h:10:#include "src/objects/fixed-array.h"
./builtins/builtins-date-gen.cc:8:#include "src/objects/dictionary.h"
./snapshot/snapshot.cc:20:#include "src/objects/js-regexp-inl.h"
./builtins/builtins-weak-refs.cc:7:#include "src/objects/js-weak-refs-inl.h"
./regexp/experimental/experimental-interpreter.cc:7:#include "src/objects/string-inl.h"
./compiler/js-operator.h:17:#include "src/objects/feedback-cell.h"
./compiler/js-operator.h:18:#include "src/objects/oddball.h"
./snapshot/startup-serializer.cc:11:#include "src/objects/contexts.h"
./snapshot/startup-serializer.cc:12:#include "src/objects/objects-inl.h"
./snapshot/startup-serializer.cc:13:#include "src/objects/slots.h"
./regexp/regexp-compiler.cc:11:#include "src/objects/fixed-array-inl.h"
./regexp/ia32/regexp-macro-assembler-ia32.cc:12:#include "src/objects/objects-inl.h"
./wasm/wasm-js.cc:24:#include "src/objects/fixed-array.h"
./wasm/wasm-js.cc:25:#include "src/objects/instance-type.h"
./wasm/wasm-js.cc:26:#include "src/objects/js-function.h"
./wasm/wasm-js.cc:27:#include "src/objects/managed-inl.h"
./wasm/wasm-js.cc:28:#include "src/objects/objects-inl.h"
./wasm/wasm-js.cc:29:#include "src/objects/shared-function-info.h"
./wasm/wasm-js.cc:30:#include "src/objects/templates.h"
./snapshot/code-serializer.cc:22:#include "src/objects/objects-inl.h"
./snapshot/code-serializer.cc:23:#include "src/objects/shared-function-info.h"
./snapshot/code-serializer.cc:24:#include "src/objects/slots.h"
./snapshot/code-serializer.cc:25:#include "src/objects/visitors.h"
./wasm/wasm-deopt-data.cc:7:#include "src/objects/deoptimization-data.h"
./snapshot/context-serializer.cc:11:#include "src/objects/embedder-data-array-inl.h"
./snapshot/context-serializer.cc:12:#include "src/objects/js-objects.h"
./snapshot/context-serializer.cc:13:#include "src/objects/objects-inl.h"
./snapshot/context-serializer.cc:14:#include "src/objects/slots.h"
./compiler/js-operator.cc:16:#include "src/objects/objects-inl.h"
./compiler/js-operator.cc:17:#include "src/objects/template-objects.h"
./snapshot/context-serializer.h:8:#include "src/objects/contexts.h"
./compiler/js-graph.h:15:#include "src/objects/oddball.h"
./compiler/osr.cc:9:#include "src/objects/js-array-inl.h"
./compiler/string-builder-optimizer.cc:25:#include "src/objects/code.h"
./compiler/string-builder-optimizer.cc:26:#include "src/objects/map-inl.h"
./compiler/wasm-gc-lowering.cc:16:#include "src/objects/heap-number.h"
./compiler/wasm-gc-lowering.cc:17:#include "src/objects/string.h"
./regexp/regexp-utils.cc:10:#include "src/objects/js-regexp-inl.h"
./regexp/regexp-utils.cc:11:#include "src/objects/objects-inl.h"
./builtins/arm/builtins-arm.cc:21:#include "src/objects/cell.h"
./builtins/arm/builtins-arm.cc:22:#include "src/objects/foreign.h"
./builtins/arm/builtins-arm.cc:23:#include "src/objects/heap-number.h"
./builtins/arm/builtins-arm.cc:24:#include "src/objects/js-generator.h"
./builtins/arm/builtins-arm.cc:25:#include "src/objects/objects-inl.h"
./builtins/arm/builtins-arm.cc:26:#include "src/objects/smi.h"
./compiler/raw-machine-assembler.h:25:#include "src/objects/string.h"
./compiler/pipeline-statistics.cc:12:#include "src/objects/shared-function-info.h"
./builtins/builtins-promise-gen.cc:13:#include "src/objects/fixed-array.h"
./builtins/builtins-promise-gen.cc:14:#include "src/objects/js-objects.h"
./builtins/builtins-promise-gen.cc:15:#include "src/objects/js-promise.h"
./builtins/builtins-promise-gen.cc:16:#include "src/objects/objects-inl.h"
./builtins/builtins-promise-gen.cc:17:#include "src/objects/smi.h"
./compiler/pipeline-statistics.h:15:#include "src/objects/code-kind.h"
./compiler/code-assembler.cc:29:#include "src/objects/smi.h"
./compiler/js-typed-lowering.cc:34:#include "src/objects/casting.h"
./compiler/js-typed-lowering.cc:35:#include "src/objects/heap-number.h"
./compiler/js-typed-lowering.cc:36:#include "src/objects/js-generator.h"
./compiler/js-typed-lowering.cc:37:#include "src/objects/module-inl.h"
./compiler/js-typed-lowering.cc:38:#include "src/objects/objects-inl.h"
./compiler/js-typed-lowering.cc:39:#include "src/objects/objects.h"
./compiler/js-typed-lowering.cc:40:#include "src/objects/property-cell.h"
./compiler/js-heap-broker.h:25:#include "src/objects/code-kind.h"
./compiler/js-heap-broker.h:26:#include "src/objects/feedback-vector.h"
./compiler/js-heap-broker.h:27:#include "src/objects/objects.h"
./compiler/js-heap-broker.h:28:#include "src/objects/tagged.h"
./compiler/heap-refs.h:12:#include "src/objects/elements-kind.h"
./compiler/heap-refs.h:13:#include "src/objects/feedback-vector.h"
./compiler/heap-refs.h:14:#include "src/objects/instance-type.h"
./compiler/heap-refs.h:15:#include "src/objects/object-list-macros.h"
./compiler/escape-analysis.cc:14:#include "src/objects/map-inl.h"
./compiler/simplified-operator.cc:14:#include "src/objects/feedback-cell.h"
./compiler/simplified-operator.cc:15:#include "src/objects/map.h"
./compiler/simplified-operator.cc:16:#include "src/objects/name.h"
./compiler/js-graph.cc:10:#include "src/objects/objects-inl.h"
./heap/mark-sweep-utilities.cc:16:#include "src/objects/objects-inl.h"
./heap/mark-sweep-utilities.cc:17:#include "src/objects/string-forwarding-table-inl.h"
./heap/mark-sweep-utilities.cc:18:#include "src/objects/visitors-inl.h"
./compiler/turbofan-graph-visualizer.h:18:#include "src/objects/code.h"
./builtins/builtins-lazy-gen.cc:10:#include "src/objects/code-inl.h"
./builtins/builtins-lazy-gen.cc:11:#include "src/objects/feedback-vector-inl.h"
./builtins/builtins-lazy-gen.cc:12:#include "src/objects/shared-function-info.h"
./heap/ephemeron-remembered-set.h:13:#include "src/objects/hash-table.h"
./compiler/code-assembler.h:27:#include "src/objects/object-type.h"
./compiler/code-assembler.h:28:#include "src/objects/objects.h"
[Step 9: Duration 10.53 seconds| Input tokens: 31,991 | Output tokens: 2,767]
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ Step 10 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'fuzzy_finder' with arguments: {'pattern': 'transitions', 'options': '--filter transitions'}                                                                                                   │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
Command: cd /Users/tarun/v8/v8/src && rg --hidden --no-follow --no-ignore-vcs --files 2>/dev/null | fzf --filter transitions 'transitions' | head -n 1000
Observations: unknown option: transitions
[Step 10: Duration 7.59 seconds| Input tokens: 54,048 | Output tokens: 3,055]
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ Step 11 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'ripgrep' with arguments: {'pattern':                                                                                                                                                          │
│ 'FindTransitionTo(Field|Accessor)|DeprecateTransition|DeprecateTransitions|New(Field|DataProperty)|AddTransition|TransitionArray|ReplaceTransitionToDataProperty|+1 map|migrat|Deprecate', 'options': '-n    │
│ --hidden --no-ignore-vcs ./objects'}                                                                                                                                                                         │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
Command: cd /Users/tarun/v8/v8/src && rg -n --hidden --no-ignore-vcs ./objects 'FindTransitionTo(Field|Accessor)|DeprecateTransition|DeprecateTransitions|New(Field|DataProperty)|AddTransition|TransitionArray|ReplaceTransitionToDataProperty|+1 map|migrat|Deprecate' | head -n 1000
Observations: rg: FindTransitionTo(Field|Accessor)|DeprecateTransition|DeprecateTransitions|New(Field|DataProperty)|AddTransition|TransitionArray|ReplaceTransitionToDataProperty|+1 map|migrat|Deprecate: IO 
error for operation on FindTransitionTo(Field|Accessor)|DeprecateTransition|DeprecateTransitions|New(Field|DataProperty)|AddTransition|TransitionArray|ReplaceTransitionToDataProperty|+1 map|migrat|Deprecate: 
No such file or directory (os error 2)
[Step 11: Duration 7.84 seconds| Input tokens: 98,522 | Output tokens: 3,267]
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ Step 12 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'fuzzy_finder' with arguments: {'pattern': 'objects/transitions.cc', 'options': '--filter'}                                                                                                    │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'fuzzy_finder' with arguments: {'pattern': 'objects/transitions-inl.h', 'options': '--filter'}                                                                                                 │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'fuzzy_finder' with arguments: {'pattern': 'objects/transitions.h', 'options': '--filter'}                                                                                                     │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
Command: cd /Users/tarun/v8/v8/src && rg --hidden --no-follow --no-ignore-vcs --files 2>/dev/null | fzf --filter 'objects/transitions.cc' | head -n 1000
│ Calling tool: 'fuzzy_finder' with arguments: {'pattern': 'objects/map-inl.h', 'options': '--filter'}                                                                                                         │
Command: cd /Users/tarun/v8/v8/src && rg --hidden --no-follow --no-ignore-vcs --files 2>/dev/null | fzf --filter 'objects/transitions-inl.h' | head -n 1000
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'fuzzy_finder' with arguments: {'pattern': 'objects/map.h', 'options': '--filter'}                                                                                                             │
Command: cd /Users/tarun/v8/v8/src && rg --hidden --no-follow --no-ignore-vcs --files 2>/dev/null | fzf --filter 'objects/transitions.h' | head -n 1000
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯

Command: cd /Users/tarun/v8/v8/src && rg --hidden --no-follow --no-ignore-vcs --files 2>/dev/null | fzf --filter 'objects/transitions.h' | head -n 1000
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'fuzzy_finder' with arguments: {'pattern': 'objects/map.cc', 'options': '--filter'}                                                                                                            │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
Command: cd /Users/tarun/v8/v8/src && rg --hidden --no-follow --no-ignore-vcs --files 2>/dev/null | fzf --filter 'objects/map-inl.h' | head -n 1000
Observations: objects/transitions-inl.h
Observations: objects/transitions.cc
Observations: objects/transitions.h
objects/transitions-inl.h
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
Command: cd /Users/tarun/v8/v8/src && rg --hidden --no-follow --no-ignore-vcs --files 2>/dev/null | fzf --filter 'objects/map.cc' | head -n 1000
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'fuzzy_finder' with arguments: {'pattern': 'objects/property-details.h', 'options': '--filter'}                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
│ Calling tool: 'fuzzy_finder' with arguments: {'pattern': 'objects/descriptor-array', 'options': '--filter'}                                                                                                  │
objects/primitive-heap-object-inl.h
Observations: objects/map-inl.h
Command: cd /Users/tarun/v8/v8/src && rg --hidden --no-follow --no-ignore-vcs --files 2>/dev/null | fzf --filter 'objects/map.h' | head -n 1000

╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'fuzzy_finder' with arguments: {'pattern': 'objects/js-objects.cc', 'options': '--filter'}                                                                                                     │
Command: cd /Users/tarun/v8/v8/src && rg --hidden --no-follow --no-ignore-vcs --files 2>/dev/null | fzf --filter 'objects/descriptor-array' | head -n 1000
Observations: objects/map.cc
objects/map-updater.cc
Command: cd /Users/tarun/v8/v8/src && rg --hidden --no-follow --no-ignore-vcs --files 2>/dev/null | fzf --filter 'objects/property-details.h' | head -n 1000
objects/descriptor-array-inl.h
Observations: objects/descriptor-array.h
Observations: objects/property-details.h
objects/descriptor-array.tq
Observations: objects/map.h
objects/map-inl.h
objects/map-updater.h
objects/primitive-heap-object.h
objects/primitive-heap-object-inl.h
Command: cd /Users/tarun/v8/v8/src && rg --hidden --no-follow --no-ignore-vcs --files 2>/dev/null | fzf --filter 'objects/js-objects.cc' | head -n 1000
Observations: objects/js-objects.cc
objects/js-temporal-objects.cc
[Step 12: Duration 12.80 seconds| Input tokens: 120,995 | Output tokens: 3,830]
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ Step 13 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'ripgrep' with arguments: {'pattern': 'FindTransitionToField|FindTransitionToAccessor|DeprecateTransition|DeprecateTransitions|NewField|NewDataProperty|Diverge|+1                             │
│ map|PlusOne|Deprecated|TransitionArray', 'options': '-n ./objects'}                                                                                                                                          │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
Command: cd /Users/tarun/v8/v8/src && rg -n ./objects 'FindTransitionToField|FindTransitionToAccessor|DeprecateTransition|DeprecateTransitions|NewField|NewDataProperty|Diverge|+1 map|PlusOne|Deprecated|TransitionArray' | head -n 1000
Observations: rg: FindTransitionToField|FindTransitionToAccessor|DeprecateTransition|DeprecateTransitions|NewField|NewDataProperty|Diverge|+1 map|PlusOne|Deprecated|TransitionArray: IO error for operation on 
FindTransitionToField|FindTransitionToAccessor|DeprecateTransition|DeprecateTransitions|NewField|NewDataProperty|Diverge|+1 map|PlusOne|Deprecated|TransitionArray: No such file or directory (os error 2)
[Step 13: Duration 10.71 seconds| Input tokens: 165,512 | Output tokens: 4,094]
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ Step 14 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'fuzzy_finder' with arguments: {'pattern': 'transitions', 'options': '--filter=transitions'}                                                                                                   │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'ripgrep' with arguments: {'pattern': 'DeprecateTransition', 'options': '-n objects/transitions.* objects/map*.*'}                                                                             │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
Command: cd /Users/tarun/v8/v8/src && rg --hidden --no-follow --no-ignore-vcs --files 2>/dev/null | fzf --filter=transitions 'transitions' | head -n 1000
│ Calling tool: 'ripgrep' with arguments: {'pattern': 'FindTransitionTo(Field|Accessor)', 'options': '-n objects/transitions.*'}                                                                               │
│ Calling tool: 'ripgrep' with arguments: {'pattern': 'New(Field|DataProperty)', 'options': '-n objects/transitions.* objects/map*.* objects/js-objects.*'}                                                    │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯

╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
Command: cd /Users/tarun/v8/v8/src && rg -n objects/transitions.* objects/map*.* 'DeprecateTransition' | head -n 1000
Observations: rg: DeprecateTransition: No such file or directory (os error 2)
Observations: unknown option: transitions
Command: cd /Users/tarun/v8/v8/src && rg -n objects/transitions.* 'FindTransitionTo(Field|Accessor)' | head -n 1000
Observations: rg: FindTransitionTo(Field|Accessor): No such file or directory (os error 2)
Command: cd /Users/tarun/v8/v8/src && rg -n objects/transitions.* objects/map*.* objects/js-objects.* 'New(Field|DataProperty)' | head -n 1000
Observations: rg: New(Field|DataProperty): No such file or directory (os error 2)
[Step 14: Duration 23.50 seconds| Input tokens: 180,226 | Output tokens: 5,203]
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ Step 15 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'fuzzy_finder' with arguments: {'pattern': 'transitions', 'options': ''}                                                                                                                       │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'tree' with arguments: {'options': '-L 1 ./objects'}                                                                                                                                           │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
Command: cd /Users/tarun/v8/v8/src && rg --hidden --no-follow --no-ignore-vcs --files 2>/dev/null | fzf  'transitions' | head -n 1000
Observations: unknown option: transitions
Command: cd /Users/tarun/v8/v8/src && tree -L 1 ./objects | head -n 1000
Observations: ./objects
├── abstract-code-inl.h
├── abstract-code.cc
├── abstract-code.h
├── all-objects-inl.h
├── allocation-site-inl.h
├── allocation-site-scopes-inl.h
├── allocation-site-scopes.h
├── allocation-site.h
├── allocation-site.tq
├── api-callbacks-inl.h
├── api-callbacks.h
├── api-callbacks.tq
├── arguments-inl.h
├── arguments.h
├── arguments.tq
├── backing-store.cc
├── backing-store.h
├── bigint.cc
├── bigint.h
├── bigint.tq
├── bytecode-array-inl.h
├── bytecode-array.cc
├── bytecode-array.h
├── bytecode-array.tq
├── call-site-info-inl.h
├── call-site-info.cc
├── call-site-info.h
├── call-site-info.tq
├── casting-inl.h
├── casting.h
├── cell-inl.h
├── cell.h
├── cell.tq
├── code-inl.h
├── code-kind.cc
├── code-kind.h
├── code.cc
├── code.h
├── compilation-cache-table-inl.h
├── compilation-cache-table.cc
├── compilation-cache-table.h
├── compressed-slots-inl.h
├── compressed-slots.h
├── contexts-inl.h
├── contexts.cc
├── contexts.h
├── contexts.tq
├── data-handler-inl.h
├── data-handler.h
├── data-handler.tq
├── debug-objects-inl.h
├── debug-objects.cc
├── debug-objects.h
├── debug-objects.tq
├── deoptimization-data-inl.h
├── deoptimization-data.cc
├── deoptimization-data.h
├── dependent-code-inl.h
├── dependent-code.cc
├── dependent-code.h
├── DEPS
├── descriptor-array-inl.h
├── descriptor-array.h
├── descriptor-array.tq
├── dictionary-inl.h
├── dictionary.h
├── DIR_METADATA
├── elements-inl.h
├── elements-kind.cc
├── elements-kind.h
├── elements.cc
├── elements.h
├── embedder-data-array-inl.h
├── embedder-data-array.cc
├── embedder-data-array.h
├── embedder-data-array.tq
├── embedder-data-slot-inl.h
├── embedder-data-slot.h
├── feedback-cell-inl.h
├── feedback-cell.h
├── feedback-cell.tq
├── feedback-vector-inl.h
├── feedback-vector.cc
├── feedback-vector.h
├── feedback-vector.tq
├── field-index-inl.h
├── field-index.h
├── field-type.cc
├── field-type.h
├── fixed-array-inl.h
├── fixed-array.cc
├── fixed-array.h
├── fixed-array.tq
├── foreign-inl.h
├── foreign.h
├── foreign.tq
├── free-space-inl.h
├── free-space.h
├── free-space.tq
├── function-kind.h
├── function-syntax-kind.h
├── hash-table-inl.h
├── hash-table.h
├── heap-number-inl.h
├── heap-number.h
├── heap-number.tq
├── heap-object-inl.h
├── heap-object.h
├── heap-object.tq
├── hole-inl.h
├── hole.h
├── hole.tq
├── instance-type-checker.h
├── instance-type-inl.h
├── instance-type.h
├── instruction-stream-inl.h
├── instruction-stream.cc
├── instruction-stream.h
├── internal-index.h
├── intl-objects.cc
├── intl-objects.h
├── intl-objects.tq
├── js-array-buffer-inl.h
├── js-array-buffer.cc
├── js-array-buffer.h
├── js-array-buffer.tq
├── js-array-inl.h
├── js-array.h
├── js-array.tq
├── js-atomics-synchronization-inl.h
├── js-atomics-synchronization.cc
├── js-atomics-synchronization.h
├── js-atomics-synchronization.tq
├── js-break-iterator-inl.h
├── js-break-iterator.cc
├── js-break-iterator.h
├── js-break-iterator.tq
├── js-collator-inl.h
├── js-collator.cc
├── js-collator.h
├── js-collator.tq
├── js-collection-inl.h
├── js-collection-iterator-inl.h
├── js-collection-iterator.h
├── js-collection-iterator.tq
├── js-collection.h
├── js-collection.tq
├── js-date-time-format-inl.h
├── js-date-time-format.cc
├── js-date-time-format.h
├── js-date-time-format.tq
├── js-display-names-inl.h
├── js-display-names.cc
├── js-display-names.h
├── js-display-names.tq
├── js-disposable-stack-inl.h
├── js-disposable-stack.cc
├── js-disposable-stack.h
├── js-disposable-stack.tq
├── js-duration-format-inl.h
├── js-duration-format.cc
├── js-duration-format.h
├── js-duration-format.tq
├── js-function-inl.h
├── js-function.cc
├── js-function.h
├── js-function.tq
├── js-generator-inl.h
├── js-generator.h
├── js-generator.tq
├── js-iterator-helpers-inl.h
├── js-iterator-helpers.h
├── js-iterator-helpers.tq
├── js-list-format-inl.h
├── js-list-format.cc
├── js-list-format.h
├── js-list-format.tq
├── js-locale-inl.h
├── js-locale.cc
├── js-locale.h
├── js-locale.tq
├── js-number-format-inl.h
├── js-number-format.cc
├── js-number-format.h
├── js-number-format.tq
├── js-objects-inl.h
├── js-objects.cc
├── js-objects.h
├── js-objects.tq
├── js-plural-rules-inl.h
├── js-plural-rules.cc
├── js-plural-rules.h
├── js-plural-rules.tq
├── js-promise-inl.h
├── js-promise.h
├── js-promise.tq
├── js-proxy-inl.h
├── js-proxy.h
├── js-proxy.tq
├── js-raw-json-inl.h
├── js-raw-json.cc
├── js-raw-json.h
├── js-raw-json.tq
├── js-regexp-inl.h
├── js-regexp-string-iterator-inl.h
├── js-regexp-string-iterator.h
├── js-regexp-string-iterator.tq
├── js-regexp.cc
├── js-regexp.h
├── js-regexp.tq
├── js-relative-time-format-inl.h
├── js-relative-time-format.cc
├── js-relative-time-format.h
├── js-relative-time-format.tq
├── js-segment-iterator-inl.h
├── js-segment-iterator.cc
├── js-segment-iterator.h
├── js-segment-iterator.tq
├── js-segmenter-inl.h
├── js-segmenter.cc
├── js-segmenter.h
├── js-segmenter.tq
├── js-segments-inl.h
├── js-segments.cc
├── js-segments.h
├── js-segments.tq
├── js-shadow-realm-inl.h
├── js-shadow-realm.h
├── js-shadow-realm.tq
├── js-shared-array-inl.h
├── js-shared-array.h
├── js-shared-array.tq
├── js-struct-inl.h
├── js-struct.cc
├── js-struct.h
├── js-struct.tq
├── js-temporal-objects-inl.h
├── js-temporal-objects.cc
├── js-temporal-objects.h
├── js-temporal-objects.tq
├── js-weak-refs-inl.h
├── js-weak-refs.cc
├── js-weak-refs.h
├── js-weak-refs.tq
├── keys.cc
├── keys.h
├── literal-objects-inl.h
├── literal-objects.cc
├── literal-objects.h
├── literal-objects.tq
├── lookup-cache-inl.h
├── lookup-cache.cc
├── lookup-cache.h
├── lookup-inl.h
├── lookup.cc
├── lookup.h
├── managed-inl.h
├── managed.cc
├── managed.h
├── map-inl.h
├── map-updater.cc
├── map-updater.h
├── map.cc
├── map.h
├── map.tq
├── maybe-object-inl.h
├── maybe-object.h
├── megadom-handler-inl.h
├── megadom-handler.h
├── megadom-handler.tq
├── microtask-inl.h
├── microtask.h
├── microtask.tq
├── module-inl.h
├── module.cc
├── module.h
├── module.tq
├── name-inl.h
├── name.h
├── name.tq
├── object-list-macros.h
├── object-macros-undef.h
├── object-macros.h
├── object-type.cc
├── object-type.h
├── objects-body-descriptors-inl.h
├── objects-body-descriptors.h
├── objects-definitions.h
├── objects-inl.h
├── objects.cc
├── objects.h
├── oddball-inl.h
├── oddball.h
├── oddball.tq
├── off-heap-hash-table-inl.h
├── off-heap-hash-table.h
├── option-utils.cc
├── option-utils.h
├── ordered-hash-table-inl.h
├── ordered-hash-table.cc
├── ordered-hash-table.h
├── ordered-hash-table.tq
├── OWNERS
├── primitive-heap-object-inl.h
├── primitive-heap-object.h
├── primitive-heap-object.tq
├── promise-inl.h
├── promise.h
├── promise.tq
├── property-array-inl.h
├── property-array.h
├── property-array.tq
├── property-cell-inl.h
├── property-cell.h
├── property-cell.tq
├── property-descriptor-object-inl.h
├── property-descriptor-object.h
├── property-descriptor-object.tq
├── property-descriptor.cc
├── property-descriptor.h
├── property-details.h
├── property.cc
├── property.h
├── prototype-info-inl.h
├── prototype-info.h
├── prototype-info.tq
├── prototype-inl.h
├── prototype.h
├── regexp-match-info-inl.h
├── regexp-match-info.cc
├── regexp-match-info.h
├── regexp-match-info.tq
├── scope-info-inl.h
├── scope-info.cc
├── scope-info.h
├── scope-info.tq
├── script-inl.h
├── script.h
├── script.tq
├── shared-function-info-inl.h
├── shared-function-info.cc
├── shared-function-info.h
├── shared-function-info.tq
├── simd.cc
├── simd.h
├── slots-atomic-inl.h
├── slots-inl.h
├── slots.h
├── smi-inl.h
├── smi.h
├── source-text-module-inl.h
├── source-text-module.cc
├── source-text-module.h
├── source-text-module.tq
├── string-comparator.cc
├── string-comparator.h
├── string-forwarding-table-inl.h
├── string-forwarding-table.cc
├── string-forwarding-table.h
├── string-inl.h
├── string-set-inl.h
├── string-set.h
├── string-table-inl.h
├── string-table.cc
├── string-table.h
├── string.cc
├── string.h
├── string.tq
├── struct-inl.h
├── struct.h
├── struct.tq
├── swiss-hash-table-helpers.h
├── swiss-hash-table-helpers.tq
├── swiss-name-dictionary-inl.h
├── swiss-name-dictionary.cc
├── swiss-name-dictionary.h
├── swiss-name-dictionary.tq
├── symbol-table.cc
├── synthetic-module-inl.h
├── synthetic-module.cc
├── synthetic-module.h
├── synthetic-module.tq
├── tagged-field-inl.h
├── tagged-field.h
├── tagged-impl-inl.h
├── tagged-impl.cc
├── tagged-impl.h
├── tagged-index.h
├── tagged-value-inl.h
├── tagged-value.h
├── tagged.h
├── template-objects-inl.h
├── template-objects.cc
├── template-objects.h
├── template-objects.tq
├── templates-inl.h
├── templates.cc
├── templates.h
├── templates.tq
├── torque-defined-classes-inl.h
├── torque-defined-classes.h
├── torque-defined-classes.tq
├── transitions-inl.h
├── transitions.cc
├── transitions.h
├── trusted-object-inl.h
├── trusted-object.h
├── trusted-object.tq
├── turbofan-types-inl.h
├── turbofan-types.h
├── turbofan-types.tq
├── turboshaft-types-inl.h
├── turboshaft-types.h
├── turboshaft-types.tq
├── type-hints.cc
├── type-hints.h
├── union.h
├── value-serializer.cc
├── value-serializer.h
├── visitors-inl.h
├── visitors.cc
├── visitors.h
├── waiter-queue-node.cc
└── waiter-queue-node.h

1 directory, 424 files
[Step 15: Duration 18.66 seconds| Input tokens: 202,332 | Output tokens: 6,036]
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ Step 16 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'ripgrep' with arguments: {'pattern': 'FindTransitionToField|FindTransitionToAccessor|DeprecateTransition|DeprecateTransitions|NewField|NewDataProperty|+1 map|one child|map migration',       │
│ 'options': '-n --hidden --no-ignore-vcs objects'}                                                                                                                                                            │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
Command: cd /Users/tarun/v8/v8/src && rg -n --hidden --no-ignore-vcs objects 'FindTransitionToField|FindTransitionToAccessor|DeprecateTransition|DeprecateTransitions|NewField|NewDataProperty|+1 map|one child|map migration' | head -n 1000
Observations: rg: FindTransitionToField|FindTransitionToAccessor|DeprecateTransition|DeprecateTransitions|NewField|NewDataProperty|+1 map|one child|map migration: IO error for operation on 
FindTransitionToField|FindTransitionToAccessor|DeprecateTransition|DeprecateTransitions|NewField|NewDataProperty|+1 map|one child|map migration: No such file or directory (os error 2)
[Step 16: Duration 26.21 seconds| Input tokens: 224,346 | Output tokens: 7,132]
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ Step 17 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'ripgrep' with arguments: {'pattern': 'FindTransitionTo|DeprecateTransition|DeprecateTransitions|NewField|NewDataProperty|ReplaceTransitionToDataProperty|TransitionArray|AddTransition|+1     │
│ map|Deprecate|ReplaceTransitionToDataField', 'options': '-n --hidden --no-ignore-vcs objects/transitions.cc objects/transitions.h objects/transitions-inl.h objects/map-inl.h objects/map.cc objects/map.h   │
│ objects/js-objects.cc'}                                                                                                                                                                                      │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
Command: cd /Users/tarun/v8/v8/src && rg -n --hidden --no-ignore-vcs objects/transitions.cc objects/transitions.h objects/transitions-inl.h objects/map-inl.h objects/map.cc objects/map.h objects/js-objects.cc 'FindTransitionTo|DeprecateTransition|DeprecateTransitions|NewField|NewDataProperty|ReplaceTransitionToDataProperty|TransitionArray|AddTransition|+1 map|Deprecate|ReplaceTransitionToDataField' | head -n 1000
Observations: rg: FindTransitionTo|DeprecateTransition|DeprecateTransitions|NewField|NewDataProperty|ReplaceTransitionToDataProperty|TransitionArray|AddTransition|+1 
map|Deprecate|ReplaceTransitionToDataField: No such file or directory (os error 2)
[Step 17: Duration 13.95 seconds| Input tokens: 269,446 | Output tokens: 7,691]
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ Step 18 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'ripgrep' with arguments: {'pattern':                                                                                                                                                          │
│ 'FindTransitionToField|FindTransitionToAccessor|NewField|NewDataProperty|DeprecateTransition|DeprecateTransitions|ReplaceTransitionToDataProperty|TransitionArray|+1 map|PlusOne', 'options': '-n            │
│ objects/transitions.cc objects/transitions.h objects/transitions-inl.h objects/map.cc objects/map-inl.h objects/js-objects.cc'}                                                                              │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
Command: cd /Users/tarun/v8/v8/src && rg -n objects/transitions.cc objects/transitions.h objects/transitions-inl.h objects/map.cc objects/map-inl.h objects/js-objects.cc 'FindTransitionToField|FindTransitionToAccessor|NewField|NewDataProperty|DeprecateTransition|DeprecateTransitions|ReplaceTransitionToDataProperty|TransitionArray|+1 map|PlusOne' | head -n 1000
Observations: rg: FindTransitionToField|FindTransitionToAccessor|NewField|NewDataProperty|DeprecateTransition|DeprecateTransitions|ReplaceTransitionToDataProperty|TransitionArray|+1 map|PlusOne: No such file 
or directory (os error 2)
[Step 18: Duration 11.60 seconds| Input tokens: 321,174 | Output tokens: 8,044]
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ Step 19 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'read_file' with arguments: {'file_path': '/Users/tarun/v8/v8/src/objects/transitions.cc'}                                                                                                     │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
Command: cd /Users/tarun/v8/v8/src && wc -l '/Users/tarun/v8/v8/src/objects/transitions.cc'
Command: cd /Users/tarun/v8/v8/src && cat '/Users/tarun/v8/v8/src/objects/transitions.cc'
Observations: // Copyright 2012 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "src/objects/transitions.h"

#include <optional>

#include "src/base/small-vector.h"
#include "src/objects/objects-inl.h"
#include "src/objects/transitions-inl.h"
#include "src/utils/utils.h"

namespace v8::internal {

// static
Tagged<Map> TransitionsAccessor::GetSimpleTransition(Isolate* isolate,
                                                     DirectHandle<Map> map) {
  Tagged<MaybeObject> raw_transitions =
      map->raw_transitions(isolate, kAcquireLoad);
  switch (GetEncoding(isolate, raw_transitions)) {
    case kWeakRef:
      return Cast<Map>(raw_transitions.GetHeapObjectAssumeWeak());
    default:
      return Tagged<Map>();
  }
}

bool TransitionsAccessor::HasSimpleTransitionTo(Tagged<Map> map) {
  switch (encoding()) {
    case kWeakRef:
      return raw_transitions_.GetHeapObjectAssumeWeak() == map;
    case kPrototypeInfo:
    case kUninitialized:
    case kMigrationTarget:
    case kFullTransitionArray:
      return false;
  }
  UNREACHABLE();
}

// static
void TransitionsAccessor::InsertHelper(Isolate* isolate, DirectHandle<Map> map,
                                       DirectHandle<Name> name,
                                       DirectHandle<Map> target,
                                       TransitionKindFlag flag) {
  DCHECK_NE(flag, PROTOTYPE_TRANSITION);
  Encoding encoding = GetEncoding(isolate, map);
  DCHECK_NE(kPrototypeInfo, encoding);
  ReadOnlyRoots roots(isolate);
  (*target)->SetBackPointer(*map);

  // If the map doesn't have any transitions at all yet, install the new one.
  if (encoding == kUninitialized || encoding == kMigrationTarget) {
    if (flag == SIMPLE_PROPERTY_TRANSITION) {
      ReplaceTransitions(isolate, map, MakeWeak(*target));
      return;
    }
    // If the flag requires a full TransitionArray, allocate one.
    DirectHandle<TransitionArray> result =
        isolate->factory()->NewTransitionArray(1, 0);
    result->Set(0, *name, MakeWeak(*target));
    ReplaceTransitions(isolate, map, result);
    DCHECK_EQ(kFullTransitionArray, GetEncoding(isolate, *result));
    return;
  }

  if (encoding == kWeakRef) {
    Tagged<Map> simple_transition = GetSimpleTransition(isolate, map);
    DCHECK(!simple_transition.is_null());

    if (flag == SIMPLE_PROPERTY_TRANSITION) {
      Tagged<Name> key = GetSimpleTransitionKey(simple_transition);
      PropertyDetails old_details =
          simple_transition->GetLastDescriptorDetails(isolate);
      PropertyDetails new_details = GetTargetDetails(*name, **target);
      if (key->Equals(*name) && old_details.kind() == new_details.kind() &&
          old_details.attributes() == new_details.attributes()) {
        ReplaceTransitions(isolate, map, MakeWeak(*target));
        return;
      }
    }

    // Otherwise allocate a full TransitionArray with slack for a new entry.
    DirectHandle<TransitionArray> result =
        isolate->factory()->NewTransitionArray(1, 1);

    // Reload `simple_transition`. Allocations might have caused it to be
    // cleared.
    simple_transition = GetSimpleTransition(isolate, map);
    if (simple_transition.is_null()) {
      result->Set(0, *name, MakeWeak(*target));
      ReplaceTransitions(isolate, map, result);
      DCHECK_EQ(kFullTransitionArray, GetEncoding(isolate, *result));
      return;
    }

    // Insert the original transition in index 0.
    result->Set(0, GetSimpleTransitionKey(simple_transition),
                MakeWeak(simple_transition));

    // Search for the correct index to insert the new transition.
    int insertion_index;
    int index;
    if (flag == SPECIAL_TRANSITION) {
      index =
          result->SearchSpecial(Cast<Symbol>(*name), false, &insertion_index);
    } else {
      PropertyDetails details = GetTargetDetails(*name, **target);
      index = result->Search(details.kind(), *name, details.attributes(),
                             &insertion_index);
    }
    DCHECK_EQ(index, kNotFound);
    USE(index);

    result->SetNumberOfTransitions(2);
    if (insertion_index == 0) {
      // If the new transition will be inserted in index 0, move the original
      // transition to index 1.
      result->Set(1, GetSimpleTransitionKey(simple_transition),
                  MakeWeak(simple_transition));
    }
    result->SetKey(insertion_index, *name);
    result->SetRawTarget(insertion_index, MakeWeak(*target));

    SLOW_DCHECK(result->IsSortedNoDuplicates());
    ReplaceTransitions(isolate, map, result);
    DCHECK_EQ(kFullTransitionArray, GetEncoding(isolate, *result));
    return;
  }

  // At this point, we know that the map has a full TransitionArray.
  DCHECK_EQ(kFullTransitionArray, encoding);

  int number_of_transitions = 0;
  int new_nof = 0;
  int insertion_index = kNotFound;
  const bool is_special_transition = flag == SPECIAL_TRANSITION;
  DCHECK_EQ(is_special_transition, IsSpecialTransition(roots, *name));
  PropertyDetails details = is_special_transition
                                ? PropertyDetails::Empty()
                                : GetTargetDetails(*name, **target);

  {
    DisallowGarbageCollection no_gc;
    Tagged<TransitionArray> array = GetTransitionArray(isolate, map);
    number_of_transitions = array->number_of_transitions();

    int index =
        is_special_transition
            ? array->SearchSpecial(Cast<Symbol>(*name), false, &insertion_index)
            : array->Search(details.kind(), *name, details.attributes(),
                            &insertion_index);
    // If an existing entry was found, overwrite it and return.
    if (index != kNotFound) {
      base::SharedMutexGuard<base::kExclusive> shared_mutex_guard(
          isolate->full_transition_array_access());
      array->SetRawTarget(index, MakeWeak(*target));
      return;
    }

    new_nof = number_of_transitions + 1;
    CHECK_LE(new_nof, kMaxNumberOfTransitions);
    DCHECK_GE(insertion_index, 0);
    DCHECK_LE(insertion_index, number_of_transitions);

    // If there is enough capacity, insert new entry into the existing array.
    if (new_nof <= array->Capacity()) {
      base::SharedMutexGuard<base::kExclusive> shared_mutex_guard(
          isolate->full_transition_array_access());
      array->SetNumberOfTransitions(new_nof);
      for (int i = number_of_transitions; i > insertion_index; --i) {
        array->SetKey(i, array->GetKey(i - 1));
        array->SetRawTarget(i, array->GetRawTarget(i - 1));
      }
      array->SetKey(insertion_index, *name);
      array->SetRawTarget(insertion_index, MakeWeak(*target));
      SLOW_DCHECK(array->IsSortedNoDuplicates());
      return;
    }
  }

  // We're gonna need a bigger TransitionArray.
  DirectHandle<TransitionArray> result = isolate->factory()->NewTransitionArray(
      new_nof,
      Map::SlackForArraySize(number_of_transitions, kMaxNumberOfTransitions));

  // The map's transition array may have shrunk during the allocation above as
  // it was weakly traversed, though it is guaranteed not to disappear. Trim the
  // result copy if needed, and recompute variables.
  DisallowGarbageCollection no_gc;
  Tagged<TransitionArray> array = GetTransitionArray(isolate, map);
  if (array->number_of_transitions() != number_of_transitions) {
    DCHECK_LT(array->number_of_transitions(), number_of_transitions);

    int index =
        is_special_transition
            ? array->SearchSpecial(Cast<Symbol>(*name), false, &insertion_index)
            : array->Search(details.kind(), *name, details.attributes(),
                            &insertion_index);
    CHECK_EQ(index, kNotFound);
    USE(index);
    DCHECK_GE(insertion_index, 0);
    DCHECK_LE(insertion_index, number_of_transitions);

    number_of_transitions = array->number_of_transitions();
    new_nof = number_of_transitions + 1;
    result->SetNumberOfTransitions(new_nof);
  }

  if (array->HasPrototypeTransitions()) {
    result->SetPrototypeTransitions(array->GetPrototypeTransitions());
  }
  if (array->HasSideStepTransitions()) {
    result->SetSideStepTransitions(array->GetSideStepTransitions());
  }

  DCHECK_NE(kNotFound, insertion_index);
  for (int i = 0; i < insertion_index; ++i) {
    result->Set(i, array->GetKey(i), array->GetRawTarget(i));
  }
  result->Set(insertion_index, *name, MakeWeak(*target));
  for (int i = insertion_index; i < number_of_transitions; ++i) {
    result->Set(i + 1, array->GetKey(i), array->GetRawTarget(i));
  }

  SLOW_DCHECK(result->IsSortedNoDuplicates());
  ReplaceTransitions(isolate, map, result);
}

Tagged<Map> TransitionsAccessor::SearchTransition(
    Tagged<Name> name, PropertyKind kind, PropertyAttributes attributes) {
  DCHECK(IsUniqueName(name));
  switch (encoding()) {
    case kPrototypeInfo:
    case kUninitialized:
    case kMigrationTarget:
      return Tagged<Map>();
    case kWeakRef: {
      Tagged<Map> map = Cast<Map>(raw_transitions_.GetHeapObjectAssumeWeak());
      if (!IsMatchingMap(map, name, kind, attributes)) return Tagged<Map>();
      return map;
    }
    case kFullTransitionArray: {
      base::SharedMutexGuardIf<base::kShared> scope(
          isolate_->full_transition_array_access(), concurrent_access_);
      return transitions()->SearchAndGetTarget(kind, name, attributes);
    }
  }
  UNREACHABLE();
}

Tagged<Map> TransitionsAccessor::SearchSpecial(Tagged<Symbol> name) {
  if (encoding() != kFullTransitionArray) return {};
  base::SharedMutexGuardIf<base::kShared> scope(
      isolate_->full_transition_array_access(), concurrent_access_);
  int transition = transitions()->SearchSpecial(name, concurrent_access_);
  if (transition == kNotFound) return {};
  return transitions()->GetTarget(transition);
}

// static
bool TransitionsAccessor::IsSpecialTransition(ReadOnlyRoots roots,
                                              Tagged<Name> name) {
  if (!IsSymbol(name)) return false;
  return name == roots.nonextensible_symbol() ||
         name == roots.sealed_symbol() || name == roots.frozen_symbol() ||
         name == roots.elements_transition_symbol() ||
         name == roots.strict_function_transition_symbol();
}

MaybeHandle<Map> TransitionsAccessor::FindTransitionToField(
    DirectHandle<String> name) {
  DCHECK(IsInternalizedString(*name));
  DisallowGarbageCollection no_gc;
  Tagged<Map> target = SearchTransition(*name, PropertyKind::kData, NONE);
  if (target.is_null()) return MaybeHandle<Map>();
#ifdef DEBUG
  PropertyDetails details = target->GetLastDescriptorDetails(isolate_);
  DCHECK_EQ(NONE, details.attributes());
  DCHECK_EQ(PropertyKind::kData, details.kind());
  DCHECK_EQ(PropertyLocation::kField, details.location());
#endif
  return Handle<Map>(target, isolate_);
}

void TransitionsAccessor::ForEachTransitionTo(
    Tagged<Name> name, const ForEachTransitionCallback& callback,
    DisallowGarbageCollection* no_gc) {
  DCHECK(IsUniqueName(name));
  switch (encoding()) {
    case kPrototypeInfo:
    case kUninitialized:
    case kMigrationTarget:
      return;
    case kWeakRef: {
      Tagged<Map> target =
          Cast<Map>(raw_transitions_.GetHeapObjectAssumeWeak());
      InternalIndex descriptor = target->LastAdded();
      Tagged<DescriptorArray> descriptors =
          target->instance_descriptors(kRelaxedLoad);
      Tagged<Name> key = descriptors->GetKey(descriptor);
      if (key == name) {
        callback(target);
      }
      return;
    }
    case kFullTransitionArray: {
      base::SharedMutexGuardIf<base::kShared> scope(
          isolate_->full_transition_array_access(), concurrent_access_);
      return transitions()->ForEachTransitionTo(name, callback);
    }
  }
  UNREACHABLE();
}

// static
bool TransitionsAccessor::CanHaveMoreTransitions(Isolate* isolate,
                                                 DirectHandle<Map> map) {
  if (map->is_dictionary_map()) return false;
  Tagged<MaybeObject> raw_transitions =
      map->raw_transitions(isolate, kAcquireLoad);
  if (GetEncoding(isolate, raw_transitions) == kFullTransitionArray) {
    return GetTransitionArray(isolate, raw_transitions)
               ->number_of_transitions() < kMaxNumberOfTransitions;
  }
  return true;
}

// static
bool TransitionsAccessor::IsMatchingMap(Tagged<Map> target, Tagged<Name> name,
                                        PropertyKind kind,
                                        PropertyAttributes attributes) {
  InternalIndex descriptor = target->LastAdded();
  Tagged<DescriptorArray> descriptors =
      target->instance_descriptors(kRelaxedLoad);
  Tagged<Name> key = descriptors->GetKey(descriptor);
  if (key != name) return false;
  return descriptors->GetDetails(descriptor)
      .HasKindAndAttributes(kind, attributes);
}

// static
bool TransitionArray::CompactPrototypeTransitionArray(
    Isolate* isolate, Tagged<WeakFixedArray> array) {
  const int header = kProtoTransitionHeaderSize;
  int number_of_transitions = NumberOfPrototypeTransitions(array);
  if (number_of_transitions == 0) {
    // Empty array cannot be compacted.
    return false;
  }
  int new_number_of_transitions = 0;
  for (int i = 0; i < number_of_transitions; i++) {
    Tagged<MaybeObject> target = array->get(header + i);
    DCHECK(target.IsCleared() ||
           (target.IsWeak() && IsMap(target.GetHeapObject())));
    if (!target.IsCleared()) {
      if (new_number_of_transitions != i) {
        array->set(header + new_number_of_transitions, target);
      }
      new_number_of_transitions++;
    }
  }
  // Fill slots that became free with undefined value.
  Tagged<MaybeObject> undefined = *isolate->factory()->undefined_value();
  for (int i = new_number_of_transitions; i < number_of_transitions; i++) {
    array->set(header + i, undefined);
  }
  if (number_of_transitions != new_number_of_transitions) {
    SetNumberOfPrototypeTransitions(array, new_number_of_transitions);
  }
  return new_number_of_transitions < number_of_transitions;
}

// static
Handle<WeakFixedArray> TransitionArray::GrowPrototypeTransitionArray(
    DirectHandle<WeakFixedArray> array, int new_capacity, Isolate* isolate) {
  // Grow array by factor 2 up to MaxCachedPrototypeTransitions.
  int capacity = array->length() - kProtoTransitionHeaderSize;
  new_capacity = std::min({kMaxCachedPrototypeTransitions, new_capacity});
  DCHECK_GT(new_capacity, capacity);
  int grow_by = new_capacity - capacity;
  Handle<WeakFixedArray> new_array =
      isolate->factory()->CopyWeakFixedArrayAndGrow(array, grow_by);
  if (capacity < 0) {
    // There was no prototype transitions array before, so the size
    // couldn't be copied. Initialize it explicitly.
    SetNumberOfPrototypeTransitions(*new_array, 0);
  }
  return new_array;
}

// static
bool TransitionsAccessor::PutPrototypeTransition(Isolate* isolate,
                                                 DirectHandle<Map> map,
                                                 DirectHandle<Object> prototype,
                                                 DirectHandle<Map> target_map) {
  DCHECK_IMPLIES(v8_flags.move_prototype_transitions_first,
                 IsUndefined(map->GetBackPointer()));
  DCHECK(IsMap(Cast<HeapObject>(*prototype)->map()));

  // Only the main thread should write to transition arrays.
  DCHECK_EQ(ThreadId::Current(), isolate->thread_id());

  // It's OK to read the transition array without holding the
  // full_transition_array_access lock in read mode, since this is only called
  // in the main thread, and the main thread is the only writer. In addition, we
  // shouldn't GC while holding the lock, because it will cause a deadlock if a
  // background thread is waiting for the shared mutex outside of a safepoint.

  // Don't cache prototype transition if this map is either shared, or a map of
  // a prototype.
  if (map->is_prototype_map()) return false;
  if (map->is_dictionary_map() || !v8_flags.cache_prototype_transitions)
    return false;

  const int header = TransitionArray::kProtoTransitionHeaderSize;

  DirectHandle<WeakFixedArray> cache(GetPrototypeTransitions(isolate, *map),
                                     isolate);
  int capacity = cache->length() - header;
  int transitions = TransitionArray::NumberOfPrototypeTransitions(*cache) + 1;

  if (transitions > capacity) {
    // Grow the array if compacting it doesn't free space.
    bool compacted;
    {
      base::SharedMutexGuard<base::kExclusive> lock(
          isolate->full_transition_array_access());
      DisallowGarbageCollection no_gc;
      compacted =
          TransitionArray::CompactPrototypeTransitionArray(isolate, *cache);
    }
    if (!compacted) {
      if (capacity == TransitionArray::kMaxCachedPrototypeTransitions)
        return false;

      cache = TransitionArray::GrowPrototypeTransitionArray(
          cache, 2 * transitions, isolate);
      SetPrototypeTransitions(isolate, map, cache);
    }
  }

  if (v8_flags.move_prototype_transitions_first) {
    target_map->SetBackPointer(*map);
  }

  // Reload number of transitions as they might have been compacted.
  int last = TransitionArray::NumberOfPrototypeTransitions(*cache);
  int entry = header + last;

  {
    base::SharedMutexGuard<base::kExclusive> lock(
        isolate->full_transition_array_access());
    DisallowGarbageCollection no_gc;
    cache->set(entry, MakeWeak(*target_map));
    TransitionArray::SetNumberOfPrototypeTransitions(*cache, last + 1);
  }
  return true;
}

// static
std::optional<Tagged<Map>> TransitionsAccessor::GetPrototypeTransition(
    Isolate* isolate, Tagged<Map> map, Tagged<Object> prototype) {
  DisallowGarbageCollection no_gc;
  Tagged<WeakFixedArray> cache = GetPrototypeTransitions(isolate, map);
  int length = TransitionArray::NumberOfPrototypeTransitions(cache);
  for (int i = 0; i < length; i++) {
    Tagged<MaybeObject> target =
        cache->get(TransitionArray::kProtoTransitionHeaderSize + i);
    DCHECK(target.IsWeakOrCleared());
    Tagged<HeapObject> heap_object;
    if (target.GetHeapObjectIfWeak(&heap_object)) {
      Tagged<Map> target_map = Cast<Map>(heap_object);
      if (target_map->prototype() == prototype) {
        return target_map;
      }
    }
  }
  return {};
}

// static
Tagged<WeakFixedArray> TransitionsAccessor::GetPrototypeTransitions(
    Isolate* isolate, Tagged<Map> map) {
  Tagged<MaybeObject> raw_transitions =
      map->raw_transitions(isolate, kAcquireLoad);
  if (GetEncoding(isolate, raw_transitions) != kFullTransitionArray) {
    return ReadOnlyRoots(isolate).empty_weak_fixed_array();
  }
  Tagged<TransitionArray> transition_array =
      GetTransitionArray(isolate, raw_transitions);
  if (!transition_array->HasPrototypeTransitions()) {
    return ReadOnlyRoots(isolate).empty_weak_fixed_array();
  }
  return transition_array->GetPrototypeTransitions();
}

// static
void TransitionArray::SetNumberOfPrototypeTransitions(
    Tagged<WeakFixedArray> proto_transitions, int value) {
  DCHECK_NE(proto_transitions->length(), 0);
  proto_transitions->set(kProtoTransitionNumberOfEntriesOffset,
                         Smi::FromInt(value));
}

int TransitionsAccessor::NumberOfTransitions() {
  switch (encoding()) {
    case kPrototypeInfo:
    case kUninitialized:
    case kMigrationTarget:
      return 0;
    case kWeakRef:
      return 1;
    case kFullTransitionArray:
      return transitions()->number_of_transitions();
  }
  UNREACHABLE();
}

bool TransitionsAccessor::HasPrototypeTransitions() {
  switch (encoding()) {
    case kPrototypeInfo:
    case kUninitialized:
    case kMigrationTarget:
    case kWeakRef:
      return false;
    case kFullTransitionArray:
      return transitions()->HasPrototypeTransitions();
  }
  UNREACHABLE();
}

// static
void TransitionsAccessor::SetMigrationTarget(Isolate* isolate,
                                             DirectHandle<Map> map,
                                             Tagged<Map> migration_target) {
  // We only cache the migration target for maps with empty transitions for GC's
  // sake.
  if (GetEncoding(isolate, map) != kUninitialized) return;
  DCHECK(map->is_deprecated());
  map->set_raw_transitions(migration_target, kReleaseStore);
}

Tagged<Map> TransitionsAccessor::GetMigrationTarget() {
  if (encoding() == kMigrationTarget) {
    return Cast<Map>(map_->raw_transitions(kAcquireLoad));
  }
  return Tagged<Map>();
}

// static
void TransitionsAccessor::ReplaceTransitions(
    Isolate* isolate, DirectHandle<Map> map,
    Tagged<UnionOf<TransitionArray, MaybeWeak<Map>>> new_transitions) {
#if DEBUG
  if (GetEncoding(isolate, map) == kFullTransitionArray) {
    CheckNewTransitionsAreConsistent(
        isolate, map, new_transitions.GetHeapObjectAssumeStrong());
    DCHECK_NE(GetTransitionArray(isolate, map),
              new_transitions.GetHeapObjectAssumeStrong());
  }
#endif
  map->set_raw_transitions(new_transitions, kReleaseStore);
  USE(isolate);
}

// static
void TransitionsAccessor::ReplaceTransitions(
    Isolate* isolate, DirectHandle<Map> map,
    DirectHandle<TransitionArray> new_transitions) {
  ReplaceTransitions(isolate, map, *new_transitions);
}

// static
void TransitionsAccessor::SetPrototypeTransitions(
    Isolate* isolate, DirectHandle<Map> map,
    DirectHandle<WeakFixedArray> proto_transitions) {
  EnsureHasFullTransitionArray(isolate, map);
  GetTransitionArray(isolate, map->raw_transitions(isolate, kAcquireLoad))
      ->SetPrototypeTransitions(*proto_transitions);
}

// static
void TransitionsAccessor::EnsureHasFullTransitionArray(Isolate* isolate,
                                                       DirectHandle<Map> map) {
  Encoding encoding =
      GetEncoding(isolate, map->raw_transitions(isolate, kAcquireLoad));
  if (encoding == kFullTransitionArray) return;
  int nof =
      (encoding == kUninitialized || encoding == kMigrationTarget) ? 0 : 1;
  DirectHandle<TransitionArray> result =
      isolate->factory()->NewTransitionArray(nof);
  // Reload encoding after possible GC.
  encoding = GetEncoding(isolate, map->raw_transitions(isolate, kAcquireLoad));
  if (nof == 1) {
    if (encoding == kUninitialized) {
      // If allocation caused GC and cleared the target, trim the new array.
      result->SetNumberOfTransitions(0);
    } else {
      // Otherwise populate the new array.
      Tagged<Map> target = GetSimpleTransition(isolate, map);
      Tagged<Name> key = GetSimpleTransitionKey(target);
      result->Set(0, key, MakeWeak(target));
    }
  }
  ReplaceTransitions(isolate, map, result);
}

void TransitionsAccessor::TraverseTransitionTreeInternal(
    const TraverseCallback& callback, DisallowGarbageCollection* no_gc) {
  // Mostly arbitrary but more than enough to run the test suite in static
  // memory.
  static constexpr int kStaticStackSize = 16;
  base::SmallVector<Tagged<Map>, kStaticStackSize> stack;
  stack.emplace_back(map_);

  // Pre-order iterative depth-first-search.
  while (!stack.empty()) {
    Tagged<Map> current_map = stack.back();
    stack.pop_back();

    callback(current_map);

    Tagged<MaybeObject> raw_transitions =
        current_map->raw_transitions(isolate_, kAcquireLoad);
    Encoding encoding = GetEncoding(isolate_, raw_transitions);

    switch (encoding) {
      case kPrototypeInfo:
      case kUninitialized:
      case kMigrationTarget:
        break;
      case kWeakRef: {
        stack.emplace_back(
            Cast<Map>(raw_transitions.GetHeapObjectAssumeWeak()));
        break;
      }
      case kFullTransitionArray: {
        Tagged<TransitionArray> transitions =
            Cast<TransitionArray>(raw_transitions.GetHeapObjectAssumeStrong());
        if (transitions->HasPrototypeTransitions()) {
          Tagged<WeakFixedArray> proto_trans =
              transitions->GetPrototypeTransitions();
          int length =
              TransitionArray::NumberOfPrototypeTransitions(proto_trans);
          for (int i = 0; i < length; ++i) {
            int index = TransitionArray::kProtoTransitionHeaderSize + i;
            Tagged<MaybeObject> target = proto_trans->get(index);
            Tagged<HeapObject> heap_object;
            if (target.GetHeapObjectIfWeak(&heap_object)) {
              stack.emplace_back(Cast<Map>(heap_object));
            } else {
              DCHECK(target.IsCleared());
            }
          }
        }
        ReadOnlyRoots roots(isolate_);
        for (int i = 0; i < transitions->number_of_transitions(); ++i) {
          stack.emplace_back(transitions->GetTarget(i));
        }
        break;
      }
    }
  }
}

#ifdef DEBUG
// static
void TransitionsAccessor::CheckNewTransitionsAreConsistent(
    Isolate* isolate, DirectHandle<Map> map, Tagged<Object> transitions) {
  // This function only handles full transition arrays.
  Tagged<TransitionArray> old_transitions = GetTransitionArray(isolate, map);
  DCHECK_EQ(kFullTransitionArray, GetEncoding(isolate, old_transitions));
  Tagged<TransitionArray> new_transitions = Cast<TransitionArray>(transitions);
  ReadOnlyRoots roots(isolate);
  for (int i = 0; i < old_transitions->number_of_transitions(); i++) {
    Tagged<Map> target;
    if (old_transitions->GetTargetIfExists(i, isolate, &target)) {
      if (target->instance_descriptors(isolate) ==
          map->instance_descriptors(isolate)) {
        Tagged<Name> key = old_transitions->GetKey(i);
        int new_target_index;
        if (IsSpecialTransition(roots, key)) {
          new_target_index = new_transitions->SearchSpecial(Cast<Symbol>(key));
        } else {
          PropertyDetails details = GetTargetDetails(key, target);
          new_target_index = new_transitions->Search(details.kind(), key,
                                                     details.attributes());
        }
        DCHECK_NE(TransitionArray::kNotFound, new_target_index);
        DCHECK_EQ(target, new_transitions->GetTarget(new_target_index));
      }
    } else {
      DCHECK(IsSpecialTransition(roots, old_transitions->GetKey(i)));
    }
  }
}
#endif

// Private non-static helper functions (operating on full transition arrays).

int TransitionArray::SearchDetails(int transition, PropertyKind kind,
                                   PropertyAttributes attributes,
                                   int* out_insertion_index) {
  int nof_transitions = number_of_transitions();
  DCHECK(transition < nof_transitions);
  Tagged<Name> key = GetKey(transition);
  for (; transition < nof_transitions && GetKey(transition) == key;
       transition++) {
    Tagged<Map> target = GetTarget(transition);
    PropertyDetails target_details =
        TransitionsAccessor::GetTargetDetails(key, target);

    int cmp = CompareDetails(kind, attributes, target_details.kind(),
                             target_details.attributes());
    if (cmp == 0) {
      return transition;
    } else if (cmp < 0) {
      break;
    }
  }
  if (out_insertion_index != nullptr) *out_insertion_index = transition;
  return kNotFound;
}

Tagged<Map> TransitionArray::SearchDetailsAndGetTarget(
    int transition, PropertyKind kind, PropertyAttributes attributes) {
  int nof_transitions = number_of_transitions();
  DCHECK(transition < nof_transitions);
  Tagged<Name> key = GetKey(transition);
  for (; transition < nof_transitions && GetKey(transition) == key;
       transition++) {
    Tagged<Map> target = GetTarget(transition);
    PropertyDetails target_details =
        TransitionsAccessor::GetTargetDetails(key, target);

    int cmp = CompareDetails(kind, attributes, target_details.kind(),
                             target_details.attributes());
    if (cmp == 0) {
      return target;
    } else if (cmp < 0) {
      break;
    }
  }
  return Tagged<Map>();
}

int TransitionArray::Search(PropertyKind kind, Tagged<Name> name,
                            PropertyAttributes attributes,
                            int* out_insertion_index) {
  int transition = SearchName(name, false, out_insertion_index);
  if (transition == kNotFound) return kNotFound;
  return SearchDetails(transition, kind, attributes, out_insertion_index);
}

Tagged<Map> TransitionArray::SearchAndGetTarget(PropertyKind kind,
                                                Tagged<Name> name,
                                                PropertyAttributes attributes) {
  int transition = SearchName(name);
  if (transition == kNotFound) {
    return Tagged<Map>();
  }
  return SearchDetailsAndGetTarget(transition, kind, attributes);
}

void TransitionArray::ForEachTransitionTo(
    Tagged<Name> name, const ForEachTransitionCallback& callback) {
  int transition = SearchName(name);
  if (transition == kNotFound) return;

  int nof_transitions = number_of_transitions();
  DCHECK(transition < nof_transitions);
  Tagged<Name> key = GetKey(transition);
  for (; transition < nof_transitions && GetKey(transition) == key;
       transition++) {
    Tagged<Map> target = GetTarget(transition);
    callback(target);
  }
}

void TransitionArray::Sort() {
  DisallowGarbageCollection no_gc;
  // In-place insertion sort.
  int length = number_of_transitions();
  ReadOnlyRoots roots = GetReadOnlyRoots();
  for (int i = 1; i < length; i++) {
    Tagged<Name> key = GetKey(i);
    Tagged<MaybeObject> target = GetRawTarget(i);
    PropertyKind kind = PropertyKind::kData;
    PropertyAttributes attributes = NONE;
    if (!TransitionsAccessor::IsSpecialTransition(roots, key)) {
      Tagged<Map> target_map = TransitionsAccessor::GetTargetFromRaw(target);
      PropertyDetails details =
          TransitionsAccessor::GetTargetDetails(key, target_map);
      kind = details.kind();
      attributes = details.attributes();
    }
    int j;
    for (j = i - 1; j >= 0; j--) {
      Tagged<Name> temp_key = GetKey(j);
      Tagged<MaybeObject> temp_target = GetRawTarget(j);
      PropertyKind temp_kind = PropertyKind::kData;
      PropertyAttributes temp_attributes = NONE;
      if (!TransitionsAccessor::IsSpecialTransition(roots, temp_key)) {
        Tagged<Map> temp_target_map =
            TransitionsAccessor::GetTargetFromRaw(temp_target);
        PropertyDetails details =
            TransitionsAccessor::GetTargetDetails(temp_key, temp_target_map);
        temp_kind = details.kind();
        temp_attributes = details.attributes();
      }
      int cmp =
          CompareKeys(temp_key, temp_key->hash(), temp_kind, temp_attributes,
                      key, key->hash(), kind, attributes);
      if (cmp > 0) {
        SetKey(j + 1, temp_key);
        SetRawTarget(j + 1, temp_target);
      } else {
        break;
      }
    }
    SetKey(j + 1, key);
    SetRawTarget(j + 1, target);
  }
  DCHECK(IsSortedNoDuplicates());
}

bool TransitionsAccessor::HasIntegrityLevelTransitionTo(
    Tagged<Map> to, Tagged<Symbol>* out_symbol,
    PropertyAttributes* out_integrity_level) {
  ReadOnlyRoots roots(isolate_);
  if (SearchSpecial(roots.frozen_symbol()) == to) {
    if (out_integrity_level) *out_integrity_level = FROZEN;
    if (out_symbol) *out_symbol = roots.frozen_symbol();
  } else if (SearchSpecial(roots.sealed_symbol()) == to) {
    if (out_integrity_level) *out_integrity_level = SEALED;
    if (out_symbol) *out_symbol = roots.sealed_symbol();
  } else if (SearchSpecial(roots.nonextensible_symbol()) == to) {
    if (out_integrity_level) *out_integrity_level = NONE;
    if (out_symbol) *out_symbol = roots.nonextensible_symbol();
  } else {
    return false;
  }
  return true;
}

// static
void TransitionsAccessor::EnsureHasSideStepTransitions(Isolate* isolate,
                                                       DirectHandle<Map> map) {
  EnsureHasFullTransitionArray(isolate, map);
  Tagged<TransitionArray> transitions =
      GetTransitionArray(isolate, map->raw_transitions());
  if (transitions->HasSideStepTransitions()) return;
  TransitionArray::CreateSideStepTransitions(
      isolate, direct_handle(transitions, isolate));
}

// static
void TransitionArray::CreateSideStepTransitions(
    Isolate* isolate, DirectHandle<TransitionArray> transitions) {
  DCHECK(!transitions->HasSideStepTransitions());  // Callers must check first.
  DirectHandle<WeakFixedArray> result = WeakFixedArray::New(
      isolate, SideStepTransition::kSize, AllocationType::kYoung,
      direct_handle(SideStepTransition::Empty, isolate));
  transitions->SetSideStepTransitions(*result);
}

std::ostream& operator<<(std::ostream& os, SideStepTransition::Kind sidestep) {
  switch (sidestep) {
    case SideStepTransition::Kind::kObjectAssignValidityCell:
      os << "Object.assign-validity-cell";
      break;
    case SideStepTransition::Kind::kObjectAssign:
      os << "Object.assign-map";
      break;
    case SideStepTransition::Kind::kCloneObject:
      os << "Clone-object-IC-map";
      break;
  }
  return os;
}

}  // namespace v8::internal
[Step 19: Duration 19.21 seconds| Input tokens: 366,455 | Output tokens: 8,722]
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ Step 20 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'ripgrep' with arguments: {'pattern': 'FindTransitionTo', 'options': '-n --hidden --no-ignore-vcs ./objects'}                                                                                  │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
Command: cd /Users/tarun/v8/v8/src && rg -n --hidden --no-ignore-vcs ./objects 'FindTransitionTo' | head -n 1000
Observations: rg: FindTransitionTo: IO error for operation on FindTransitionTo: No such file or directory (os error 2)
[Step 20: Duration 24.22 seconds| Input tokens: 411,172 | Output tokens: 9,594]
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ Step 21 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'fuzzy_finder' with arguments: {'pattern': 'objects/transitions.cc'}                                                                                                                           │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'fuzzy_finder' with arguments: {'pattern': 'objects/transitions.h'}                                                                                                                            │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'fuzzy_finder' with arguments: {'pattern': 'objects/map-inl.h'}                                                                                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
Command: cd /Users/tarun/v8/v8/src && rg --hidden --no-follow --no-ignore-vcs --files 2>/dev/null | fzf  'objects/transitions.cc' | head -n 1000
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'fuzzy_finder' with arguments: {'pattern': 'objects/map.cc'}                                                                                                                                   │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
Command: cd /Users/tarun/v8/v8/src && rg --hidden --no-follow --no-ignore-vcs --files 2>/dev/null | fzf  'objects/transitions.h' | head -n 1000
Command: cd /Users/tarun/v8/v8/src && rg --hidden --no-follow --no-ignore-vcs --files 2>/dev/null | fzf  'objects/transitions.h' | head -n 1000
Command: cd /Users/tarun/v8/v8/src && rg --hidden --no-follow --no-ignore-vcs --files 2>/dev/null | fzf  'objects/map-inl.h' | head -n 1000
Observations: unknown option: objects/transitions.cc
Observations: unknown option: objects/transitions.h
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'fuzzy_finder' with arguments: {'pattern': 'objects/transitions-inl.h'}                                                                                                                        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'fuzzy_finder' with arguments: {'pattern': 'objects/js-objects.cc'}                                                                                                                            │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'fuzzy_finder' with arguments: {'pattern': 'objects/property-details.h'}                                                                                                                       │
Command: cd /Users/tarun/v8/v8/src && rg --hidden --no-follow --no-ignore-vcs --files 2>/dev/null | fzf  'objects/map.cc' | head -n 1000
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯

Observations: unknown option: objects/map-inl.h
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
Command: cd /Users/tarun/v8/v8/src && rg --hidden --no-follow --no-ignore-vcs --files 2>/dev/null | fzf  'objects/js-objects.cc' | head -n 1000Command: cd /Users/tarun/v8/v8/src && rg --hidden --no-follow --no-ignore-vcs --files 2>/dev/null | fzf  'objects/transitions-inl.h' | head -n 1000
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
│ Calling tool: 'fuzzy_finder' with arguments: {'pattern': 'objects/map.h'}                                                                                                                                    │
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'fuzzy_finder' with arguments: {'pattern': 'objects/descriptor-array-inl.h'}                                                                                                                   │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
Command: cd /Users/tarun/v8/v8/src && rg --hidden --no-follow --no-ignore-vcs --files 2>/dev/null | fzf  'objects/property-details.h' | head -n 1000
Observations: unknown option: objects/map.cc


Command: cd /Users/tarun/v8/v8/src && rg --hidden --no-follow --no-ignore-vcs --files 2>/dev/null | fzf  'objects/descriptor-array-inl.h' | head -n 1000
Observations: unknown option: objects/property-details.h
Observations: unknown option: objects/js-objects.cc
Observations: unknown option: objects/transitions-inl.h
Observations: unknown option: objects/descriptor-array-inl.h
Command: cd /Users/tarun/v8/v8/src && rg --hidden --no-follow --no-ignore-vcs --files 2>/dev/null | fzf  'objects/map.h' | head -n 1000
Observations: unknown option: objects/map.h
[Step 21: Duration 23.32 seconds| Input tokens: 456,676 | Output tokens: 10,435]
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ Step 22 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'ripgrep' with arguments: {'pattern':                                                                                                                                                          │
│ 'FindTransitionTo(Field|Accessor)|DeprecateTransitions?|New(Field|DataProperty)|ReplaceTransitionTo(DataProperty|DataField)|AddTransition|TransitionArray|Diverge|PlusOne', 'options': '-n                   │
│ objects/transitions.cc objects/transitions.h objects/transitions-inl.h objects/map-inl.h objects/map.cc objects/map.h objects/js-objects.cc'}                                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
Command: cd /Users/tarun/v8/v8/src && rg -n objects/transitions.cc objects/transitions.h objects/transitions-inl.h objects/map-inl.h objects/map.cc objects/map.h objects/js-objects.cc 'FindTransitionTo(Field|Accessor)|DeprecateTransitions?|New(Field|DataProperty)|ReplaceTransitionTo(DataProperty|DataField)|AddTransition|TransitionArray|Diverge|PlusOne' | head -n 1000
Observations: rg: FindTransitionTo(Field|Accessor)|DeprecateTransitions?|New(Field|DataProperty)|ReplaceTransitionTo(DataProperty|DataField)|AddTransition|TransitionArray|Diverge|PlusOne: No such file or 
directory (os error 2)
[Step 22: Duration 11.75 seconds| Input tokens: 508,749 | Output tokens: 10,916]
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ Step 23 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'fuzzy_finder' with arguments: {'pattern': 'objects/transitions.cc', 'options': '--filter=objects/transitions.cc'}                                                                             │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'fuzzy_finder' with arguments: {'pattern': 'objects/transitions-inl.h', 'options': '--filter=objects/transitions-inl.h'}                                                                       │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
Command: cd /Users/tarun/v8/v8/src && rg --hidden --no-follow --no-ignore-vcs --files 2>/dev/null | fzf --filter=objects/transitions.cc 'objects/transitions.cc' | head -n 1000
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'fuzzy_finder' with arguments: {'pattern': 'objects/transitions.h', 'options': '--filter=objects/transitions.h'}                                                                               │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'fuzzy_finder' with arguments: {'pattern': 'objects/map.cc', 'options': '--filter=objects/map.cc'}                                                                                             │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
Command: cd /Users/tarun/v8/v8/src && rg --hidden --no-follow --no-ignore-vcs --files 2>/dev/null | fzf --filter=objects/transitions-inl.h 'objects/transitions-inl.h' | head -n 1000
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'fuzzy_finder' with arguments: {'pattern': 'objects/map.h', 'options': '--filter=objects/map.h'}                                                                                               │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
Command: cd /Users/tarun/v8/v8/src && rg --hidden --no-follow --no-ignore-vcs --files 2>/dev/null | fzf --filter=objects/transitions.h 'objects/transitions.h' | head -n 1000
Observations: unknown option: objects/transitions.cc
Command: cd /Users/tarun/v8/v8/src && rg --hidden --no-follow --no-ignore-vcs --files 2>/dev/null | fzf --filter=objects/map.cc 'objects/map.cc' | head -n 1000
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'fuzzy_finder' with arguments: {'pattern': 'objects/map-inl.h', 'options': '--filter=objects/map-inl.h'}                                                                                       │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
Observations: unknown option: objects/transitions-inl.h
Command: cd /Users/tarun/v8/v8/src && rg --hidden --no-follow --no-ignore-vcs --files 2>/dev/null | fzf --filter=objects/map.h 'objects/map.h' | head -n 1000
Observations: unknown option: objects/transitions.h
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'fuzzy_finder' with arguments: {'pattern': 'objects/js-objects.cc', 'options': '--filter=objects/js-objects.cc'}                                                                               │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
Observations: unknown option: objects/map.cc
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'fuzzy_finder' with arguments: {'pattern': 'objects/js-objects-inl.h', 'options': '--filter=objects/js-objects-inl.h'}                                                                         │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'fuzzy_finder' with arguments: {'pattern': 'objects/property-details.h', 'options': '--filter=objects/property-details.h'}                                                                     │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'fuzzy_finder' with arguments: {'pattern': 'objects/descriptor-array-inl.h', 'options': '--filter=objects/descriptor-array-inl.h'}                                                             │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
Command: cd /Users/tarun/v8/v8/src && rg --hidden --no-follow --no-ignore-vcs --files 2>/dev/null | fzf --filter=objects/js-objects.cc 'objects/js-objects.cc' | head -n 1000
Command: cd /Users/tarun/v8/v8/src && rg --hidden --no-follow --no-ignore-vcs --files 2>/dev/null | fzf --filter=objects/js-objects-inl.h 'objects/js-objects-inl.h' | head -n 1000
Command: cd /Users/tarun/v8/v8/src && rg --hidden --no-follow --no-ignore-vcs --files 2>/dev/null | fzf --filter=objects/map-inl.h 'objects/map-inl.h' | head -n 1000
│ Calling tool: 'fuzzy_finder' with arguments: {'pattern': 'objects/descriptor-array.h', 'options': '--filter=objects/descriptor-array.h'}                                                                     │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
Command: cd /Users/tarun/v8/v8/src && rg --hidden --no-follow --no-ignore-vcs --files 2>/dev/null | fzf --filter=objects/property-details.h 'objects/property-details.h' | head -n 1000
Command: cd /Users/tarun/v8/v8/src && rg --hidden --no-follow --no-ignore-vcs --files 2>/dev/null | fzf --filter=objects/property-details.h 'objects/property-details.h' | head -n 1000
Observations: unknown option: objects/map.h
Command: cd /Users/tarun/v8/v8/src && rg --hidden --no-follow --no-ignore-vcs --files 2>/dev/null | fzf --filter=objects/descriptor-array-inl.h 'objects/descriptor-array-inl.h' | head -n 1000
Observations: unknown option: objects/js-objects.cc
Observations: unknown option: objects/js-objects-inl.h
Observations: unknown option: objects/map-inl.h
Observations: unknown option: objects/property-details.h
Observations: unknown option: objects/descriptor-array-inl.h
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'read_file' with arguments: {'file_path': '/Users/tarun/v8/v8/src/objects/transitions.h'}                                                                                                      │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
Command: cd /Users/tarun/v8/v8/src && rg --hidden --no-follow --no-ignore-vcs --files 2>/dev/null | fzf --filter=objects/descriptor-array.h 'objects/descriptor-array.h' | head -n 1000
Observations: unknown option: objects/descriptor-array.h
[Step 23: Duration 22.13 seconds| Input tokens: 560,646 | Output tokens: 11,854]
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ Step 24 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
Command: cd /Users/tarun/v8/v8/src && wc -l '/Users/tarun/v8/v8/src/objects/transitions.h'
Command: cd /Users/tarun/v8/v8/src && cat '/Users/tarun/v8/v8/src/objects/transitions.h'
Observations: // Copyright 2012 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef V8_OBJECTS_TRANSITIONS_H_
#define V8_OBJECTS_TRANSITIONS_H_

#include <optional>

#include "src/common/checks.h"
#include "src/execution/isolate.h"
#include "src/objects/descriptor-array.h"
#include "src/objects/elements-kind.h"
#include "src/objects/map.h"
#include "src/objects/maybe-object.h"
#include "src/objects/name.h"
#include "src/objects/objects.h"

// Has to be the last include (doesn't have include guards):
#include "src/objects/object-macros.h"

namespace v8::internal {

// Find all transitions with given name and calls the callback.
using ForEachTransitionCallback = std::function<void(Tagged<Map>)>;

// Descriptor for the contents of special side-step transition arrays.
// Side-step transitions are accessed through the TransitionsAccessor which
// enforces adherence to this format. The entries are either weak, Empty, or
// Unreachable.
struct SideStepTransition {
  enum class Kind : uint32_t {
    kCloneObject,
    kObjectAssign,
    kObjectAssignValidityCell,
  };
  static constexpr uint32_t kSize =
      static_cast<uint32_t>(Kind::kObjectAssignValidityCell) + 1;

  static constexpr Tagged<Smi> Empty = Smi::FromInt(0);
  static constexpr Tagged<Smi> Unreachable = Smi::FromInt(1);

 private:
  static constexpr int index_of(Kind kind) {
    return static_cast<uint32_t>(kind);
  }
  static constexpr uint32_t kFirstMapIdx =
      static_cast<uint32_t>(Kind::kCloneObject);
  static constexpr uint32_t kLastMapIdx =
      static_cast<uint32_t>(Kind::kObjectAssign);
  friend class TransitionsAccessor;
  friend class TransitionArray;
  friend class ObjectAssignAssembler;
};

std::ostream& operator<<(std::ostream& os, SideStepTransition::Kind sidestep);

// TransitionsAccessor is a helper class to encapsulate access to the various
// ways a Map can store transitions to other maps in its respective field at
// Map::kTransitionsOrPrototypeInfo.
// It caches state information internally, which becomes stale when a Map's
// transitions storage changes or when a GC cycle clears dead transitions;
// so while a TransitionsAccessor instance can be used for several read-only
// operations in a row (provided no GC happens between them), it must be
// discarded and recreated after "Insert" and "UpdateHandler" operations.
//
// Internal details: a Map's field either holds an in-place weak reference to a
// transition target, or a StoreIC handler for a transitioning store (which in
// turn points to its target map), or a TransitionArray for several target maps
// and/or handlers as well as prototype and ElementsKind transitions.  Property
// details (and in case of inline target storage, the key) are retrieved from
// the target map's descriptor array.  Stored transitions are weak in the GC
// sense: both single transitions stored inline and TransitionArray fields are
// cleared when the map they refer to is not otherwise reachable.
class V8_EXPORT_PRIVATE TransitionsAccessor {
 public:
  // {concurrent_access} signals that the TransitionsAccessor will only be used
  // in background threads. It acquires a reader lock for critical paths, as
  // well as blocking the accessor from modifying the TransitionsArray.
  inline TransitionsAccessor(Isolate* isolate, Tagged<Map> map,
                             bool concurrent_access = false);

  // Insert a new transition into |map|'s transition array, extending it
  // as necessary. This can trigger GC.
  static void Insert(Isolate* isolate, DirectHandle<Map> map,
                     DirectHandle<Name> name, DirectHandle<Map> target,
                     TransitionKindFlag flag) {
    InsertHelper(isolate, map, name, DirectHandle<Map>(target), flag);
  }
  static void InsertNoneSentinel(Isolate* isolate, DirectHandle<Map> map,
                                 DirectHandle<Name> name) {
    InsertHelper(isolate, map, name, DirectHandle<Map>(),
                 TransitionKindFlag::SPECIAL_TRANSITION);
  }

  Tagged<Map> SearchTransition(Tagged<Name> name, PropertyKind kind,
                               PropertyAttributes attributes);
  static inline MaybeHandle<Map> SearchTransition(
      Isolate* isolate, DirectHandle<Map> map, Tagged<Name> name,
      PropertyKind kind, PropertyAttributes attributes);

  // Searches for a transition with a special symbol.
  Tagged<Map> SearchSpecial(Tagged<Symbol> name);
  static inline MaybeHandle<Map> SearchSpecial(Isolate* isolate,
                                               DirectHandle<Map> map,
                                               Tagged<Symbol> name);

  // Returns true for non-property transitions like elements kind, or
  // or frozen/sealed transitions.
  static bool IsSpecialTransition(ReadOnlyRoots roots, Tagged<Name> name);

  MaybeHandle<Map> FindTransitionToField(DirectHandle<String> name);

  // Find all transitions with given name and calls the callback.
  // Neither GCs nor operations requiring Isolate::full_transition_array_access
  // lock are allowed inside the callback.
  // If any of the GC- or lock-requiring processing is necessary, it has to be
  // done outside of the callback.
  void ForEachTransitionTo(Tagged<Name> name,
                           const ForEachTransitionCallback& callback,
                           DisallowGarbageCollection* no_gc);

  template <typename Char>
  inline bool IsExpectedTransition(Tagged<Name> transition_name,
                                   Tagged<Map> transition_target,
                                   base::Vector<const Char> key_chars);

  template <typename Char>
  inline std::pair<Handle<String>, Handle<Map>> ExpectedTransition(
      base::Vector<const Char> key_chars);

  template <typename Callback, typename ProtoCallback,
            typename SideStepCallback>
  void ForEachTransition(DisallowGarbageCollection* no_gc, Callback callback,
                         ProtoCallback proto_transition_callback,
                         SideStepCallback side_step_transition_callback) {
    ForEachTransitionWithKey<Callback, ProtoCallback, SideStepCallback, false>(
        no_gc, callback, proto_transition_callback,
        side_step_transition_callback);
  }

  template <typename Callback, typename ProtoCallback,
            typename SideStepCallback, bool with_key = true>
  void ForEachTransitionWithKey(DisallowGarbageCollection* no_gc,
                                Callback callback,
                                ProtoCallback proto_transition_callback,
                                SideStepCallback side_step_transition_callback);

  int NumberOfTransitions();
  // The size of transition arrays are limited so they do not end up in large
  // object space. Otherwise ClearNonLiveReferences would leak memory while
  // applying in-place right trimming.
  static const int kMaxNumberOfTransitions = 1024 + 512;
  inline Tagged<Name> GetKey(int transition_number);
  inline Tagged<Map> GetTarget(int transition_number);
  static inline PropertyDetails GetTargetDetails(Tagged<Name> name,
                                                 Tagged<Map> target);

  static bool CanHaveMoreTransitions(Isolate* isolate, DirectHandle<Map> map);

  static bool IsMatchingMap(Tagged<Map> target, Tagged<Name> name,
                            PropertyKind kind, PropertyAttributes attributes);

  bool HasIntegrityLevelTransitionTo(
      Tagged<Map> to, Tagged<Symbol>* out_symbol = nullptr,
      PropertyAttributes* out_integrity_level = nullptr);

  // ===== ITERATION =====
  using TraverseCallback = std::function<void(Tagged<Map>)>;

  // Traverse the transition tree in preorder.
  void TraverseTransitionTree(const TraverseCallback& callback) {
    // Make sure that we do not allocate in the callback.
    DisallowGarbageCollection no_gc;
    base::SharedMutexGuardIf<base::kShared> scope(
        isolate_->full_transition_array_access(), concurrent_access_);
    TraverseTransitionTreeInternal(callback, &no_gc);
  }

  // ===== PROTOTYPE TRANSITIONS =====
  // When you set the prototype of an object using the __proto__ accessor you
  // need a new map for the object (the prototype is stored in the map).  In
  // order not to multiply maps unnecessarily we store these as transitions in
  // the original map.  That way we can transition to the same map if the same
  // prototype is set, rather than creating a new map every time.  The
  // transitions are in the form of a map where the keys are prototype objects
  // and the values are the maps they transition to.
  // PutPrototypeTransition can trigger GC.
  static bool PutPrototypeTransition(Isolate* isolate, DirectHandle<Map>,
                                     DirectHandle<Object> prototype,
                                     DirectHandle<Map> target_map);
  static std::optional<Tagged<Map>> GetPrototypeTransition(
      Isolate* isolate, Tagged<Map> map, Tagged<Object> prototype);
  bool HasPrototypeTransitions();

  // During the first-time Map::Update and Map::TryUpdate, the migration target
  // map could be cached in the raw_transitions slot of the old map that is
  // deprecated from the map transition tree. The next time old map is updated,
  // we will check this cache slot as a shortcut to get the migration target
  // map.
  static void SetMigrationTarget(Isolate* isolate, DirectHandle<Map> map,
                                 Tagged<Map> migration_target);
  Tagged<Map> GetMigrationTarget();

  inline bool HasSideStepTransitions();
  static void EnsureHasSideStepTransitions(Isolate* isolate,
                                           DirectHandle<Map> map);
  inline Tagged<Object> GetSideStepTransition(SideStepTransition::Kind i);
  inline void SetSideStepTransition(SideStepTransition::Kind i,
                                    Tagged<Object> target);

#if DEBUG || OBJECT_PRINT
  void PrintTransitions(std::ostream& os);
  static void PrintOneTransition(std::ostream& os, Tagged<Name> key,
                                 Tagged<Map> target);
  void PrintTransitionTree();
  void PrintTransitionTree(std::ostream& os, int level,
                           DisallowGarbageCollection* no_gc);
#endif
#if DEBUG
  static void CheckNewTransitionsAreConsistent(Isolate* isolate,
                                               DirectHandle<Map> map,
                                               Tagged<Object> transitions);
  bool IsConsistentWithBackPointers();
  bool IsSortedNoDuplicates();
#endif

 protected:
  // Allow tests to use inheritance to access internals.
  enum Encoding {
    kPrototypeInfo,
    kUninitialized,
    kMigrationTarget,
    kWeakRef,
    kFullTransitionArray,
  };

  inline Encoding encoding() { return encoding_; }

  inline int Capacity();

  inline Tagged<TransitionArray> transitions();

  DISALLOW_GARBAGE_COLLECTION(no_gc_)

 private:
  friend class MarkCompactCollector;  // For HasSimpleTransitionTo.
  friend class TransitionArray;

  static inline Encoding GetEncoding(Isolate* isolate,
                                     Tagged<MaybeObject> raw_transitions);
  static inline Encoding GetEncoding(Isolate* isolate,
                                     Tagged<TransitionArray> array);
  static inline Encoding GetEncoding(Isolate* isolate, DirectHandle<Map> map);

  static inline Tagged<TransitionArray> GetTransitionArray(
      Isolate* isolate, Tagged<MaybeObject> raw_transitions);
  static inline Tagged<TransitionArray> GetTransitionArray(
      Isolate* isolate, DirectHandle<Map> map);

  static inline Tagged<Map> GetSimpleTransition(Isolate* isolate,
                                                DirectHandle<Map> map);
  static inline Tagged<Name> GetSimpleTransitionKey(Tagged<Map> transition);
  inline PropertyDetails GetSimpleTargetDetails(Tagged<Map> transition);

  static inline Tagged<Map> GetTargetFromRaw(Tagged<MaybeObject> raw);

  static void EnsureHasFullTransitionArray(Isolate* isolate,
                                           DirectHandle<Map> map);
  static void SetPrototypeTransitions(
      Isolate* isolate, DirectHandle<Map> map,
      DirectHandle<WeakFixedArray> proto_transitions);
  static Tagged<WeakFixedArray> GetPrototypeTransitions(Isolate* isolate,
                                                        Tagged<Map> map);

  static void InsertHelper(Isolate* isolate, DirectHandle<Map> map,
                           DirectHandle<Name> name, DirectHandle<Map> target,
                           TransitionKindFlag flag);

  static inline void ReplaceTransitions(
      Isolate* isolate, DirectHandle<Map> map,
      Tagged<UnionOf<TransitionArray, MaybeWeak<Map>>> new_transitions);
  static inline void ReplaceTransitions(
      Isolate* isolate, DirectHandle<Map> map,
      DirectHandle<TransitionArray> new_transitions);

  bool HasSimpleTransitionTo(Tagged<Map> map);

  inline Tagged<Map> GetTargetMapFromWeakRef();

  void TraverseTransitionTreeInternal(const TraverseCallback& callback,
                                      DisallowGarbageCollection* no_gc);

  Isolate* isolate_;
  Tagged<Map> map_;
  Tagged<MaybeObject> raw_transitions_;
  Encoding encoding_;
  bool concurrent_access_;

  DISALLOW_IMPLICIT_CONSTRUCTORS(TransitionsAccessor);
};

// TransitionArrays are fixed arrays used to hold map transitions for property,
// constant, and element changes.
// The TransitionArray class exposes a very low-level interface. Most clients
// should use TransitionsAccessors.
// TransitionArrays have the following format:
// |0] Tagged<Smi>(0) or WeakFixedArray of prototype transitions (strong ref)
// |1] Tagged<Smi>(0) or WeakFixedArray of side-step transitions (strong ref)
// |2] Number of transitions (can be zero after trimming)
// |3] First transition key (strong ref)
// |4] First transition target (weak ref)
// ...
// |4 + number of transitions * kTransitionSize]: start of slack
// TODO(olivf): The slots for prototype transitions and side-steps could be
// shared.
class TransitionArray : public WeakFixedArray {
 public:
  inline int number_of_transitions() const;

  inline Tagged<WeakFixedArray> GetPrototypeTransitions();
  inline bool HasPrototypeTransitions();

  // Accessors for fetching instance transition at transition number.
  inline void SetKey(int transition_number, Tagged<Name> value);
  inline Tagged<Name> GetKey(int transition_number);
  inline HeapObjectSlot GetKeySlot(int transition_number);

  inline Tagged<Map> GetTarget(int transition_number);
  inline void SetRawTarget(int transition_number, Tagged<MaybeObject> target);
  inline Tagged<MaybeObject> GetRawTarget(int transition_number);
  inline HeapObjectSlot GetTargetSlot(int transition_number);
  inline bool GetTargetIfExists(int transition_number, Isolate* isolate,
                                Tagged<Map>* target);

  static constexpr int kNotFound = -1;

#ifdef DEBUG
  V8_EXPORT_PRIVATE bool IsSortedNoDuplicates();
#endif

  V8_EXPORT_PRIVATE void Sort();

  void PrintInternal(std::ostream& os);

  DECL_PRINTER(TransitionArray)
  DECL_VERIFIER(TransitionArray)

  // Layout for full transition arrays.
  static const int kPrototypeTransitionsIndex = 0;
  static const int kSideStepTransitionsIndex = 1;
  static const int kTransitionLengthIndex = 2;
  static const int kFirstIndex = 3;

  // Layout of map transition entries in full transition arrays.
  static const int kEntryKeyIndex = 0;
  static const int kEntryTargetIndex = 1;
  static const int kEntrySize = 2;

  // Conversion from transition number to array indices.
  static int ToKeyIndex(int transition_number) {
    return kFirstIndex + (transition_number * kEntrySize) + kEntryKeyIndex;
  }

  static int ToTargetIndex(int transition_number) {
    return kFirstIndex + (transition_number * kEntrySize) + kEntryTargetIndex;
  }

  inline int SearchNameForTesting(Tagged<Name> name,
                                  int* out_insertion_index = nullptr);

  inline Tagged<Map> SearchAndGetTargetForTesting(
      PropertyKind kind, Tagged<Name> name, PropertyAttributes attributes);

  // Accessors for side-step transitions.
  inline bool HasSideStepTransitions();
  static void CreateSideStepTransitions(
      Isolate* isolate, DirectHandle<TransitionArray> transitions);

 private:
  friend class Factory;
  friend class MarkCompactCollector;
  friend class TransitionsAccessor;

  inline void SetNumberOfTransitions(int number_of_transitions);

  inline int Capacity();

  // ===== PROTOTYPE TRANSITIONS =====
  // Cache format:
  //    0: finger - index of the first free cell in the cache
  //    1 + i: target map
  static const int kProtoTransitionHeaderSize = 1;
  static const int kMaxCachedPrototypeTransitions = 256;

  inline void SetPrototypeTransitions(
      Tagged<WeakFixedArray> prototype_transitions);

  static inline int NumberOfPrototypeTransitions(
      Tagged<WeakFixedArray> proto_transitions);
  static void SetNumberOfPrototypeTransitions(
      Tagged<WeakFixedArray> proto_transitions, int value);

  static const int kProtoTransitionNumberOfEntriesOffset = 0;
  static_assert(kProtoTransitionHeaderSize == 1);

  // Returns the fixed array length required to hold number_of_transitions
  // transitions.
  static int LengthFor(int number_of_transitions) {
    return ToKeyIndex(number_of_transitions);
  }

  // Search a  transition for a given kind, property name and attributes.
  int Search(PropertyKind kind, Tagged<Name> name,
             PropertyAttributes attributes, int* out_insertion_index = nullptr);

  V8_EXPORT_PRIVATE Tagged<Map> SearchAndGetTarget(
      PropertyKind kind, Tagged<Name> name, PropertyAttributes attributes);

  // Search a non-property transition (like elements kind, observe or frozen
  // transitions).
  inline int SearchSpecial(Tagged<Symbol> symbol,
                           bool concurrent_search = false,
                           int* out_insertion_index = nullptr);
  // Search a first transition for a given property name.
  inline int SearchName(Tagged<Name> name, bool concurrent_search = false,
                        int* out_insertion_index = nullptr);
  int SearchDetails(int transition, PropertyKind kind,
                    PropertyAttributes attributes, int* out_insertion_index);
  Tagged<Map> SearchDetailsAndGetTarget(int transition, PropertyKind kind,
                                        PropertyAttributes attributes);

  inline int LinearSearchName(Tagged<Name> name, int* out_insertion_index);
  inline int BinarySearchName(Tagged<Name> name, int* out_insertion_index);

  // Find all transitions with given name and calls the callback.
  void ForEachTransitionTo(Tagged<Name> name,
                           const ForEachTransitionCallback& callback);

  static bool CompactPrototypeTransitionArray(Isolate* isolate,
                                              Tagged<WeakFixedArray> array);

  static Handle<WeakFixedArray> GrowPrototypeTransitionArray(
      DirectHandle<WeakFixedArray> array, int new_capacity, Isolate* isolate);

  // Compares two tuples <key, kind, attributes>, returns -1 if
  // tuple1 is "less" than tuple2, 0 if tuple1 equal to tuple2 and 1 otherwise.
  static inline int CompareKeys(Tagged<Name> key1, uint32_t hash1,
                                PropertyKind kind1,
                                PropertyAttributes attributes1,
                                Tagged<Name> key2, uint32_t hash2,
                                PropertyKind kind2,
                                PropertyAttributes attributes2);

  // Compares keys, returns -1 if key1 is "less" than key2,
  // 0 if key1 equal to key2 and 1 otherwise.
  static inline int CompareNames(Tagged<Name> key1, uint32_t hash1,
                                 Tagged<Name> key2, uint32_t hash2);

  // Compares two details, returns -1 if details1 is "less" than details2,
  // 0 if details1 equal to details2 and 1 otherwise.
  static inline int CompareDetails(PropertyKind kind1,
                                   PropertyAttributes attributes1,
                                   PropertyKind kind2,
                                   PropertyAttributes attributes2);

  inline void Set(int transition_number, Tagged<Name> key,
                  Tagged<MaybeObject> target);

  inline Tagged<WeakFixedArray> GetSideStepTransitions();
  inline void SetSideStepTransitions(Tagged<WeakFixedArray> transitions);
};

}  // namespace v8::internal

#include "src/objects/object-macros-undef.h"

#endif  // V8_OBJECTS_TRANSITIONS_H_
[Step 24: Duration 6.34 seconds| Input tokens: 620,419 | Output tokens: 12,020]
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ Step 25 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'read_file' with arguments: {'file_path': '/Users/tarun/v8/v8/src/objects/transitions.h'}                                                                                                      │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
Command: cd /Users/tarun/v8/v8/src && wc -l '/Users/tarun/v8/v8/src/objects/transitions.h'
Command: cd /Users/tarun/v8/v8/src && cat '/Users/tarun/v8/v8/src/objects/transitions.h'
Observations: // Copyright 2012 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef V8_OBJECTS_TRANSITIONS_H_
#define V8_OBJECTS_TRANSITIONS_H_

#include <optional>

#include "src/common/checks.h"
#include "src/execution/isolate.h"
#include "src/objects/descriptor-array.h"
#include "src/objects/elements-kind.h"
#include "src/objects/map.h"
#include "src/objects/maybe-object.h"
#include "src/objects/name.h"
#include "src/objects/objects.h"

// Has to be the last include (doesn't have include guards):
#include "src/objects/object-macros.h"

namespace v8::internal {

// Find all transitions with given name and calls the callback.
using ForEachTransitionCallback = std::function<void(Tagged<Map>)>;

// Descriptor for the contents of special side-step transition arrays.
// Side-step transitions are accessed through the TransitionsAccessor which
// enforces adherence to this format. The entries are either weak, Empty, or
// Unreachable.
struct SideStepTransition {
  enum class Kind : uint32_t {
    kCloneObject,
    kObjectAssign,
    kObjectAssignValidityCell,
  };
  static constexpr uint32_t kSize =
      static_cast<uint32_t>(Kind::kObjectAssignValidityCell) + 1;

  static constexpr Tagged<Smi> Empty = Smi::FromInt(0);
  static constexpr Tagged<Smi> Unreachable = Smi::FromInt(1);

 private:
  static constexpr int index_of(Kind kind) {
    return static_cast<uint32_t>(kind);
  }
  static constexpr uint32_t kFirstMapIdx =
      static_cast<uint32_t>(Kind::kCloneObject);
  static constexpr uint32_t kLastMapIdx =
      static_cast<uint32_t>(Kind::kObjectAssign);
  friend class TransitionsAccessor;
  friend class TransitionArray;
  friend class ObjectAssignAssembler;
};

std::ostream& operator<<(std::ostream& os, SideStepTransition::Kind sidestep);

// TransitionsAccessor is a helper class to encapsulate access to the various
// ways a Map can store transitions to other maps in its respective field at
// Map::kTransitionsOrPrototypeInfo.
// It caches state information internally, which becomes stale when a Map's
// transitions storage changes or when a GC cycle clears dead transitions;
// so while a TransitionsAccessor instance can be used for several read-only
// operations in a row (provided no GC happens between them), it must be
// discarded and recreated after "Insert" and "UpdateHandler" operations.
//
// Internal details: a Map's field either holds an in-place weak reference to a
// transition target, or a StoreIC handler for a transitioning store (which in
// turn points to its target map), or a TransitionArray for several target maps
// and/or handlers as well as prototype and ElementsKind transitions.  Property
// details (and in case of inline target storage, the key) are retrieved from
// the target map's descriptor array.  Stored transitions are weak in the GC
// sense: both single transitions stored inline and TransitionArray fields are
// cleared when the map they refer to is not otherwise reachable.
class V8_EXPORT_PRIVATE TransitionsAccessor {
 public:
  // {concurrent_access} signals that the TransitionsAccessor will only be used
  // in background threads. It acquires a reader lock for critical paths, as
  // well as blocking the accessor from modifying the TransitionsArray.
  inline TransitionsAccessor(Isolate* isolate, Tagged<Map> map,
                             bool concurrent_access = false);

  // Insert a new transition into |map|'s transition array, extending it
  // as necessary. This can trigger GC.
  static void Insert(Isolate* isolate, DirectHandle<Map> map,
                     DirectHandle<Name> name, DirectHandle<Map> target,
                     TransitionKindFlag flag) {
    InsertHelper(isolate, map, name, DirectHandle<Map>(target), flag);
  }
  static void InsertNoneSentinel(Isolate* isolate, DirectHandle<Map> map,
                                 DirectHandle<Name> name) {
    InsertHelper(isolate, map, name, DirectHandle<Map>(),
                 TransitionKindFlag::SPECIAL_TRANSITION);
  }

  Tagged<Map> SearchTransition(Tagged<Name> name, PropertyKind kind,
                               PropertyAttributes attributes);
  static inline MaybeHandle<Map> SearchTransition(
      Isolate* isolate, DirectHandle<Map> map, Tagged<Name> name,
      PropertyKind kind, PropertyAttributes attributes);

  // Searches for a transition with a special symbol.
  Tagged<Map> SearchSpecial(Tagged<Symbol> name);
  static inline MaybeHandle<Map> SearchSpecial(Isolate* isolate,
                                               DirectHandle<Map> map,
                                               Tagged<Symbol> name);

  // Returns true for non-property transitions like elements kind, or
  // or frozen/sealed transitions.
  static bool IsSpecialTransition(ReadOnlyRoots roots, Tagged<Name> name);

  MaybeHandle<Map> FindTransitionToField(DirectHandle<String> name);

  // Find all transitions with given name and calls the callback.
  // Neither GCs nor operations requiring Isolate::full_transition_array_access
  // lock are allowed inside the callback.
  // If any of the GC- or lock-requiring processing is necessary, it has to be
  // done outside of the callback.
  void ForEachTransitionTo(Tagged<Name> name,
                           const ForEachTransitionCallback& callback,
                           DisallowGarbageCollection* no_gc);

  template <typename Char>
  inline bool IsExpectedTransition(Tagged<Name> transition_name,
                                   Tagged<Map> transition_target,
                                   base::Vector<const Char> key_chars);

  template <typename Char>
  inline std::pair<Handle<String>, Handle<Map>> ExpectedTransition(
      base::Vector<const Char> key_chars);

  template <typename Callback, typename ProtoCallback,
            typename SideStepCallback>
  void ForEachTransition(DisallowGarbageCollection* no_gc, Callback callback,
                         ProtoCallback proto_transition_callback,
                         SideStepCallback side_step_transition_callback) {
    ForEachTransitionWithKey<Callback, ProtoCallback, SideStepCallback, false>(
        no_gc, callback, proto_transition_callback,
        side_step_transition_callback);
  }

  template <typename Callback, typename ProtoCallback,
            typename SideStepCallback, bool with_key = true>
  void ForEachTransitionWithKey(DisallowGarbageCollection* no_gc,
                                Callback callback,
                                ProtoCallback proto_transition_callback,
                                SideStepCallback side_step_transition_callback);

  int NumberOfTransitions();
  // The size of transition arrays are limited so they do not end up in large
  // object space. Otherwise ClearNonLiveReferences would leak memory while
  // applying in-place right trimming.
  static const int kMaxNumberOfTransitions = 1024 + 512;
  inline Tagged<Name> GetKey(int transition_number);
  inline Tagged<Map> GetTarget(int transition_number);
  static inline PropertyDetails GetTargetDetails(Tagged<Name> name,
                                                 Tagged<Map> target);

  static bool CanHaveMoreTransitions(Isolate* isolate, DirectHandle<Map> map);

  static bool IsMatchingMap(Tagged<Map> target, Tagged<Name> name,
                            PropertyKind kind, PropertyAttributes attributes);

  bool HasIntegrityLevelTransitionTo(
      Tagged<Map> to, Tagged<Symbol>* out_symbol = nullptr,
      PropertyAttributes* out_integrity_level = nullptr);

  // ===== ITERATION =====
  using TraverseCallback = std::function<void(Tagged<Map>)>;

  // Traverse the transition tree in preorder.
  void TraverseTransitionTree(const TraverseCallback& callback) {
    // Make sure that we do not allocate in the callback.
    DisallowGarbageCollection no_gc;
    base::SharedMutexGuardIf<base::kShared> scope(
        isolate_->full_transition_array_access(), concurrent_access_);
    TraverseTransitionTreeInternal(callback, &no_gc);
  }

  // ===== PROTOTYPE TRANSITIONS =====
  // When you set the prototype of an object using the __proto__ accessor you
  // need a new map for the object (the prototype is stored in the map).  In
  // order not to multiply maps unnecessarily we store these as transitions in
  // the original map.  That way we can transition to the same map if the same
  // prototype is set, rather than creating a new map every time.  The
  // transitions are in the form of a map where the keys are prototype objects
  // and the values are the maps they transition to.
  // PutPrototypeTransition can trigger GC.
  static bool PutPrototypeTransition(Isolate* isolate, DirectHandle<Map>,
                                     DirectHandle<Object> prototype,
                                     DirectHandle<Map> target_map);
  static std::optional<Tagged<Map>> GetPrototypeTransition(
      Isolate* isolate, Tagged<Map> map, Tagged<Object> prototype);
  bool HasPrototypeTransitions();

  // During the first-time Map::Update and Map::TryUpdate, the migration target
  // map could be cached in the raw_transitions slot of the old map that is
  // deprecated from the map transition tree. The next time old map is updated,
  // we will check this cache slot as a shortcut to get the migration target
  // map.
  static void SetMigrationTarget(Isolate* isolate, DirectHandle<Map> map,
                                 Tagged<Map> migration_target);
  Tagged<Map> GetMigrationTarget();

  inline bool HasSideStepTransitions();
  static void EnsureHasSideStepTransitions(Isolate* isolate,
                                           DirectHandle<Map> map);
  inline Tagged<Object> GetSideStepTransition(SideStepTransition::Kind i);
  inline void SetSideStepTransition(SideStepTransition::Kind i,
                                    Tagged<Object> target);

#if DEBUG || OBJECT_PRINT
  void PrintTransitions(std::ostream& os);
  static void PrintOneTransition(std::ostream& os, Tagged<Name> key,
                                 Tagged<Map> target);
  void PrintTransitionTree();
  void PrintTransitionTree(std::ostream& os, int level,
                           DisallowGarbageCollection* no_gc);
#endif
#if DEBUG
  static void CheckNewTransitionsAreConsistent(Isolate* isolate,
                                               DirectHandle<Map> map,
                                               Tagged<Object> transitions);
  bool IsConsistentWithBackPointers();
  bool IsSortedNoDuplicates();
#endif

 protected:
  // Allow tests to use inheritance to access internals.
  enum Encoding {
    kPrototypeInfo,
    kUninitialized,
    kMigrationTarget,
    kWeakRef,
    kFullTransitionArray,
  };

  inline Encoding encoding() { return encoding_; }

  inline int Capacity();

  inline Tagged<TransitionArray> transitions();

  DISALLOW_GARBAGE_COLLECTION(no_gc_)

 private:
  friend class MarkCompactCollector;  // For HasSimpleTransitionTo.
  friend class TransitionArray;

  static inline Encoding GetEncoding(Isolate* isolate,
                                     Tagged<MaybeObject> raw_transitions);
  static inline Encoding GetEncoding(Isolate* isolate,
                                     Tagged<TransitionArray> array);
  static inline Encoding GetEncoding(Isolate* isolate, DirectHandle<Map> map);

  static inline Tagged<TransitionArray> GetTransitionArray(
      Isolate* isolate, Tagged<MaybeObject> raw_transitions);
  static inline Tagged<TransitionArray> GetTransitionArray(
      Isolate* isolate, DirectHandle<Map> map);

  static inline Tagged<Map> GetSimpleTransition(Isolate* isolate,
                                                DirectHandle<Map> map);
  static inline Tagged<Name> GetSimpleTransitionKey(Tagged<Map> transition);
  inline PropertyDetails GetSimpleTargetDetails(Tagged<Map> transition);

  static inline Tagged<Map> GetTargetFromRaw(Tagged<MaybeObject> raw);

  static void EnsureHasFullTransitionArray(Isolate* isolate,
                                           DirectHandle<Map> map);
  static void SetPrototypeTransitions(
      Isolate* isolate, DirectHandle<Map> map,
      DirectHandle<WeakFixedArray> proto_transitions);
  static Tagged<WeakFixedArray> GetPrototypeTransitions(Isolate* isolate,
                                                        Tagged<Map> map);

  static void InsertHelper(Isolate* isolate, DirectHandle<Map> map,
                           DirectHandle<Name> name, DirectHandle<Map> target,
                           TransitionKindFlag flag);

  static inline void ReplaceTransitions(
      Isolate* isolate, DirectHandle<Map> map,
      Tagged<UnionOf<TransitionArray, MaybeWeak<Map>>> new_transitions);
  static inline void ReplaceTransitions(
      Isolate* isolate, DirectHandle<Map> map,
      DirectHandle<TransitionArray> new_transitions);

  bool HasSimpleTransitionTo(Tagged<Map> map);

  inline Tagged<Map> GetTargetMapFromWeakRef();

  void TraverseTransitionTreeInternal(const TraverseCallback& callback,
                                      DisallowGarbageCollection* no_gc);

  Isolate* isolate_;
  Tagged<Map> map_;
  Tagged<MaybeObject> raw_transitions_;
  Encoding encoding_;
  bool concurrent_access_;

  DISALLOW_IMPLICIT_CONSTRUCTORS(TransitionsAccessor);
};

// TransitionArrays are fixed arrays used to hold map transitions for property,
// constant, and element changes.
// The TransitionArray class exposes a very low-level interface. Most clients
// should use TransitionsAccessors.
// TransitionArrays have the following format:
// |0] Tagged<Smi>(0) or WeakFixedArray of prototype transitions (strong ref)
// |1] Tagged<Smi>(0) or WeakFixedArray of side-step transitions (strong ref)
// |2] Number of transitions (can be zero after trimming)
// |3] First transition key (strong ref)
// |4] First transition target (weak ref)
// ...
// |4 + number of transitions * kTransitionSize]: start of slack
// TODO(olivf): The slots for prototype transitions and side-steps could be
// shared.
class TransitionArray : public WeakFixedArray {
 public:
  inline int number_of_transitions() const;

  inline Tagged<WeakFixedArray> GetPrototypeTransitions();
  inline bool HasPrototypeTransitions();

  // Accessors for fetching instance transition at transition number.
  inline void SetKey(int transition_number, Tagged<Name> value);
  inline Tagged<Name> GetKey(int transition_number);
  inline HeapObjectSlot GetKeySlot(int transition_number);

  inline Tagged<Map> GetTarget(int transition_number);
  inline void SetRawTarget(int transition_number, Tagged<MaybeObject> target);
  inline Tagged<MaybeObject> GetRawTarget(int transition_number);
  inline HeapObjectSlot GetTargetSlot(int transition_number);
  inline bool GetTargetIfExists(int transition_number, Isolate* isolate,
                                Tagged<Map>* target);

  static constexpr int kNotFound = -1;

#ifdef DEBUG
  V8_EXPORT_PRIVATE bool IsSortedNoDuplicates();
#endif

  V8_EXPORT_PRIVATE void Sort();

  void PrintInternal(std::ostream& os);

  DECL_PRINTER(TransitionArray)
  DECL_VERIFIER(TransitionArray)

  // Layout for full transition arrays.
  static const int kPrototypeTransitionsIndex = 0;
  static const int kSideStepTransitionsIndex = 1;
  static const int kTransitionLengthIndex = 2;
  static const int kFirstIndex = 3;

  // Layout of map transition entries in full transition arrays.
  static const int kEntryKeyIndex = 0;
  static const int kEntryTargetIndex = 1;
  static const int kEntrySize = 2;

  // Conversion from transition number to array indices.
  static int ToKeyIndex(int transition_number) {
    return kFirstIndex + (transition_number * kEntrySize) + kEntryKeyIndex;
  }

  static int ToTargetIndex(int transition_number) {
    return kFirstIndex + (transition_number * kEntrySize) + kEntryTargetIndex;
  }

  inline int SearchNameForTesting(Tagged<Name> name,
                                  int* out_insertion_index = nullptr);

  inline Tagged<Map> SearchAndGetTargetForTesting(
      PropertyKind kind, Tagged<Name> name, PropertyAttributes attributes);

  // Accessors for side-step transitions.
  inline bool HasSideStepTransitions();
  static void CreateSideStepTransitions(
      Isolate* isolate, DirectHandle<TransitionArray> transitions);

 private:
  friend class Factory;
  friend class MarkCompactCollector;
  friend class TransitionsAccessor;

  inline void SetNumberOfTransitions(int number_of_transitions);

  inline int Capacity();

  // ===== PROTOTYPE TRANSITIONS =====
  // Cache format:
  //    0: finger - index of the first free cell in the cache
  //    1 + i: target map
  static const int kProtoTransitionHeaderSize = 1;
  static const int kMaxCachedPrototypeTransitions = 256;

  inline void SetPrototypeTransitions(
      Tagged<WeakFixedArray> prototype_transitions);

  static inline int NumberOfPrototypeTransitions(
      Tagged<WeakFixedArray> proto_transitions);
  static void SetNumberOfPrototypeTransitions(
      Tagged<WeakFixedArray> proto_transitions, int value);

  static const int kProtoTransitionNumberOfEntriesOffset = 0;
  static_assert(kProtoTransitionHeaderSize == 1);

  // Returns the fixed array length required to hold number_of_transitions
  // transitions.
  static int LengthFor(int number_of_transitions) {
    return ToKeyIndex(number_of_transitions);
  }

  // Search a  transition for a given kind, property name and attributes.
  int Search(PropertyKind kind, Tagged<Name> name,
             PropertyAttributes attributes, int* out_insertion_index = nullptr);

  V8_EXPORT_PRIVATE Tagged<Map> SearchAndGetTarget(
      PropertyKind kind, Tagged<Name> name, PropertyAttributes attributes);

  // Search a non-property transition (like elements kind, observe or frozen
  // transitions).
  inline int SearchSpecial(Tagged<Symbol> symbol,
                           bool concurrent_search = false,
                           int* out_insertion_index = nullptr);
  // Search a first transition for a given property name.
  inline int SearchName(Tagged<Name> name, bool concurrent_search = false,
                        int* out_insertion_index = nullptr);
  int SearchDetails(int transition, PropertyKind kind,
                    PropertyAttributes attributes, int* out_insertion_index);
  Tagged<Map> SearchDetailsAndGetTarget(int transition, PropertyKind kind,
                                        PropertyAttributes attributes);

  inline int LinearSearchName(Tagged<Name> name, int* out_insertion_index);
  inline int BinarySearchName(Tagged<Name> name, int* out_insertion_index);

  // Find all transitions with given name and calls the callback.
  void ForEachTransitionTo(Tagged<Name> name,
                           const ForEachTransitionCallback& callback);

  static bool CompactPrototypeTransitionArray(Isolate* isolate,
                                              Tagged<WeakFixedArray> array);

  static Handle<WeakFixedArray> GrowPrototypeTransitionArray(
      DirectHandle<WeakFixedArray> array, int new_capacity, Isolate* isolate);

  // Compares two tuples <key, kind, attributes>, returns -1 if
  // tuple1 is "less" than tuple2, 0 if tuple1 equal to tuple2 and 1 otherwise.
  static inline int CompareKeys(Tagged<Name> key1, uint32_t hash1,
                                PropertyKind kind1,
                                PropertyAttributes attributes1,
                                Tagged<Name> key2, uint32_t hash2,
                                PropertyKind kind2,
                                PropertyAttributes attributes2);

  // Compares keys, returns -1 if key1 is "less" than key2,
  // 0 if key1 equal to key2 and 1 otherwise.
  static inline int CompareNames(Tagged<Name> key1, uint32_t hash1,
                                 Tagged<Name> key2, uint32_t hash2);

  // Compares two details, returns -1 if details1 is "less" than details2,
  // 0 if details1 equal to details2 and 1 otherwise.
  static inline int CompareDetails(PropertyKind kind1,
                                   PropertyAttributes attributes1,
                                   PropertyKind kind2,
                                   PropertyAttributes attributes2);

  inline void Set(int transition_number, Tagged<Name> key,
                  Tagged<MaybeObject> target);

  inline Tagged<WeakFixedArray> GetSideStepTransitions();
  inline void SetSideStepTransitions(Tagged<WeakFixedArray> transitions);
};

}  // namespace v8::internal

#include "src/objects/object-macros-undef.h"

#endif  // V8_OBJECTS_TRANSITIONS_H_
[Step 25: Duration 11.15 seconds| Input tokens: 681,118 | Output tokens: 12,250]
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ Step 26 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'ripgrep' with arguments: {'pattern':                                                                                                                                                          │
│ 'FindTransitionTo(Field|Accessor)|DeprecateTransition|DeprecateTransitions|New(Field|DataProperty)|TransitionTo.*Property|ReplaceTransitionToDataProperty|NewDataProperty|FindTransitionTo', 'options': '-n  │
│ --hidden --no-ignore-vcs objects/transitions.cc objects/transitions.h objects/transitions-inl.h objects/map.cc objects/map-inl.h objects/js-objects.cc objects/map-updater.cc objects/map-updater.h'}        │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'ripgrep' with arguments: {'pattern': '\\+1|plus one|\\+1 map|one child|split transition|split.*transition|deprecat|shape(s)? diverge|descriptor(s)? diverge|own(s)?                           │
│ descriptors|own.*descriptors|copy.*descriptors|+1', 'options': '-n --hidden --no-ignore-vcs objects/map*.* objects/transitions*.* objects/js-objects.*'}                                                     │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
Command: cd /Users/tarun/v8/v8/src && rg -n --hidden --no-ignore-vcs objects/transitions.cc objects/transitions.h objects/transitions-inl.h objects/map.cc objects/map-inl.h objects/js-objects.cc objects/map-updater.cc objects/map-updater.h 'FindTransitionTo(Field|Accessor)|DeprecateTransition|DeprecateTransitions|New(Field|DataProperty)|TransitionTo.*Property|ReplaceTransitionToDataProperty|NewDataProperty|FindTransitionTo' | head -n 1000
Observations: rg: FindTransitionTo(Field|Accessor)|DeprecateTransition|DeprecateTransitions|New(Field|DataProperty)|TransitionTo.*Property|ReplaceTransitionToDataProperty|NewDataProperty|FindTransitionTo: No 
such file or directory (os error 2)
Command: cd /Users/tarun/v8/v8/src && rg -n --hidden --no-ignore-vcs objects/map*.* objects/transitions*.* objects/js-objects.* '\+1|plus one|\+1 map|one child|split transition|split.*transition|deprecat|shape(s)? diverge|descriptor(s)? diverge|own(s)? descriptors|own.*descriptors|copy.*descriptors|+1' | head -n 1000
Observations: objects/js-objects.cc:55:#include "src/objects/map-inl.h"
[Step 26: Duration 21.21 seconds| Input tokens: 740,820 | Output tokens: 13,114]
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ Step 27 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'fuzzy_finder' with arguments: {'pattern': 'objects/transitions.cc'}                                                                                                                           │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'ripgrep' with arguments: {'pattern': 'TransitionArray', 'options': '-n ./objects/transitions.* ./objects/map.* ./objects/js-objects.*'}                                                       │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'ripgrep' with arguments: {'pattern': 'FindTransitionToAccessor', 'options': '-n ./objects/transitions.* ./objects/map.* ./objects/js-objects.*'}                                              │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
Command: cd /Users/tarun/v8/v8/src && rg --hidden --no-follow --no-ignore-vcs --files 2>/dev/null | fzf  'objects/transitions.cc' | head -n 1000
│ Calling tool: 'ripgrep' with arguments: {'pattern': 'FindTransitionToField', 'options': '-n ./objects/transitions.* ./objects/map.* ./objects/js-objects.*'}                                                 │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
Command: cd /Users/tarun/v8/v8/src && rg -n ./objects/transitions.* ./objects/map.* ./objects/js-objects.* 'TransitionArray' | head -n 1000
│ Calling tool: 'ripgrep' with arguments: {'pattern': 'NewDataProperty', 'options': '-n ./objects/transitions.* ./objects/map.* ./objects/js-objects.*'}                                                       │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
Command: cd /Users/tarun/v8/v8/src && rg -n ./objects/transitions.* ./objects/map.* ./objects/js-objects.* 'FindTransitionToAccessor' | head -n 1000
Observations: unknown option: objects/transitions.cc
Command: cd /Users/tarun/v8/v8/src && rg -n ./objects/transitions.* ./objects/map.* ./objects/js-objects.* 'FindTransitionToField' | head -n 1000
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'ripgrep' with arguments: {'pattern': 'NewField', 'options': '-n ./objects/transitions.* ./objects/map.* ./objects/js-objects.*'}                                                              │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'ripgrep' with arguments: {'pattern': 'DeprecateTransitions', 'options': '-n ./objects/transitions.* ./objects/map.* ./objects/js-objects.*'}                                                  │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
Observations: rg: TransitionArray: No such file or directory (os error 2)
Observations: rg: FindTransitionToAccessor: No such file or directory (os error 2)
Command: cd /Users/tarun/v8/v8/src && rg -n ./objects/transitions.* ./objects/map.* ./objects/js-objects.* 'NewDataProperty' | head -n 1000
│ Calling tool: 'ripgrep' with arguments: {'pattern': 'DeprecateTransition', 'options': '-n ./objects/transitions.* ./objects/map.* ./objects/js-objects.*'}                                                   │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'ripgrep' with arguments: {'pattern': 'ReplaceTransitionToDataProperty|ReplaceTransitionToDataField', 'options': '-n ./objects/transitions.* ./objects/map.* ./objects/js-objects.*'}          │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
Observations: rg: FindTransitionToField: No such file or directory (os error 2)
Command: cd /Users/tarun/v8/v8/src && rg -n ./objects/transitions.* ./objects/map.* ./objects/js-objects.* 'NewField' | head -n 1000
│ Calling tool: 'ripgrep' with arguments: {'pattern': 'Plus\\s*one|\\+1 map|single.*transition|one child', 'options': '-n ./objects/transitions.* ./objects/map.* ./objects/js-objects.*'}                     │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
Observations: rg: NewDataProperty: No such file or directory (os error 2)
Command: cd /Users/tarun/v8/v8/src && rg -n ./objects/transitions.* ./objects/map.* ./objects/js-objects.* 'DeprecateTransitions' | head -n 1000
Command: cd /Users/tarun/v8/v8/src && rg -n ./objects/transitions.* ./objects/map.* ./objects/js-objects.* 'DeprecateTransition' | head -n 1000
Command: cd /Users/tarun/v8/v8/src && rg -n ./objects/transitions.* ./objects/map.* ./objects/js-objects.* 'ReplaceTransitionToDataProperty|ReplaceTransitionToDataField' | head -n 1000
Observations: rg: NewField: No such file or directory (os error 2)
Observations: rg: DeprecateTransitions: No such file or directory (os error 2)
Observations: rg: DeprecateTransition: No such file or directory (os error 2)
Observations: rg: ReplaceTransitionToDataProperty|ReplaceTransitionToDataField: No such file or directory (os error 2)
Command: cd /Users/tarun/v8/v8/src && rg -n ./objects/transitions.* ./objects/map.* ./objects/js-objects.* 'Plus\s*one|\+1 map|single.*transition|one child' | head -n 1000
Observations: rg: Plus\s*one|\+1 map|single.*transition|one child: No such file or directory (os error 2)
[Step 27: Duration 29.94 seconds| Input tokens: 793,051 | Output tokens: 14,539]
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ Step 28 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'ripgrep' with arguments: {'pattern': 'TransitionArray', 'options': '-n ./objects'}                                                                                                            │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'read_file' with arguments: {'file_path': '/Users/tarun/v8/v8/src/objects/transitions.h'}                                                                                                      │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
Command: cd /Users/tarun/v8/v8/src && rg -n ./objects 'TransitionArray' | head -n 1000
Observations: rg: TransitionArray: IO error for operation on TransitionArray: No such file or directory (os error 2)
[Step 28: Duration 20.30 seconds| Input tokens: 853,118 | Output tokens: 15,275]
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ Step 29 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
Command: cd /Users/tarun/v8/v8/src && wc -l '/Users/tarun/v8/v8/src/objects/transitions.h'
Command: cd /Users/tarun/v8/v8/src && cat '/Users/tarun/v8/v8/src/objects/transitions.h'
Observations: // Copyright 2012 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef V8_OBJECTS_TRANSITIONS_H_
#define V8_OBJECTS_TRANSITIONS_H_

#include <optional>

#include "src/common/checks.h"
#include "src/execution/isolate.h"
#include "src/objects/descriptor-array.h"
#include "src/objects/elements-kind.h"
#include "src/objects/map.h"
#include "src/objects/maybe-object.h"
#include "src/objects/name.h"
#include "src/objects/objects.h"

// Has to be the last include (doesn't have include guards):
#include "src/objects/object-macros.h"

namespace v8::internal {

// Find all transitions with given name and calls the callback.
using ForEachTransitionCallback = std::function<void(Tagged<Map>)>;

// Descriptor for the contents of special side-step transition arrays.
// Side-step transitions are accessed through the TransitionsAccessor which
// enforces adherence to this format. The entries are either weak, Empty, or
// Unreachable.
struct SideStepTransition {
  enum class Kind : uint32_t {
    kCloneObject,
    kObjectAssign,
    kObjectAssignValidityCell,
  };
  static constexpr uint32_t kSize =
      static_cast<uint32_t>(Kind::kObjectAssignValidityCell) + 1;

  static constexpr Tagged<Smi> Empty = Smi::FromInt(0);
  static constexpr Tagged<Smi> Unreachable = Smi::FromInt(1);

 private:
  static constexpr int index_of(Kind kind) {
    return static_cast<uint32_t>(kind);
  }
  static constexpr uint32_t kFirstMapIdx =
      static_cast<uint32_t>(Kind::kCloneObject);
  static constexpr uint32_t kLastMapIdx =
      static_cast<uint32_t>(Kind::kObjectAssign);
  friend class TransitionsAccessor;
  friend class TransitionArray;
  friend class ObjectAssignAssembler;
};

std::ostream& operator<<(std::ostream& os, SideStepTransition::Kind sidestep);

// TransitionsAccessor is a helper class to encapsulate access to the various
// ways a Map can store transitions to other maps in its respective field at
// Map::kTransitionsOrPrototypeInfo.
// It caches state information internally, which becomes stale when a Map's
// transitions storage changes or when a GC cycle clears dead transitions;
// so while a TransitionsAccessor instance can be used for several read-only
// operations in a row (provided no GC happens between them), it must be
// discarded and recreated after "Insert" and "UpdateHandler" operations.
//
// Internal details: a Map's field either holds an in-place weak reference to a
// transition target, or a StoreIC handler for a transitioning store (which in
// turn points to its target map), or a TransitionArray for several target maps
// and/or handlers as well as prototype and ElementsKind transitions.  Property
// details (and in case of inline target storage, the key) are retrieved from
// the target map's descriptor array.  Stored transitions are weak in the GC
// sense: both single transitions stored inline and TransitionArray fields are
// cleared when the map they refer to is not otherwise reachable.
class V8_EXPORT_PRIVATE TransitionsAccessor {
 public:
  // {concurrent_access} signals that the TransitionsAccessor will only be used
  // in background threads. It acquires a reader lock for critical paths, as
  // well as blocking the accessor from modifying the TransitionsArray.
  inline TransitionsAccessor(Isolate* isolate, Tagged<Map> map,
                             bool concurrent_access = false);

  // Insert a new transition into |map|'s transition array, extending it
  // as necessary. This can trigger GC.
  static void Insert(Isolate* isolate, DirectHandle<Map> map,
                     DirectHandle<Name> name, DirectHandle<Map> target,
                     TransitionKindFlag flag) {
    InsertHelper(isolate, map, name, DirectHandle<Map>(target), flag);
  }
  static void InsertNoneSentinel(Isolate* isolate, DirectHandle<Map> map,
                                 DirectHandle<Name> name) {
    InsertHelper(isolate, map, name, DirectHandle<Map>(),
                 TransitionKindFlag::SPECIAL_TRANSITION);
  }

  Tagged<Map> SearchTransition(Tagged<Name> name, PropertyKind kind,
                               PropertyAttributes attributes);
  static inline MaybeHandle<Map> SearchTransition(
      Isolate* isolate, DirectHandle<Map> map, Tagged<Name> name,
      PropertyKind kind, PropertyAttributes attributes);

  // Searches for a transition with a special symbol.
  Tagged<Map> SearchSpecial(Tagged<Symbol> name);
  static inline MaybeHandle<Map> SearchSpecial(Isolate* isolate,
                                               DirectHandle<Map> map,
                                               Tagged<Symbol> name);

  // Returns true for non-property transitions like elements kind, or
  // or frozen/sealed transitions.
  static bool IsSpecialTransition(ReadOnlyRoots roots, Tagged<Name> name);

  MaybeHandle<Map> FindTransitionToField(DirectHandle<String> name);

  // Find all transitions with given name and calls the callback.
  // Neither GCs nor operations requiring Isolate::full_transition_array_access
  // lock are allowed inside the callback.
  // If any of the GC- or lock-requiring processing is necessary, it has to be
  // done outside of the callback.
  void ForEachTransitionTo(Tagged<Name> name,
                           const ForEachTransitionCallback& callback,
                           DisallowGarbageCollection* no_gc);

  template <typename Char>
  inline bool IsExpectedTransition(Tagged<Name> transition_name,
                                   Tagged<Map> transition_target,
                                   base::Vector<const Char> key_chars);

  template <typename Char>
  inline std::pair<Handle<String>, Handle<Map>> ExpectedTransition(
      base::Vector<const Char> key_chars);

  template <typename Callback, typename ProtoCallback,
            typename SideStepCallback>
  void ForEachTransition(DisallowGarbageCollection* no_gc, Callback callback,
                         ProtoCallback proto_transition_callback,
                         SideStepCallback side_step_transition_callback) {
    ForEachTransitionWithKey<Callback, ProtoCallback, SideStepCallback, false>(
        no_gc, callback, proto_transition_callback,
        side_step_transition_callback);
  }

  template <typename Callback, typename ProtoCallback,
            typename SideStepCallback, bool with_key = true>
  void ForEachTransitionWithKey(DisallowGarbageCollection* no_gc,
                                Callback callback,
                                ProtoCallback proto_transition_callback,
                                SideStepCallback side_step_transition_callback);

  int NumberOfTransitions();
  // The size of transition arrays are limited so they do not end up in large
  // object space. Otherwise ClearNonLiveReferences would leak memory while
  // applying in-place right trimming.
  static const int kMaxNumberOfTransitions = 1024 + 512;
  inline Tagged<Name> GetKey(int transition_number);
  inline Tagged<Map> GetTarget(int transition_number);
  static inline PropertyDetails GetTargetDetails(Tagged<Name> name,
                                                 Tagged<Map> target);

  static bool CanHaveMoreTransitions(Isolate* isolate, DirectHandle<Map> map);

  static bool IsMatchingMap(Tagged<Map> target, Tagged<Name> name,
                            PropertyKind kind, PropertyAttributes attributes);

  bool HasIntegrityLevelTransitionTo(
      Tagged<Map> to, Tagged<Symbol>* out_symbol = nullptr,
      PropertyAttributes* out_integrity_level = nullptr);

  // ===== ITERATION =====
  using TraverseCallback = std::function<void(Tagged<Map>)>;

  // Traverse the transition tree in preorder.
  void TraverseTransitionTree(const TraverseCallback& callback) {
    // Make sure that we do not allocate in the callback.
    DisallowGarbageCollection no_gc;
    base::SharedMutexGuardIf<base::kShared> scope(
        isolate_->full_transition_array_access(), concurrent_access_);
    TraverseTransitionTreeInternal(callback, &no_gc);
  }

  // ===== PROTOTYPE TRANSITIONS =====
  // When you set the prototype of an object using the __proto__ accessor you
  // need a new map for the object (the prototype is stored in the map).  In
  // order not to multiply maps unnecessarily we store these as transitions in
  // the original map.  That way we can transition to the same map if the same
  // prototype is set, rather than creating a new map every time.  The
  // transitions are in the form of a map where the keys are prototype objects
  // and the values are the maps they transition to.
  // PutPrototypeTransition can trigger GC.
  static bool PutPrototypeTransition(Isolate* isolate, DirectHandle<Map>,
                                     DirectHandle<Object> prototype,
                                     DirectHandle<Map> target_map);
  static std::optional<Tagged<Map>> GetPrototypeTransition(
      Isolate* isolate, Tagged<Map> map, Tagged<Object> prototype);
  bool HasPrototypeTransitions();

  // During the first-time Map::Update and Map::TryUpdate, the migration target
  // map could be cached in the raw_transitions slot of the old map that is
  // deprecated from the map transition tree. The next time old map is updated,
  // we will check this cache slot as a shortcut to get the migration target
  // map.
  static void SetMigrationTarget(Isolate* isolate, DirectHandle<Map> map,
                                 Tagged<Map> migration_target);
  Tagged<Map> GetMigrationTarget();

  inline bool HasSideStepTransitions();
  static void EnsureHasSideStepTransitions(Isolate* isolate,
                                           DirectHandle<Map> map);
  inline Tagged<Object> GetSideStepTransition(SideStepTransition::Kind i);
  inline void SetSideStepTransition(SideStepTransition::Kind i,
                                    Tagged<Object> target);

#if DEBUG || OBJECT_PRINT
  void PrintTransitions(std::ostream& os);
  static void PrintOneTransition(std::ostream& os, Tagged<Name> key,
                                 Tagged<Map> target);
  void PrintTransitionTree();
  void PrintTransitionTree(std::ostream& os, int level,
                           DisallowGarbageCollection* no_gc);
#endif
#if DEBUG
  static void CheckNewTransitionsAreConsistent(Isolate* isolate,
                                               DirectHandle<Map> map,
                                               Tagged<Object> transitions);
  bool IsConsistentWithBackPointers();
  bool IsSortedNoDuplicates();
#endif

 protected:
  // Allow tests to use inheritance to access internals.
  enum Encoding {
    kPrototypeInfo,
    kUninitialized,
    kMigrationTarget,
    kWeakRef,
    kFullTransitionArray,
  };

  inline Encoding encoding() { return encoding_; }

  inline int Capacity();

  inline Tagged<TransitionArray> transitions();

  DISALLOW_GARBAGE_COLLECTION(no_gc_)

 private:
  friend class MarkCompactCollector;  // For HasSimpleTransitionTo.
  friend class TransitionArray;

  static inline Encoding GetEncoding(Isolate* isolate,
                                     Tagged<MaybeObject> raw_transitions);
  static inline Encoding GetEncoding(Isolate* isolate,
                                     Tagged<TransitionArray> array);
  static inline Encoding GetEncoding(Isolate* isolate, DirectHandle<Map> map);

  static inline Tagged<TransitionArray> GetTransitionArray(
      Isolate* isolate, Tagged<MaybeObject> raw_transitions);
  static inline Tagged<TransitionArray> GetTransitionArray(
      Isolate* isolate, DirectHandle<Map> map);

  static inline Tagged<Map> GetSimpleTransition(Isolate* isolate,
                                                DirectHandle<Map> map);
  static inline Tagged<Name> GetSimpleTransitionKey(Tagged<Map> transition);
  inline PropertyDetails GetSimpleTargetDetails(Tagged<Map> transition);

  static inline Tagged<Map> GetTargetFromRaw(Tagged<MaybeObject> raw);

  static void EnsureHasFullTransitionArray(Isolate* isolate,
                                           DirectHandle<Map> map);
  static void SetPrototypeTransitions(
      Isolate* isolate, DirectHandle<Map> map,
      DirectHandle<WeakFixedArray> proto_transitions);
  static Tagged<WeakFixedArray> GetPrototypeTransitions(Isolate* isolate,
                                                        Tagged<Map> map);

  static void InsertHelper(Isolate* isolate, DirectHandle<Map> map,
                           DirectHandle<Name> name, DirectHandle<Map> target,
                           TransitionKindFlag flag);

  static inline void ReplaceTransitions(
      Isolate* isolate, DirectHandle<Map> map,
      Tagged<UnionOf<TransitionArray, MaybeWeak<Map>>> new_transitions);
  static inline void ReplaceTransitions(
      Isolate* isolate, DirectHandle<Map> map,
      DirectHandle<TransitionArray> new_transitions);

  bool HasSimpleTransitionTo(Tagged<Map> map);

  inline Tagged<Map> GetTargetMapFromWeakRef();

  void TraverseTransitionTreeInternal(const TraverseCallback& callback,
                                      DisallowGarbageCollection* no_gc);

  Isolate* isolate_;
  Tagged<Map> map_;
  Tagged<MaybeObject> raw_transitions_;
  Encoding encoding_;
  bool concurrent_access_;

  DISALLOW_IMPLICIT_CONSTRUCTORS(TransitionsAccessor);
};

// TransitionArrays are fixed arrays used to hold map transitions for property,
// constant, and element changes.
// The TransitionArray class exposes a very low-level interface. Most clients
// should use TransitionsAccessors.
// TransitionArrays have the following format:
// |0] Tagged<Smi>(0) or WeakFixedArray of prototype transitions (strong ref)
// |1] Tagged<Smi>(0) or WeakFixedArray of side-step transitions (strong ref)
// |2] Number of transitions (can be zero after trimming)
// |3] First transition key (strong ref)
// |4] First transition target (weak ref)
// ...
// |4 + number of transitions * kTransitionSize]: start of slack
// TODO(olivf): The slots for prototype transitions and side-steps could be
// shared.
class TransitionArray : public WeakFixedArray {
 public:
  inline int number_of_transitions() const;

  inline Tagged<WeakFixedArray> GetPrototypeTransitions();
  inline bool HasPrototypeTransitions();

  // Accessors for fetching instance transition at transition number.
  inline void SetKey(int transition_number, Tagged<Name> value);
  inline Tagged<Name> GetKey(int transition_number);
  inline HeapObjectSlot GetKeySlot(int transition_number);

  inline Tagged<Map> GetTarget(int transition_number);
  inline void SetRawTarget(int transition_number, Tagged<MaybeObject> target);
  inline Tagged<MaybeObject> GetRawTarget(int transition_number);
  inline HeapObjectSlot GetTargetSlot(int transition_number);
  inline bool GetTargetIfExists(int transition_number, Isolate* isolate,
                                Tagged<Map>* target);

  static constexpr int kNotFound = -1;

#ifdef DEBUG
  V8_EXPORT_PRIVATE bool IsSortedNoDuplicates();
#endif

  V8_EXPORT_PRIVATE void Sort();

  void PrintInternal(std::ostream& os);

  DECL_PRINTER(TransitionArray)
  DECL_VERIFIER(TransitionArray)

  // Layout for full transition arrays.
  static const int kPrototypeTransitionsIndex = 0;
  static const int kSideStepTransitionsIndex = 1;
  static const int kTransitionLengthIndex = 2;
  static const int kFirstIndex = 3;

  // Layout of map transition entries in full transition arrays.
  static const int kEntryKeyIndex = 0;
  static const int kEntryTargetIndex = 1;
  static const int kEntrySize = 2;

  // Conversion from transition number to array indices.
  static int ToKeyIndex(int transition_number) {
    return kFirstIndex + (transition_number * kEntrySize) + kEntryKeyIndex;
  }

  static int ToTargetIndex(int transition_number) {
    return kFirstIndex + (transition_number * kEntrySize) + kEntryTargetIndex;
  }

  inline int SearchNameForTesting(Tagged<Name> name,
                                  int* out_insertion_index = nullptr);

  inline Tagged<Map> SearchAndGetTargetForTesting(
      PropertyKind kind, Tagged<Name> name, PropertyAttributes attributes);

  // Accessors for side-step transitions.
  inline bool HasSideStepTransitions();
  static void CreateSideStepTransitions(
      Isolate* isolate, DirectHandle<TransitionArray> transitions);

 private:
  friend class Factory;
  friend class MarkCompactCollector;
  friend class TransitionsAccessor;

  inline void SetNumberOfTransitions(int number_of_transitions);

  inline int Capacity();

  // ===== PROTOTYPE TRANSITIONS =====
  // Cache format:
  //    0: finger - index of the first free cell in the cache
  //    1 + i: target map
  static const int kProtoTransitionHeaderSize = 1;
  static const int kMaxCachedPrototypeTransitions = 256;

  inline void SetPrototypeTransitions(
      Tagged<WeakFixedArray> prototype_transitions);

  static inline int NumberOfPrototypeTransitions(
      Tagged<WeakFixedArray> proto_transitions);
  static void SetNumberOfPrototypeTransitions(
      Tagged<WeakFixedArray> proto_transitions, int value);

  static const int kProtoTransitionNumberOfEntriesOffset = 0;
  static_assert(kProtoTransitionHeaderSize == 1);

  // Returns the fixed array length required to hold number_of_transitions
  // transitions.
  static int LengthFor(int number_of_transitions) {
    return ToKeyIndex(number_of_transitions);
  }

  // Search a  transition for a given kind, property name and attributes.
  int Search(PropertyKind kind, Tagged<Name> name,
             PropertyAttributes attributes, int* out_insertion_index = nullptr);

  V8_EXPORT_PRIVATE Tagged<Map> SearchAndGetTarget(
      PropertyKind kind, Tagged<Name> name, PropertyAttributes attributes);

  // Search a non-property transition (like elements kind, observe or frozen
  // transitions).
  inline int SearchSpecial(Tagged<Symbol> symbol,
                           bool concurrent_search = false,
                           int* out_insertion_index = nullptr);
  // Search a first transition for a given property name.
  inline int SearchName(Tagged<Name> name, bool concurrent_search = false,
                        int* out_insertion_index = nullptr);
  int SearchDetails(int transition, PropertyKind kind,
                    PropertyAttributes attributes, int* out_insertion_index);
  Tagged<Map> SearchDetailsAndGetTarget(int transition, PropertyKind kind,
                                        PropertyAttributes attributes);

  inline int LinearSearchName(Tagged<Name> name, int* out_insertion_index);
  inline int BinarySearchName(Tagged<Name> name, int* out_insertion_index);

  // Find all transitions with given name and calls the callback.
  void ForEachTransitionTo(Tagged<Name> name,
                           const ForEachTransitionCallback& callback);

  static bool CompactPrototypeTransitionArray(Isolate* isolate,
                                              Tagged<WeakFixedArray> array);

  static Handle<WeakFixedArray> GrowPrototypeTransitionArray(
      DirectHandle<WeakFixedArray> array, int new_capacity, Isolate* isolate);

  // Compares two tuples <key, kind, attributes>, returns -1 if
  // tuple1 is "less" than tuple2, 0 if tuple1 equal to tuple2 and 1 otherwise.
  static inline int CompareKeys(Tagged<Name> key1, uint32_t hash1,
                                PropertyKind kind1,
                                PropertyAttributes attributes1,
                                Tagged<Name> key2, uint32_t hash2,
                                PropertyKind kind2,
                                PropertyAttributes attributes2);

  // Compares keys, returns -1 if key1 is "less" than key2,
  // 0 if key1 equal to key2 and 1 otherwise.
  static inline int CompareNames(Tagged<Name> key1, uint32_t hash1,
                                 Tagged<Name> key2, uint32_t hash2);

  // Compares two details, returns -1 if details1 is "less" than details2,
  // 0 if details1 equal to details2 and 1 otherwise.
  static inline int CompareDetails(PropertyKind kind1,
                                   PropertyAttributes attributes1,
                                   PropertyKind kind2,
                                   PropertyAttributes attributes2);

  inline void Set(int transition_number, Tagged<Name> key,
                  Tagged<MaybeObject> target);

  inline Tagged<WeakFixedArray> GetSideStepTransitions();
  inline void SetSideStepTransitions(Tagged<WeakFixedArray> transitions);
};

}  // namespace v8::internal

#include "src/objects/object-macros-undef.h"

#endif  // V8_OBJECTS_TRANSITIONS_H_
[Step 29: Duration 19.68 seconds| Input tokens: 913,340 | Output tokens: 15,953]
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ Step 30 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'read_file' with arguments: {'file_path': '/Users/tarun/v8/v8/src/objects/map-inl.h'}                                                                                                          │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
Command: cd /Users/tarun/v8/v8/src && wc -l '/Users/tarun/v8/v8/src/objects/map-inl.h'
Command: cd /Users/tarun/v8/v8/src && cat '/Users/tarun/v8/v8/src/objects/map-inl.h'
Observations: // Copyright 2017 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef V8_OBJECTS_MAP_INL_H_
#define V8_OBJECTS_MAP_INL_H_

#include "src/heap/heap-layout-inl.h"
#include "src/heap/heap-write-barrier-inl.h"
#include "src/objects/api-callbacks-inl.h"
#include "src/objects/cell-inl.h"
#include "src/objects/dependent-code.h"
#include "src/objects/descriptor-array-inl.h"
#include "src/objects/dictionary.h"
#include "src/objects/field-type.h"
#include "src/objects/instance-type-inl.h"
#include "src/objects/js-function-inl.h"
#include "src/objects/map-updater.h"
#include "src/objects/map.h"
#include "src/objects/objects-inl.h"
#include "src/objects/property.h"
#include "src/objects/prototype-info-inl.h"
#include "src/objects/prototype-info.h"
#include "src/objects/shared-function-info-inl.h"
#include "src/objects/templates-inl.h"
#include "src/objects/transitions-inl.h"
#include "src/objects/transitions.h"

#if V8_ENABLE_WEBASSEMBLY
#include "src/wasm/wasm-objects-inl.h"
#endif  // V8_ENABLE_WEBASSEMBLY

// Has to be the last include (doesn't have include guards):
#include "src/objects/object-macros.h"

namespace v8 {
namespace internal {

#include "torque-generated/src/objects/map-tq-inl.inc"

TQ_OBJECT_CONSTRUCTORS_IMPL(Map)

ACCESSORS(Map, instance_descriptors, Tagged<DescriptorArray>,
          kInstanceDescriptorsOffset)
RELAXED_ACCESSORS(Map, instance_descriptors, Tagged<DescriptorArray>,
                  kInstanceDescriptorsOffset)
RELEASE_ACQUIRE_ACCESSORS(Map, instance_descriptors, Tagged<DescriptorArray>,
                          kInstanceDescriptorsOffset)

// A freshly allocated layout descriptor can be set on an existing map.
// We need to use release-store and acquire-load accessor pairs to ensure
// that the concurrent marking thread observes initializing stores of the
// layout descriptor.
ACCESSORS(Map, raw_transitions,
          (Tagged<UnionOf<Smi, MaybeWeak<Map>, TransitionArray>>),
          kTransitionsOrPrototypeInfoOffset)
RELEASE_ACQUIRE_ACCESSORS(
    Map, raw_transitions,
    (Tagged<UnionOf<Smi, MaybeWeak<Map>, TransitionArray>>),
    kTransitionsOrPrototypeInfoOffset)

ACCESSORS_CHECKED2(Map, prototype, Tagged<JSPrototype>, kPrototypeOffset, true,
                   IsNull(value) || IsJSProxy(value) || IsWasmObject(value) ||
                       (IsJSObject(value) &&
                        (HeapLayout::InWritableSharedSpace(value) ||
                         value->map()->is_prototype_map())))

DEF_GETTER(Map, prototype_info, Tagged<UnionOf<Smi, PrototypeInfo>>) {
  Tagged<UnionOf<Smi, PrototypeInfo>> value =
      TaggedField<UnionOf<Smi, PrototypeInfo>,
                  kTransitionsOrPrototypeInfoOffset>::load(cage_base, *this);
  DCHECK(this->is_prototype_map());
  return value;
}
RELEASE_ACQUIRE_ACCESSORS(Map, prototype_info,
                          (Tagged<UnionOf<Smi, PrototypeInfo>>),
                          kTransitionsOrPrototypeInfoOffset)

void Map::init_prototype_and_constructor_or_back_pointer(ReadOnlyRoots roots) {
  Tagged<HeapObject> null = roots.null_value();
  TaggedField<HeapObject,
              kConstructorOrBackPointerOrNativeContextOffset>::store(*this,
                                                                     null);
  TaggedField<HeapObject, kPrototypeOffset>::store(*this, null);
}

// |bit_field| fields.
// Concurrent access to |has_prototype_slot| and |has_non_instance_prototype|
// is explicitly allowlisted here. The former is never modified after the map
// is setup but it's being read by concurrent marker when pointer compression
// is enabled. The latter bit can be modified on a live objects.
BIT_FIELD_ACCESSORS(Map, relaxed_bit_field, has_non_instance_prototype,
                    Map::Bits1::HasNonInstancePrototypeBit)
BIT_FIELD_ACCESSORS(Map, relaxed_bit_field, has_prototype_slot,
                    Map::Bits1::HasPrototypeSlotBit)

// These are fine to be written as non-atomic since we don't have data races.
// However, they have to be read atomically from the background since the
// |bit_field| as a whole can mutate when using the above setters.
BIT_FIELD_ACCESSORS2(Map, relaxed_bit_field, bit_field, is_callable,
                     Map::Bits1::IsCallableBit)
BIT_FIELD_ACCESSORS2(Map, relaxed_bit_field, bit_field, has_named_interceptor,
                     Map::Bits1::HasNamedInterceptorBit)
BIT_FIELD_ACCESSORS2(Map, relaxed_bit_field, bit_field, has_indexed_interceptor,
                     Map::Bits1::HasIndexedInterceptorBit)
BIT_FIELD_ACCESSORS2(Map, relaxed_bit_field, bit_field, is_undetectable,
                     Map::Bits1::IsUndetectableBit)
BIT_FIELD_ACCESSORS2(Map, relaxed_bit_field, bit_field, is_access_check_needed,
                     Map::Bits1::IsAccessCheckNeededBit)
BIT_FIELD_ACCESSORS2(Map, relaxed_bit_field, bit_field, is_constructor,
                     Map::Bits1::IsConstructorBit)

// |bit_field2| fields.
BIT_FIELD_ACCESSORS(Map, bit_field2, new_target_is_base,
                    Map::Bits2::NewTargetIsBaseBit)
BIT_FIELD_ACCESSORS(Map, bit_field2, is_immutable_proto,
                    Map::Bits2::IsImmutablePrototypeBit)

// |bit_field3| fields.
BIT_FIELD_ACCESSORS(Map, relaxed_bit_field3, owns_descriptors,
                    Map::Bits3::OwnsDescriptorsBit)
BIT_FIELD_ACCESSORS(Map, release_acquire_bit_field3, is_deprecated,
                    Map::Bits3::IsDeprecatedBit)
BIT_FIELD_ACCESSORS(Map, relaxed_bit_field3, is_in_retained_map_list,
                    Map::Bits3::IsInRetainedMapListBit)
BIT_FIELD_ACCESSORS(Map, release_acquire_bit_field3, is_prototype_map,
                    Map::Bits3::IsPrototypeMapBit)
BIT_FIELD_ACCESSORS(Map, relaxed_bit_field3, is_migration_target,
                    Map::Bits3::IsMigrationTargetBit)
BIT_FIELD_ACCESSORS2(Map, relaxed_bit_field3, bit_field3, is_extensible,
                     Map::Bits3::IsExtensibleBit)
BIT_FIELD_ACCESSORS(Map, bit_field3, may_have_interesting_properties,
                    Map::Bits3::MayHaveInterestingPropertiesBit)
BIT_FIELD_ACCESSORS(Map, relaxed_bit_field3, construction_counter,
                    Map::Bits3::ConstructionCounterBits)

DEF_GETTER(Map, GetNamedInterceptor, Tagged<InterceptorInfo>) {
  DCHECK(has_named_interceptor());
  Tagged<FunctionTemplateInfo> info = GetFunctionTemplateInfo(cage_base);
  return Cast<InterceptorInfo>(info->GetNamedPropertyHandler(cage_base));
}

DEF_GETTER(Map, GetIndexedInterceptor, Tagged<InterceptorInfo>) {
  DCHECK(has_indexed_interceptor());
  Tagged<FunctionTemplateInfo> info = GetFunctionTemplateInfo(cage_base);
  return Cast<InterceptorInfo>(info->GetIndexedPropertyHandler(cage_base));
}

// static
bool Map::IsMostGeneralFieldType(Representation representation,
                                 Tagged<FieldType> field_type) {
  return !representation.IsHeapObject() || IsAny(field_type);
}

// static
bool Map::CanHaveFastTransitionableElementsKind(InstanceType instance_type) {
  return instance_type == JS_ARRAY_TYPE ||
         instance_type == JS_PRIMITIVE_WRAPPER_TYPE ||
         instance_type == JS_ARGUMENTS_OBJECT_TYPE;
}

bool Map::CanHaveFastTransitionableElementsKind() const {
  return CanHaveFastTransitionableElementsKind(instance_type());
}

bool Map::IsDetached(Isolate* isolate) const {
  if (is_prototype_map()) return true;
  return instance_type() == JS_OBJECT_TYPE && NumberOfOwnDescriptors() > 0 &&
         IsUndefined(GetBackPointer(), isolate);
}

// static
void Map::GeneralizeIfCanHaveTransitionableFastElementsKind(
    Isolate* isolate, InstanceType instance_type,
    Representation* representation, Handle<FieldType>* field_type) {
  if (CanHaveFastTransitionableElementsKind(instance_type)) {
    // We don't support propagation of field generalization through elements
    // kind transitions because they are inserted into the transition tree
    // before field transitions. In order to avoid complexity of handling
    // such a case we ensure that all maps with transitionable elements kinds
    // have the most general field representation and type.
    *field_type = FieldType::Any(isolate);
    *representation = Representation::Tagged();
  }
}

Handle<Map> Map::Normalize(Isolate* isolate, DirectHandle<Map> fast_map,
                           PropertyNormalizationMode mode, const char* reason) {
  const bool kUseCache = true;
  return Normalize(isolate, fast_map, fast_map->elements_kind(), {}, mode,
                   kUseCache, reason);
}

bool Map::EquivalentToForNormalization(const Tagged<Map> other,
                                       PropertyNormalizationMode mode) const {
  return EquivalentToForNormalization(other, elements_kind(), prototype(),
                                      mode);
}

bool Map::TooManyFastProperties(StoreOrigin store_origin) const {
  if (UnusedPropertyFields() != 0) return false;
  if (store_origin != StoreOrigin::kMaybeKeyed) return false;
  if (is_prototype_map()) return false;
  int limit = std::max(
      {v8_flags.fast_properties_soft_limit.value(), GetInObjectProperties()});
  int external =
      NumberOfFields(ConcurrencyMode::kSynchronous) - GetInObjectProperties();
  return external > limit;
}

Tagged<Name> Map::GetLastDescriptorName(Isolate* isolate) const {
  return instance_descriptors(isolate)->GetKey(LastAdded());
}

PropertyDetails Map::GetLastDescriptorDetails(Isolate* isolate) const {
  return instance_descriptors(isolate)->GetDetails(LastAdded());
}

InternalIndex Map::LastAdded() const {
  int number_of_own_descriptors = NumberOfOwnDescriptors();
  DCHECK_GT(number_of_own_descriptors, 0);
  return InternalIndex(number_of_own_descriptors - 1);
}

int Map::NumberOfOwnDescriptors() const {
  return Bits3::NumberOfOwnDescriptorsBits::decode(
      release_acquire_bit_field3());
}

void Map::SetNumberOfOwnDescriptors(int number) {
  DCHECK_LE(number, instance_descriptors()->number_of_descriptors());
  CHECK_LE(static_cast<unsigned>(number),
           static_cast<unsigned>(kMaxNumberOfDescriptors));
  set_release_acquire_bit_field3(
      Bits3::NumberOfOwnDescriptorsBits::update(bit_field3(), number));
}

InternalIndex::Range Map::IterateOwnDescriptors() const {
  return InternalIndex::Range(NumberOfOwnDescriptors());
}

int Map::EnumLength() const {
  return Bits3::EnumLengthBits::decode(bit_field3());
}

void Map::SetEnumLength(int length) {
  if (length != kInvalidEnumCacheSentinel) {
    DCHECK_LE(length, NumberOfOwnDescriptors());
    CHECK_LE(static_cast<unsigned>(length),
             static_cast<unsigned>(kMaxNumberOfDescriptors));
  }
  set_relaxed_bit_field3(Bits3::EnumLengthBits::update(bit_field3(), length));
}

Tagged<FixedArrayBase> Map::GetInitialElements() const {
  Tagged<FixedArrayBase> result;
  if (has_fast_elements() || has_fast_string_wrapper_elements() ||
      has_any_nonextensible_elements()) {
    result = GetReadOnlyRoots().empty_fixed_array();
  } else if (has_typed_array_or_rab_gsab_typed_array_elements()) {
    result = GetReadOnlyRoots().empty_byte_array();
  } else if (has_dictionary_elements()) {
    result = GetReadOnlyRoots().empty_slow_element_dictionary();
  } else {
    UNREACHABLE();
  }
  DCHECK(!HeapLayout::InYoungGeneration(result));
  return result;
}

VisitorId Map::visitor_id() const {
  return static_cast<VisitorId>(
      RELAXED_READ_BYTE_FIELD(*this, kVisitorIdOffset));
}

void Map::set_visitor_id(VisitorId id) {
  CHECK_LT(static_cast<unsigned>(id), 256);
  RELAXED_WRITE_BYTE_FIELD(*this, kVisitorIdOffset, static_cast<uint8_t>(id));
}

int Map::instance_size_in_words() const {
  return RELAXED_READ_BYTE_FIELD(*this, kInstanceSizeInWordsOffset);
}

void Map::set_instance_size_in_words(int value) {
  RELAXED_WRITE_BYTE_FIELD(*this, kInstanceSizeInWordsOffset,
                           static_cast<uint8_t>(value));
}

int Map::instance_size() const {
  return instance_size_in_words() << kTaggedSizeLog2;
}

void Map::set_instance_size(int size_in_bytes) {
  CHECK(IsAligned(size_in_bytes, kTaggedSize));
  DCHECK_LE(static_cast<unsigned>(size_in_bytes), JSObject::kMaxInstanceSize);
  int size_in_words = size_in_bytes >>= kTaggedSizeLog2;
  CHECK_LE(static_cast<unsigned>(size_in_words), kMaxUInt8);
  set_instance_size_in_words(size_in_words);
}

int Map::inobject_properties_start_or_constructor_function_index() const {
  // TODO(solanes, v8:7790, v8:11353): Make this and the setter non-atomic
  // when TSAN sees the map's store synchronization.
  return RELAXED_READ_BYTE_FIELD(
      *this, kInobjectPropertiesStartOrConstructorFunctionIndexOffset);
}

void Map::set_inobject_properties_start_or_constructor_function_index(
    int value) {
  CHECK_LE(static_cast<unsigned>(value), kMaxUInt8);
  RELAXED_WRITE_BYTE_FIELD(
      *this, kInobjectPropertiesStartOrConstructorFunctionIndexOffset,
      static_cast<uint8_t>(value));
}

int Map::GetInObjectPropertiesStartInWords() const {
  DCHECK(IsJSObjectMap(*this));
  return inobject_properties_start_or_constructor_function_index();
}

void Map::SetInObjectPropertiesStartInWords(int value) {
  CHECK(IsJSObjectMap(*this));
  set_inobject_properties_start_or_constructor_function_index(value);
}

bool Map::HasOutOfObjectProperties() const {
  bool ret = used_or_unused_instance_size_in_words() < JSObject::kFieldsAdded;
  DCHECK_EQ(ret, GetInObjectProperties() <
                     NumberOfFields(ConcurrencyMode::kSynchronous));
  return ret;
}

int Map::GetInObjectProperties() const {
  DCHECK(IsJSObjectMap(*this));
  return instance_size_in_words() - GetInObjectPropertiesStartInWords();
}

int Map::GetConstructorFunctionIndex() const {
#if V8_ENABLE_WEBASSEMBLY
  // We allow WasmNull here so builtins can produce error messages when
  // called from Wasm, without having to special-case WasmNull at every
  // caller of such a builtin.
  DCHECK(IsPrimitiveMap(*this) || instance_type() == WASM_NULL_TYPE);
#else
  DCHECK(IsPrimitiveMap(*this));
#endif
  return inobject_properties_start_or_constructor_function_index();
}

void Map::SetConstructorFunctionIndex(int value) {
  CHECK(IsPrimitiveMap(*this));
  set_inobject_properties_start_or_constructor_function_index(value);
}

int Map::GetInObjectPropertyOffset(int index) const {
  return (GetInObjectPropertiesStartInWords() + index) * kTaggedSize;
}

Handle<Map> Map::AddMissingTransitionsForTesting(
    Isolate* isolate, DirectHandle<Map> split_map,
    DirectHandle<DescriptorArray> descriptors) {
  return AddMissingTransitions(isolate, split_map, descriptors);
}

int Map::UnusedPropertyFields() const {
#if V8_ENABLE_WEBASSEMBLY
  DCHECK(!IsWasmObjectMap(*this));
#endif  // V8_ENABLE_WEBASSEMBLY
  int value = used_or_unused_instance_size_in_words();
  DCHECK_IMPLIES(!IsJSObjectMap(*this), value == 0);
  int unused;
  if (value >= JSObject::kFieldsAdded) {
    unused = instance_size_in_words() - value;
  } else {
    // For out of object properties "used_or_unused_instance_size_in_words"
    // byte encodes the slack in the property array.
    unused = value;
  }
  return unused;
}

int Map::UnusedInObjectProperties() const {
  // Like Map::UnusedPropertyFields(), but returns 0 for out of object
  // properties.
#if V8_ENABLE_WEBASSEMBLY
  DCHECK(!IsWasmObjectMap(*this));
#endif  // V8_ENABLE_WEBASSEMBLY
  int value = used_or_unused_instance_size_in_words();
  DCHECK_IMPLIES(!IsJSObjectMap(*this), value == 0);
  if (value >= JSObject::kFieldsAdded) {
    return instance_size_in_words() - value;
  }
  return 0;
}

int Map::used_or_unused_instance_size_in_words() const {
  return RELAXED_READ_BYTE_FIELD(*this, kUsedOrUnusedInstanceSizeInWordsOffset);
}

void Map::set_used_or_unused_instance_size_in_words(int value) {
  CHECK_LE(static_cast<unsigned>(value), 255);
  RELAXED_WRITE_BYTE_FIELD(*this, kUsedOrUnusedInstanceSizeInWordsOffset,
                           static_cast<uint8_t>(value));
}

int Map::UsedInstanceSize() const {
#if V8_ENABLE_WEBASSEMBLY
  DCHECK(!IsWasmObjectMap(*this));
#endif  // V8_ENABLE_WEBASSEMBLY
  int words = used_or_unused_instance_size_in_words();
  if (words < JSObject::kFieldsAdded) {
    // All in-object properties are used and the words is tracking the slack
    // in the property array.
    return instance_size();
  }
  return words * kTaggedSize;
}

void Map::SetInObjectUnusedPropertyFields(int value) {
  static_assert(JSObject::kFieldsAdded == JSObject::kHeaderSize / kTaggedSize);
  if (!IsJSObjectMap(*this)) {
    CHECK_EQ(0, value);
    set_used_or_unused_instance_size_in_words(0);
    return;
  }
  CHECK_LE(0, value);
  DCHECK_LE(value, GetInObjectProperties());
  int used_inobject_properties = GetInObjectProperties() - value;
  set_used_or_unused_instance_size_in_words(
      GetInObjectPropertyOffset(used_inobject_properties) / kTaggedSize);
  DCHECK_EQ(value, UnusedPropertyFields());
}

void Map::SetOutOfObjectUnusedPropertyFields(int value) {
  static_assert(JSObject::kFieldsAdded == JSObject::kHeaderSize / kTaggedSize);
  CHECK_LT(static_cast<unsigned>(value), JSObject::kFieldsAdded);
  // For out of object properties "used_instance_size_in_words" byte encodes
  // the slack in the property array.
  set_used_or_unused_instance_size_in_words(value);
  DCHECK_EQ(value, UnusedPropertyFields());
}

void Map::CopyUnusedPropertyFields(Tagged<Map> map) {
  set_used_or_unused_instance_size_in_words(
      map->used_or_unused_instance_size_in_words());
  DCHECK_EQ(UnusedPropertyFields(), map->UnusedPropertyFields());
}

void Map::CopyUnusedPropertyFieldsAdjustedForInstanceSize(Tagged<Map> map) {
  int value = map->used_or_unused_instance_size_in_words();
  if (value >= JSPrimitiveWrapper::kFieldsAdded) {
    // Unused in-object fields. Adjust the offset from the object’s start
    // so it matches the distance to the object’s end.
    value += instance_size_in_words() - map->instance_size_in_words();
  }
  set_used_or_unused_instance_size_in_words(value);
  DCHECK_EQ(UnusedPropertyFields(), map->UnusedPropertyFields());
}

void Map::AccountAddedPropertyField() {
  // Update used instance size and unused property fields number.
  static_assert(JSObject::kFieldsAdded == JSObject::kHeaderSize / kTaggedSize);
#ifdef DEBUG
  int new_unused = UnusedPropertyFields() - 1;
  if (new_unused < 0) new_unused += JSObject::kFieldsAdded;
#endif
  int value = used_or_unused_instance_size_in_words();
  if (value >= JSObject::kFieldsAdded) {
    if (value == instance_size_in_words()) {
      AccountAddedOutOfObjectPropertyField(0);
    } else {
      // The property is added in-object, so simply increment the counter.
      set_used_or_unused_instance_size_in_words(value + 1);
    }
  } else {
    AccountAddedOutOfObjectPropertyField(value);
  }
  DCHECK_EQ(new_unused, UnusedPropertyFields());
}

void Map::AccountAddedOutOfObjectPropertyField(int unused_in_property_array) {
  unused_in_property_array--;
  if (unused_in_property_array < 0) {
    unused_in_property_array += JSObject::kFieldsAdded;
  }
  CHECK_LT(static_cast<unsigned>(unused_in_property_array),
           JSObject::kFieldsAdded);
  set_used_or_unused_instance_size_in_words(unused_in_property_array);
  DCHECK_EQ(unused_in_property_array, UnusedPropertyFields());
}

#if V8_ENABLE_WEBASSEMBLY
uint8_t Map::WasmByte1() const {
  DCHECK(IsWasmObjectMap(*this));
  return inobject_properties_start_or_constructor_function_index();
}

uint8_t Map::WasmByte2() const {
  DCHECK(IsWasmObjectMap(*this));
  return used_or_unused_instance_size_in_words();
}

void Map::SetWasmByte1(uint8_t value) {
  CHECK(IsWasmObjectMap(*this));
  set_inobject_properties_start_or_constructor_function_index(value);
}

void Map::SetWasmByte2(uint8_t value) {
  CHECK(IsWasmObjectMap(*this));
  set_used_or_unused_instance_size_in_words(value);
}
#endif  // V8_ENABLE_WEBASSEMBLY

uint8_t Map::bit_field() const {
  // TODO(solanes, v8:7790, v8:11353): Make this non-atomic when TSAN sees the
  // map's store synchronization.
  return relaxed_bit_field();
}

void Map::set_bit_field(uint8_t value) {
  // TODO(solanes, v8:7790, v8:11353): Make this non-atomic when TSAN sees the
  // map's store synchronization.
  set_relaxed_bit_field(value);
}

uint8_t Map::relaxed_bit_field() const {
  return RELAXED_READ_BYTE_FIELD(*this, kBitFieldOffset);
}

void Map::set_relaxed_bit_field(uint8_t value) {
  RELAXED_WRITE_BYTE_FIELD(*this, kBitFieldOffset, value);
}

uint8_t Map::bit_field2() const { return ReadField<uint8_t>(kBitField2Offset); }

void Map::set_bit_field2(uint8_t value) {
  WriteField<uint8_t>(kBitField2Offset, value);
}

uint32_t Map::bit_field3() const {
  // TODO(solanes, v8:7790, v8:11353): Make this and the setter non-atomic
  // when TSAN sees the map's store synchronization.
  return relaxed_bit_field3();
}

void Map::set_bit_field3(uint32_t value) { set_relaxed_bit_field3(value); }

uint32_t Map::relaxed_bit_field3() const {
  return RELAXED_READ_UINT32_FIELD(*this, kBitField3Offset);
}

void Map::set_relaxed_bit_field3(uint32_t value) {
  RELAXED_WRITE_UINT32_FIELD(*this, kBitField3Offset, value);
}

uint32_t Map::release_acquire_bit_field3() const {
  return ACQUIRE_READ_UINT32_FIELD(*this, kBitField3Offset);
}

void Map::set_release_acquire_bit_field3(uint32_t value) {
  RELEASE_WRITE_UINT32_FIELD(*this, kBitField3Offset, value);
}

bool Map::is_abandoned_prototype_map() const {
  return is_prototype_map() && !owns_descriptors();
}

bool Map::should_be_fast_prototype_map() const {
  DCHECK(is_prototype_map());
  if (!has_prototype_info()) return false;
  return Cast<PrototypeInfo>(prototype_info())->should_be_fast_map();
}

bool Map::has_prototype_info() const {
  DCHECK(is_prototype_map());
  return PrototypeInfo::IsPrototypeInfoFast(prototype_info());
}

bool Map::TryGetPrototypeInfo(Tagged<PrototypeInfo>* result) const {
  DCHECK(is_prototype_map());
  Tagged<Object> maybe_proto_info = prototype_info();
  if (!PrototypeInfo::IsPrototypeInfoFast(maybe_proto_info)) return false;
  *result = Cast<PrototypeInfo>(maybe_proto_info);
  return true;
}

void Map::set_elements_kind(ElementsKind elements_kind) {
  CHECK_LT(static_cast<int>(elements_kind), kElementsKindCount);
  set_bit_field2(
      Map::Bits2::ElementsKindBits::update(bit_field2(), elements_kind));
}

ElementsKind Map::elements_kind() const {
  return Map::Bits2::ElementsKindBits::decode(bit_field2());
}

bool Map::has_fast_smi_elements() const {
  return IsSmiElementsKind(elements_kind());
}

bool Map::has_fast_object_elements() const {
  return IsObjectElementsKind(elements_kind());
}

bool Map::has_fast_smi_or_object_elements() const {
  return IsSmiOrObjectElementsKind(elements_kind());
}

bool Map::has_fast_double_elements() const {
  return IsDoubleElementsKind(elements_kind());
}

bool Map::has_fast_elements() const {
  return IsFastElementsKind(elements_kind());
}

bool Map::has_fast_packed_elements() const {
  return IsFastPackedElementsKind(elements_kind());
}

bool Map::has_sloppy_arguments_elements() const {
  return IsSloppyArgumentsElementsKind(elements_kind());
}

bool Map::has_fast_sloppy_arguments_elements() const {
  return elements_kind() == FAST_SLOPPY_ARGUMENTS_ELEMENTS;
}

bool Map::has_fast_string_wrapper_elements() const {
  return elements_kind() == FAST_STRING_WRAPPER_ELEMENTS;
}

bool Map::has_typed_array_or_rab_gsab_typed_array_elements() const {
  return IsTypedArrayOrRabGsabTypedArrayElementsKind(elements_kind());
}

bool Map::has_any_typed_array_or_wasm_array_elements() const {
  ElementsKind kind = elements_kind();
  return IsTypedArrayOrRabGsabTypedArrayElementsKind(kind) ||
#if V8_ENABLE_WEBASSEMBLY
         IsWasmArrayElementsKind(kind) ||
#endif  // V8_ENABLE_WEBASSEMBLY
         false;
}

bool Map::has_dictionary_elements() const {
  return IsDictionaryElementsKind(elements_kind());
}

bool Map::has_any_nonextensible_elements() const {
  return IsAnyNonextensibleElementsKind(elements_kind());
}

bool Map::has_nonextensible_elements() const {
  return IsNonextensibleElementsKind(elements_kind());
}

bool Map::has_sealed_elements() const {
  return IsSealedElementsKind(elements_kind());
}

bool Map::has_frozen_elements() const {
  return IsFrozenElementsKind(elements_kind());
}

bool Map::has_shared_array_elements() const {
  return IsSharedArrayElementsKind(elements_kind());
}

void Map::set_is_dictionary_map(bool value) {
  uint32_t new_bit_field3 =
      Bits3::IsDictionaryMapBit::update(bit_field3(), value);
  new_bit_field3 = Bits3::IsUnstableBit::update(new_bit_field3, value);
  set_bit_field3(new_bit_field3);
}

bool Map::is_dictionary_map() const {
  return Bits3::IsDictionaryMapBit::decode(relaxed_bit_field3());
}

void Map::mark_unstable() {
  set_release_acquire_bit_field3(
      Bits3::IsUnstableBit::update(bit_field3(), true));
}

bool Map::is_stable() const {
  return !Bits3::IsUnstableBit::decode(release_acquire_bit_field3());
}

bool Map::CanBeDeprecated() const {
  for (InternalIndex i : IterateOwnDescriptors()) {
    PropertyDetails details = instance_descriptors(kRelaxedLoad)->GetDetails(i);
    if (details.representation().MightCauseMapDeprecation()) return true;
    if (details.kind() == PropertyKind::kData &&
        details.location() == PropertyLocation::kDescriptor) {
      return true;
    }
  }
  return false;
}

void Map::NotifyLeafMapLayoutChange(Isolate* isolate) {
  if (is_stable()) {
    mark_unstable();
    DependentCode::DeoptimizeDependencyGroups(
        isolate, *this, DependentCode::kPrototypeCheckGroup);
  }
}

bool Map::CanTransition() const {
  // Only JSObject and subtypes have map transitions and back pointers.
  const InstanceType type = instance_type();
  // Shared JS objects have fixed shapes and do not transition. Their maps are
  // either in shared space or RO space.
  DCHECK_IMPLIES(InstanceTypeChecker::IsAlwaysSharedSpaceJSObject(type),
                 HeapLayout::InAnySharedSpace(*this));
  return InstanceTypeChecker::IsJSObject(type) &&
         !InstanceTypeChecker::IsAlwaysSharedSpaceJSObject(type);
}

bool IsBooleanMap(Tagged<Map> map) {
  return map == GetReadOnlyRoots().boolean_map();
}

bool IsNullOrUndefinedMap(Tagged<Map> map) {
  auto roots = GetReadOnlyRoots();
  return map == roots.null_map() || map == roots.undefined_map();
}

bool IsPrimitiveMap(Tagged<Map> map) {
  return map->instance_type() <= LAST_PRIMITIVE_HEAP_OBJECT_TYPE;
}

void Map::UpdateDescriptors(Isolate* isolate,
                            Tagged<DescriptorArray> descriptors,
                            int number_of_own_descriptors) {
  SetInstanceDescriptors(isolate, descriptors, number_of_own_descriptors);
}

void Map::InitializeDescriptors(Isolate* isolate,
                                Tagged<DescriptorArray> descriptors) {
  SetInstanceDescriptors(isolate, descriptors,
                         descriptors->number_of_descriptors());
}

void Map::clear_padding() {
  if (FIELD_SIZE(kOptionalPaddingOffset) == 0) return;
  DCHECK_EQ(4, FIELD_SIZE(kOptionalPaddingOffset));
  memset(reinterpret_cast<void*>(address() + kOptionalPaddingOffset), 0,
         FIELD_SIZE(kOptionalPaddingOffset));
}

void Map::AppendDescriptor(Isolate* isolate, Descriptor* desc) {
  Tagged<DescriptorArray> descriptors = instance_descriptors(isolate);
  int number_of_own_descriptors = NumberOfOwnDescriptors();
  DCHECK(descriptors->number_of_descriptors() == number_of_own_descriptors);
  {
    // The following two operations need to happen before the marking write
    // barrier.
    descriptors->Append(desc);
    SetNumberOfOwnDescriptors(number_of_own_descriptors + 1);
#ifndef V8_DISABLE_WRITE_BARRIERS
    WriteBarrier::ForDescriptorArray(descriptors,
                                     number_of_own_descriptors + 1);
#endif
  }
  // Properly mark the map if the {desc} is an "interesting symbol".
  if (desc->GetKey()->IsInteresting(isolate)) {
    set_may_have_interesting_properties(true);
  }
  PropertyDetails details = desc->GetDetails();
  if (details.location() == PropertyLocation::kField) {
    DCHECK_GT(UnusedPropertyFields(), 0);
    AccountAddedPropertyField();
  }

// This function does not support appending double field descriptors and
// it should never try to (otherwise, layout descriptor must be updated too).
#ifdef DEBUG
  DCHECK(details.location() != PropertyLocation::kField ||
         !details.representation().IsDouble());
#endif
}

// static
bool Map::ConcurrentIsHeapObjectWithMap(PtrComprCageBase cage_base,
                                        Tagged<Object> object,
                                        Tagged<Map> meta_map) {
  if (!IsHeapObject(object)) return false;
  Tagged<HeapObject> heap_object = Cast<HeapObject>(object);
  return heap_object->map(cage_base) == meta_map;
}

DEF_GETTER(Map, GetBackPointer, Tagged<HeapObject>) {
  Tagged<Map> back_pointer;
  if (TryGetBackPointer(cage_base, &back_pointer)) {
    return back_pointer;
  }
  return GetReadOnlyRoots().undefined_value();
}

bool Map::TryGetBackPointer(PtrComprCageBase cage_base,
                            Tagged<Map>* back_pointer) const {
  Tagged<Object> object = constructor_or_back_pointer(cage_base, kRelaxedLoad);
  // We don't expect maps from another native context in the transition tree,
  // so just compare object's map against current map's meta map.
  Tagged<Map> meta_map = map(cage_base);
  if (ConcurrentIsHeapObjectWithMap(cage_base, object, meta_map)) {
    DCHECK(IsMap(object));
    // Sanity check - only contextful maps can transition.
    DCHECK(IsNativeContext(meta_map->native_context_or_null()));
    *back_pointer = Cast<Map>(object);
    return true;
  }
  // If it was a map that'd mean that there are maps from different native
  // contexts in the transition tree.
  DCHECK(!IsMap(object));
  return false;
}

void Map::SetBackPointer(Tagged<HeapObject> value, WriteBarrierMode mode) {
  CHECK_GE(instance_type(), FIRST_JS_RECEIVER_TYPE);
  CHECK(IsMap(value));
  CHECK(IsUndefined(GetBackPointer()));
  CHECK_EQ(Cast<Map>(value)->GetConstructorRaw(),
           constructor_or_back_pointer());
  set_constructor_or_back_pointer(value, mode);
}

// static
Tagged<Map> Map::GetMapFor(ReadOnlyRoots roots, InstanceType type) {
  RootIndex map_idx = TryGetMapRootIdxFor(type).value();
  return UncheckedCast<Map>(roots.object_at(map_idx));
}

// static
Tagged<Map> Map::ElementsTransitionMap(Isolate* isolate,
                                       ConcurrencyMode cmode) {
  return TransitionsAccessor(isolate, *this, IsConcurrent(cmode))
      .SearchSpecial(ReadOnlyRoots(isolate).elements_transition_symbol());
}

ACCESSORS(Map, dependent_code, Tagged<DependentCode>, kDependentCodeOffset)
RELAXED_ACCESSORS(Map, prototype_validity_cell, (Tagged<UnionOf<Smi, Cell>>),
                  kPrototypeValidityCellOffset)
ACCESSORS_CHECKED2(Map, constructor_or_back_pointer, Tagged<Object>,
                   kConstructorOrBackPointerOrNativeContextOffset,
                   !IsContextMap(*this), IsNull(value) || !IsContextMap(*this))
RELAXED_ACCESSORS_CHECKED2(Map, constructor_or_back_pointer, Tagged<Object>,
                           kConstructorOrBackPointerOrNativeContextOffset,
                           !IsContextMap(*this),
                           IsNull(value) || !IsContextMap(*this))
ACCESSORS_CHECKED(Map, native_context, Tagged<NativeContext>,
                  kConstructorOrBackPointerOrNativeContextOffset,
                  IsContextMap(*this) || IsMapMap(*this))
ACCESSORS_CHECKED(Map, native_context_or_null, Tagged<Object>,
                  kConstructorOrBackPointerOrNativeContextOffset,
                  (IsNull(value) || IsNativeContext(value)) &&
                      (IsContextMap(*this) || IsMapMap(*this)))
// Unlike native_context_or_null() this getter allows the value to be
// equal to Smi::uninitialized_deserialization_value().
DEF_GETTER(Map, raw_native_context_or_null, Tagged<Object>) {
  Tagged<Object> value = TaggedField<
      Tagged<Object>,
      kConstructorOrBackPointerOrNativeContextOffset>::load(cage_base, *this);
  DCHECK(IsNull(value) || IsNativeContext(value) ||
         value == Smi::uninitialized_deserialization_value());
  DCHECK(IsContextMap(*this) || IsMapMap(*this));
  return value;
}
#if V8_ENABLE_WEBASSEMBLY
ACCESSORS_CHECKED(Map, wasm_type_info, Tagged<WasmTypeInfo>,
                  kConstructorOrBackPointerOrNativeContextOffset,
                  IsWasmStructMap(*this) || IsWasmArrayMap(*this) ||
                      IsWasmFuncRefMap(*this))
#endif  // V8_ENABLE_WEBASSEMBLY

bool Map::IsPrototypeValidityCellValid() const {
  Tagged<Object> validity_cell = prototype_validity_cell(kRelaxedLoad);
  if (IsSmi(validity_cell)) {
    // Smi validity cells should always be considered valid.
    DCHECK_EQ(Cast<Smi>(validity_cell).value(), Map::kPrototypeChainValid);
    return true;
  }
  Tagged<Smi> cell_value = Cast<Smi>(Cast<Cell>(validity_cell)->value());
  return cell_value == Smi::FromInt(Map::kPrototypeChainValid);
}

bool Map::BelongsToSameNativeContextAs(Tagged<Map> other_map) const {
  Tagged<Map> this_meta_map = map();
  // If the meta map is contextless (as in case of remote object's meta map)
  // we can't be sure the maps belong to the same context.
  if (this_meta_map == GetReadOnlyRoots().meta_map()) return false;
  DCHECK(IsNativeContext(this_meta_map->native_context_or_null()));
  return this_meta_map == other_map->map();
}

bool Map::BelongsToSameNativeContextAs(Tagged<Context> context) const {
  Tagged<Map> context_meta_map = context->map()->map();
  Tagged<Map> this_meta_map = map();
  DCHECK_NE(context_meta_map, GetReadOnlyRoots().meta_map());
  return this_meta_map == context_meta_map;
}

DEF_GETTER(Map, GetConstructorRaw, Tagged<Object>) {
  Tagged<Object> maybe_constructor = constructor_or_back_pointer(cage_base);
  // Follow any back pointers.
  // We don't expect maps from another native context in the transition tree,
  // so just compare object's map against current map's meta map.
  Tagged<Map> meta_map = map(cage_base);
  while (
      ConcurrentIsHeapObjectWithMap(cage_base, maybe_constructor, meta_map)) {
    DCHECK(IsMap(maybe_constructor));
    // Sanity check - only contextful maps can transition.
    DCHECK(IsNativeContext(meta_map->native_context_or_null()));
    maybe_constructor =
        Cast<Map>(maybe_constructor)->constructor_or_back_pointer(cage_base);
  }
  // If it was a map that'd mean that there are maps from different native
  // contexts in the transition tree.
  DCHECK(!IsMap(maybe_constructor));
  return maybe_constructor;
}

DEF_GETTER(Map, GetNonInstancePrototype, Tagged<Object>) {
  DCHECK(has_non_instance_prototype());
  Tagged<Object> raw_constructor = GetConstructorRaw(cage_base);
  CHECK(IsTuple2(raw_constructor));
  // Get prototype from the {constructor, non-instance_prototype} tuple.
  Tagged<Tuple2> non_instance_prototype_constructor_tuple =
      Cast<Tuple2>(raw_constructor);
  Tagged<Object> result = non_instance_prototype_constructor_tuple->value2();
  DCHECK(!IsJSReceiver(result));
  DCHECK(!IsFunctionTemplateInfo(result));
  return result;
}

DEF_GETTER(Map, GetConstructor, Tagged<Object>) {
  Tagged<Object> maybe_constructor = GetConstructorRaw(cage_base);
  if (IsTuple2(maybe_constructor)) {
    // Get constructor from the {constructor, non-instance_prototype} tuple.
    maybe_constructor = Cast<Tuple2>(maybe_constructor)->value1();
  }
  return maybe_constructor;
}

Tagged<Object> Map::TryGetConstructor(PtrComprCageBase cage_base,
                                      int max_steps) {
  Tagged<Object> maybe_constructor = constructor_or_back_pointer(cage_base);
  // Follow any back pointers.
  while (IsMap(maybe_constructor, cage_base)) {
    if (max_steps-- == 0) return Smi::FromInt(0);
    maybe_constructor =
        Cast<Map>(maybe_constructor)->constructor_or_back_pointer(cage_base);
  }
  if (IsTuple2(maybe_constructor)) {
    // Get constructor from the {constructor, non-instance_prototype} tuple.
    maybe_constructor = Cast<Tuple2>(maybe_constructor)->value1();
  }
  return maybe_constructor;
}

DEF_GETTER(Map, GetFunctionTemplateInfo, Tagged<FunctionTemplateInfo>) {
  Tagged<Object> constructor = GetConstructor(cage_base);
  if (IsJSFunction(constructor, cage_base)) {
    Tagged<SharedFunctionInfo> sfi =
        Cast<JSFunction>(constructor)->shared(cage_base);
    DCHECK(sfi->IsApiFunction());
    return sfi->api_func_data();
  }
  DCHECK(IsFunctionTemplateInfo(constructor, cage_base));
  return Cast<FunctionTemplateInfo>(constructor);
}

void Map::SetConstructor(Tagged<Object> constructor, WriteBarrierMode mode) {
  // Never overwrite a back pointer with a constructor.
  CHECK(!IsMap(constructor_or_back_pointer()));
  // Constructor field must contain {constructor, non-instance_prototype} tuple
  // for maps with non-instance prototype.
  DCHECK_EQ(has_non_instance_prototype(), IsTuple2(constructor));
  set_constructor_or_back_pointer(constructor, mode);
}

Handle<Map> Map::CopyInitialMap(Isolate* isolate, DirectHandle<Map> map) {
  return CopyInitialMap(isolate, map, map->instance_size(),
                        map->GetInObjectProperties(),
                        map->UnusedPropertyFields());
}

bool Map::IsInobjectSlackTrackingInProgress() const {
  return construction_counter() != Map::kNoSlackTracking;
}

void Map::InobjectSlackTrackingStep(Isolate* isolate) {
  DisallowGarbageCollection no_gc;
  // Slack tracking should only be performed on an initial map.
  DCHECK(IsUndefined(GetBackPointer()));
  if (!this->IsInobjectSlackTrackingInProgress()) return;
  int counter = construction_counter();
  set_construction_counter(counter - 1);
  if (counter == kSlackTrackingCounterEnd) {
    MapUpdater::CompleteInobjectSlackTracking(isolate, *this);
  }
}

int Map::SlackForArraySize(int old_size, int size_limit) {
  const int max_slack = size_limit - old_size;
  CHECK_LE(0, max_slack);
  if (old_size < 4) {
    DCHECK_LE(1, max_slack);
    return 1;
  }
  return std::min(max_slack, old_size / 4);
}

int Map::InstanceSizeFromSlack(int slack) const {
  return instance_size() - slack * kTaggedSize;
}

NEVER_READ_ONLY_SPACE_IMPL(NormalizedMapCache)

int NormalizedMapCache::GetIndex(Isolate* isolate, Tagged<Map> map,
                                 Tagged<HeapObject> prototype) {
  DisallowGarbageCollection no_gc;
  return map->Hash(isolate, prototype) % NormalizedMapCache::kEntries;
}

DEF_HEAP_OBJECT_PREDICATE(HeapObject, IsNormalizedMapCache) {
  if (!IsWeakFixedArray(obj, cage_base)) return false;
  if (Cast<WeakFixedArray>(obj)->length() != NormalizedMapCache::kEntries) {
    return false;
  }
  return true;
}

}  // namespace internal
}  // namespace v8

#include "src/objects/object-macros-undef.h"

#endif  // V8_OBJECTS_MAP_INL_H_
[Step 30: Duration 8.41 seconds| Input tokens: 982,617 | Output tokens: 16,248]
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ Step 31 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'ripgrep' with arguments: {'pattern': 'FindTransitionToField', 'options': '-n ./objects ./objects/*'}                                                                                          │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
Command: cd /Users/tarun/v8/v8/src && rg -n ./objects ./objects/* 'FindTransitionToField' | head -n 1000
Observations: ./objects/abstract-code.h:8:#include "src/objects/code-kind.h"
./objects/abstract-code.h:9:#include "src/objects/heap-object.h"
./objects/abstract-code.h:12:#include "src/objects/object-macros.h"
./objects/abstract-code.h:74:#include "src/objects/object-macros-undef.h"
./objects/all-objects-inl.h:8:// This file includes all inline headers from src/objects, which is handy for
./objects/all-objects-inl.h:12:#include "src/objects/allocation-site-inl.h"
./objects/all-objects-inl.h:13:#include "src/objects/allocation-site-scopes-inl.h"
./objects/all-objects-inl.h:14:#include "src/objects/api-callbacks-inl.h"
./objects/all-objects-inl.h:15:#include "src/objects/arguments-inl.h"
./objects/all-objects-inl.h:16:#include "src/objects/call-site-info-inl.h"
./objects/all-objects-inl.h:17:#include "src/objects/cell-inl.h"
./objects/all-objects-inl.h:18:#include "src/objects/code-inl.h"
./objects/all-objects-inl.h:19:#include "src/objects/compilation-cache-table-inl.h"
./objects/all-objects-inl.h:20:#include "src/objects/compressed-slots-inl.h"
./objects/all-objects-inl.h:21:#include "src/objects/contexts-inl.h"
./objects/all-objects-inl.h:22:#include "src/objects/data-handler-inl.h"
./objects/all-objects-inl.h:23:#include "src/objects/debug-objects-inl.h"
./objects/all-objects-inl.h:24:#include "src/objects/descriptor-array-inl.h"
./objects/all-objects-inl.h:25:#include "src/objects/dictionary-inl.h"
./objects/all-objects-inl.h:26:#include "src/objects/elements-inl.h"
./objects/all-objects-inl.h:27:#include "src/objects/embedder-data-array-inl.h"
./objects/all-objects-inl.h:28:#include "src/objects/embedder-data-slot-inl.h"
./objects/all-objects-inl.h:29:#include "src/objects/feedback-cell-inl.h"
./objects/all-objects-inl.h:30:#include "src/objects/feedback-vector-inl.h"
./objects/all-objects-inl.h:31:#include "src/objects/field-index-inl.h"
./objects/all-objects-inl.h:32:#include "src/objects/fixed-array-inl.h"
./objects/all-objects-inl.h:33:#include "src/objects/foreign-inl.h"
./objects/all-objects-inl.h:34:#include "src/objects/free-space-inl.h"
./objects/all-objects-inl.h:35:#include "src/objects/hash-table-inl.h"
./objects/all-objects-inl.h:36:#include "src/objects/heap-number-inl.h"
./objects/all-objects-inl.h:37:#include "src/objects/heap-object-inl.h"
./objects/all-objects-inl.h:38:#include "src/objects/instance-type-inl.h"
./objects/all-objects-inl.h:39:#include "src/objects/js-array-buffer-inl.h"
./objects/all-objects-inl.h:40:#include "src/objects/js-array-inl.h"
./objects/all-objects-inl.h:41:#include "src/objects/js-atomics-synchronization-inl.h"
./objects/all-objects-inl.h:42:#include "src/objects/js-collection-inl.h"
./objects/all-objects-inl.h:43:#include "src/objects/js-disposable-stack-inl.h"
./objects/all-objects-inl.h:44:#include "src/objects/js-function-inl.h"
./objects/all-objects-inl.h:45:#include "src/objects/js-generator-inl.h"
./objects/all-objects-inl.h:46:#include "src/objects/js-iterator-helpers-inl.h"
./objects/all-objects-inl.h:47:#include "src/objects/js-objects-inl.h"
./objects/all-objects-inl.h:48:#include "src/objects/js-promise-inl.h"
./objects/all-objects-inl.h:49:#include "src/objects/js-proxy-inl.h"
./objects/all-objects-inl.h:50:#include "src/objects/js-raw-json-inl.h"
./objects/all-objects-inl.h:51:#include "src/objects/js-regexp-inl.h"
./objects/all-objects-inl.h:52:#include "src/objects/js-regexp-string-iterator-inl.h"
./objects/all-objects-inl.h:53:#include "src/objects/js-shadow-realm-inl.h"
./objects/all-objects-inl.h:54:#include "src/objects/js-shared-array-inl.h"
./objects/all-objects-inl.h:55:#include "src/objects/js-struct-inl.h"
./objects/all-objects-inl.h:56:#include "src/objects/js-temporal-objects-inl.h"
./objects/all-objects-inl.h:57:#include "src/objects/js-weak-refs-inl.h"
./objects/all-objects-inl.h:58:#include "src/objects/literal-objects-inl.h"
./objects/all-objects-inl.h:59:#include "src/objects/lookup-cache-inl.h"
./objects/all-objects-inl.h:60:#include "src/objects/lookup-inl.h"
./objects/all-objects-inl.h:61:#include "src/objects/map-inl.h"
./objects/all-objects-inl.h:62:#include "src/objects/maybe-object-inl.h"
./objects/all-objects-inl.h:63:#include "src/objects/megadom-handler-inl.h"
./objects/all-objects-inl.h:64:#include "src/objects/microtask-inl.h"
./objects/all-objects-inl.h:65:#include "src/objects/module-inl.h"
./objects/all-objects-inl.h:66:#include "src/objects/name-inl.h"
./objects/all-objects-inl.h:67:#include "src/objects/objects-inl.h"
./objects/all-objects-inl.h:68:#include "src/objects/oddball-inl.h"
./objects/all-objects-inl.h:69:#include "src/objects/ordered-hash-table-inl.h"
./objects/all-objects-inl.h:70:#include "src/objects/primitive-heap-object-inl.h"
./objects/all-objects-inl.h:71:#include "src/objects/promise-inl.h"
./objects/all-objects-inl.h:72:#include "src/objects/property-array-inl.h"
./objects/all-objects-inl.h:73:#include "src/objects/property-cell-inl.h"
./objects/all-objects-inl.h:74:#include "src/objects/property-descriptor-object-inl.h"
./objects/all-objects-inl.h:75:#include "src/objects/prototype-info-inl.h"
./objects/all-objects-inl.h:76:#include "src/objects/scope-info-inl.h"
./objects/all-objects-inl.h:77:#include "src/objects/script-inl.h"
./objects/all-objects-inl.h:78:#include "src/objects/shared-function-info-inl.h"
./objects/all-objects-inl.h:79:#include "src/objects/slots-atomic-inl.h"
./objects/all-objects-inl.h:80:#include "src/objects/slots-inl.h"
./objects/all-objects-inl.h:81:#include "src/objects/string-forwarding-table-inl.h"
./objects/all-objects-inl.h:82:#include "src/objects/string-inl.h"
./objects/all-objects-inl.h:83:#include "src/objects/string-set-inl.h"
./objects/all-objects-inl.h:84:#include "src/objects/string-table-inl.h"
./objects/all-objects-inl.h:85:#include "src/objects/struct-inl.h"
./objects/all-objects-inl.h:86:#include "src/objects/swiss-name-dictionary-inl.h"
./objects/all-objects-inl.h:87:#include "src/objects/synthetic-module-inl.h"
./objects/all-objects-inl.h:88:#include "src/objects/tagged-field-inl.h"
./objects/all-objects-inl.h:89:#include "src/objects/tagged-impl-inl.h"
./objects/all-objects-inl.h:90:#include "src/objects/tagged-value-inl.h"
./objects/all-objects-inl.h:91:#include "src/objects/template-objects-inl.h"
./objects/all-objects-inl.h:92:#include "src/objects/templates-inl.h"
./objects/all-objects-inl.h:93:#include "src/objects/torque-defined-classes-inl.h"
./objects/all-objects-inl.h:94:#include "src/objects/transitions-inl.h"
./objects/all-objects-inl.h:95:#include "src/objects/trusted-object-inl.h"
./objects/all-objects-inl.h:96:#include "src/objects/turbofan-types-inl.h"
./objects/all-objects-inl.h:97:#include "src/objects/turboshaft-types-inl.h"
./objects/all-objects-inl.h💯#include "src/objects/js-break-iterator-inl.h"
./objects/all-objects-inl.h:101:#include "src/objects/js-collator-inl.h"
./objects/all-objects-inl.h:102:#include "src/objects/js-date-time-format-inl.h"
./objects/all-objects-inl.h:103:#include "src/objects/js-display-names-inl.h"
./objects/all-objects-inl.h:104:#include "src/objects/js-duration-format-inl.h"
./objects/all-objects-inl.h:105:#include "src/objects/js-list-format-inl.h"
./objects/all-objects-inl.h:106:#include "src/objects/js-locale-inl.h"
./objects/all-objects-inl.h:107:#include "src/objects/js-number-format-inl.h"
./objects/all-objects-inl.h:108:#include "src/objects/js-plural-rules-inl.h"
./objects/all-objects-inl.h:109:#include "src/objects/js-relative-time-format-inl.h"
./objects/all-objects-inl.h:110:#include "src/objects/js-segment-iterator-inl.h"
./objects/all-objects-inl.h:111:#include "src/objects/js-segmenter-inl.h"
./objects/all-objects-inl.h:112:#include "src/objects/js-segments-inl.h"
./objects/abstract-code-inl.h:8:#include "src/objects/abstract-code.h"
./objects/abstract-code-inl.h:9:#include "src/objects/bytecode-array-inl.h"
./objects/abstract-code-inl.h:10:#include "src/objects/code-inl.h"
./objects/abstract-code-inl.h:11:#include "src/objects/instance-type-inl.h"
./objects/abstract-code-inl.h:14:#include "src/objects/object-macros.h"
./objects/abstract-code-inl.h:119:#include "src/objects/object-macros-undef.h"
./objects/abstract-code.cc:5:#include "src/objects/abstract-code.h"
./objects/abstract-code.cc:7:#include "src/objects/abstract-code-inl.h"
./objects/allocation-site-scopes.h:9:#include "src/objects/allocation-site.h"
./objects/allocation-site-scopes.h:10:#include "src/objects/map.h"
./objects/allocation-site-scopes.h:11:#include "src/objects/objects.h"
./objects/allocation-site.h:8:#include "src/objects/objects.h"
./objects/allocation-site.h:9:#include "src/objects/struct.h"
./objects/allocation-site.h:12:#include "src/objects/object-macros.h"
./objects/allocation-site.h:19:#include "torque-generated/src/objects/allocation-site-tq.inc"
./objects/allocation-site.h:190:#include "src/objects/object-macros-undef.h"
./objects/api-callbacks-inl.h:8:#include "src/objects/api-callbacks.h"
./objects/api-callbacks-inl.h:12:#include "src/objects/foreign-inl.h"
./objects/api-callbacks-inl.h:13:#include "src/objects/js-objects-inl.h"
./objects/api-callbacks-inl.h:14:#include "src/objects/name.h"
./objects/api-callbacks-inl.h:15:#include "src/objects/templates.h"
./objects/api-callbacks-inl.h:18:#include "src/objects/object-macros.h"
./objects/api-callbacks-inl.h:23:#include "torque-generated/src/objects/api-callbacks-tq-inl.inc"
./objects/api-callbacks-inl.h:124:#include "src/objects/object-macros-undef.h"
./objects/api-callbacks.h:8:#include "src/objects/struct.h"
./objects/api-callbacks.h:12:#include "src/objects/object-macros.h"
./objects/api-callbacks.h:20:#include "torque-generated/src/objects/api-callbacks-tq.inc"
./objects/api-callbacks.h:126:#include "src/objects/object-macros-undef.h"
./objects/allocation-site-scopes-inl.h:8:#include "src/objects/allocation-site-scopes.h"
./objects/allocation-site-scopes-inl.h:10:#include "src/objects/allocation-site-inl.h"
./objects/bytecode-array-inl.h:11:#include "src/objects/bytecode-array.h"
./objects/bytecode-array-inl.h:12:#include "src/objects/fixed-array-inl.h"
./objects/bytecode-array-inl.h:15:#include "src/objects/object-macros.h"
./objects/bytecode-array-inl.h:191:#include "src/objects/object-macros-undef.h"
./objects/arguments-inl.h:9:#include "src/objects/arguments.h"
./objects/arguments-inl.h:10:#include "src/objects/contexts-inl.h"
./objects/arguments-inl.h:11:#include "src/objects/fixed-array-inl.h"
./objects/arguments-inl.h:12:#include "src/objects/objects-inl.h"
./objects/arguments-inl.h:15:#include "src/objects/object-macros.h"
./objects/arguments-inl.h:20:#include "torque-generated/src/objects/arguments-tq-inl.inc"
./objects/arguments-inl.h:63:#include "src/objects/object-macros-undef.h"
./objects/bytecode-array.cc:5:#include "src/objects/bytecode-array.h"
./objects/bytecode-array.cc:14:#include "src/objects/bytecode-array-inl.h"
./objects/allocation-site-inl.h:10:#include "src/objects/allocation-site.h"
./objects/allocation-site-inl.h:11:#include "src/objects/dependent-code-inl.h"
./objects/allocation-site-inl.h:12:#include "src/objects/js-objects-inl.h"
./objects/allocation-site-inl.h:15:#include "src/objects/object-macros.h"
./objects/allocation-site-inl.h:20:#include "torque-generated/src/objects/allocation-site-tq-inl.inc"
./objects/allocation-site-inl.h:276:#include "src/objects/object-macros-undef.h"
./objects/bigint.h:11:#include "src/objects/objects.h"
./objects/bigint.h:12:#include "src/objects/primitive-heap-object.h"
./objects/bigint.h:16:#include "src/objects/object-macros.h"
./objects/bigint.h:312:#include "src/objects/object-macros-undef.h"
./objects/arguments.h:8:#include "src/objects/fixed-array.h"
./objects/arguments.h:9:#include "src/objects/hole.h"
./objects/arguments.h:10:#include "src/objects/js-objects.h"
./objects/arguments.h:11:#include "src/objects/struct.h"
./objects/arguments.h:14:#include "src/objects/object-macros.h"
./objects/arguments.h:21:#include "torque-generated/src/objects/arguments-tq.inc"
./objects/arguments.h:169:#include "src/objects/object-macros-undef.h"
./objects/bytecode-array.h:8:#include "src/objects/struct.h"
./objects/bytecode-array.h:9:#include "src/objects/trusted-object.h"
./objects/bytecode-array.h:12:#include "src/objects/object-macros.h"
./objects/bytecode-array.h:25:#include "torque-generated/src/objects/bytecode-array-tq.inc"
./objects/bytecode-array.h:182:#include "src/objects/object-macros-undef.h"
./objects/call-site-info-inl.h:9:#include "src/objects/call-site-info.h"
./objects/call-site-info-inl.h:10:#include "src/objects/objects-inl.h"
./objects/call-site-info-inl.h:11:#include "src/objects/struct-inl.h"
./objects/call-site-info-inl.h:14:#include "src/objects/object-macros.h"
./objects/call-site-info-inl.h:19:#include "torque-generated/src/objects/call-site-info-tq-inl.inc"
./objects/call-site-info-inl.h:69:#include "src/objects/object-macros-undef.h"
./objects/call-site-info.h:10:#include "src/objects/struct.h"
./objects/call-site-info.h:14:#include "src/objects/object-macros.h"
./objects/call-site-info.h:22:#include "torque-generated/src/objects/call-site-info-tq.inc"
./objects/call-site-info.h:124:#include "src/objects/object-macros-undef.h"
./objects/backing-store.cc:5:#include "src/objects/backing-store.h"
./objects/cell.h:8:#include "src/objects/heap-object.h"
./objects/cell.h:11:#include "src/objects/object-macros.h"
./objects/cell.h:16:#include "torque-generated/src/objects/cell-tq.inc"
./objects/cell.h:33:#include "src/objects/object-macros-undef.h"
./objects/data-handler-inl.h:8:#include "src/objects/data-handler.h"
./objects/data-handler-inl.h:9:#include "src/objects/objects-inl.h"  // Needed for write barriers
./objects/data-handler-inl.h:12:#include "src/objects/object-macros.h"
./objects/data-handler-inl.h:17:#include "torque-generated/src/objects/data-handler-tq-inl.inc"
./objects/data-handler-inl.h:35:#include "src/objects/object-macros-undef.h"
./objects/cell-inl.h:8:#include "src/objects/cell.h"
./objects/cell-inl.h:11:#include "src/objects/objects-inl.h"
./objects/cell-inl.h:14:#include "src/objects/object-macros.h"
./objects/cell-inl.h:19:#include "torque-generated/src/objects/cell-tq-inl.inc"
./objects/cell-inl.h:30:#include "src/objects/object-macros-undef.h"
./objects/bigint.cc:20:#include "src/objects/bigint.h"
./objects/bigint.cc:32:#include "src/objects/casting.h"
./objects/bigint.cc:33:#include "src/objects/heap-number-inl.h"
./objects/bigint.cc:34:#include "src/objects/instance-type-inl.h"
./objects/bigint.cc:35:#include "src/objects/objects-inl.h"
./objects/bigint.cc:36:#include "src/objects/smi.h"
./objects/bigint.cc:39:#include "src/objects/object-macros.h"
./objects/bigint.cc:1722:#include "src/objects/object-macros-undef.h"
./objects/code.cc:5:#include "src/objects/code.h"
./objects/code.cc:15:#include "src/objects/code-inl.h"
./objects/code-inl.h:13:#include "src/objects/code.h"
./objects/code-inl.h:14:#include "src/objects/deoptimization-data-inl.h"
./objects/code-inl.h:15:#include "src/objects/instance-type-inl.h"
./objects/code-inl.h:16:#include "src/objects/instruction-stream-inl.h"
./objects/code-inl.h:17:#include "src/objects/trusted-object-inl.h"
./objects/code-inl.h:21:#include "src/objects/object-macros.h"
./objects/code-inl.h:954:#include "src/objects/object-macros-undef.h"
./objects/code-kind.cc:5:#include "src/objects/code-kind.h"
./objects/contexts.cc:5:#include "src/objects/contexts.h"
./objects/contexts.cc:18:#include "src/objects/dependent-code.h"
./objects/contexts.cc:19:#include "src/objects/heap-number.h"
./objects/contexts.cc:20:#include "src/objects/module-inl.h"
./objects/contexts.cc:21:#include "src/objects/property-cell.h"
./objects/contexts.cc:22:#include "src/objects/string-set-inl.h"
./objects/compilation-cache-table-inl.h:10:#include "src/objects/compilation-cache-table.h"
./objects/compilation-cache-table-inl.h:11:#include "src/objects/name-inl.h"
./objects/compilation-cache-table-inl.h:12:#include "src/objects/script-inl.h"
./objects/compilation-cache-table-inl.h:13:#include "src/objects/shared-function-info.h"
./objects/compilation-cache-table-inl.h:14:#include "src/objects/smi.h"
./objects/compilation-cache-table-inl.h:15:#include "src/objects/string.h"
./objects/compilation-cache-table-inl.h:18:#include "src/objects/object-macros.h"
./objects/compilation-cache-table-inl.h:179:#include "src/objects/object-macros-undef.h"
./objects/dependent-code.h:8:#include "src/objects/fixed-array.h"
./objects/dependent-code.h:11:#include "src/objects/object-macros.h"
./objects/dependent-code.h:147:#include "src/objects/object-macros-undef.h"
./objects/call-site-info.cc:5:#include "src/objects/call-site-info.h"
./objects/call-site-info.cc:10:#include "src/objects/call-site-info-inl.h"
./objects/call-site-info.cc:11:#include "src/objects/shared-function-info.h"
./objects/casting-inl.h:12:#include "src/objects/casting.h"
./objects/casting-inl.h:13:#include "src/objects/heap-object.h"
./objects/compressed-slots.h:11:#include "src/objects/slots.h"
./objects/compressed-slots.h:12:#include "src/objects/tagged-field.h"
./objects/contexts-inl.h:10:#include "src/objects/casting.h"
./objects/contexts-inl.h:11:#include "src/objects/contexts.h"
./objects/contexts-inl.h:12:#include "src/objects/dictionary-inl.h"
./objects/contexts-inl.h:13:#include "src/objects/fixed-array-inl.h"
./objects/contexts-inl.h:14:#include "src/objects/js-function-inl.h"
./objects/contexts-inl.h:15:#include "src/objects/js-objects-inl.h"
./objects/contexts-inl.h:16:#include "src/objects/map-inl.h"
./objects/contexts-inl.h:17:#include "src/objects/objects-inl.h"
./objects/contexts-inl.h:18:#include "src/objects/ordered-hash-table-inl.h"
./objects/contexts-inl.h:19:#include "src/objects/regexp-match-info.h"
./objects/contexts-inl.h:20:#include "src/objects/scope-info.h"
./objects/contexts-inl.h:21:#include "src/objects/shared-function-info.h"
./objects/contexts-inl.h:24:#include "src/objects/object-macros.h"
./objects/contexts-inl.h:29:#include "torque-generated/src/objects/contexts-tq-inl.inc"
./objects/contexts-inl.h:310:#include "src/objects/object-macros-undef.h"
./objects/casting.h:12:#include "src/objects/tagged.h"
./objects/data-handler.h:8:#include "src/objects/struct.h"
./objects/data-handler.h:11:#include "src/objects/object-macros.h"
./objects/data-handler.h:16:#include "torque-generated/src/objects/data-handler-tq.inc"
./objects/data-handler.h:46:#include "src/objects/object-macros-undef.h"
./objects/compilation-cache-table.h:8:#include "src/objects/feedback-cell.h"
./objects/compilation-cache-table.h:9:#include "src/objects/hash-table.h"
./objects/compilation-cache-table.h:10:#include "src/objects/js-regexp.h"
./objects/compilation-cache-table.h:11:#include "src/objects/shared-function-info.h"
./objects/compilation-cache-table.h:15:#include "src/objects/object-macros.h"
./objects/compilation-cache-table.h:178:#include "src/objects/object-macros-undef.h"
./objects/compilation-cache-table.cc:5:#include "src/objects/compilation-cache-table.h"
./objects/compilation-cache-table.cc:9:#include "src/objects/compilation-cache-table-inl.h"
./objects/deoptimization-data-inl.h:9:#include "src/objects/deoptimization-data.h"
./objects/deoptimization-data-inl.h:10:#include "src/objects/fixed-array-inl.h"
./objects/deoptimization-data-inl.h:11:#include "src/objects/js-regexp-inl.h"
./objects/deoptimization-data-inl.h:14:#include "src/objects/object-macros.h"
./objects/deoptimization-data-inl.h:111:#include "src/objects/object-macros-undef.h"
./objects/contexts.h:10:#include "src/objects/fixed-array.h"
./objects/contexts.h:11:#include "src/objects/function-kind.h"
./objects/contexts.h:12:#include "src/objects/ordered-hash-table.h"
./objects/contexts.h:13:#include "src/objects/property-cell.h"
./objects/contexts.h:16:#include "src/objects/object-macros.h"
./objects/contexts.h:421:#include "torque-generated/src/objects/contexts-tq.inc"
./objects/contexts.h:866:#include "src/objects/object-macros-undef.h"
./objects/deoptimization-data.cc:5:#include "src/objects/deoptimization-data.h"
./objects/deoptimization-data.cc:11:#include "src/objects/casting.h"
./objects/deoptimization-data.cc:12:#include "src/objects/code.h"
./objects/deoptimization-data.cc:13:#include "src/objects/deoptimization-data-inl.h"
./objects/deoptimization-data.cc:14:#include "src/objects/shared-function-info.h"
./objects/debug-objects-inl.h:10:#include "src/objects/bytecode-array-inl.h"
./objects/debug-objects-inl.h:11:#include "src/objects/code-inl.h"
./objects/debug-objects-inl.h:12:#include "src/objects/debug-objects.h"
./objects/debug-objects-inl.h:13:#include "src/objects/objects-inl.h"
./objects/debug-objects-inl.h:14:#include "src/objects/shared-function-info.h"
./objects/debug-objects-inl.h:15:#include "src/objects/string.h"
./objects/debug-objects-inl.h:20:#include "src/objects/object-macros.h"
./objects/debug-objects-inl.h:25:#include "torque-generated/src/objects/debug-objects-tq-inl.inc"
./objects/debug-objects-inl.h:106:#include "src/objects/object-macros-undef.h"
./objects/deoptimization-data.h:10:#include "src/objects/bytecode-array.h"
./objects/deoptimization-data.h:11:#include "src/objects/fixed-array.h"
./objects/deoptimization-data.h:15:#include "src/objects/object-macros.h"
./objects/deoptimization-data.h:379:#include "src/objects/object-macros-undef.h"
./objects/compressed-slots-inl.h:11:#include "src/objects/casting.h"
./objects/compressed-slots-inl.h:12:#include "src/objects/compressed-slots.h"
./objects/compressed-slots-inl.h:13:#include "src/objects/maybe-object-inl.h"
./objects/debug-objects.cc:5:#include "src/objects/debug-objects.h"
./objects/debug-objects.cc:10:#include "src/objects/call-site-info-inl.h"
./objects/debug-objects.cc:11:#include "src/objects/debug-objects-inl.h"
./objects/code.h:9:#include "src/objects/code-kind.h"
./objects/code.h:10:#include "src/objects/struct.h"
./objects/code.h:11:#include "src/objects/trusted-object.h"
./objects/code.h:14:#include "src/objects/object-macros.h"
./objects/code.h:578:#include "src/objects/object-macros-undef.h"
./objects/elements.h:9:#include "src/objects/elements-kind.h"
./objects/elements.h:10:#include "src/objects/internal-index.h"
./objects/elements.h:11:#include "src/objects/keys.h"
./objects/elements.h:12:#include "src/objects/objects.h"
./objects/descriptor-array.h:9:#include "src/objects/fixed-array.h"
./objects/descriptor-array.h:12:#include "src/objects/internal-index.h"
./objects/descriptor-array.h:13:#include "src/objects/objects.h"
./objects/descriptor-array.h:14:#include "src/objects/struct.h"
./objects/descriptor-array.h:18:#include "src/objects/object-macros.h"
./objects/descriptor-array.h:25:#include "torque-generated/src/objects/descriptor-array-tq.inc"
./objects/descriptor-array.h:324:#include "src/objects/object-macros-undef.h"
./objects/dependent-code-inl.h:9:#include "src/objects/dependent-code.h"
./objects/dependent-code-inl.h:10:#include "src/objects/fixed-array-inl.h"
./objects/dependent-code-inl.h:11:#include "src/objects/tagged.h"
./objects/dependent-code-inl.h:14:#include "src/objects/object-macros.h"
./objects/dependent-code-inl.h:54:#include "src/objects/object-macros-undef.h"
./objects/debug-objects.h:11:#include "src/objects/fixed-array.h"
./objects/debug-objects.h:12:#include "src/objects/objects.h"
./objects/debug-objects.h:13:#include "src/objects/struct.h"
./objects/debug-objects.h:17:#include "src/objects/object-macros.h"
./objects/debug-objects.h:26:#include "torque-generated/src/objects/debug-objects-tq.inc"
./objects/debug-objects.h:277:#include "src/objects/object-macros-undef.h"
./objects/elements-inl.h:9:#include "src/objects/elements.h"
./objects/elements-inl.h:12:#include "src/objects/objects-inl.h"
./objects/elements-kind.cc:5:#include "src/objects/elements-kind.h"
./objects/elements-kind.cc:8:#include "src/objects/elements.h"
./objects/elements-kind.cc:9:#include "src/objects/objects-inl.h"
./objects/elements-kind.cc:10:#include "src/objects/objects.h"
./objects/embedder-data-array-inl.h:8:#include "src/objects/embedder-data-array.h"
./objects/embedder-data-array-inl.h:9:#include "src/objects/heap-object-inl.h"
./objects/embedder-data-array-inl.h:10:#include "src/objects/instance-type-inl.h"
./objects/embedder-data-array-inl.h:11:#include "src/objects/maybe-object-inl.h"
./objects/embedder-data-array-inl.h:12:#include "src/objects/objects-inl.h"
./objects/embedder-data-array-inl.h:15:#include "src/objects/object-macros.h"
./objects/embedder-data-array-inl.h:20:#include "torque-generated/src/objects/embedder-data-array-tq-inl.inc"
./objects/embedder-data-array-inl.h:35:#include "src/objects/object-macros-undef.h"
./objects/embedder-data-array.h:10:#include "src/objects/heap-object.h"
./objects/embedder-data-array.h:13:#include "src/objects/object-macros.h"
./objects/embedder-data-array.h:18:#include "torque-generated/src/objects/embedder-data-array-tq.inc"
./objects/embedder-data-array.h:67:#include "src/objects/object-macros-undef.h"
./objects/dependent-code.cc:5:#include "src/objects/dependent-code.h"
./objects/dependent-code.cc:9:#include "src/objects/allocation-site-inl.h"
./objects/dependent-code.cc:10:#include "src/objects/dependent-code-inl.h"
./objects/dependent-code.cc:11:#include "src/objects/map.h"
./objects/dictionary-inl.h:12:#include "src/objects/dictionary.h"
./objects/dictionary-inl.h:13:#include "src/objects/hash-table-inl.h"
./objects/dictionary-inl.h:14:#include "src/objects/objects-inl.h"
./objects/dictionary-inl.h:15:#include "src/objects/oddball.h"
./objects/dictionary-inl.h:16:#include "src/objects/property-cell-inl.h"
./objects/dictionary-inl.h:19:#include "src/objects/object-macros.h"
./objects/dictionary-inl.h:382:#include "src/objects/object-macros-undef.h"
./objects/feedback-cell-inl.h:12:#include "src/objects/feedback-cell.h"
./objects/feedback-cell-inl.h:13:#include "src/objects/feedback-vector-inl.h"
./objects/feedback-cell-inl.h:14:#include "src/objects/objects-inl.h"
./objects/feedback-cell-inl.h:15:#include "src/objects/struct-inl.h"
./objects/feedback-cell-inl.h:18:#include "src/objects/object-macros.h"
./objects/feedback-cell-inl.h:22:#include "torque-generated/src/objects/feedback-cell-tq-inl.inc"
./objects/feedback-cell-inl.h:102:#include "src/objects/object-macros-undef.h"
./objects/feedback-vector.h:16:#include "src/objects/elements-kind.h"
./objects/feedback-vector.h:17:#include "src/objects/feedback-cell.h"
./objects/feedback-vector.h:18:#include "src/objects/map.h"
./objects/feedback-vector.h:19:#include "src/objects/maybe-object.h"
./objects/feedback-vector.h:20:#include "src/objects/name.h"
./objects/feedback-vector.h:21:#include "src/objects/type-hints.h"
./objects/feedback-vector.h:25:#include "src/objects/object-macros.h"
./objects/feedback-vector.h:177:#include "torque-generated/src/objects/feedback-vector-tq.inc"
./objects/feedback-vector.h:1052:#include "src/objects/object-macros-undef.h"
./objects/feedback-cell.h:10:#include "src/objects/struct.h"
./objects/feedback-cell.h:13:#include "src/objects/object-macros.h"
./objects/feedback-cell.h:19:#include "torque-generated/src/objects/feedback-cell-tq.inc"
./objects/feedback-cell.h:72:#include "src/objects/object-macros-undef.h"
./objects/dictionary.h:12:#include "src/objects/hash-table.h"
./objects/dictionary.h:13:#include "src/objects/property-array.h"
./objects/dictionary.h:14:#include "src/objects/smi.h"
./objects/dictionary.h:18:#include "src/objects/object-macros.h"
./objects/dictionary.h:459:#include "src/objects/object-macros-undef.h"
./objects/field-index.h:9:#include "src/objects/internal-index.h"
./objects/field-index.h:10:#include "src/objects/property-details.h"
./objects/descriptor-array-inl.h:12:#include "src/objects/descriptor-array.h"
./objects/descriptor-array-inl.h:13:#include "src/objects/dictionary.h"
./objects/descriptor-array-inl.h:14:#include "src/objects/field-type.h"
./objects/descriptor-array-inl.h:15:#include "src/objects/heap-object-inl.h"
./objects/descriptor-array-inl.h:16:#include "src/objects/lookup-cache-inl.h"
./objects/descriptor-array-inl.h:17:#include "src/objects/maybe-object-inl.h"
./objects/descriptor-array-inl.h:18:#include "src/objects/property.h"
./objects/descriptor-array-inl.h:19:#include "src/objects/struct-inl.h"
./objects/descriptor-array-inl.h:20:#include "src/objects/tagged-field-inl.h"
./objects/descriptor-array-inl.h:25:#include "src/objects/object-macros.h"
./objects/descriptor-array-inl.h:30:#include "torque-generated/src/objects/descriptor-array-tq-inl.inc"
./objects/descriptor-array-inl.h:409:#include "src/objects/object-macros-undef.h"
./objects/embedder-data-slot-inl.h:11:#include "src/objects/embedder-data-array.h"
./objects/embedder-data-slot-inl.h:12:#include "src/objects/embedder-data-slot.h"
./objects/embedder-data-slot-inl.h:13:#include "src/objects/js-objects-inl.h"
./objects/embedder-data-slot-inl.h:14:#include "src/objects/objects-inl.h"
./objects/embedder-data-slot-inl.h:19:#include "src/objects/object-macros.h"
./objects/embedder-data-slot-inl.h:220:#include "src/objects/object-macros-undef.h"
./objects/field-type.cc:5:#include "src/objects/field-type.h"
./objects/field-type.cc:8:#include "src/objects/map.h"
./objects/field-type.cc:9:#include "src/objects/objects-inl.h"
./objects/field-type.cc:10:#include "src/objects/smi.h"
./objects/fixed-array.cc:5:#include "src/objects/fixed-array.h"
./objects/fixed-array.cc:7:#include "src/objects/map-inl.h"
./objects/feedback-vector-inl.h:12:#include "src/objects/code-inl.h"
./objects/feedback-vector-inl.h:13:#include "src/objects/feedback-cell-inl.h"
./objects/feedback-vector-inl.h:14:#include "src/objects/feedback-vector.h"
./objects/feedback-vector-inl.h:15:#include "src/objects/maybe-object-inl.h"
./objects/feedback-vector-inl.h:16:#include "src/objects/shared-function-info.h"
./objects/feedback-vector-inl.h:17:#include "src/objects/smi.h"
./objects/feedback-vector-inl.h:18:#include "src/objects/tagged.h"
./objects/feedback-vector-inl.h:24:#include "src/objects/object-macros.h"
./objects/feedback-vector-inl.h:28:#include "torque-generated/src/objects/feedback-vector-tq-inl.inc"
./objects/feedback-vector-inl.h:595:#include "src/objects/object-macros-undef.h"
./objects/free-space-inl.h:11:#include "src/objects/free-space.h"
./objects/free-space-inl.h:12:#include "src/objects/objects-inl.h"
./objects/free-space-inl.h:15:#include "src/objects/object-macros.h"
./objects/free-space-inl.h:20:#include "torque-generated/src/objects/free-space-tq-inl.inc"
./objects/free-space-inl.h:75:#include "src/objects/object-macros-undef.h"
./objects/embedder-data-slot.h:12:#include "src/objects/slots.h"
./objects/embedder-data-slot.h:16:#include "src/objects/object-macros.h"
./objects/embedder-data-slot.h:145:#include "src/objects/object-macros-undef.h"
./objects/embedder-data-array.cc:5:#include "src/objects/embedder-data-array.h"
./objects/embedder-data-array.cc:8:#include "src/objects/embedder-data-array-inl.h"
./objects/heap-number.h:8:#include "src/objects/primitive-heap-object.h"
./objects/heap-number.h:9:#include "src/objects/tagged-field.h"
./objects/heap-number.h:12:#include "src/objects/object-macros.h"
./objects/heap-number.h:72:#include "src/objects/object-macros-undef.h"
./objects/fixed-array.h:12:#include "src/objects/heap-object.h"
./objects/fixed-array.h:13:#include "src/objects/instance-type.h"
./objects/fixed-array.h:14:#include "src/objects/maybe-object.h"
./objects/fixed-array.h:15:#include "src/objects/objects.h"
./objects/fixed-array.h:16:#include "src/objects/smi.h"
./objects/fixed-array.h:17:#include "src/objects/tagged.h"
./objects/fixed-array.h:18:#include "src/objects/trusted-object.h"
./objects/fixed-array.h:23:#include "src/objects/object-macros.h"
./objects/fixed-array.h:27:#include "torque-generated/src/objects/fixed-array-tq.inc"
./objects/fixed-array.h:941:#include "src/objects/object-macros-undef.h"
./objects/field-type.h:9:#include "src/objects/casting.h"
./objects/field-type.h:10:#include "src/objects/tagged.h"
./objects/hole.h:9:#include "src/objects/heap-number.h"
./objects/hole.h:10:#include "src/objects/heap-object.h"
./objects/hole.h:13:#include "src/objects/object-macros.h"
./objects/hole.h:18:#include "torque-generated/src/objects/hole-tq.inc"
./objects/hole.h:46:#include "src/objects/object-macros-undef.h"
./objects/foreign-inl.h:11:#include "src/objects/foreign.h"
./objects/foreign-inl.h:12:#include "src/objects/objects-inl.h"
./objects/foreign-inl.h:17:#include "src/objects/object-macros.h"
./objects/foreign-inl.h:21:#include "torque-generated/src/objects/foreign-tq-inl.inc"
./objects/foreign-inl.h:70:#include "src/objects/object-macros-undef.h"
./objects/heap-number-inl.h:9:#include "src/objects/heap-number.h"
./objects/heap-number-inl.h:10:#include "src/objects/primitive-heap-object-inl.h"
./objects/heap-number-inl.h:13:#include "src/objects/object-macros.h"
./objects/heap-number-inl.h:30:#include "src/objects/object-macros-undef.h"
./objects/hash-table.h:13:#include "src/objects/fixed-array.h"
./objects/hash-table.h:14:#include "src/objects/property-array.h"
./objects/hash-table.h:15:#include "src/objects/smi.h"
./objects/hash-table.h:16:#include "src/objects/tagged-field.h"
./objects/hash-table.h:20:#include "src/objects/object-macros.h"
./objects/hash-table.h:582:#include "src/objects/object-macros-undef.h"
./objects/fixed-array-inl.h:14:#include "src/objects/bigint.h"
./objects/fixed-array-inl.h:15:#include "src/objects/compressed-slots.h"
./objects/fixed-array-inl.h:16:#include "src/objects/fixed-array.h"
./objects/fixed-array-inl.h:17:#include "src/objects/map.h"
./objects/fixed-array-inl.h:18:#include "src/objects/maybe-object-inl.h"
./objects/fixed-array-inl.h:19:#include "src/objects/objects-inl.h"
./objects/fixed-array-inl.h:20:#include "src/objects/oddball.h"
./objects/fixed-array-inl.h:21:#include "src/objects/slots-inl.h"
./objects/fixed-array-inl.h:22:#include "src/objects/slots.h"
./objects/fixed-array-inl.h:29:#include "src/objects/object-macros.h"
./objects/fixed-array-inl.h:33:#include "torque-generated/src/objects/fixed-array-tq-inl.inc"
./objects/fixed-array-inl.h:897:#include "src/objects/object-macros-undef.h"
./objects/heap-object.h:10:#include "src/objects/casting.h"
./objects/heap-object.h:11:#include "src/objects/instance-type.h"
./objects/heap-object.h:12:#include "src/objects/slots.h"
./objects/heap-object.h:13:#include "src/objects/tagged-field.h"
./objects/heap-object.h:18:#include "src/objects/object-macros.h"
./objects/heap-object.h:603:#include "src/objects/object-macros-undef.h"
./objects/field-index-inl.h:9:#include "src/objects/descriptor-array-inl.h"
./objects/field-index-inl.h:10:#include "src/objects/field-index.h"
./objects/field-index-inl.h:11:#include "src/objects/map-inl.h"
./objects/field-index-inl.h:12:#include "src/objects/objects-inl.h"
./objects/field-index-inl.h:13:#include "src/objects/tagged-field.h"
./objects/elements.cc:5:#include "src/objects/elements.h"
./objects/elements.cc:18:#include "src/objects/arguments-inl.h"
./objects/elements.cc:19:#include "src/objects/hash-table-inl.h"
./objects/elements.cc:20:#include "src/objects/js-array-buffer-inl.h"
./objects/elements.cc:21:#include "src/objects/js-array-inl.h"
./objects/elements.cc:22:#include "src/objects/js-shared-array-inl.h"
./objects/elements.cc:23:#include "src/objects/keys.h"
./objects/elements.cc:24:#include "src/objects/objects-inl.h"
./objects/elements.cc:25:#include "src/objects/slots-atomic-inl.h"
./objects/elements.cc:26:#include "src/objects/slots.h"
./objects/instruction-stream.cc:5:#include "src/objects/instruction-stream.h"
./objects/instruction-stream.cc:12:#include "src/objects/instruction-stream-inl.h"
./objects/free-space.h:8:#include "src/objects/heap-object.h"
./objects/free-space.h:11:#include "src/objects/object-macros.h"
./objects/free-space.h:16:#include "torque-generated/src/objects/free-space-tq.inc"
./objects/free-space.h:60:#include "src/objects/object-macros-undef.h"
./objects/instance-type-checker.h:8:#include "src/objects/instance-type.h"
./objects/instance-type-checker.h:13:#include "src/objects/object-macros.h"
./objects/instance-type-checker.h:102:#include "src/objects/object-macros-undef.h"
./objects/instruction-stream-inl.h:13:#include "src/objects/code.h"
./objects/instruction-stream-inl.h:14:#include "src/objects/instruction-stream.h"
./objects/instruction-stream-inl.h:15:#include "src/objects/objects-inl.h"  // For HeapObject::IsInstructionStream.
./objects/instruction-stream-inl.h:18:#include "src/objects/object-macros.h"
./objects/instruction-stream-inl.h:272:#include "src/objects/object-macros-undef.h"
./objects/js-array-buffer-inl.h:9:#include "src/objects/js-array-buffer.h"
./objects/js-array-buffer-inl.h:10:#include "src/objects/js-objects-inl.h"
./objects/js-array-buffer-inl.h:11:#include "src/objects/objects-inl.h"
./objects/js-array-buffer-inl.h:14:#include "src/objects/object-macros.h"
./objects/js-array-buffer-inl.h:19:#include "torque-generated/src/objects/js-array-buffer-tq-inl.inc"
./objects/js-array-buffer-inl.h:426:#include "src/objects/object-macros-undef.h"
./objects/hash-table-inl.h:10:#include "src/objects/fixed-array-inl.h"
./objects/hash-table-inl.h:11:#include "src/objects/hash-table.h"
./objects/hash-table-inl.h:12:#include "src/objects/heap-object-inl.h"
./objects/hash-table-inl.h:13:#include "src/objects/objects-inl.h"
./objects/hash-table-inl.h:17:#include "src/objects/object-macros.h"
./objects/hash-table-inl.h:324:#include "src/objects/object-macros-undef.h"
./objects/hole-inl.h:10:#include "src/objects/heap-number-inl.h"
./objects/hole-inl.h:11:#include "src/objects/hole.h"
./objects/hole-inl.h:12:#include "src/objects/objects-inl.h"
./objects/hole-inl.h:13:#include "src/objects/smi-inl.h"
./objects/hole-inl.h:14:#include "src/objects/tagged-field-inl.h"
./objects/hole-inl.h:17:#include "src/objects/object-macros.h"
./objects/hole-inl.h:37:#include "src/objects/object-macros-undef.h"
./objects/instruction-stream.h:13:#include "src/objects/trusted-object.h"
./objects/instruction-stream.h:16:#include "src/objects/object-macros.h"
./objects/instruction-stream.h:200:#include "src/objects/object-macros-undef.h"
./objects/intl-objects.h:15:#include "src/objects/contexts.h"
./objects/intl-objects.h:16:#include "src/objects/managed.h"
./objects/intl-objects.h:17:#include "src/objects/objects.h"
./objects/intl-objects.h:328:  // Usage in src/objects/js-XXX.cc
./objects/js-collator.tq:5:#include 'src/objects/js-collator.h'
./objects/js-array.h:8:#include "src/objects/allocation-site.h"
./objects/js-array.h:9:#include "src/objects/fixed-array.h"
./objects/js-array.h:10:#include "src/objects/js-objects.h"
./objects/js-array.h:13:#include "src/objects/object-macros.h"
./objects/js-array.h:18:#include "torque-generated/src/objects/js-array-tq.inc"
./objects/js-array.h:180:#include "src/objects/object-macros-undef.h"
./objects/instance-type.h:9:#include "src/objects/objects-definitions.h"
./objects/instance-type.h:13:#include "src/objects/object-macros.h"
./objects/instance-type.h:340:#include "src/objects/object-macros-undef.h"
./objects/js-array-buffer.h:11:#include "src/objects/backing-store.h"
./objects/js-array-buffer.h:12:#include "src/objects/js-objects.h"
./objects/js-array-buffer.h:16:#include "src/objects/object-macros.h"
./objects/js-array-buffer.h:23:#include "torque-generated/src/objects/js-array-buffer-tq.inc"
./objects/js-array-buffer.h:499:#include "src/objects/object-macros-undef.h"
./objects/js-array-buffer.cc:5:#include "src/objects/js-array-buffer.h"
./objects/js-array-buffer.cc:9:#include "src/objects/js-array-buffer-inl.h"
./objects/js-array-buffer.cc:10:#include "src/objects/property-descriptor.h"
./objects/js-break-iterator.cc:9:#include "src/objects/js-break-iterator.h"
./objects/js-break-iterator.cc:11:#include "src/objects/intl-objects.h"
./objects/js-break-iterator.cc:12:#include "src/objects/js-break-iterator-inl.h"
./objects/js-break-iterator.cc:13:#include "src/objects/managed-inl.h"
./objects/js-break-iterator.cc:14:#include "src/objects/option-utils.h"
./objects/intl-objects.tq:5:#include 'src/objects/js-objects.h'
./objects/intl-objects.tq:6:#include 'src/objects/intl-objects.h'
./objects/intl-objects.tq:47:// src/objects/intl-objects.cc.
./objects/intl-objects.cc:5:#include "src/objects/intl-objects.h"
./objects/intl-objects.cc:23:#include "src/objects/js-collator-inl.h"
./objects/intl-objects.cc:24:#include "src/objects/js-date-time-format-inl.h"
./objects/intl-objects.cc:25:#include "src/objects/js-locale-inl.h"
./objects/intl-objects.cc:26:#include "src/objects/js-locale.h"
./objects/intl-objects.cc:27:#include "src/objects/js-number-format-inl.h"
./objects/intl-objects.cc:28:#include "src/objects/js-temporal-objects.h"
./objects/intl-objects.cc:29:#include "src/objects/managed-inl.h"
./objects/intl-objects.cc:30:#include "src/objects/objects-inl.h"
./objects/intl-objects.cc:31:#include "src/objects/option-utils.h"
./objects/intl-objects.cc:32:#include "src/objects/property-descriptor.h"
./objects/intl-objects.cc:33:#include "src/objects/smi.h"
./objects/intl-objects.cc:34:#include "src/objects/string.h"
./objects/feedback-vector.cc:5:#include "src/objects/feedback-vector.h"
./objects/feedback-vector.cc:17:#include "src/objects/data-handler-inl.h"
./objects/feedback-vector.cc:18:#include "src/objects/feedback-vector-inl.h"
./objects/feedback-vector.cc:19:#include "src/objects/hash-table-inl.h"
./objects/feedback-vector.cc:20:#include "src/objects/map-inl.h"
./objects/feedback-vector.cc:21:#include "src/objects/objects.h"
./objects/js-atomics-synchronization-inl.h:11:#include "src/objects/js-atomics-synchronization.h"
./objects/js-atomics-synchronization-inl.h:12:#include "src/objects/js-struct-inl.h"
./objects/js-atomics-synchronization-inl.h:13:#include "src/objects/objects-inl.h"
./objects/js-atomics-synchronization-inl.h:16:#include "src/objects/object-macros.h"
./objects/js-atomics-synchronization-inl.h:21:#include "torque-generated/src/objects/js-atomics-synchronization-tq-inl.inc"
./objects/js-atomics-synchronization-inl.h:253:#include "src/objects/object-macros-undef.h"
./objects/js-array-inl.h:8:#include "src/objects/js-array.h"
./objects/js-array-inl.h:10:#include "src/objects/objects-inl.h"  // Needed for write barriers
./objects/js-array-inl.h:13:#include "src/objects/object-macros.h"
./objects/js-array-inl.h:18:#include "torque-generated/src/objects/js-array-tq-inl.inc"
./objects/js-array-inl.h:92:#include "src/objects/object-macros-undef.h"
./objects/js-collator.h:17:#include "src/objects/intl-objects.h"
./objects/js-collator.h:18:#include "src/objects/js-objects.h"
./objects/js-collator.h:19:#include "src/objects/managed.h"
./objects/js-collator.h:20:#include "src/objects/objects.h"
./objects/js-collator.h:23:#include "src/objects/object-macros.h"
./objects/js-collator.h:32:#include "torque-generated/src/objects/js-collator-tq.inc"
./objects/js-collator.h:57:#include "src/objects/object-macros-undef.h"
./objects/js-break-iterator.tq:5:#include 'src/objects/js-break-iterator.h'
./objects/instance-type-inl.h:12:#include "src/objects/instance-type-checker.h"
./objects/instance-type-inl.h:13:#include "src/objects/instance-type.h"
./objects/instance-type-inl.h:16:#include "src/objects/object-macros.h"
./objects/instance-type-inl.h:538:#include "src/objects/object-macros-undef.h"
./objects/js-break-iterator.h:15:#include "src/objects/intl-objects.h"
./objects/js-break-iterator.h:16:#include "src/objects/managed.h"
./objects/js-break-iterator.h:17:#include "src/objects/objects.h"
./objects/js-break-iterator.h:20:#include "src/objects/object-macros.h"
./objects/js-break-iterator.h:29:#include "torque-generated/src/objects/js-break-iterator-tq.inc"
./objects/js-break-iterator.h:68:#include "src/objects/object-macros-undef.h"
./objects/js-display-names.cc:9:#include "src/objects/js-display-names.h"
./objects/js-display-names.cc:16:#include "src/objects/intl-objects.h"
./objects/js-display-names.cc:17:#include "src/objects/js-display-names-inl.h"
./objects/js-display-names.cc:18:#include "src/objects/js-locale.h"
./objects/js-display-names.cc:19:#include "src/objects/managed-inl.h"
./objects/js-display-names.cc:20:#include "src/objects/objects-inl.h"
./objects/js-display-names.cc:21:#include "src/objects/option-utils.h"
./objects/js-atomics-synchronization.h:12:#include "src/objects/contexts.h"
./objects/js-atomics-synchronization.h:13:#include "src/objects/js-objects.h"
./objects/js-atomics-synchronization.h:14:#include "src/objects/js-struct.h"
./objects/js-atomics-synchronization.h:15:#include "src/objects/struct.h"
./objects/js-atomics-synchronization.h:18:#include "src/objects/object-macros.h"
./objects/js-atomics-synchronization.h:23:#include "torque-generated/src/objects/js-atomics-synchronization-tq.inc"
./objects/js-atomics-synchronization.h:457:#include "src/objects/object-macros-undef.h"
./objects/foreign.h:8:#include "src/objects/heap-object.h"
./objects/foreign.h:9:#include "src/objects/objects-body-descriptors.h"
./objects/foreign.h:12:#include "src/objects/object-macros.h"
./objects/foreign.h:16:#include "torque-generated/src/objects/foreign-tq.inc"
./objects/foreign.h:78:#include "src/objects/object-macros-undef.h"
./objects/js-break-iterator-inl.h:12:#include "src/objects/js-break-iterator.h"
./objects/js-break-iterator-inl.h:13:#include "src/objects/objects-inl.h"
./objects/js-break-iterator-inl.h:16:#include "src/objects/object-macros.h"
./objects/js-break-iterator-inl.h:21:#include "torque-generated/src/objects/js-break-iterator-tq-inl.inc"
./objects/js-break-iterator-inl.h:33:#include "src/objects/object-macros-undef.h"
./objects/js-collator.cc:9:#include "src/objects/js-collator.h"
./objects/js-collator.cc:12:#include "src/objects/js-collator-inl.h"
./objects/js-collator.cc:13:#include "src/objects/js-locale.h"
./objects/js-collator.cc:14:#include "src/objects/managed-inl.h"
./objects/js-collator.cc:15:#include "src/objects/objects-inl.h"
./objects/js-collator.cc:16:#include "src/objects/option-utils.h"
./objects/js-display-names-inl.h:12:#include "src/objects/js-display-names.h"
./objects/js-display-names-inl.h:13:#include "src/objects/objects-inl.h"
./objects/js-display-names-inl.h:16:#include "src/objects/object-macros.h"
./objects/js-display-names-inl.h:21:#include "torque-generated/src/objects/js-display-names-tq-inl.inc"
./objects/js-display-names-inl.h:58:#include "src/objects/object-macros-undef.h"
./objects/js-date-time-format-inl.h:12:#include "src/objects/js-date-time-format.h"
./objects/js-date-time-format-inl.h:13:#include "src/objects/objects-inl.h"
./objects/js-date-time-format-inl.h:16:#include "src/objects/object-macros.h"
./objects/js-date-time-format-inl.h:21:#include "torque-generated/src/objects/js-date-time-format-tq-inl.inc"
./objects/js-date-time-format-inl.h:68:#include "src/objects/object-macros-undef.h"
./objects/js-collection-iterator.h:9:#include "src/objects/js-objects.h"
./objects/js-collection-iterator.h:10:#include "src/objects/objects.h"
./objects/js-collection-iterator.h:11:#include "src/objects/smi.h"
./objects/js-collection-iterator.h:14:#include "src/objects/object-macros.h"
./objects/js-collection-iterator.h:19:#include "torque-generated/src/objects/js-collection-iterator-tq.inc"
./objects/js-collection-iterator.h:67:#include "src/objects/object-macros-undef.h"
./objects/js-disposable-stack.cc:5:#include "src/objects/js-disposable-stack.h"
./objects/js-disposable-stack.cc:16:#include "src/objects/fixed-array-inl.h"
./objects/js-disposable-stack.cc:17:#include "src/objects/heap-object.h"
./objects/js-disposable-stack.cc:18:#include "src/objects/js-disposable-stack-inl.h"
./objects/js-disposable-stack.cc:19:#include "src/objects/js-function.h"
./objects/js-disposable-stack.cc:20:#include "src/objects/js-objects.h"
./objects/js-disposable-stack.cc:21:#include "src/objects/js-promise-inl.h"
./objects/js-disposable-stack.cc:22:#include "src/objects/js-promise.h"
./objects/js-disposable-stack.cc:23:#include "src/objects/objects-inl.h"
./objects/js-disposable-stack.cc:24:#include "src/objects/objects.h"
./objects/js-disposable-stack.cc:25:#include "src/objects/oddball.h"
./objects/js-disposable-stack.cc:26:#include "src/objects/tagged.h"
./objects/js-iterator-helpers-inl.h:8:#include "src/objects/js-iterator-helpers.h"
./objects/js-iterator-helpers-inl.h:9:#include "src/objects/oddball-inl.h"
./objects/js-iterator-helpers-inl.h:12:#include "src/objects/object-macros.h"
./objects/js-iterator-helpers-inl.h:17:#include "torque-generated/src/objects/js-iterator-helpers-tq-inl.inc"
./objects/js-iterator-helpers-inl.h:29:#include "src/objects/object-macros-undef.h"
./objects/js-collection-inl.h:9:#include "src/objects/heap-object-inl.h"
./objects/js-collection-inl.h:10:#include "src/objects/js-collection-iterator-inl.h"
./objects/js-collection-inl.h:11:#include "src/objects/js-collection.h"
./objects/js-collection-inl.h:12:#include "src/objects/objects-inl.h"
./objects/js-collection-inl.h:13:#include "src/objects/ordered-hash-table-inl.h"
./objects/js-collection-inl.h:17:#include "src/objects/object-macros.h"
./objects/js-collection-inl.h:22:#include "torque-generated/src/objects/js-collection-tq-inl.inc"
./objects/js-collection-inl.h:59:#include "src/objects/object-macros-undef.h"
./objects/heap-object-inl.h:9:#include "src/objects/heap-object.h"
./objects/heap-object-inl.h:10:#include "src/objects/instance-type-inl.h"
./objects/heap-object-inl.h:11:#include "src/objects/objects-inl.h"
./objects/heap-object-inl.h:14:#include "src/objects/object-macros.h"
./objects/heap-object-inl.h:39:#include "src/objects/object-macros-undef.h"
./objects/js-collator-inl.h:12:#include "src/objects/js-collator.h"
./objects/js-collator-inl.h:13:#include "src/objects/objects-inl.h"
./objects/js-collator-inl.h:16:#include "src/objects/object-macros.h"
./objects/js-collator-inl.h:21:#include "torque-generated/src/objects/js-collator-tq-inl.inc"
./objects/js-collator-inl.h:31:#include "src/objects/object-macros-undef.h"
./objects/js-collection.h:8:#include "src/objects/js-collection-iterator.h"
./objects/js-collection.h:9:#include "src/objects/objects.h"
./objects/js-collection.h:12:#include "src/objects/object-macros.h"
./objects/js-collection.h:20:#include "torque-generated/src/objects/js-collection-tq.inc"
./objects/js-collection.h:136:#include "src/objects/object-macros-undef.h"
./objects/js-function.cc:5:#include "src/objects/js-function.h"
./objects/js-function.cc:19:#include "src/objects/feedback-cell-inl.h"
./objects/js-function.cc:23:#include "src/objects/object-macros.h"
./objects/js-function.cc:1535:#include "src/objects/object-macros-undef.h"
./objects/js-display-names.h:17:#include "src/objects/managed.h"
./objects/js-display-names.h:18:#include "src/objects/objects.h"
./objects/js-display-names.h:21:#include "src/objects/object-macros.h"
./objects/js-display-names.h:28:#include "torque-generated/src/objects/js-display-names-tq.inc"
./objects/js-display-names.h:102:#include "src/objects/object-macros-undef.h"
./objects/js-date-time-format.tq:5:#include 'src/objects/js-date-time-format.h'
./objects/js-generator.h:8:#include "src/objects/js-objects.h"
./objects/js-generator.h:9:#include "src/objects/struct.h"
./objects/js-generator.h:12:#include "src/objects/object-macros.h"
./objects/js-generator.h:21:#include "torque-generated/src/objects/js-generator-tq.inc"
./objects/js-generator.h:84:#include "src/objects/object-macros-undef.h"
./objects/js-date-time-format.cc:5:#include "src/objects/js-date-time-format.h"
./objects/js-date-time-format.cc:19:#include "src/objects/intl-objects.h"
./objects/js-date-time-format.cc:20:#include "src/objects/js-date-time-format-inl.h"
./objects/js-date-time-format.cc:21:#include "src/objects/js-temporal-objects-inl.h"
./objects/js-date-time-format.cc:22:#include "src/objects/managed-inl.h"
./objects/js-date-time-format.cc:23:#include "src/objects/option-utils.h"
./objects/js-date-time-format.h:17:#include "src/objects/intl-objects.h"
./objects/js-date-time-format.h:18:#include "src/objects/managed.h"
./objects/js-date-time-format.h:22:#include "src/objects/object-macros.h"
./objects/js-date-time-format.h:34:#include "torque-generated/src/objects/js-date-time-format-tq.inc"
./objects/js-date-time-format.h:163:#include "src/objects/object-macros-undef.h"
./objects/js-disposable-stack.h:11:#include "src/objects/contexts.h"
./objects/js-disposable-stack.h:12:#include "src/objects/heap-object.h"
./objects/js-disposable-stack.h:13:#include "src/objects/js-objects.h"
./objects/js-disposable-stack.h:14:#include "src/objects/js-promise.h"
./objects/js-disposable-stack.h:18:#include "src/objects/object-macros.h"
./objects/js-disposable-stack.h:23:#include "torque-generated/src/objects/js-disposable-stack-tq.inc"
./objects/js-disposable-stack.h:120:#include "src/objects/object-macros-undef.h"
./objects/js-duration-format-inl.h:12:#include "src/objects/js-duration-format.h"
./objects/js-duration-format-inl.h:13:#include "src/objects/objects-inl.h"
./objects/js-duration-format-inl.h:16:#include "src/objects/object-macros.h"
./objects/js-duration-format-inl.h:21:#include "torque-generated/src/objects/js-duration-format-tq-inl.inc"
./objects/js-duration-format-inl.h:103:#include "src/objects/object-macros-undef.h"
./objects/js-disposable-stack-inl.h:12:#include "src/objects/fixed-array-inl.h"
./objects/js-disposable-stack-inl.h:13:#include "src/objects/heap-object.h"
./objects/js-disposable-stack-inl.h:14:#include "src/objects/js-disposable-stack.h"
./objects/js-disposable-stack-inl.h:15:#include "src/objects/objects-inl.h"
./objects/js-disposable-stack-inl.h:16:#include "src/objects/objects.h"
./objects/js-disposable-stack-inl.h:19:#include "src/objects/object-macros.h"
./objects/js-disposable-stack-inl.h:24:#include "torque-generated/src/objects/js-disposable-stack-tq-inl.inc"
./objects/js-disposable-stack-inl.h:215:#include "src/objects/object-macros-undef.h"
./objects/js-duration-format.tq:5:#include 'src/objects/js-duration-format.h'
./objects/js-list-format.tq:5:#include 'src/objects/js-list-format.h'
./objects/js-function-inl.h:10:#include "src/objects/js-function.h"
./objects/js-function-inl.h:19:#include "src/objects/abstract-code-inl.h"
./objects/js-function-inl.h:20:#include "src/objects/feedback-cell-inl.h"
./objects/js-function-inl.h:21:#include "src/objects/feedback-vector-inl.h"
./objects/js-function-inl.h:22:#include "src/objects/instance-type-inl.h"
./objects/js-function-inl.h:23:#include "src/objects/map-updater.h"
./objects/js-function-inl.h:24:#include "src/objects/shared-function-info-inl.h"
./objects/js-function-inl.h:29:#include "src/objects/object-macros.h"
./objects/js-function-inl.h:33:#include "torque-generated/src/objects/js-function-tq-inl.inc"
./objects/js-function-inl.h:570:#include "src/objects/object-macros-undef.h"
./objects/js-locale.tq:5:#include 'src/objects/js-locale.h'
./objects/js-duration-format.h:14:#include "src/objects/managed.h"
./objects/js-duration-format.h:15:#include "src/objects/objects.h"
./objects/js-duration-format.h:18:#include "src/objects/object-macros.h"
./objects/js-duration-format.h:30:#include "torque-generated/src/objects/js-duration-format-tq.inc"
./objects/js-duration-format.h:181:#include "src/objects/object-macros-undef.h"
./objects/js-generator-inl.h:8:#include "src/objects/js-generator.h"
./objects/js-generator-inl.h:9:#include "src/objects/js-promise-inl.h"
./objects/js-generator-inl.h:11:#include "src/objects/objects-inl.h"  // Needed for write barriers
./objects/js-generator-inl.h:14:#include "src/objects/object-macros.h"
./objects/js-generator-inl.h:19:#include "torque-generated/src/objects/js-generator-tq-inl.inc"
./objects/js-generator-inl.h:43:#include "src/objects/object-macros-undef.h"
./objects/js-function.h:10:#include "src/objects/code-kind.h"
./objects/js-function.h:11:#include "src/objects/js-objects.h"
./objects/js-function.h:14:#include "src/objects/object-macros.h"
./objects/js-function.h:21:#include "torque-generated/src/objects/js-function-tq.inc"
./objects/js-function.h:474:#include "src/objects/object-macros-undef.h"
./objects/js-raw-json.cc:5:#include "src/objects/js-raw-json.h"
./objects/js-raw-json.cc:10:#include "src/objects/js-raw-json-inl.h"
./objects/js-raw-json.cc:11:#include "src/objects/string-inl.h"
./objects/js-list-format.cc:9:#include "src/objects/js-list-format.h"
./objects/js-list-format.cc:16:#include "src/objects/elements-inl.h"
./objects/js-list-format.cc:17:#include "src/objects/elements.h"
./objects/js-list-format.cc:18:#include "src/objects/intl-objects.h"
./objects/js-list-format.cc:19:#include "src/objects/js-array-inl.h"
./objects/js-list-format.cc:20:#include "src/objects/js-list-format-inl.h"
./objects/js-list-format.cc:21:#include "src/objects/managed-inl.h"
./objects/js-list-format.cc:22:#include "src/objects/objects-inl.h"
./objects/js-list-format.cc:23:#include "src/objects/option-utils.h"
./objects/js-list-format-inl.h:12:#include "src/objects/js-list-format.h"
./objects/js-list-format-inl.h:13:#include "src/objects/objects-inl.h"
./objects/js-list-format-inl.h:16:#include "src/objects/object-macros.h"
./objects/js-list-format-inl.h:21:#include "torque-generated/src/objects/js-list-format-tq-inl.inc"
./objects/js-list-format-inl.h:54:#include "src/objects/object-macros-undef.h"
./objects/js-locale.h:15:#include "src/objects/managed.h"
./objects/js-locale.h:16:#include "src/objects/objects.h"
./objects/js-locale.h:19:#include "src/objects/object-macros.h"
./objects/js-locale.h:28:#include "torque-generated/src/objects/js-locale-tq.inc"
./objects/js-locale.h:102:#include "src/objects/object-macros-undef.h"
./objects/js-iterator-helpers.h:8:#include "src/objects/js-objects.h"
./objects/js-iterator-helpers.h:11:#include "src/objects/object-macros.h"
./objects/js-iterator-helpers.h:18:#include "torque-generated/src/objects/js-iterator-helpers-tq.inc"
./objects/js-iterator-helpers.h:119:#include "src/objects/object-macros-undef.h"
./objects/js-plural-rules.tq:5:#include 'src/objects/js-plural-rules.h'
./objects/js-list-format.h:18:#include "src/objects/managed.h"
./objects/js-list-format.h:19:#include "src/objects/objects.h"
./objects/js-list-format.h:23:#include "src/objects/object-macros.h"
./objects/js-list-format.h:32:#include "torque-generated/src/objects/js-list-format-tq.inc"
./objects/js-list-format.h:104:#include "src/objects/object-macros-undef.h"
./objects/js-number-format-inl.h:12:#include "src/objects/js-number-format.h"
./objects/js-number-format-inl.h:13:#include "src/objects/objects-inl.h"
./objects/js-number-format-inl.h:16:#include "src/objects/object-macros.h"
./objects/js-number-format-inl.h:21:#include "torque-generated/src/objects/js-number-format-tq-inl.inc"
./objects/js-number-format-inl.h:32:#include "src/objects/object-macros-undef.h"
./objects/js-locale-inl.h:13:#include "src/objects/js-locale.h"
./objects/js-locale-inl.h:14:#include "src/objects/objects-inl.h"
./objects/js-locale-inl.h:17:#include "src/objects/object-macros.h"
./objects/js-locale-inl.h:22:#include "torque-generated/src/objects/js-locale-tq-inl.inc"
./objects/js-locale-inl.h:31:#include "src/objects/object-macros-undef.h"
./objects/js-objects.cc:5:#include "src/objects/js-objects.h"
./objects/js-objects.cc:29:#include "src/objects/allocation-site-inl.h"
./objects/js-objects.cc:30:#include "src/objects/api-callbacks.h"
./objects/js-objects.cc:31:#include "src/objects/arguments-inl.h"
./objects/js-objects.cc:32:#include "src/objects/dictionary.h"
./objects/js-objects.cc:33:#include "src/objects/elements.h"
./objects/js-objects.cc:34:#include "src/objects/field-type.h"
./objects/js-objects.cc:35:#include "src/objects/fixed-array.h"
./objects/js-objects.cc:36:#include "src/objects/heap-number.h"
./objects/js-objects.cc:37:#include "src/objects/heap-object.h"
./objects/js-objects.cc:38:#include "src/objects/js-array-buffer-inl.h"
./objects/js-objects.cc:39:#include "src/objects/js-array-inl.h"
./objects/js-objects.cc:40:#include "src/objects/js-atomics-synchronization.h"
./objects/js-objects.cc:41:#include "src/objects/js-collection.h"
./objects/js-objects.cc:42:#include "src/objects/js-disposable-stack.h"
./objects/js-objects.cc:43:#include "src/objects/js-generator-inl.h"
./objects/js-objects.cc:44:#include "src/objects/js-iterator-helpers-inl.h"
./objects/js-objects.cc:45:#include "src/objects/js-promise.h"
./objects/js-objects.cc:46:#include "src/objects/js-raw-json-inl.h"
./objects/js-objects.cc:47:#include "src/objects/js-regexp-inl.h"
./objects/js-objects.cc:48:#include "src/objects/js-regexp-string-iterator.h"
./objects/js-objects.cc:49:#include "src/objects/js-shadow-realm.h"
./objects/js-objects.cc:50:#include "src/objects/js-shared-array-inl.h"
./objects/js-objects.cc:51:#include "src/objects/js-struct-inl.h"
./objects/js-objects.cc:52:#include "src/objects/js-temporal-objects-inl.h"
./objects/js-objects.cc:53:#include "src/objects/js-weak-refs.h"
./objects/js-objects.cc:54:#include "src/objects/lookup.h"
./objects/js-objects.cc:55:#include "src/objects/map-inl.h"
./objects/js-objects.cc:56:#include "src/objects/map-updater.h"
./objects/js-objects.cc:57:#include "src/objects/module.h"
./objects/js-objects.cc:58:#include "src/objects/objects-body-descriptors-inl.h"
./objects/js-objects.cc:59:#include "src/objects/objects-inl.h"
./objects/js-objects.cc:60:#include "src/objects/oddball.h"
./objects/js-objects.cc:61:#include "src/objects/property-cell.h"
./objects/js-objects.cc:62:#include "src/objects/property-descriptor.h"
./objects/js-objects.cc:63:#include "src/objects/property.h"
./objects/js-objects.cc:64:#include "src/objects/prototype-info.h"
./objects/js-objects.cc:65:#include "src/objects/prototype.h"
./objects/js-objects.cc:66:#include "src/objects/shared-function-info.h"
./objects/js-objects.cc:67:#include "src/objects/swiss-name-dictionary-inl.h"
./objects/js-objects.cc:68:#include "src/objects/tagged.h"
./objects/js-objects.cc:69:#include "src/objects/transitions.h"
./objects/js-objects.cc:80:#include "src/objects/js-break-iterator.h"
./objects/js-objects.cc:81:#include "src/objects/js-collator.h"
./objects/js-objects.cc:82:#include "src/objects/js-date-time-format.h"
./objects/js-objects.cc:83:#include "src/objects/js-display-names.h"
./objects/js-objects.cc:84:#include "src/objects/js-duration-format.h"
./objects/js-objects.cc:85:#include "src/objects/js-list-format.h"
./objects/js-objects.cc:86:#include "src/objects/js-locale.h"
./objects/js-objects.cc:87:#include "src/objects/js-number-format.h"
./objects/js-objects.cc:88:#include "src/objects/js-plural-rules.h"
./objects/js-objects.cc:89:#include "src/objects/js-relative-time-format.h"
./objects/js-objects.cc:90:#include "src/objects/js-segment-iterator.h"
./objects/js-objects.cc:91:#include "src/objects/js-segmenter.h"
./objects/js-objects.cc:92:#include "src/objects/js-segments.h"
./objects/js-atomics-synchronization.cc:5:#include "src/objects/js-atomics-synchronization.h"
./objects/js-atomics-synchronization.cc:10:#include "src/objects/js-atomics-synchronization-inl.h"
./objects/js-atomics-synchronization.cc:11:#include "src/objects/js-promise-inl.h"
./objects/js-atomics-synchronization.cc:12:#include "src/objects/waiter-queue-node.h"
./objects/js-duration-format.cc:9:#include "src/objects/js-duration-format.h"
./objects/js-duration-format.cc:19:#include "src/objects/intl-objects.h"
./objects/js-duration-format.cc:20:#include "src/objects/js-duration-format-inl.h"
./objects/js-duration-format.cc:21:#include "src/objects/js-number-format.h"
./objects/js-duration-format.cc:22:#include "src/objects/js-temporal-objects.h"
./objects/js-duration-format.cc:23:#include "src/objects/managed-inl.h"
./objects/js-duration-format.cc:24:#include "src/objects/objects-inl.h"
./objects/js-duration-format.cc:25:#include "src/objects/option-utils.h"
./objects/js-objects.h:12:#include "src/objects/embedder-data-slot.h"
./objects/js-objects.h:14:#include "src/objects/internal-index.h"
./objects/js-objects.h:15:#include "src/objects/objects.h"
./objects/js-objects.h:16:#include "src/objects/property-array.h"
./objects/js-objects.h:19:#include "src/objects/object-macros.h"
./objects/js-objects.h:41:#include "torque-generated/src/objects/js-objects-tq.inc"
./objects/js-objects.h:1454:#include "src/objects/object-macros-undef.h"
./objects/js-relative-time-format.h:19:#include "src/objects/managed.h"
./objects/js-relative-time-format.h:20:#include "src/objects/objects.h"
./objects/js-relative-time-format.h:24:#include "src/objects/object-macros.h"
./objects/js-relative-time-format.h:33:#include "torque-generated/src/objects/js-relative-time-format-tq.inc"
./objects/js-relative-time-format.h:92:#include "src/objects/object-macros-undef.h"
./objects/js-plural-rules.h:18:#include "src/objects/intl-objects.h"
./objects/js-plural-rules.h:19:#include "src/objects/managed.h"
./objects/js-plural-rules.h:20:#include "src/objects/objects.h"
./objects/js-plural-rules.h:23:#include "src/objects/object-macros.h"
./objects/js-plural-rules.h:36:#include "torque-generated/src/objects/js-plural-rules-tq.inc"
./objects/js-plural-rules.h:84:#include "src/objects/object-macros-undef.h"
./objects/js-number-format.h:18:#include "src/objects/intl-objects.h"
./objects/js-number-format.h:19:#include "src/objects/managed.h"
./objects/js-number-format.h:20:#include "src/objects/objects.h"
./objects/js-number-format.h:23:#include "src/objects/object-macros.h"
./objects/js-number-format.h:40:#include "torque-generated/src/objects/js-number-format-tq.inc"
./objects/js-number-format.h:155:#include "src/objects/object-macros-undef.h"
./objects/js-regexp-string-iterator-inl.h:8:#include "src/objects/js-regexp-string-iterator.h"
./objects/js-regexp-string-iterator-inl.h:10:#include "src/objects/objects-inl.h"  // Needed for write barriers
./objects/js-regexp-string-iterator-inl.h:13:#include "src/objects/object-macros.h"
./objects/js-regexp-string-iterator-inl.h:18:#include "torque-generated/src/objects/js-regexp-string-iterator-tq-inl.inc"
./objects/js-regexp-string-iterator-inl.h:29:#include "src/objects/object-macros-undef.h"
./objects/js-promise-inl.h:8:#include "src/objects/js-promise.h"
./objects/js-promise-inl.h:10:#include "src/objects/objects-inl.h"  // Needed for write barriers
./objects/js-promise-inl.h:11:#include "src/objects/objects.h"
./objects/js-promise-inl.h:14:#include "src/objects/object-macros.h"
./objects/js-promise-inl.h:19:#include "torque-generated/src/objects/js-promise-tq-inl.inc"
./objects/js-promise-inl.h:60:#include "src/objects/object-macros-undef.h"
./objects/js-number-format.cc:9:#include "src/objects/js-number-format.h"
./objects/js-number-format.cc:16:#include "src/objects/intl-objects.h"
./objects/js-number-format.cc:17:#include "src/objects/js-number-format-inl.h"
./objects/js-number-format.cc:18:#include "src/objects/managed-inl.h"
./objects/js-number-format.cc:19:#include "src/objects/objects-inl.h"
./objects/js-number-format.cc:20:#include "src/objects/option-utils.h"
./objects/js-raw-json-inl.h:8:#include "src/objects/js-raw-json.h"
./objects/js-raw-json-inl.h:9:#include "src/objects/objects-inl.h"
./objects/js-raw-json-inl.h:12:#include "src/objects/object-macros.h"
./objects/js-raw-json-inl.h:17:#include "torque-generated/src/objects/js-raw-json-tq-inl.inc"
./objects/js-raw-json-inl.h:28:#include "src/objects/object-macros-undef.h"
./objects/js-collection-iterator-inl.h:8:#include "src/objects/js-collection-iterator.h"
./objects/js-collection-iterator-inl.h:9:#include "src/objects/objects-inl.h"
./objects/js-collection-iterator-inl.h:12:#include "src/objects/object-macros.h"
./objects/js-collection-iterator-inl.h:17:#include "torque-generated/src/objects/js-collection-iterator-tq-inl.inc"
./objects/js-collection-iterator-inl.h:24:#include "src/objects/object-macros-undef.h"
./objects/js-plural-rules-inl.h:13:#include "src/objects/js-plural-rules.h"
./objects/js-plural-rules-inl.h:14:#include "src/objects/objects-inl.h"
./objects/js-plural-rules-inl.h:17:#include "src/objects/object-macros.h"
./objects/js-plural-rules-inl.h:22:#include "torque-generated/src/objects/js-plural-rules-tq-inl.inc"
./objects/js-plural-rules-inl.h:46:#include "src/objects/object-macros-undef.h"
./objects/js-segments.h:14:#include "src/objects/js-segmenter.h"
./objects/js-segments.h:15:#include "src/objects/managed.h"
./objects/js-segments.h:16:#include "src/objects/objects.h"
./objects/js-segments.h:20:#include "src/objects/object-macros.h"
./objects/js-segments.h:30:#include "torque-generated/src/objects/js-segments-tq.inc"
./objects/js-segments.h:77:#include "src/objects/object-macros-undef.h"
./objects/js-regexp-inl.h:8:#include "src/objects/js-regexp.h"
./objects/js-regexp-inl.h:10:#include "src/objects/js-array-inl.h"
./objects/js-regexp-inl.h:11:#include "src/objects/objects-inl.h"  // Needed for write barriers
./objects/js-regexp-inl.h:12:#include "src/objects/smi.h"
./objects/js-regexp-inl.h:13:#include "src/objects/string.h"
./objects/js-regexp-inl.h:16:#include "src/objects/object-macros.h"
./objects/js-regexp-inl.h:21:#include "torque-generated/src/objects/js-regexp-tq-inl.inc"
./objects/js-regexp-inl.h:161:#include "src/objects/object-macros-undef.h"
./objects/js-segment-iterator.h:14:#include "src/objects/js-segmenter.h"
./objects/js-segment-iterator.h:15:#include "src/objects/managed.h"
./objects/js-segment-iterator.h:16:#include "src/objects/objects.h"
./objects/js-segment-iterator.h:20:#include "src/objects/object-macros.h"
./objects/js-segment-iterator.h:30:#include "torque-generated/src/objects/js-segment-iterator-tq.inc"
./objects/js-segment-iterator.h:86:#include "src/objects/object-macros-undef.h"
./objects/js-relative-time-format-inl.h:12:#include "src/objects/js-relative-time-format.h"
./objects/js-relative-time-format-inl.h:13:#include "src/objects/objects-inl.h"
./objects/js-relative-time-format-inl.h:16:#include "src/objects/object-macros.h"
./objects/js-relative-time-format-inl.h:21:#include "torque-generated/src/objects/js-relative-time-format-tq-inl.inc"
./objects/js-relative-time-format-inl.h:43:#include "src/objects/object-macros-undef.h"
./objects/js-objects-inl.h:13:#include "src/objects/dictionary.h"
./objects/js-objects-inl.h:14:#include "src/objects/elements.h"
./objects/js-objects-inl.h:15:#include "src/objects/embedder-data-slot-inl.h"
./objects/js-objects-inl.h:16:#include "src/objects/feedback-vector.h"
./objects/js-objects-inl.h:17:#include "src/objects/field-index-inl.h"
./objects/js-objects-inl.h:18:#include "src/objects/fixed-array.h"
./objects/js-objects-inl.h:19:#include "src/objects/hash-table-inl.h"
./objects/js-objects-inl.h:20:#include "src/objects/heap-number-inl.h"
./objects/js-objects-inl.h:21:#include "src/objects/heap-object-inl.h"
./objects/js-objects-inl.h:22:#include "src/objects/heap-object.h"
./objects/js-objects-inl.h:23:#include "src/objects/instance-type-inl.h"
./objects/js-objects-inl.h:24:#include "src/objects/js-objects.h"
./objects/js-objects-inl.h:25:#include "src/objects/keys.h"
./objects/js-objects-inl.h:26:#include "src/objects/lookup-inl.h"
./objects/js-objects-inl.h:27:#include "src/objects/primitive-heap-object.h"
./objects/js-objects-inl.h:28:#include "src/objects/property-array-inl.h"
./objects/js-objects-inl.h:29:#include "src/objects/prototype-inl.h"
./objects/js-objects-inl.h:30:#include "src/objects/shared-function-info.h"
./objects/js-objects-inl.h:31:#include "src/objects/slots.h"
./objects/js-objects-inl.h:32:#include "src/objects/smi-inl.h"
./objects/js-objects-inl.h:33:#include "src/objects/string.h"
./objects/js-objects-inl.h:34:#include "src/objects/swiss-name-dictionary-inl.h"
./objects/js-objects-inl.h:37:#include "src/objects/object-macros.h"
./objects/js-objects-inl.h:41:#include "torque-generated/src/objects/js-objects-tq-inl.inc"
./objects/js-objects-inl.h:1066:#include "src/objects/object-macros-undef.h"
./objects/js-regexp-string-iterator.h:8:#include "src/objects/js-objects.h"
./objects/js-regexp-string-iterator.h:12:#include "src/objects/object-macros.h"
./objects/js-regexp-string-iterator.h:17:#include "torque-generated/src/objects/js-regexp-string-iterator-tq.inc"
./objects/js-regexp-string-iterator.h:42:#include "src/objects/object-macros-undef.h"
./objects/js-promise.h:9:#include "src/objects/js-objects.h"
./objects/js-promise.h:10:#include "src/objects/promise.h"
./objects/js-promise.h:14:#include "src/objects/object-macros.h"
./objects/js-promise.h:19:#include "torque-generated/src/objects/js-promise-tq.inc"
./objects/js-promise.h:98:#include "src/objects/object-macros-undef.h"
./objects/js-raw-json.h:11:#include "src/objects/object-macros.h"
./objects/js-raw-json.h:16:#include "torque-generated/src/objects/js-raw-json-tq.inc"
./objects/js-raw-json.h:46:#include "src/objects/object-macros-undef.h"
./objects/js-temporal-objects-inl.h:9:#include "src/objects/js-temporal-objects.h"
./objects/js-temporal-objects-inl.h:10:#include "src/objects/objects-inl.h"
[Step 31: Duration 20.40 seconds| Input tokens: 1,047,605 | Output tokens: 17,053]
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ Step 32 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'read_file' with arguments: {'file_path': '/Users/tarun/v8/v8/src/objects/map-inl.h'}                                                                                                          │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
Command: cd /Users/tarun/v8/v8/src && wc -l '/Users/tarun/v8/v8/src/objects/map-inl.h'
Command: cd /Users/tarun/v8/v8/src && cat '/Users/tarun/v8/v8/src/objects/map-inl.h'
Observations: // Copyright 2017 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef V8_OBJECTS_MAP_INL_H_
#define V8_OBJECTS_MAP_INL_H_

#include "src/heap/heap-layout-inl.h"
#include "src/heap/heap-write-barrier-inl.h"
#include "src/objects/api-callbacks-inl.h"
#include "src/objects/cell-inl.h"
#include "src/objects/dependent-code.h"
#include "src/objects/descriptor-array-inl.h"
#include "src/objects/dictionary.h"
#include "src/objects/field-type.h"
#include "src/objects/instance-type-inl.h"
#include "src/objects/js-function-inl.h"
#include "src/objects/map-updater.h"
#include "src/objects/map.h"
#include "src/objects/objects-inl.h"
#include "src/objects/property.h"
#include "src/objects/prototype-info-inl.h"
#include "src/objects/prototype-info.h"
#include "src/objects/shared-function-info-inl.h"
#include "src/objects/templates-inl.h"
#include "src/objects/transitions-inl.h"
#include "src/objects/transitions.h"

#if V8_ENABLE_WEBASSEMBLY
#include "src/wasm/wasm-objects-inl.h"
#endif  // V8_ENABLE_WEBASSEMBLY

// Has to be the last include (doesn't have include guards):
#include "src/objects/object-macros.h"

namespace v8 {
namespace internal {

#include "torque-generated/src/objects/map-tq-inl.inc"

TQ_OBJECT_CONSTRUCTORS_IMPL(Map)

ACCESSORS(Map, instance_descriptors, Tagged<DescriptorArray>,
          kInstanceDescriptorsOffset)
RELAXED_ACCESSORS(Map, instance_descriptors, Tagged<DescriptorArray>,
                  kInstanceDescriptorsOffset)
RELEASE_ACQUIRE_ACCESSORS(Map, instance_descriptors, Tagged<DescriptorArray>,
                          kInstanceDescriptorsOffset)

// A freshly allocated layout descriptor can be set on an existing map.
// We need to use release-store and acquire-load accessor pairs to ensure
// that the concurrent marking thread observes initializing stores of the
// layout descriptor.
ACCESSORS(Map, raw_transitions,
          (Tagged<UnionOf<Smi, MaybeWeak<Map>, TransitionArray>>),
          kTransitionsOrPrototypeInfoOffset)
RELEASE_ACQUIRE_ACCESSORS(
    Map, raw_transitions,
    (Tagged<UnionOf<Smi, MaybeWeak<Map>, TransitionArray>>),
    kTransitionsOrPrototypeInfoOffset)

ACCESSORS_CHECKED2(Map, prototype, Tagged<JSPrototype>, kPrototypeOffset, true,
                   IsNull(value) || IsJSProxy(value) || IsWasmObject(value) ||
                       (IsJSObject(value) &&
                        (HeapLayout::InWritableSharedSpace(value) ||
                         value->map()->is_prototype_map())))

DEF_GETTER(Map, prototype_info, Tagged<UnionOf<Smi, PrototypeInfo>>) {
  Tagged<UnionOf<Smi, PrototypeInfo>> value =
      TaggedField<UnionOf<Smi, PrototypeInfo>,
                  kTransitionsOrPrototypeInfoOffset>::load(cage_base, *this);
  DCHECK(this->is_prototype_map());
  return value;
}
RELEASE_ACQUIRE_ACCESSORS(Map, prototype_info,
                          (Tagged<UnionOf<Smi, PrototypeInfo>>),
                          kTransitionsOrPrototypeInfoOffset)

void Map::init_prototype_and_constructor_or_back_pointer(ReadOnlyRoots roots) {
  Tagged<HeapObject> null = roots.null_value();
  TaggedField<HeapObject,
              kConstructorOrBackPointerOrNativeContextOffset>::store(*this,
                                                                     null);
  TaggedField<HeapObject, kPrototypeOffset>::store(*this, null);
}

// |bit_field| fields.
// Concurrent access to |has_prototype_slot| and |has_non_instance_prototype|
// is explicitly allowlisted here. The former is never modified after the map
// is setup but it's being read by concurrent marker when pointer compression
// is enabled. The latter bit can be modified on a live objects.
BIT_FIELD_ACCESSORS(Map, relaxed_bit_field, has_non_instance_prototype,
                    Map::Bits1::HasNonInstancePrototypeBit)
BIT_FIELD_ACCESSORS(Map, relaxed_bit_field, has_prototype_slot,
                    Map::Bits1::HasPrototypeSlotBit)

// These are fine to be written as non-atomic since we don't have data races.
// However, they have to be read atomically from the background since the
// |bit_field| as a whole can mutate when using the above setters.
BIT_FIELD_ACCESSORS2(Map, relaxed_bit_field, bit_field, is_callable,
                     Map::Bits1::IsCallableBit)
BIT_FIELD_ACCESSORS2(Map, relaxed_bit_field, bit_field, has_named_interceptor,
                     Map::Bits1::HasNamedInterceptorBit)
BIT_FIELD_ACCESSORS2(Map, relaxed_bit_field, bit_field, has_indexed_interceptor,
                     Map::Bits1::HasIndexedInterceptorBit)
BIT_FIELD_ACCESSORS2(Map, relaxed_bit_field, bit_field, is_undetectable,
                     Map::Bits1::IsUndetectableBit)
BIT_FIELD_ACCESSORS2(Map, relaxed_bit_field, bit_field, is_access_check_needed,
                     Map::Bits1::IsAccessCheckNeededBit)
BIT_FIELD_ACCESSORS2(Map, relaxed_bit_field, bit_field, is_constructor,
                     Map::Bits1::IsConstructorBit)

// |bit_field2| fields.
BIT_FIELD_ACCESSORS(Map, bit_field2, new_target_is_base,
                    Map::Bits2::NewTargetIsBaseBit)
BIT_FIELD_ACCESSORS(Map, bit_field2, is_immutable_proto,
                    Map::Bits2::IsImmutablePrototypeBit)

// |bit_field3| fields.
BIT_FIELD_ACCESSORS(Map, relaxed_bit_field3, owns_descriptors,
                    Map::Bits3::OwnsDescriptorsBit)
BIT_FIELD_ACCESSORS(Map, release_acquire_bit_field3, is_deprecated,
                    Map::Bits3::IsDeprecatedBit)
BIT_FIELD_ACCESSORS(Map, relaxed_bit_field3, is_in_retained_map_list,
                    Map::Bits3::IsInRetainedMapListBit)
BIT_FIELD_ACCESSORS(Map, release_acquire_bit_field3, is_prototype_map,
                    Map::Bits3::IsPrototypeMapBit)
BIT_FIELD_ACCESSORS(Map, relaxed_bit_field3, is_migration_target,
                    Map::Bits3::IsMigrationTargetBit)
BIT_FIELD_ACCESSORS2(Map, relaxed_bit_field3, bit_field3, is_extensible,
                     Map::Bits3::IsExtensibleBit)
BIT_FIELD_ACCESSORS(Map, bit_field3, may_have_interesting_properties,
                    Map::Bits3::MayHaveInterestingPropertiesBit)
BIT_FIELD_ACCESSORS(Map, relaxed_bit_field3, construction_counter,
                    Map::Bits3::ConstructionCounterBits)

DEF_GETTER(Map, GetNamedInterceptor, Tagged<InterceptorInfo>) {
  DCHECK(has_named_interceptor());
  Tagged<FunctionTemplateInfo> info = GetFunctionTemplateInfo(cage_base);
  return Cast<InterceptorInfo>(info->GetNamedPropertyHandler(cage_base));
}

DEF_GETTER(Map, GetIndexedInterceptor, Tagged<InterceptorInfo>) {
  DCHECK(has_indexed_interceptor());
  Tagged<FunctionTemplateInfo> info = GetFunctionTemplateInfo(cage_base);
  return Cast<InterceptorInfo>(info->GetIndexedPropertyHandler(cage_base));
}

// static
bool Map::IsMostGeneralFieldType(Representation representation,
                                 Tagged<FieldType> field_type) {
  return !representation.IsHeapObject() || IsAny(field_type);
}

// static
bool Map::CanHaveFastTransitionableElementsKind(InstanceType instance_type) {
  return instance_type == JS_ARRAY_TYPE ||
         instance_type == JS_PRIMITIVE_WRAPPER_TYPE ||
         instance_type == JS_ARGUMENTS_OBJECT_TYPE;
}

bool Map::CanHaveFastTransitionableElementsKind() const {
  return CanHaveFastTransitionableElementsKind(instance_type());
}

bool Map::IsDetached(Isolate* isolate) const {
  if (is_prototype_map()) return true;
  return instance_type() == JS_OBJECT_TYPE && NumberOfOwnDescriptors() > 0 &&
         IsUndefined(GetBackPointer(), isolate);
}

// static
void Map::GeneralizeIfCanHaveTransitionableFastElementsKind(
    Isolate* isolate, InstanceType instance_type,
    Representation* representation, Handle<FieldType>* field_type) {
  if (CanHaveFastTransitionableElementsKind(instance_type)) {
    // We don't support propagation of field generalization through elements
    // kind transitions because they are inserted into the transition tree
    // before field transitions. In order to avoid complexity of handling
    // such a case we ensure that all maps with transitionable elements kinds
    // have the most general field representation and type.
    *field_type = FieldType::Any(isolate);
    *representation = Representation::Tagged();
  }
}

Handle<Map> Map::Normalize(Isolate* isolate, DirectHandle<Map> fast_map,
                           PropertyNormalizationMode mode, const char* reason) {
  const bool kUseCache = true;
  return Normalize(isolate, fast_map, fast_map->elements_kind(), {}, mode,
                   kUseCache, reason);
}

bool Map::EquivalentToForNormalization(const Tagged<Map> other,
                                       PropertyNormalizationMode mode) const {
  return EquivalentToForNormalization(other, elements_kind(), prototype(),
                                      mode);
}

bool Map::TooManyFastProperties(StoreOrigin store_origin) const {
  if (UnusedPropertyFields() != 0) return false;
  if (store_origin != StoreOrigin::kMaybeKeyed) return false;
  if (is_prototype_map()) return false;
  int limit = std::max(
      {v8_flags.fast_properties_soft_limit.value(), GetInObjectProperties()});
  int external =
      NumberOfFields(ConcurrencyMode::kSynchronous) - GetInObjectProperties();
  return external > limit;
}

Tagged<Name> Map::GetLastDescriptorName(Isolate* isolate) const {
  return instance_descriptors(isolate)->GetKey(LastAdded());
}

PropertyDetails Map::GetLastDescriptorDetails(Isolate* isolate) const {
  return instance_descriptors(isolate)->GetDetails(LastAdded());
}

InternalIndex Map::LastAdded() const {
  int number_of_own_descriptors = NumberOfOwnDescriptors();
  DCHECK_GT(number_of_own_descriptors, 0);
  return InternalIndex(number_of_own_descriptors - 1);
}

int Map::NumberOfOwnDescriptors() const {
  return Bits3::NumberOfOwnDescriptorsBits::decode(
      release_acquire_bit_field3());
}

void Map::SetNumberOfOwnDescriptors(int number) {
  DCHECK_LE(number, instance_descriptors()->number_of_descriptors());
  CHECK_LE(static_cast<unsigned>(number),
           static_cast<unsigned>(kMaxNumberOfDescriptors));
  set_release_acquire_bit_field3(
      Bits3::NumberOfOwnDescriptorsBits::update(bit_field3(), number));
}

InternalIndex::Range Map::IterateOwnDescriptors() const {
  return InternalIndex::Range(NumberOfOwnDescriptors());
}

int Map::EnumLength() const {
  return Bits3::EnumLengthBits::decode(bit_field3());
}

void Map::SetEnumLength(int length) {
  if (length != kInvalidEnumCacheSentinel) {
    DCHECK_LE(length, NumberOfOwnDescriptors());
    CHECK_LE(static_cast<unsigned>(length),
             static_cast<unsigned>(kMaxNumberOfDescriptors));
  }
  set_relaxed_bit_field3(Bits3::EnumLengthBits::update(bit_field3(), length));
}

Tagged<FixedArrayBase> Map::GetInitialElements() const {
  Tagged<FixedArrayBase> result;
  if (has_fast_elements() || has_fast_string_wrapper_elements() ||
      has_any_nonextensible_elements()) {
    result = GetReadOnlyRoots().empty_fixed_array();
  } else if (has_typed_array_or_rab_gsab_typed_array_elements()) {
    result = GetReadOnlyRoots().empty_byte_array();
  } else if (has_dictionary_elements()) {
    result = GetReadOnlyRoots().empty_slow_element_dictionary();
  } else {
    UNREACHABLE();
  }
  DCHECK(!HeapLayout::InYoungGeneration(result));
  return result;
}

VisitorId Map::visitor_id() const {
  return static_cast<VisitorId>(
      RELAXED_READ_BYTE_FIELD(*this, kVisitorIdOffset));
}

void Map::set_visitor_id(VisitorId id) {
  CHECK_LT(static_cast<unsigned>(id), 256);
  RELAXED_WRITE_BYTE_FIELD(*this, kVisitorIdOffset, static_cast<uint8_t>(id));
}

int Map::instance_size_in_words() const {
  return RELAXED_READ_BYTE_FIELD(*this, kInstanceSizeInWordsOffset);
}

void Map::set_instance_size_in_words(int value) {
  RELAXED_WRITE_BYTE_FIELD(*this, kInstanceSizeInWordsOffset,
                           static_cast<uint8_t>(value));
}

int Map::instance_size() const {
  return instance_size_in_words() << kTaggedSizeLog2;
}

void Map::set_instance_size(int size_in_bytes) {
  CHECK(IsAligned(size_in_bytes, kTaggedSize));
  DCHECK_LE(static_cast<unsigned>(size_in_bytes), JSObject::kMaxInstanceSize);
  int size_in_words = size_in_bytes >>= kTaggedSizeLog2;
  CHECK_LE(static_cast<unsigned>(size_in_words), kMaxUInt8);
  set_instance_size_in_words(size_in_words);
}

int Map::inobject_properties_start_or_constructor_function_index() const {
  // TODO(solanes, v8:7790, v8:11353): Make this and the setter non-atomic
  // when TSAN sees the map's store synchronization.
  return RELAXED_READ_BYTE_FIELD(
      *this, kInobjectPropertiesStartOrConstructorFunctionIndexOffset);
}

void Map::set_inobject_properties_start_or_constructor_function_index(
    int value) {
  CHECK_LE(static_cast<unsigned>(value), kMaxUInt8);
  RELAXED_WRITE_BYTE_FIELD(
      *this, kInobjectPropertiesStartOrConstructorFunctionIndexOffset,
      static_cast<uint8_t>(value));
}

int Map::GetInObjectPropertiesStartInWords() const {
  DCHECK(IsJSObjectMap(*this));
  return inobject_properties_start_or_constructor_function_index();
}

void Map::SetInObjectPropertiesStartInWords(int value) {
  CHECK(IsJSObjectMap(*this));
  set_inobject_properties_start_or_constructor_function_index(value);
}

bool Map::HasOutOfObjectProperties() const {
  bool ret = used_or_unused_instance_size_in_words() < JSObject::kFieldsAdded;
  DCHECK_EQ(ret, GetInObjectProperties() <
                     NumberOfFields(ConcurrencyMode::kSynchronous));
  return ret;
}

int Map::GetInObjectProperties() const {
  DCHECK(IsJSObjectMap(*this));
  return instance_size_in_words() - GetInObjectPropertiesStartInWords();
}

int Map::GetConstructorFunctionIndex() const {
#if V8_ENABLE_WEBASSEMBLY
  // We allow WasmNull here so builtins can produce error messages when
  // called from Wasm, without having to special-case WasmNull at every
  // caller of such a builtin.
  DCHECK(IsPrimitiveMap(*this) || instance_type() == WASM_NULL_TYPE);
#else
  DCHECK(IsPrimitiveMap(*this));
#endif
  return inobject_properties_start_or_constructor_function_index();
}

void Map::SetConstructorFunctionIndex(int value) {
  CHECK(IsPrimitiveMap(*this));
  set_inobject_properties_start_or_constructor_function_index(value);
}

int Map::GetInObjectPropertyOffset(int index) const {
  return (GetInObjectPropertiesStartInWords() + index) * kTaggedSize;
}

Handle<Map> Map::AddMissingTransitionsForTesting(
    Isolate* isolate, DirectHandle<Map> split_map,
    DirectHandle<DescriptorArray> descriptors) {
  return AddMissingTransitions(isolate, split_map, descriptors);
}

int Map::UnusedPropertyFields() const {
#if V8_ENABLE_WEBASSEMBLY
  DCHECK(!IsWasmObjectMap(*this));
#endif  // V8_ENABLE_WEBASSEMBLY
  int value = used_or_unused_instance_size_in_words();
  DCHECK_IMPLIES(!IsJSObjectMap(*this), value == 0);
  int unused;
  if (value >= JSObject::kFieldsAdded) {
    unused = instance_size_in_words() - value;
  } else {
    // For out of object properties "used_or_unused_instance_size_in_words"
    // byte encodes the slack in the property array.
    unused = value;
  }
  return unused;
}

int Map::UnusedInObjectProperties() const {
  // Like Map::UnusedPropertyFields(), but returns 0 for out of object
  // properties.
#if V8_ENABLE_WEBASSEMBLY
  DCHECK(!IsWasmObjectMap(*this));
#endif  // V8_ENABLE_WEBASSEMBLY
  int value = used_or_unused_instance_size_in_words();
  DCHECK_IMPLIES(!IsJSObjectMap(*this), value == 0);
  if (value >= JSObject::kFieldsAdded) {
    return instance_size_in_words() - value;
  }
  return 0;
}

int Map::used_or_unused_instance_size_in_words() const {
  return RELAXED_READ_BYTE_FIELD(*this, kUsedOrUnusedInstanceSizeInWordsOffset);
}

void Map::set_used_or_unused_instance_size_in_words(int value) {
  CHECK_LE(static_cast<unsigned>(value), 255);
  RELAXED_WRITE_BYTE_FIELD(*this, kUsedOrUnusedInstanceSizeInWordsOffset,
                           static_cast<uint8_t>(value));
}

int Map::UsedInstanceSize() const {
#if V8_ENABLE_WEBASSEMBLY
  DCHECK(!IsWasmObjectMap(*this));
#endif  // V8_ENABLE_WEBASSEMBLY
  int words = used_or_unused_instance_size_in_words();
  if (words < JSObject::kFieldsAdded) {
    // All in-object properties are used and the words is tracking the slack
    // in the property array.
    return instance_size();
  }
  return words * kTaggedSize;
}

void Map::SetInObjectUnusedPropertyFields(int value) {
  static_assert(JSObject::kFieldsAdded == JSObject::kHeaderSize / kTaggedSize);
  if (!IsJSObjectMap(*this)) {
    CHECK_EQ(0, value);
    set_used_or_unused_instance_size_in_words(0);
    return;
  }
  CHECK_LE(0, value);
  DCHECK_LE(value, GetInObjectProperties());
  int used_inobject_properties = GetInObjectProperties() - value;
  set_used_or_unused_instance_size_in_words(
      GetInObjectPropertyOffset(used_inobject_properties) / kTaggedSize);
  DCHECK_EQ(value, UnusedPropertyFields());
}

void Map::SetOutOfObjectUnusedPropertyFields(int value) {
  static_assert(JSObject::kFieldsAdded == JSObject::kHeaderSize / kTaggedSize);
  CHECK_LT(static_cast<unsigned>(value), JSObject::kFieldsAdded);
  // For out of object properties "used_instance_size_in_words" byte encodes
  // the slack in the property array.
  set_used_or_unused_instance_size_in_words(value);
  DCHECK_EQ(value, UnusedPropertyFields());
}

void Map::CopyUnusedPropertyFields(Tagged<Map> map) {
  set_used_or_unused_instance_size_in_words(
      map->used_or_unused_instance_size_in_words());
  DCHECK_EQ(UnusedPropertyFields(), map->UnusedPropertyFields());
}

void Map::CopyUnusedPropertyFieldsAdjustedForInstanceSize(Tagged<Map> map) {
  int value = map->used_or_unused_instance_size_in_words();
  if (value >= JSPrimitiveWrapper::kFieldsAdded) {
    // Unused in-object fields. Adjust the offset from the object’s start
    // so it matches the distance to the object’s end.
    value += instance_size_in_words() - map->instance_size_in_words();
  }
  set_used_or_unused_instance_size_in_words(value);
  DCHECK_EQ(UnusedPropertyFields(), map->UnusedPropertyFields());
}

void Map::AccountAddedPropertyField() {
  // Update used instance size and unused property fields number.
  static_assert(JSObject::kFieldsAdded == JSObject::kHeaderSize / kTaggedSize);
#ifdef DEBUG
  int new_unused = UnusedPropertyFields() - 1;
  if (new_unused < 0) new_unused += JSObject::kFieldsAdded;
#endif
  int value = used_or_unused_instance_size_in_words();
  if (value >= JSObject::kFieldsAdded) {
    if (value == instance_size_in_words()) {
      AccountAddedOutOfObjectPropertyField(0);
    } else {
      // The property is added in-object, so simply increment the counter.
      set_used_or_unused_instance_size_in_words(value + 1);
    }
  } else {
    AccountAddedOutOfObjectPropertyField(value);
  }
  DCHECK_EQ(new_unused, UnusedPropertyFields());
}

void Map::AccountAddedOutOfObjectPropertyField(int unused_in_property_array) {
  unused_in_property_array--;
  if (unused_in_property_array < 0) {
    unused_in_property_array += JSObject::kFieldsAdded;
  }
  CHECK_LT(static_cast<unsigned>(unused_in_property_array),
           JSObject::kFieldsAdded);
  set_used_or_unused_instance_size_in_words(unused_in_property_array);
  DCHECK_EQ(unused_in_property_array, UnusedPropertyFields());
}

#if V8_ENABLE_WEBASSEMBLY
uint8_t Map::WasmByte1() const {
  DCHECK(IsWasmObjectMap(*this));
  return inobject_properties_start_or_constructor_function_index();
}

uint8_t Map::WasmByte2() const {
  DCHECK(IsWasmObjectMap(*this));
  return used_or_unused_instance_size_in_words();
}

void Map::SetWasmByte1(uint8_t value) {
  CHECK(IsWasmObjectMap(*this));
  set_inobject_properties_start_or_constructor_function_index(value);
}

void Map::SetWasmByte2(uint8_t value) {
  CHECK(IsWasmObjectMap(*this));
  set_used_or_unused_instance_size_in_words(value);
}
#endif  // V8_ENABLE_WEBASSEMBLY

uint8_t Map::bit_field() const {
  // TODO(solanes, v8:7790, v8:11353): Make this non-atomic when TSAN sees the
  // map's store synchronization.
  return relaxed_bit_field();
}

void Map::set_bit_field(uint8_t value) {
  // TODO(solanes, v8:7790, v8:11353): Make this non-atomic when TSAN sees the
  // map's store synchronization.
  set_relaxed_bit_field(value);
}

uint8_t Map::relaxed_bit_field() const {
  return RELAXED_READ_BYTE_FIELD(*this, kBitFieldOffset);
}

void Map::set_relaxed_bit_field(uint8_t value) {
  RELAXED_WRITE_BYTE_FIELD(*this, kBitFieldOffset, value);
}

uint8_t Map::bit_field2() const { return ReadField<uint8_t>(kBitField2Offset); }

void Map::set_bit_field2(uint8_t value) {
  WriteField<uint8_t>(kBitField2Offset, value);
}

uint32_t Map::bit_field3() const {
  // TODO(solanes, v8:7790, v8:11353): Make this and the setter non-atomic
  // when TSAN sees the map's store synchronization.
  return relaxed_bit_field3();
}

void Map::set_bit_field3(uint32_t value) { set_relaxed_bit_field3(value); }

uint32_t Map::relaxed_bit_field3() const {
  return RELAXED_READ_UINT32_FIELD(*this, kBitField3Offset);
}

void Map::set_relaxed_bit_field3(uint32_t value) {
  RELAXED_WRITE_UINT32_FIELD(*this, kBitField3Offset, value);
}

uint32_t Map::release_acquire_bit_field3() const {
  return ACQUIRE_READ_UINT32_FIELD(*this, kBitField3Offset);
}

void Map::set_release_acquire_bit_field3(uint32_t value) {
  RELEASE_WRITE_UINT32_FIELD(*this, kBitField3Offset, value);
}

bool Map::is_abandoned_prototype_map() const {
  return is_prototype_map() && !owns_descriptors();
}

bool Map::should_be_fast_prototype_map() const {
  DCHECK(is_prototype_map());
  if (!has_prototype_info()) return false;
  return Cast<PrototypeInfo>(prototype_info())->should_be_fast_map();
}

bool Map::has_prototype_info() const {
  DCHECK(is_prototype_map());
  return PrototypeInfo::IsPrototypeInfoFast(prototype_info());
}

bool Map::TryGetPrototypeInfo(Tagged<PrototypeInfo>* result) const {
  DCHECK(is_prototype_map());
  Tagged<Object> maybe_proto_info = prototype_info();
  if (!PrototypeInfo::IsPrototypeInfoFast(maybe_proto_info)) return false;
  *result = Cast<PrototypeInfo>(maybe_proto_info);
  return true;
}

void Map::set_elements_kind(ElementsKind elements_kind) {
  CHECK_LT(static_cast<int>(elements_kind), kElementsKindCount);
  set_bit_field2(
      Map::Bits2::ElementsKindBits::update(bit_field2(), elements_kind));
}

ElementsKind Map::elements_kind() const {
  return Map::Bits2::ElementsKindBits::decode(bit_field2());
}

bool Map::has_fast_smi_elements() const {
  return IsSmiElementsKind(elements_kind());
}

bool Map::has_fast_object_elements() const {
  return IsObjectElementsKind(elements_kind());
}

bool Map::has_fast_smi_or_object_elements() const {
  return IsSmiOrObjectElementsKind(elements_kind());
}

bool Map::has_fast_double_elements() const {
  return IsDoubleElementsKind(elements_kind());
}

bool Map::has_fast_elements() const {
  return IsFastElementsKind(elements_kind());
}

bool Map::has_fast_packed_elements() const {
  return IsFastPackedElementsKind(elements_kind());
}

bool Map::has_sloppy_arguments_elements() const {
  return IsSloppyArgumentsElementsKind(elements_kind());
}

bool Map::has_fast_sloppy_arguments_elements() const {
  return elements_kind() == FAST_SLOPPY_ARGUMENTS_ELEMENTS;
}

bool Map::has_fast_string_wrapper_elements() const {
  return elements_kind() == FAST_STRING_WRAPPER_ELEMENTS;
}

bool Map::has_typed_array_or_rab_gsab_typed_array_elements() const {
  return IsTypedArrayOrRabGsabTypedArrayElementsKind(elements_kind());
}

bool Map::has_any_typed_array_or_wasm_array_elements() const {
  ElementsKind kind = elements_kind();
  return IsTypedArrayOrRabGsabTypedArrayElementsKind(kind) ||
#if V8_ENABLE_WEBASSEMBLY
         IsWasmArrayElementsKind(kind) ||
#endif  // V8_ENABLE_WEBASSEMBLY
         false;
}

bool Map::has_dictionary_elements() const {
  return IsDictionaryElementsKind(elements_kind());
}

bool Map::has_any_nonextensible_elements() const {
  return IsAnyNonextensibleElementsKind(elements_kind());
}

bool Map::has_nonextensible_elements() const {
  return IsNonextensibleElementsKind(elements_kind());
}

bool Map::has_sealed_elements() const {
  return IsSealedElementsKind(elements_kind());
}

bool Map::has_frozen_elements() const {
  return IsFrozenElementsKind(elements_kind());
}

bool Map::has_shared_array_elements() const {
  return IsSharedArrayElementsKind(elements_kind());
}

void Map::set_is_dictionary_map(bool value) {
  uint32_t new_bit_field3 =
      Bits3::IsDictionaryMapBit::update(bit_field3(), value);
  new_bit_field3 = Bits3::IsUnstableBit::update(new_bit_field3, value);
  set_bit_field3(new_bit_field3);
}

bool Map::is_dictionary_map() const {
  return Bits3::IsDictionaryMapBit::decode(relaxed_bit_field3());
}

void Map::mark_unstable() {
  set_release_acquire_bit_field3(
      Bits3::IsUnstableBit::update(bit_field3(), true));
}

bool Map::is_stable() const {
  return !Bits3::IsUnstableBit::decode(release_acquire_bit_field3());
}

bool Map::CanBeDeprecated() const {
  for (InternalIndex i : IterateOwnDescriptors()) {
    PropertyDetails details = instance_descriptors(kRelaxedLoad)->GetDetails(i);
    if (details.representation().MightCauseMapDeprecation()) return true;
    if (details.kind() == PropertyKind::kData &&
        details.location() == PropertyLocation::kDescriptor) {
      return true;
    }
  }
  return false;
}

void Map::NotifyLeafMapLayoutChange(Isolate* isolate) {
  if (is_stable()) {
    mark_unstable();
    DependentCode::DeoptimizeDependencyGroups(
        isolate, *this, DependentCode::kPrototypeCheckGroup);
  }
}

bool Map::CanTransition() const {
  // Only JSObject and subtypes have map transitions and back pointers.
  const InstanceType type = instance_type();
  // Shared JS objects have fixed shapes and do not transition. Their maps are
  // either in shared space or RO space.
  DCHECK_IMPLIES(InstanceTypeChecker::IsAlwaysSharedSpaceJSObject(type),
                 HeapLayout::InAnySharedSpace(*this));
  return InstanceTypeChecker::IsJSObject(type) &&
         !InstanceTypeChecker::IsAlwaysSharedSpaceJSObject(type);
}

bool IsBooleanMap(Tagged<Map> map) {
  return map == GetReadOnlyRoots().boolean_map();
}

bool IsNullOrUndefinedMap(Tagged<Map> map) {
  auto roots = GetReadOnlyRoots();
  return map == roots.null_map() || map == roots.undefined_map();
}

bool IsPrimitiveMap(Tagged<Map> map) {
  return map->instance_type() <= LAST_PRIMITIVE_HEAP_OBJECT_TYPE;
}

void Map::UpdateDescriptors(Isolate* isolate,
                            Tagged<DescriptorArray> descriptors,
                            int number_of_own_descriptors) {
  SetInstanceDescriptors(isolate, descriptors, number_of_own_descriptors);
}

void Map::InitializeDescriptors(Isolate* isolate,
                                Tagged<DescriptorArray> descriptors) {
  SetInstanceDescriptors(isolate, descriptors,
                         descriptors->number_of_descriptors());
}

void Map::clear_padding() {
  if (FIELD_SIZE(kOptionalPaddingOffset) == 0) return;
  DCHECK_EQ(4, FIELD_SIZE(kOptionalPaddingOffset));
  memset(reinterpret_cast<void*>(address() + kOptionalPaddingOffset), 0,
         FIELD_SIZE(kOptionalPaddingOffset));
}

void Map::AppendDescriptor(Isolate* isolate, Descriptor* desc) {
  Tagged<DescriptorArray> descriptors = instance_descriptors(isolate);
  int number_of_own_descriptors = NumberOfOwnDescriptors();
  DCHECK(descriptors->number_of_descriptors() == number_of_own_descriptors);
  {
    // The following two operations need to happen before the marking write
    // barrier.
    descriptors->Append(desc);
    SetNumberOfOwnDescriptors(number_of_own_descriptors + 1);
#ifndef V8_DISABLE_WRITE_BARRIERS
    WriteBarrier::ForDescriptorArray(descriptors,
                                     number_of_own_descriptors + 1);
#endif
  }
  // Properly mark the map if the {desc} is an "interesting symbol".
  if (desc->GetKey()->IsInteresting(isolate)) {
    set_may_have_interesting_properties(true);
  }
  PropertyDetails details = desc->GetDetails();
  if (details.location() == PropertyLocation::kField) {
    DCHECK_GT(UnusedPropertyFields(), 0);
    AccountAddedPropertyField();
  }

// This function does not support appending double field descriptors and
// it should never try to (otherwise, layout descriptor must be updated too).
#ifdef DEBUG
  DCHECK(details.location() != PropertyLocation::kField ||
         !details.representation().IsDouble());
#endif
}

// static
bool Map::ConcurrentIsHeapObjectWithMap(PtrComprCageBase cage_base,
                                        Tagged<Object> object,
                                        Tagged<Map> meta_map) {
  if (!IsHeapObject(object)) return false;
  Tagged<HeapObject> heap_object = Cast<HeapObject>(object);
  return heap_object->map(cage_base) == meta_map;
}

DEF_GETTER(Map, GetBackPointer, Tagged<HeapObject>) {
  Tagged<Map> back_pointer;
  if (TryGetBackPointer(cage_base, &back_pointer)) {
    return back_pointer;
  }
  return GetReadOnlyRoots().undefined_value();
}

bool Map::TryGetBackPointer(PtrComprCageBase cage_base,
                            Tagged<Map>* back_pointer) const {
  Tagged<Object> object = constructor_or_back_pointer(cage_base, kRelaxedLoad);
  // We don't expect maps from another native context in the transition tree,
  // so just compare object's map against current map's meta map.
  Tagged<Map> meta_map = map(cage_base);
  if (ConcurrentIsHeapObjectWithMap(cage_base, object, meta_map)) {
    DCHECK(IsMap(object));
    // Sanity check - only contextful maps can transition.
    DCHECK(IsNativeContext(meta_map->native_context_or_null()));
    *back_pointer = Cast<Map>(object);
    return true;
  }
  // If it was a map that'd mean that there are maps from different native
  // contexts in the transition tree.
  DCHECK(!IsMap(object));
  return false;
}

void Map::SetBackPointer(Tagged<HeapObject> value, WriteBarrierMode mode) {
  CHECK_GE(instance_type(), FIRST_JS_RECEIVER_TYPE);
  CHECK(IsMap(value));
  CHECK(IsUndefined(GetBackPointer()));
  CHECK_EQ(Cast<Map>(value)->GetConstructorRaw(),
           constructor_or_back_pointer());
  set_constructor_or_back_pointer(value, mode);
}

// static
Tagged<Map> Map::GetMapFor(ReadOnlyRoots roots, InstanceType type) {
  RootIndex map_idx = TryGetMapRootIdxFor(type).value();
  return UncheckedCast<Map>(roots.object_at(map_idx));
}

// static
Tagged<Map> Map::ElementsTransitionMap(Isolate* isolate,
                                       ConcurrencyMode cmode) {
  return TransitionsAccessor(isolate, *this, IsConcurrent(cmode))
      .SearchSpecial(ReadOnlyRoots(isolate).elements_transition_symbol());
}

ACCESSORS(Map, dependent_code, Tagged<DependentCode>, kDependentCodeOffset)
RELAXED_ACCESSORS(Map, prototype_validity_cell, (Tagged<UnionOf<Smi, Cell>>),
                  kPrototypeValidityCellOffset)
ACCESSORS_CHECKED2(Map, constructor_or_back_pointer, Tagged<Object>,
                   kConstructorOrBackPointerOrNativeContextOffset,
                   !IsContextMap(*this), IsNull(value) || !IsContextMap(*this))
RELAXED_ACCESSORS_CHECKED2(Map, constructor_or_back_pointer, Tagged<Object>,
                           kConstructorOrBackPointerOrNativeContextOffset,
                           !IsContextMap(*this),
                           IsNull(value) || !IsContextMap(*this))
ACCESSORS_CHECKED(Map, native_context, Tagged<NativeContext>,
                  kConstructorOrBackPointerOrNativeContextOffset,
                  IsContextMap(*this) || IsMapMap(*this))
ACCESSORS_CHECKED(Map, native_context_or_null, Tagged<Object>,
                  kConstructorOrBackPointerOrNativeContextOffset,
                  (IsNull(value) || IsNativeContext(value)) &&
                      (IsContextMap(*this) || IsMapMap(*this)))
// Unlike native_context_or_null() this getter allows the value to be
// equal to Smi::uninitialized_deserialization_value().
DEF_GETTER(Map, raw_native_context_or_null, Tagged<Object>) {
  Tagged<Object> value = TaggedField<
      Tagged<Object>,
      kConstructorOrBackPointerOrNativeContextOffset>::load(cage_base, *this);
  DCHECK(IsNull(value) || IsNativeContext(value) ||
         value == Smi::uninitialized_deserialization_value());
  DCHECK(IsContextMap(*this) || IsMapMap(*this));
  return value;
}
#if V8_ENABLE_WEBASSEMBLY
ACCESSORS_CHECKED(Map, wasm_type_info, Tagged<WasmTypeInfo>,
                  kConstructorOrBackPointerOrNativeContextOffset,
                  IsWasmStructMap(*this) || IsWasmArrayMap(*this) ||
                      IsWasmFuncRefMap(*this))
#endif  // V8_ENABLE_WEBASSEMBLY

bool Map::IsPrototypeValidityCellValid() const {
  Tagged<Object> validity_cell = prototype_validity_cell(kRelaxedLoad);
  if (IsSmi(validity_cell)) {
    // Smi validity cells should always be considered valid.
    DCHECK_EQ(Cast<Smi>(validity_cell).value(), Map::kPrototypeChainValid);
    return true;
  }
  Tagged<Smi> cell_value = Cast<Smi>(Cast<Cell>(validity_cell)->value());
  return cell_value == Smi::FromInt(Map::kPrototypeChainValid);
}

bool Map::BelongsToSameNativeContextAs(Tagged<Map> other_map) const {
  Tagged<Map> this_meta_map = map();
  // If the meta map is contextless (as in case of remote object's meta map)
  // we can't be sure the maps belong to the same context.
  if (this_meta_map == GetReadOnlyRoots().meta_map()) return false;
  DCHECK(IsNativeContext(this_meta_map->native_context_or_null()));
  return this_meta_map == other_map->map();
}

bool Map::BelongsToSameNativeContextAs(Tagged<Context> context) const {
  Tagged<Map> context_meta_map = context->map()->map();
  Tagged<Map> this_meta_map = map();
  DCHECK_NE(context_meta_map, GetReadOnlyRoots().meta_map());
  return this_meta_map == context_meta_map;
}

DEF_GETTER(Map, GetConstructorRaw, Tagged<Object>) {
  Tagged<Object> maybe_constructor = constructor_or_back_pointer(cage_base);
  // Follow any back pointers.
  // We don't expect maps from another native context in the transition tree,
  // so just compare object's map against current map's meta map.
  Tagged<Map> meta_map = map(cage_base);
  while (
      ConcurrentIsHeapObjectWithMap(cage_base, maybe_constructor, meta_map)) {
    DCHECK(IsMap(maybe_constructor));
    // Sanity check - only contextful maps can transition.
    DCHECK(IsNativeContext(meta_map->native_context_or_null()));
    maybe_constructor =
        Cast<Map>(maybe_constructor)->constructor_or_back_pointer(cage_base);
  }
  // If it was a map that'd mean that there are maps from different native
  // contexts in the transition tree.
  DCHECK(!IsMap(maybe_constructor));
  return maybe_constructor;
}

DEF_GETTER(Map, GetNonInstancePrototype, Tagged<Object>) {
  DCHECK(has_non_instance_prototype());
  Tagged<Object> raw_constructor = GetConstructorRaw(cage_base);
  CHECK(IsTuple2(raw_constructor));
  // Get prototype from the {constructor, non-instance_prototype} tuple.
  Tagged<Tuple2> non_instance_prototype_constructor_tuple =
      Cast<Tuple2>(raw_constructor);
  Tagged<Object> result = non_instance_prototype_constructor_tuple->value2();
  DCHECK(!IsJSReceiver(result));
  DCHECK(!IsFunctionTemplateInfo(result));
  return result;
}

DEF_GETTER(Map, GetConstructor, Tagged<Object>) {
  Tagged<Object> maybe_constructor = GetConstructorRaw(cage_base);
  if (IsTuple2(maybe_constructor)) {
    // Get constructor from the {constructor, non-instance_prototype} tuple.
    maybe_constructor = Cast<Tuple2>(maybe_constructor)->value1();
  }
  return maybe_constructor;
}

Tagged<Object> Map::TryGetConstructor(PtrComprCageBase cage_base,
                                      int max_steps) {
  Tagged<Object> maybe_constructor = constructor_or_back_pointer(cage_base);
  // Follow any back pointers.
  while (IsMap(maybe_constructor, cage_base)) {
    if (max_steps-- == 0) return Smi::FromInt(0);
    maybe_constructor =
        Cast<Map>(maybe_constructor)->constructor_or_back_pointer(cage_base);
  }
  if (IsTuple2(maybe_constructor)) {
    // Get constructor from the {constructor, non-instance_prototype} tuple.
    maybe_constructor = Cast<Tuple2>(maybe_constructor)->value1();
  }
  return maybe_constructor;
}

DEF_GETTER(Map, GetFunctionTemplateInfo, Tagged<FunctionTemplateInfo>) {
  Tagged<Object> constructor = GetConstructor(cage_base);
  if (IsJSFunction(constructor, cage_base)) {
    Tagged<SharedFunctionInfo> sfi =
        Cast<JSFunction>(constructor)->shared(cage_base);
    DCHECK(sfi->IsApiFunction());
    return sfi->api_func_data();
  }
  DCHECK(IsFunctionTemplateInfo(constructor, cage_base));
  return Cast<FunctionTemplateInfo>(constructor);
}

void Map::SetConstructor(Tagged<Object> constructor, WriteBarrierMode mode) {
  // Never overwrite a back pointer with a constructor.
  CHECK(!IsMap(constructor_or_back_pointer()));
  // Constructor field must contain {constructor, non-instance_prototype} tuple
  // for maps with non-instance prototype.
  DCHECK_EQ(has_non_instance_prototype(), IsTuple2(constructor));
  set_constructor_or_back_pointer(constructor, mode);
}

Handle<Map> Map::CopyInitialMap(Isolate* isolate, DirectHandle<Map> map) {
  return CopyInitialMap(isolate, map, map->instance_size(),
                        map->GetInObjectProperties(),
                        map->UnusedPropertyFields());
}

bool Map::IsInobjectSlackTrackingInProgress() const {
  return construction_counter() != Map::kNoSlackTracking;
}

void Map::InobjectSlackTrackingStep(Isolate* isolate) {
  DisallowGarbageCollection no_gc;
  // Slack tracking should only be performed on an initial map.
  DCHECK(IsUndefined(GetBackPointer()));
  if (!this->IsInobjectSlackTrackingInProgress()) return;
  int counter = construction_counter();
  set_construction_counter(counter - 1);
  if (counter == kSlackTrackingCounterEnd) {
    MapUpdater::CompleteInobjectSlackTracking(isolate, *this);
  }
}

int Map::SlackForArraySize(int old_size, int size_limit) {
  const int max_slack = size_limit - old_size;
  CHECK_LE(0, max_slack);
  if (old_size < 4) {
    DCHECK_LE(1, max_slack);
    return 1;
  }
  return std::min(max_slack, old_size / 4);
}

int Map::InstanceSizeFromSlack(int slack) const {
  return instance_size() - slack * kTaggedSize;
}

NEVER_READ_ONLY_SPACE_IMPL(NormalizedMapCache)

int NormalizedMapCache::GetIndex(Isolate* isolate, Tagged<Map> map,
                                 Tagged<HeapObject> prototype) {
  DisallowGarbageCollection no_gc;
  return map->Hash(isolate, prototype) % NormalizedMapCache::kEntries;
}

DEF_HEAP_OBJECT_PREDICATE(HeapObject, IsNormalizedMapCache) {
  if (!IsWeakFixedArray(obj, cage_base)) return false;
  if (Cast<WeakFixedArray>(obj)->length() != NormalizedMapCache::kEntries) {
    return false;
  }
  return true;
}

}  // namespace internal
}  // namespace v8

#include "src/objects/object-macros-undef.h"

#endif  // V8_OBJECTS_MAP_INL_H_
[Step 32: Duration 7.28 seconds| Input tokens: 1,117,189 | Output tokens: 17,284]
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ Step 33 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'ripgrep' with arguments: {'pattern': 'Deprecat|deprecat|Deprecated|Deprecate', 'options': '-n --hidden --no-ignore-vcs ./objects'}                                                            │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
Command: cd /Users/tarun/v8/v8/src && rg -n --hidden --no-ignore-vcs ./objects 'Deprecat|deprecat|Deprecated|Deprecate' | head -n 1000
Observations: rg: Deprecat|deprecat|Deprecated|Deprecate: IO error for operation on Deprecat|deprecat|Deprecated|Deprecate: No such file or directory (os error 2)
[Step 33: Duration 8.83 seconds| Input tokens: 1,191,727 | Output tokens: 17,590]
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ Step 34 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'ripgrep' with arguments: {'pattern': 'TransitionTo(Data|Accessor)|NewData|NewField|FindTransitionToAccessor|ReplaceTransitionToData', 'options': '-n --hidden --no-ignore-vcs                 │
│ /Users/tarun/v8/v8/src/objects/map.cc /Users/tarun/v8/v8/src/objects/js-objects.cc /Users/tarun/v8/v8/src/objects/transitions-inl.h /Users/tarun/v8/v8/src/objects/transitions.cc                            │
│ /Users/tarun/v8/v8/src/objects/transitions.h'}                                                                                                                                                               │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
Command: cd /Users/tarun/v8/v8/src && rg -n --hidden --no-ignore-vcs /Users/tarun/v8/v8/src/objects/map.cc /Users/tarun/v8/v8/src/objects/js-objects.cc /Users/tarun/v8/v8/src/objects/transitions-inl.h /Users/tarun/v8/v8/src/objects/transitions.cc /Users/tarun/v8/v8/src/objects/transitions.h 'TransitionTo(Data|Accessor)|NewData|NewField|FindTransitionToAccessor|ReplaceTransitionToData' | head -n 1000
Observations: rg: TransitionTo(Data|Accessor)|NewData|NewField|FindTransitionToAccessor|ReplaceTransitionToData: No such file or directory (os error 2)
[Step 34: Duration 8.38 seconds| Input tokens: 1,306,405 | Output tokens: 17,915]
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ Step 35 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'read_file' with arguments: {'file_path': '/Users/tarun/v8/v8/src/objects/transitions-inl.h'}                                                                                                  │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
Command: cd /Users/tarun/v8/v8/src && wc -l '/Users/tarun/v8/v8/src/objects/transitions-inl.h'
Command: cd /Users/tarun/v8/v8/src && cat '/Users/tarun/v8/v8/src/objects/transitions-inl.h'
Observations: // Copyright 2012 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef V8_OBJECTS_TRANSITIONS_INL_H_
#define V8_OBJECTS_TRANSITIONS_INL_H_

#include <ranges>
#include <type_traits>

#include "src/objects/fixed-array-inl.h"
#include "src/objects/maybe-object-inl.h"
#include "src/objects/slots.h"
#include "src/objects/smi.h"
#include "src/objects/transitions.h"

// Has to be the last include (doesn't have include guards):
#include "src/objects/object-macros.h"

namespace v8 {
namespace internal {

// static
Tagged<TransitionArray> TransitionsAccessor::GetTransitionArray(
    Isolate* isolate, Tagged<MaybeObject> raw_transitions) {
  DCHECK_EQ(kFullTransitionArray, GetEncoding(isolate, raw_transitions));
  USE(isolate);
  return Cast<TransitionArray>(raw_transitions.GetHeapObjectAssumeStrong());
}

// static
Tagged<TransitionArray> TransitionsAccessor::GetTransitionArray(
    Isolate* isolate, DirectHandle<Map> map) {
  Tagged<MaybeObject> raw_transitions =
      map->raw_transitions(isolate, kAcquireLoad);
  return GetTransitionArray(isolate, raw_transitions);
}

Tagged<TransitionArray> TransitionsAccessor::transitions() {
  return GetTransitionArray(isolate_, raw_transitions_);
}

bool TransitionArray::HasPrototypeTransitions() {
  return get(kPrototypeTransitionsIndex, kAcquireLoad) != Smi::zero();
}

Tagged<WeakFixedArray> TransitionArray::GetPrototypeTransitions() {
  DCHECK(HasPrototypeTransitions());  // Callers must check first.
  Tagged<Object> prototype_transitions =
      get(kPrototypeTransitionsIndex, kAcquireLoad).GetHeapObjectAssumeStrong();
  return Cast<WeakFixedArray>(prototype_transitions);
}

bool TransitionArray::HasSideStepTransitions() {
  return get(kSideStepTransitionsIndex) != Smi::zero();
}

bool TransitionsAccessor::HasSideStepTransitions() {
  if (encoding() != kFullTransitionArray) {
    return false;
  }
  return transitions()->HasSideStepTransitions();
}

Tagged<Object> TransitionsAccessor::GetSideStepTransition(
    SideStepTransition::Kind kind) {
  DCHECK(HasSideStepTransitions());
  auto res = transitions()->GetSideStepTransitions()->get(
      SideStepTransition::index_of(kind));
  if (res.IsSmi()) {
    DCHECK(res == SideStepTransition::Empty ||
           res == SideStepTransition::Unreachable);
    return res.ToSmi();
  }
  Tagged<HeapObject> target;
  if (res.GetHeapObjectIfWeak(&target)) return target;
  DCHECK(res.IsCleared());
  return SideStepTransition::Empty;
}

void TransitionsAccessor::SetSideStepTransition(SideStepTransition::Kind kind,
                                                Tagged<Object> object) {
  DCHECK(HasSideStepTransitions());
  DCHECK(object == SideStepTransition::Unreachable || IsMap(object) ||
         IsCell(object));
  DCHECK_IMPLIES(IsCell(object),
                 kind == SideStepTransition::Kind::kObjectAssignValidityCell);
  DCHECK_LT(SideStepTransition::index_of(kind), SideStepTransition::kSize);
  DCHECK_GE(SideStepTransition::index_of(kind), 0);
  transitions()->GetSideStepTransitions()->set(
      SideStepTransition::index_of(kind),
      object.IsSmi() ? object : MakeWeak(object));
}

Tagged<WeakFixedArray> TransitionArray::GetSideStepTransitions() {
  DCHECK(HasSideStepTransitions());  // Callers must check first.
  Tagged<Object> transitions =
      get(kSideStepTransitionsIndex).GetHeapObjectAssumeStrong();
  return Cast<WeakFixedArray>(transitions);
}

void TransitionArray::SetSideStepTransitions(
    Tagged<WeakFixedArray> transitions) {
  DCHECK(IsWeakFixedArray(transitions));
  WeakFixedArray::set(kSideStepTransitionsIndex, transitions);
}

HeapObjectSlot TransitionArray::GetKeySlot(int transition_number) {
  DCHECK(transition_number < number_of_transitions());
  return HeapObjectSlot(RawFieldOfElementAt(ToKeyIndex(transition_number)));
}

void TransitionArray::SetPrototypeTransitions(
    Tagged<WeakFixedArray> transitions) {
  DCHECK(IsWeakFixedArray(transitions));
  WeakFixedArray::set(kPrototypeTransitionsIndex, transitions, kReleaseStore);
}

int TransitionArray::NumberOfPrototypeTransitions(
    Tagged<WeakFixedArray> proto_transitions) {
  if (proto_transitions->length() == 0) return 0;
  Tagged<MaybeObject> raw =
      proto_transitions->get(kProtoTransitionNumberOfEntriesOffset);
  return raw.ToSmi().value();
}

Tagged<Name> TransitionArray::GetKey(int transition_number) {
  DCHECK(transition_number < number_of_transitions());
  return Cast<Name>(
      get(ToKeyIndex(transition_number)).GetHeapObjectAssumeStrong());
}

Tagged<Name> TransitionsAccessor::GetKey(int transition_number) {
  switch (encoding()) {
    case kPrototypeInfo:
    case kUninitialized:
    case kMigrationTarget:
      UNREACHABLE();
      return Tagged<Name>();
    case kWeakRef: {
      Tagged<Map> map = Cast<Map>(raw_transitions_.GetHeapObjectAssumeWeak());
      return GetSimpleTransitionKey(map);
    }
    case kFullTransitionArray:
      return transitions()->GetKey(transition_number);
  }
  UNREACHABLE();
}

void TransitionArray::SetKey(int transition_number, Tagged<Name> key) {
  DCHECK(transition_number < number_of_transitions());
  WeakFixedArray::set(ToKeyIndex(transition_number), key);
}

HeapObjectSlot TransitionArray::GetTargetSlot(int transition_number) {
  DCHECK(transition_number < number_of_transitions());
  return HeapObjectSlot(RawFieldOfElementAt(ToTargetIndex(transition_number)));
}

// static
PropertyDetails TransitionsAccessor::GetTargetDetails(Tagged<Name> name,
                                                      Tagged<Map> target) {
  DCHECK(!IsSpecialTransition(GetReadOnlyRoots(), name));
  InternalIndex descriptor = target->LastAdded();
  Tagged<DescriptorArray> descriptors =
      target->instance_descriptors(kRelaxedLoad);
  // Transitions are allowed only for the last added property.
  DCHECK(descriptors->GetKey(descriptor)->Equals(name));
  return descriptors->GetDetails(descriptor);
}

PropertyDetails TransitionsAccessor::GetSimpleTargetDetails(
    Tagged<Map> transition) {
  return transition->GetLastDescriptorDetails(isolate_);
}

// static
Tagged<Name> TransitionsAccessor::GetSimpleTransitionKey(
    Tagged<Map> transition) {
  InternalIndex descriptor = transition->LastAdded();
  return transition->instance_descriptors()->GetKey(descriptor);
}

// static
Tagged<Map> TransitionsAccessor::GetTargetFromRaw(Tagged<MaybeObject> raw) {
  return Cast<Map>(raw.GetHeapObjectAssumeWeak());
}

Tagged<MaybeObject> TransitionArray::GetRawTarget(int transition_number) {
  DCHECK(transition_number < number_of_transitions());
  return get(ToTargetIndex(transition_number));
}

Tagged<Map> TransitionArray::GetTarget(int transition_number) {
  Tagged<MaybeObject> raw = GetRawTarget(transition_number);
  return TransitionsAccessor::GetTargetFromRaw(raw);
}

Tagged<Map> TransitionsAccessor::GetTarget(int transition_number) {
  switch (encoding()) {
    case kPrototypeInfo:
    case kUninitialized:
    case kMigrationTarget:
      UNREACHABLE();
      return Map();
    case kWeakRef:
      return Cast<Map>(raw_transitions_.GetHeapObjectAssumeWeak());
    case kFullTransitionArray:
      return transitions()->GetTarget(transition_number);
  }
  UNREACHABLE();
}

void TransitionArray::SetRawTarget(int transition_number,
                                   Tagged<MaybeObject> value) {
  DCHECK(transition_number < number_of_transitions());
  DCHECK(value.IsWeakOrCleared());
  DCHECK(value.IsCleared() || IsMap(value.GetHeapObjectAssumeWeak()));
  DCHECK(!value.IsCleared());
  WeakFixedArray::set(ToTargetIndex(transition_number), value);
}

bool TransitionArray::GetTargetIfExists(int transition_number, Isolate* isolate,
                                        Tagged<Map>* target) {
  Tagged<MaybeObject> raw = GetRawTarget(transition_number);
  Tagged<HeapObject> heap_object;
  // If the raw target is a Smi, then this TransitionArray is in the process of
  // being deserialized, and doesn't yet have an initialized entry for this
  // transition.
  if (raw.IsSmi()) {
    DCHECK(isolate->has_active_deserializer());
    DCHECK_EQ(raw.ToSmi(), Smi::uninitialized_deserialization_value());
    return false;
  }
  if (raw.GetHeapObjectIfStrong(&heap_object) &&
      IsUndefined(heap_object, isolate)) {
    return false;
  }
  *target = TransitionsAccessor::GetTargetFromRaw(raw);
  return true;
}

int TransitionArray::SearchNameForTesting(Tagged<Name> name,
                                          int* out_insertion_index) {
  return SearchName(name, out_insertion_index);
}

Tagged<Map> TransitionArray::SearchAndGetTargetForTesting(
    PropertyKind kind, Tagged<Name> name, PropertyAttributes attributes) {
  return SearchAndGetTarget(kind, name, attributes);
}

int TransitionArray::SearchSpecial(Tagged<Symbol> symbol,
                                   bool concurrent_search,
                                   int* out_insertion_index) {
  return SearchName(symbol, concurrent_search, out_insertion_index);
}

int TransitionArray::SearchName(Tagged<Name> name, bool concurrent_search,
                                int* out_insertion_index) {
  DCHECK(IsUniqueName(name));
  SLOW_DCHECK_IMPLIES(!concurrent_search, IsSortedNoDuplicates());

  if (number_of_transitions() == 0) {
    if (out_insertion_index != nullptr) {
      *out_insertion_index = 0;
    }
    return kNotFound;
  }

  // Do linear search for small arrays, and for searches in the background
  // thread.
  const int kMaxElementsForLinearSearch = 8;
  if (number_of_transitions() <= kMaxElementsForLinearSearch ||
      concurrent_search) {
    return LinearSearchName(name, out_insertion_index);
  }

  return BinarySearchName(name, out_insertion_index);
}

int TransitionArray::BinarySearchName(Tagged<Name> name,
                                      int* out_insertion_index) {
  int end = number_of_transitions();
  uint32_t hash = name->hash();

  // Find the first index whose key's hash is greater-than-or-equal-to the
  // search hash.
  int i = *std::ranges::lower_bound(std::views::iota(0, end), hash,
                                    std::less<>(), |&](int i) {
                                      Tagged<Name> entry = GetKey(i);
                                      return entry->hash();
                                    });

  // There may have been hash collisions, so search for the name from the first
  // index until the first non-matching hash.
  for (; i < end; ++i) {
    Tagged<Name> entry = GetKey(i);
    if (entry == name) {
      return i;
    }
    uint32_t entry_hash = entry->hash();
    if (entry_hash != hash) {
      if (out_insertion_index != nullptr) {
        *out_insertion_index = i + (entry_hash > hash ? 0 : 1);
      }
      return kNotFound;
    }
  }

  if (out_insertion_index != nullptr) {
    *out_insertion_index = end;
  }
  return kNotFound;
}

int TransitionArray::LinearSearchName(Tagged<Name> name,
                                      int* out_insertion_index) {
  int len = number_of_transitions();
  if (out_insertion_index != nullptr) {
    uint32_t hash = name->hash();
    for (int i = 0; i < len; i++) {
      Tagged<Name> entry = GetKey(i);
      if (entry == name) return i;
      if (entry->hash() > hash) {
        *out_insertion_index = i;
        return kNotFound;
      }
    }
    *out_insertion_index = len;
    return kNotFound;
  } else {
    for (int i = 0; i < len; i++) {
      if (GetKey(i) == name) return i;
    }
    return kNotFound;
  }
}

TransitionsAccessor::TransitionsAccessor(Isolate* isolate, Tagged<Map> map,
                                         bool concurrent_access)
    : isolate_(isolate),
      map_(map),
      raw_transitions_(map->raw_transitions(isolate_, kAcquireLoad)),
      encoding_(GetEncoding(isolate_, raw_transitions_)),
      concurrent_access_(concurrent_access) {
  DCHECK_IMPLIES(encoding_ == kMigrationTarget, map_->is_deprecated());
}

int TransitionsAccessor::Capacity() { return transitions()->Capacity(); }

// static
TransitionsAccessor::Encoding TransitionsAccessor::GetEncoding(
    Isolate* isolate, Tagged<MaybeObject> raw_transitions) {
  Tagged<HeapObject> heap_object;
  if (raw_transitions.IsSmi() || raw_transitions.IsCleared()) {
    return kUninitialized;
  } else if (raw_transitions.IsWeak()) {
    return kWeakRef;
  } else if (raw_transitions.GetHeapObjectIfStrong(isolate, &heap_object)) {
    if (IsTransitionArray(heap_object)) {
      return kFullTransitionArray;
    } else if (IsPrototypeInfo(heap_object)) {
      return kPrototypeInfo;
    } else {
      DCHECK(IsMap(heap_object));
      return kMigrationTarget;
    }
  } else {
    UNREACHABLE();
  }
}

// static
TransitionsAccessor::Encoding TransitionsAccessor::GetEncoding(
    Isolate* isolate, Tagged<TransitionArray> array) {
  DCHECK_EQ(GetEncoding(isolate, Tagged<MaybeObject>(array)),
            kFullTransitionArray);
  return kFullTransitionArray;
}

// static
TransitionsAccessor::Encoding TransitionsAccessor::GetEncoding(
    Isolate* isolate, DirectHandle<Map> map) {
  Tagged<MaybeObject> raw_transitions =
      map->raw_transitions(isolate, kAcquireLoad);
  return GetEncoding(isolate, raw_transitions);
}

// static
MaybeHandle<Map> TransitionsAccessor::SearchTransition(
    Isolate* isolate, DirectHandle<Map> map, Tagged<Name> name,
    PropertyKind kind, PropertyAttributes attributes) {
  Tagged<Map> result = TransitionsAccessor(isolate, *map)
                           .SearchTransition(name, kind, attributes);
  if (result.is_null()) return MaybeHandle<Map>();
  return MaybeHandle<Map>(result, isolate);
}

// static
MaybeHandle<Map> TransitionsAccessor::SearchSpecial(Isolate* isolate,
                                                    DirectHandle<Map> map,
                                                    Tagged<Symbol> name) {
  Tagged<Map> result = TransitionsAccessor(isolate, *map).SearchSpecial(name);
  if (result.is_null()) return {};
  return MaybeHandle<Map>(result, isolate);
}

int TransitionArray::number_of_transitions() const {
  if (length() < kFirstIndex) return 0;
  return get(kTransitionLengthIndex).ToSmi().value();
}

int TransitionArray::CompareKeys(Tagged<Name> key1, uint32_t hash1,
                                 PropertyKind kind1,
                                 PropertyAttributes attributes1,
                                 Tagged<Name> key2, uint32_t hash2,
                                 PropertyKind kind2,
                                 PropertyAttributes attributes2) {
  int cmp = CompareNames(key1, hash1, key2, hash2);
  if (cmp != 0) return cmp;

  return CompareDetails(kind1, attributes1, kind2, attributes2);
}

int TransitionArray::CompareNames(Tagged<Name> key1, uint32_t hash1,
                                  Tagged<Name> key2, uint32_t hash2) {
  if (key1 != key2) {
    // In case of hash collisions key1 is always "less" than key2.
    return hash1 <= hash2 ? -1 : 1;
  }

  return 0;
}

int TransitionArray::CompareDetails(PropertyKind kind1,
                                    PropertyAttributes attributes1,
                                    PropertyKind kind2,
                                    PropertyAttributes attributes2) {
  if (kind1 != kind2) {
    return static_cast<int>(kind1) < static_cast<int>(kind2) ? -1 : 1;
  }

  if (attributes1 != attributes2) {
    return static_cast<int>(attributes1) < static_cast<int>(attributes2) ? -1
                                                                         : 1;
  }

  return 0;
}

void TransitionArray::Set(int transition_number, Tagged<Name> key,
                          Tagged<MaybeObject> target) {
  WeakFixedArray::set(ToKeyIndex(transition_number), key);
  WeakFixedArray::set(ToTargetIndex(transition_number), target);
}

int TransitionArray::Capacity() {
  if (length() <= kFirstIndex) return 0;
  return (length() - kFirstIndex) / kEntrySize;
}

void TransitionArray::SetNumberOfTransitions(int number_of_transitions) {
  DCHECK(number_of_transitions <= Capacity());
  WeakFixedArray::set(kTransitionLengthIndex,
                      Smi::FromInt(number_of_transitions));
}

template <typename Char>
bool TransitionsAccessor::IsExpectedTransition(
    Tagged<Name> transition_name, Tagged<Map> transition_target,
    base::Vector<const Char> key_chars) {
  if (transition_target->NumberOfOwnDescriptors() == 0) return false;
  PropertyDetails details = GetSimpleTargetDetails(transition_target);
  if (details.location() != PropertyLocation::kField) return false;
  DCHECK_EQ(PropertyKind::kData, details.kind());
  if (details.attributes() != NONE) return false;
  if (!IsString(transition_name)) return false;
  if (!Cast<String>(transition_name)->IsEqualTo(key_chars)) return false;
  return true;
}

template <typename Char>
std::pair<Handle<String>, Handle<Map>> TransitionsAccessor::ExpectedTransition(
    base::Vector<const Char> key_chars) {
  DisallowGarbageCollection no_gc;
  switch (encoding()) {
    case kPrototypeInfo:
    case kUninitialized:
    case kMigrationTarget:
      return {Handle<String>::null(), Handle<Map>::null()};
    case kWeakRef: {
      Tagged<Map> target =
          Cast<Map>(raw_transitions_.GetHeapObjectAssumeWeak());
      Tagged<Name> name = GetSimpleTransitionKey(target);
      if (IsExpectedTransition(name, target, key_chars)) {
        return {handle(Cast<String>(name), isolate_), handle(target, isolate_)};
      }
      return {Handle<String>::null(), Handle<Map>::null()};
    }
    case kFullTransitionArray: {
      Tagged<TransitionArray> array =
          Cast<TransitionArray>(raw_transitions_.GetHeapObjectAssumeStrong());
      int entries = array->number_of_transitions();
      // Do linear search for small entries.
      const int kMaxEntriesForLinearSearch = 8;
      if (entries > kMaxEntriesForLinearSearch)
        return {Handle<String>::null(), Handle<Map>::null()};
      for (int i = entries - 1; i >= 0; i--) {
        Tagged<Name> name = array->GetKey(i);
        Tagged<Map> target = array->GetTarget(i);
        if (IsExpectedTransition(name, target, key_chars)) {
          return {handle(Cast<String>(name), isolate_),
                  handle(GetTarget(i), isolate_)};
        }
      }
      return {Handle<String>::null(), Handle<Map>::null()};
    }
  }
  UNREACHABLE();
}

template <typename Callback, typename ProtoCallback, typename SideStepCallback,
          bool with_key>
void TransitionsAccessor::ForEachTransitionWithKey(
    DisallowGarbageCollection* no_gc, Callback callback,
    ProtoCallback proto_transition_callback,
    SideStepCallback side_step_transition_callback) {
  switch (encoding()) {
    case kPrototypeInfo:
    case kUninitialized:
    case kMigrationTarget:
      return;
    case kWeakRef: {
      Tagged<Map> target =
          Cast<Map>(raw_transitions_.GetHeapObjectAssumeWeak());
      if constexpr (with_key) {
        callback(GetSimpleTransitionKey(target), target);
      } else {
        callback(target);
      }
      return;
    }
    case kFullTransitionArray: {
      base::SharedMutexGuardIf<base::kShared> scope(
          isolate_->full_transition_array_access(), concurrent_access_);
      Tagged<TransitionArray> transition_array = transitions();
      int num_transitions = transition_array->number_of_transitions();
      ReadOnlyRoots roots(isolate_);
      for (int i = 0; i < num_transitions; ++i) {
        if constexpr (with_key) {
          Tagged<Name> key = transition_array->GetKey(i);
          callback(key, GetTarget(i));
        } else {
          callback(GetTarget(i));
        }
      }
      if constexpr (!std::is_same<ProtoCallback, std::nullptr_t>::value) {
        if (transitions()->HasPrototypeTransitions()) {
          Tagged<WeakFixedArray> cache =
              transitions()->GetPrototypeTransitions();
          int length = TransitionArray::NumberOfPrototypeTransitions(cache);
          for (int i = 0; i < length; i++) {
            Tagged<MaybeObject> target =
                cache->get(TransitionArray::kProtoTransitionHeaderSize + i);
            Tagged<HeapObject> heap_object;
            if (target.GetHeapObjectIfWeak(&heap_object)) {
              proto_transition_callback(Cast<Map>(heap_object));
            }
          }
        }
      }
      if constexpr (!std::is_same<SideStepCallback, std::nullptr_t>::value) {
        if (transitions()->HasSideStepTransitions()) {
          Tagged<WeakFixedArray> cache =
              transitions()->GetSideStepTransitions();
          for (uint32_t i = SideStepTransition::kFirstMapIdx;
               i <= SideStepTransition::kLastMapIdx; i++) {
            Tagged<MaybeObject> target = cache->get(i);
            if (target.IsWeak() || target == SideStepTransition::Unreachable) {
              if constexpr (with_key) {
                side_step_transition_callback(
                    static_cast<SideStepTransition::Kind>(i),
                    target.GetHeapObjectOrSmi());
              } else {
                side_step_transition_callback(target.GetHeapObjectOrSmi());
              }
            }
          }
        }
      }

      return;
    }
  }
  UNREACHABLE();
}

}  // namespace internal
}  // namespace v8

#include "src/objects/object-macros-undef.h"

#endif  // V8_OBJECTS_TRANSITIONS_INL_H_
[Step 35: Duration 17.25 seconds| Input tokens: 1,376,593 | Output tokens: 18,531]
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ Step 36 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'ripgrep' with arguments: {'pattern':                                                                                                                                                          │
│ 'TransitionTo(Data|Accessor)|ReplaceTransitionTo(Data|Accessor)|New(Data|Field)|FindTransitionTo(Field|Accessor)|Deprecat|Deprecated|SideStep|TransitionArray', 'options': '-n ./objects/transitions.*       │
│ ./objects/map.* ./objects/js-objects.* ./objects/transitions-inl.h'}                                                                                                                                         │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
Command: cd /Users/tarun/v8/v8/src && rg -n ./objects/transitions.* ./objects/map.* ./objects/js-objects.* ./objects/transitions-inl.h 'TransitionTo(Data|Accessor)|ReplaceTransitionTo(Data|Accessor)|New(Data|Field)|FindTransitionTo(Field|Accessor)|Deprecat|Deprecated|SideStep|TransitionArray' | head -n 1000
Observations: rg: TransitionTo(Data|Accessor)|ReplaceTransitionTo(Data|Accessor)|New(Data|Field)|FindTransitionTo(Field|Accessor)|Deprecat|Deprecated|SideStep|TransitionArray: No such file or directory (os 
error 2)
[Step 36: Duration 22.18 seconds| Input tokens: 1,460,327 | Output tokens: 19,065]
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ Step 37 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'ripgrep' with arguments: {'pattern':                                                                                                                                                          │
│ 'FindTransitionTo(Field|Accessor)|New(DataProperty|Field)|DeprecateTransition|DeprecateTransitions|TransitionArray|ReplaceTransitionTo(DataProperty|DataField)|Diverge|split transition|\\+1 map'}           │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
Command: cd /Users/tarun/v8/v8/src && rg 'FindTransitionTo(Field|Accessor)|New(DataProperty|Field)|DeprecateTransition|DeprecateTransitions|TransitionArray|ReplaceTransitionTo(DataProperty|DataField)|Diverge|split transition|\+1 map' | head -n 10000
Observations: snapshot/embedded/platform-embedded-file-writer-win.cc:    // Diverges from other platforms due to compile error
heap/factory.h:  Handle<TransitionArray> NewTransitionArray(int number_of_transitions,
roots/static-roots.h:  static constexpr Tagged_t kTransitionArrayMap = 0xb79;
roots/static-roots.h:    StaticReadOnlyRoot::kTransitionArrayMap,
roots/roots.h:  V(Map, transition_array_map, TransitionArrayMap)                             \
objects/map.tq:      case (Map | TransitionArray): {
objects/map.tq:  transitions_or_prototype_info: Map|Weak<Map>|TransitionArray|PrototypeInfo|
objects/objects.cc:      return Cast<TransitionArray>(*this)->number_of_transitions() > 1;
objects/objects.cc:      Cast<TransitionArray>(*this)->Sort();
json/json-parser.cc:        TransitionsAccessor(isolate_, *map_).FindTransitionToField(key);
heap/mark-compact.cc:  Tagged<TransitionArray> array;
heap/mark-compact.cc:              CompactTransitionArray(parent, array, descriptors);
heap/mark-compact.cc:bool MarkCompactCollector::TransitionArrayNeedsCompaction(
heap/mark-compact.cc:    Tagged<TransitionArray> transitions, int num_transitions) {
heap/mark-compact.cc:bool MarkCompactCollector::CompactTransitionArray(
heap/mark-compact.cc:    Tagged<Map> map, Tagged<TransitionArray> transitions,
heap/mark-compact.cc:  if (!TransitionArrayNeedsCompaction(transitions, num_transitions)) {
heap/mark-compact.cc:  // TransitionArray::Insert() will need to deal with the case that a transition
heap/mark-compact.cc:    static_assert(TransitionArray::kEntryKeyIndex == 0);
heap/mark-compact.cc:    DCHECK_EQ(TransitionArray::ToKeyIndex(old_capacity_in_entries),
heap/mark-compact.cc:    int new_capacity = TransitionArray::ToKeyIndex(transition_index);
common/globals.h:class TransitionArray;
objects/map-inl.h:          (Tagged<UnionOf<Smi, MaybeWeak<Map>, TransitionArray>>),
objects/map-inl.h:    (Tagged<UnionOf<Smi, MaybeWeak<Map>, TransitionArray>>),
objects/transitions.h:  friend class TransitionArray;
objects/transitions.h:// turn points to its target map), or a TransitionArray for several target maps
objects/transitions.h:// sense: both single transitions stored inline and TransitionArray fields are
objects/transitions.h:  MaybeHandle<Map> FindTransitionToField(DirectHandle<String> name);
objects/transitions.h:    kFullTransitionArray,
objects/transitions.h:  inline Tagged<TransitionArray> transitions();
objects/transitions.h:  friend class TransitionArray;
objects/transitions.h:                                     Tagged<TransitionArray> array);
objects/transitions.h:  static inline Tagged<TransitionArray> GetTransitionArray(
objects/transitions.h:  static inline Tagged<TransitionArray> GetTransitionArray(
objects/transitions.h:  static void EnsureHasFullTransitionArray(Isolate* isolate,
objects/transitions.h:      Tagged<UnionOf<TransitionArray, MaybeWeak<Map>>> new_transitions);
objects/transitions.h:      DirectHandle<TransitionArray> new_transitions);
objects/transitions.h:// TransitionArrays are fixed arrays used to hold map transitions for property,
objects/transitions.h:// The TransitionArray class exposes a very low-level interface. Most clients
objects/transitions.h:// TransitionArrays have the following format:
objects/transitions.h:class TransitionArray : public WeakFixedArray {
objects/transitions.h:  DECL_PRINTER(TransitionArray)
objects/transitions.h:  DECL_VERIFIER(TransitionArray)
objects/transitions.h:      Isolate* isolate, DirectHandle<TransitionArray> transitions);
objects/transitions.h:  static bool CompactPrototypeTransitionArray(Isolate* isolate,
objects/transitions.h:  static Handle<WeakFixedArray> GrowPrototypeTransitionArray(
objects/instance-type.h:  V(_, TransitionArrayMap, transition_array_map, TransitionArray)              \
objects/object-list-macros.h:  V(TransitionArray)                            \
objects/map.h:  V(TransitionArray)                  \
objects/map.h:  // the TransitionArray::ReplaceTransitions() wrapper instead!
objects/map.h:                 Tagged<UnionOf<Smi, MaybeWeak<Map>, TransitionArray>>)
objects/map.h:      raw_transitions, Tagged<UnionOf<Smi, MaybeWeak<Map>, TransitionArray>>)
objects/map.h:  void DeprecateTransitionTree(Isolate* isolate);
objects/map.cc:      return kVisitTransitionArray;
objects/map.cc:void Map::DeprecateTransitionTree(Isolate* isolate) {
objects/map.cc:      &no_gc, |&](Tagged<Map> map) { map->DeprecateTransitionTree(isolate); },
objects/map.cc:          map->DeprecateTransitionTree(isolate);
objects/map.cc:      initial_map->DeprecateTransitionTree(isolate);
objects/transitions.cc:    case kFullTransitionArray:
objects/transitions.cc:    // If the flag requires a full TransitionArray, allocate one.
objects/transitions.cc:    DirectHandle<TransitionArray> result =
objects/transitions.cc:        isolate->factory()->NewTransitionArray(1, 0);
objects/transitions.cc:    DCHECK_EQ(kFullTransitionArray, GetEncoding(isolate, *result));
objects/transitions.cc:    // Otherwise allocate a full TransitionArray with slack for a new entry.
objects/transitions.cc:    DirectHandle<TransitionArray> result =
objects/transitions.cc:        isolate->factory()->NewTransitionArray(1, 1);
objects/transitions.cc:      DCHECK_EQ(kFullTransitionArray, GetEncoding(isolate, *result));
objects/transitions.cc:    DCHECK_EQ(kFullTransitionArray, GetEncoding(isolate, *result));
objects/transitions.cc:  // At this point, we know that the map has a full TransitionArray.
objects/transitions.cc:  DCHECK_EQ(kFullTransitionArray, encoding);
objects/transitions.cc:    Tagged<TransitionArray> array = GetTransitionArray(isolate, map);
objects/transitions.cc:  // We're gonna need a bigger TransitionArray.
objects/transitions.cc:  DirectHandle<TransitionArray> result = isolate->factory()->NewTransitionArray(
objects/transitions.cc:  Tagged<TransitionArray> array = GetTransitionArray(isolate, map);
objects/transitions.cc:    case kFullTransitionArray: {
objects/transitions.cc:  if (encoding() != kFullTransitionArray) return {};
objects/transitions.cc:MaybeHandle<Map> TransitionsAccessor::FindTransitionToField(
objects/transitions.cc:    case kFullTransitionArray: {
objects/transitions.cc:  if (GetEncoding(isolate, raw_transitions) == kFullTransitionArray) {
objects/transitions.cc:    return GetTransitionArray(isolate, raw_transitions)
objects/transitions.cc:bool TransitionArray::CompactPrototypeTransitionArray(
objects/transitions.cc:Handle<WeakFixedArray> TransitionArray::GrowPrototypeTransitionArray(
objects/transitions.cc:  const int header = TransitionArray::kProtoTransitionHeaderSize;
objects/transitions.cc:  int transitions = TransitionArray::NumberOfPrototypeTransitions(*cache) + 1;
objects/transitions.cc:          TransitionArray::CompactPrototypeTransitionArray(isolate, *cache);
objects/transitions.cc:      if (capacity == TransitionArray::kMaxCachedPrototypeTransitions)
objects/transitions.cc:      cache = TransitionArray::GrowPrototypeTransitionArray(
objects/transitions.cc:  int last = TransitionArray::NumberOfPrototypeTransitions(*cache);
objects/transitions.cc:    TransitionArray::SetNumberOfPrototypeTransitions(*cache, last + 1);
objects/transitions.cc:  int length = TransitionArray::NumberOfPrototypeTransitions(cache);
objects/transitions.cc:        cache->get(TransitionArray::kProtoTransitionHeaderSize + i);
objects/transitions.cc:  if (GetEncoding(isolate, raw_transitions) != kFullTransitionArray) {
objects/transitions.cc:  Tagged<TransitionArray> transition_array =
objects/transitions.cc:      GetTransitionArray(isolate, raw_transitions);
objects/transitions.cc:void TransitionArray::SetNumberOfPrototypeTransitions(
objects/transitions.cc:    case kFullTransitionArray:
objects/transitions.cc:    case kFullTransitionArray:
objects/transitions.cc:    Tagged<UnionOf<TransitionArray, MaybeWeak<Map>>> new_transitions) {
objects/transitions.cc:  if (GetEncoding(isolate, map) == kFullTransitionArray) {
objects/transitions.cc:    DCHECK_NE(GetTransitionArray(isolate, map),
objects/transitions.cc:    DirectHandle<TransitionArray> new_transitions) {
objects/transitions.cc:  EnsureHasFullTransitionArray(isolate, map);
objects/transitions.cc:  GetTransitionArray(isolate, map->raw_transitions(isolate, kAcquireLoad))
objects/transitions.cc:void TransitionsAccessor::EnsureHasFullTransitionArray(Isolate* isolate,
objects/transitions.cc:  if (encoding == kFullTransitionArray) return;
objects/transitions.cc:  DirectHandle<TransitionArray> result =
objects/transitions.cc:      isolate->factory()->NewTransitionArray(nof);
objects/transitions.cc:      case kFullTransitionArray: {
objects/transitions.cc:        Tagged<TransitionArray> transitions =
objects/transitions.cc:            Cast<TransitionArray>(raw_transitions.GetHeapObjectAssumeStrong());
objects/transitions.cc:              TransitionArray::NumberOfPrototypeTransitions(proto_trans);
objects/transitions.cc:            int index = TransitionArray::kProtoTransitionHeaderSize + i;
objects/transitions.cc:  Tagged<TransitionArray> old_transitions = GetTransitionArray(isolate, map);
objects/transitions.cc:  DCHECK_EQ(kFullTransitionArray, GetEncoding(isolate, old_transitions));
objects/transitions.cc:  Tagged<TransitionArray> new_transitions = Cast<TransitionArray>(transitions);
objects/transitions.cc:        DCHECK_NE(TransitionArray::kNotFound, new_target_index);
objects/transitions.cc:int TransitionArray::SearchDetails(int transition, PropertyKind kind,
objects/transitions.cc:Tagged<Map> TransitionArray::SearchDetailsAndGetTarget(
objects/transitions.cc:int TransitionArray::Search(PropertyKind kind, Tagged<Name> name,
objects/transitions.cc:Tagged<Map> TransitionArray::SearchAndGetTarget(PropertyKind kind,
objects/transitions.cc:void TransitionArray::ForEachTransitionTo(
objects/transitions.cc:void TransitionArray::Sort() {
objects/transitions.cc:  EnsureHasFullTransitionArray(isolate, map);
objects/transitions.cc:  Tagged<TransitionArray> transitions =
objects/transitions.cc:      GetTransitionArray(isolate, map->raw_transitions());
objects/transitions.cc:  TransitionArray::CreateSideStepTransitions(
objects/transitions.cc:void TransitionArray::CreateSideStepTransitions(
objects/transitions.cc:    Isolate* isolate, DirectHandle<TransitionArray> transitions) {
objects/map-updater.cc:    maybe_transition.ToHandleChecked()->DeprecateTransitionTree(isolate_);
objects/transitions-inl.h:Tagged<TransitionArray> TransitionsAccessor::GetTransitionArray(
objects/transitions-inl.h:  DCHECK_EQ(kFullTransitionArray, GetEncoding(isolate, raw_transitions));
objects/transitions-inl.h:  return Cast<TransitionArray>(raw_transitions.GetHeapObjectAssumeStrong());
objects/transitions-inl.h:Tagged<TransitionArray> TransitionsAccessor::GetTransitionArray(
objects/transitions-inl.h:  return GetTransitionArray(isolate, raw_transitions);
objects/transitions-inl.h:Tagged<TransitionArray> TransitionsAccessor::transitions() {
objects/transitions-inl.h:  return GetTransitionArray(isolate_, raw_transitions_);
objects/transitions-inl.h:bool TransitionArray::HasPrototypeTransitions() {
objects/transitions-inl.h:Tagged<WeakFixedArray> TransitionArray::GetPrototypeTransitions() {
objects/transitions-inl.h:bool TransitionArray::HasSideStepTransitions() {
objects/transitions-inl.h:  if (encoding() != kFullTransitionArray) {
objects/transitions-inl.h:Tagged<WeakFixedArray> TransitionArray::GetSideStepTransitions() {
objects/transitions-inl.h:void TransitionArray::SetSideStepTransitions(
objects/transitions-inl.h:HeapObjectSlot TransitionArray::GetKeySlot(int transition_number) {
objects/transitions-inl.h:void TransitionArray::SetPrototypeTransitions(
objects/transitions-inl.h:int TransitionArray::NumberOfPrototypeTransitions(
objects/transitions-inl.h:Tagged<Name> TransitionArray::GetKey(int transition_number) {
objects/transitions-inl.h:    case kFullTransitionArray:
objects/transitions-inl.h:void TransitionArray::SetKey(int transition_number, Tagged<Name> key) {
objects/transitions-inl.h:HeapObjectSlot TransitionArray::GetTargetSlot(int transition_number) {
objects/transitions-inl.h:Tagged<MaybeObject> TransitionArray::GetRawTarget(int transition_number) {
objects/transitions-inl.h:Tagged<Map> TransitionArray::GetTarget(int transition_number) {
objects/transitions-inl.h:    case kFullTransitionArray:
objects/transitions-inl.h:void TransitionArray::SetRawTarget(int transition_number,
objects/transitions-inl.h:bool TransitionArray::GetTargetIfExists(int transition_number, Isolate* isolate,
objects/transitions-inl.h:  // If the raw target is a Smi, then this TransitionArray is in the process of
objects/transitions-inl.h:int TransitionArray::SearchNameForTesting(Tagged<Name> name,
objects/transitions-inl.h:Tagged<Map> TransitionArray::SearchAndGetTargetForTesting(
objects/transitions-inl.h:int TransitionArray::SearchSpecial(Tagged<Symbol> symbol,
objects/transitions-inl.h:int TransitionArray::SearchName(Tagged<Name> name, bool concurrent_search,
objects/transitions-inl.h:int TransitionArray::BinarySearchName(Tagged<Name> name,
objects/transitions-inl.h:int TransitionArray::LinearSearchName(Tagged<Name> name,
objects/transitions-inl.h:    if (IsTransitionArray(heap_object)) {
objects/transitions-inl.h:      return kFullTransitionArray;
objects/transitions-inl.h:    Isolate* isolate, Tagged<TransitionArray> array) {
objects/transitions-inl.h:            kFullTransitionArray);
objects/transitions-inl.h:  return kFullTransitionArray;
objects/transitions-inl.h:int TransitionArray::number_of_transitions() const {
objects/transitions-inl.h:int TransitionArray::CompareKeys(Tagged<Name> key1, uint32_t hash1,
objects/transitions-inl.h:int TransitionArray::CompareNames(Tagged<Name> key1, uint32_t hash1,
objects/transitions-inl.h:int TransitionArray::CompareDetails(PropertyKind kind1,
objects/transitions-inl.h:void TransitionArray::Set(int transition_number, Tagged<Name> key,
objects/transitions-inl.h:int TransitionArray::Capacity() {
objects/transitions-inl.h:void TransitionArray::SetNumberOfTransitions(int number_of_transitions) {
objects/transitions-inl.h:    case kFullTransitionArray: {
objects/transitions-inl.h:      Tagged<TransitionArray> array =
objects/transitions-inl.h:          Cast<TransitionArray>(raw_transitions_.GetHeapObjectAssumeStrong());
objects/transitions-inl.h:    case kFullTransitionArray: {
objects/transitions-inl.h:      Tagged<TransitionArray> transition_array = transitions();
objects/transitions-inl.h:          int length = TransitionArray::NumberOfPrototypeTransitions(cache);
objects/transitions-inl.h:                cache->get(TransitionArray::kProtoTransitionHeaderSize + i);
objects/value-serializer.cc:                              .FindTransitionToField(Cast<String>(key))
codegen/code-stub-assembler.h:  // Implements TransitionArray::SearchName() - searches for first transition
codegen/code-stub-assembler.h:                        TNode<TransitionArray> transitions, Label* if_found,
diagnostics/objects-debug.cc:      Cast<TransitionArray>(*this)->TransitionArrayVerify(isolate);
diagnostics/objects-debug.cc:void TransitionArray::TransitionArrayVerify(Isolate* isolate) {
diagnostics/objects-debug.cc:    int length = TransitionArray::NumberOfPrototypeTransitions(proto_trans);
diagnostics/objects-debug.cc:      int index = TransitionArray::kProtoTransitionHeaderSize + i;
diagnostics/objects-debug.cc:bool TransitionArray::IsSortedNoDuplicates() {
diagnostics/objects-debug.cc:  if (encoding() != kFullTransitionArray) return true;
diagnostics/objects-printer.cc:      Cast<TransitionArray>(*this)->TransitionArrayPrint(os);
diagnostics/objects-printer.cc:void TransitionArray::TransitionArrayPrint(std::ostream& os) {
diagnostics/objects-printer.cc:  PrintHeader(os, "TransitionArray");
diagnostics/objects-printer.cc:      os << "<TransitionArray|" << Cast<TransitionArray>(*this)->length()
diagnostics/objects-printer.cc:void TransitionArray::PrintInternal(std::ostream& os) {
diagnostics/objects-printer.cc:          TransitionArray::kProtoTransitionHeaderSize + i);
diagnostics/objects-printer.cc:    case kFullTransitionArray:
codegen/code-stub-assembler.cc:    TNode<TransitionArray> array) {
codegen/code-stub-assembler.cc:CodeStubAssembler::LoadArrayElement<TransitionArray, IntPtrT>(
codegen/code-stub-assembler.cc:    TNode<TransitionArray>, int, TNode<IntPtrT>, int);
codegen/code-stub-assembler.cc:// TODO(leszeks): Remove once both TransitionArray and DescriptorArray are
codegen/code-stub-assembler.cc:struct OffsetOfArrayDataStart<TransitionArray> {
codegen/code-stub-assembler.cc:  static constexpr int value = OFFSET_OF_DATA_START(TransitionArray);
codegen/code-stub-assembler.cc:constexpr int CodeStubAssembler::MaxNumberOfEntries<TransitionArray>() {
codegen/code-stub-assembler.cc:TNode<Uint32T> CodeStubAssembler::NumberOfEntries<TransitionArray>(
codegen/code-stub-assembler.cc:    TNode<TransitionArray> transitions) {
codegen/code-stub-assembler.cc:      Uint32LessThan(length, Uint32Constant(TransitionArray::kFirstIndex)),
codegen/code-stub-assembler.cc:            IntPtrConstant(TransitionArray::kTransitionLengthIndex)));
codegen/code-stub-assembler.cc:template TNode<IntPtrT> CodeStubAssembler::ToKeyIndex<TransitionArray>(
codegen/code-stub-assembler.cc:TNode<Uint32T> CodeStubAssembler::GetSortedKeyIndex<TransitionArray>(
codegen/code-stub-assembler.cc:    TNode<TransitionArray> transitions, TNode<Uint32T> transition_number) {
codegen/code-stub-assembler.cc:  static_assert(std::is_base_of_v<TransitionArray, Array> ||
codegen/code-stub-assembler.cc:                "T must be a descendant of DescriptorArray or TransitionArray");
codegen/code-stub-assembler.cc:template TNode<Name> CodeStubAssembler::GetKey<TransitionArray>(
codegen/code-stub-assembler.cc:    TNode<TransitionArray>, TNode<Uint32T>);
codegen/code-stub-assembler.cc:                                         TNode<TransitionArray> transitions,
codegen/code-stub-assembler.cc:  Comment("TransitionArrayLookup");
codegen/code-stub-assembler.cc:      NumberOfEntries<TransitionArray>(transitions);
codegen/code-stub-assembler.cc:  Lookup<TransitionArray>(unique_name, transitions, number_of_valid_transitions,
heap/mark-compact-inl.h:void MarkCompactCollector::AddTransitionArray(Tagged<TransitionArray> array) {
heap/weak-object-worklists.h:class TransitionArray;
heap/weak-object-worklists.h:  F(Tagged<TransitionArray>, transition_arrays, TransitionArrays)             \
heap/heap-visitor.h:  V(TransitionArray)                  \
heap/heap-visitor.h:  V(TransitionArray)                                      \
heap/weak-object-worklists.cc:void WeakObjects::UpdateTransitionArrays(
heap/weak-object-worklists.cc:    WeakObjectWorklist<Tagged<TransitionArray>>& transition_arrays) {
heap/marking-visitor.h:  V8_INLINE size_t VisitTransitionArray(Tagged<Map> map,
heap/marking-visitor.h:                                        Tagged<TransitionArray> object,
heap/mark-compact.h:  V8_INLINE void AddTransitionArray(Tagged<TransitionArray> array);
heap/mark-compact.h:  bool CompactTransitionArray(Tagged<Map> map,
heap/mark-compact.h:                              Tagged<TransitionArray> transitions,
heap/mark-compact.h:  bool TransitionArrayNeedsCompaction(Tagged<TransitionArray> transitions,
heap/factory.cc:Handle<TransitionArray> Factory::NewTransitionArray(int number_of_transitions,
heap/factory.cc:  int capacity = TransitionArray::LengthFor(number_of_transitions + slack);
heap/factory.cc:  Handle<TransitionArray> array = Cast<TransitionArray>(
heap/factory.cc:    heap->mark_compact_collector()->AddTransitionArray(*array);
heap/factory.cc:  array->WeakFixedArray::set(TransitionArray::kPrototypeTransitionsIndex,
heap/factory.cc:  array->WeakFixedArray::set(TransitionArray::kSideStepTransitionsIndex,
heap/factory.cc:  array->WeakFixedArray::set(TransitionArray::kTransitionLengthIndex,
heap/factory.cc:  DCHECK(!IsTransitionArray(*src));  // Compacted by GC, this code doesn't work
heap/factory.cc:  DCHECK(!IsTransitionArray(*src));  // Compacted by GC, this code doesn't work
heap/heap.h:  V(TransitionArray)                  \
heap/marking-visitor-inl.h:         !(IsMap(host) || IsTransitionArray(host) || IsDescriptorArray(host));
heap/marking-visitor-inl.h:    // TransitionArray and DescriptorArray.
heap/marking-visitor-inl.h:size_t MarkingVisitorBase<ConcreteVisitor>::VisitTransitionArray(
heap/marking-visitor-inl.h:    Tagged<Map> map, Tagged<TransitionArray> array,
heap/marking-visitor-inl.h:  return Base::VisitTransitionArray(map, array, maybe_object_size);
execution/isolate.h:  // Shared mutex for allowing thread-safe concurrent reads of TransitionArrays
execution/isolate.h:  // of kind kFullTransitionArray.
ic/keyed-store-generic.cc:    GotoIfNot(IsTransitionArrayMap(maybe_handler_map), slow);
ic/keyed-store-generic.cc:    TNode<TransitionArray> transitions =
ic/keyed-store-generic.cc:      // See TransitionArray::CompareDetails() for details.
ic/keyed-store-generic.cc:      const int kKeyToTargetOffset = (TransitionArray::kEntryTargetIndex -
ic/keyed-store-generic.cc:                                      TransitionArray::kEntryKeyIndex) *
profiler/heap-snapshot-generator.h:  void ExtractTransitionArrayReferences(HeapEntry* entry,
profiler/heap-snapshot-generator.h:                                        Tagged<TransitionArray> transitions);
profiler/heap-snapshot-generator.cc:      InstanceTypeChecker::IsTransitionArray(type) ||
profiler/heap-snapshot-generator.cc:  } else if (IsTransitionArray(obj)) {
profiler/heap-snapshot-generator.cc:    ExtractTransitionArrayReferences(entry, Cast<TransitionArray>(obj));
profiler/heap-snapshot-generator.cc:    if (IsTransitionArray(raw_transitions_or_prototype_info)) {
profiler/heap-snapshot-generator.cc:      Tagged<TransitionArray> transitions =
profiler/heap-snapshot-generator.cc:          Cast<TransitionArray>(raw_transitions_or_prototype_info);
profiler/heap-snapshot-generator.cc:void V8HeapExplorer::ExtractTransitionArrayReferences(
profiler/heap-snapshot-generator.cc:    HeapEntry* entry, Tagged<TransitionArray> transitions) {
builtins/base.tq:extern class TransitionArray extends WeakFixedArray;
builtins/builtins-object-gen.cc:      GotoIfNot(IsTransitionArrayMap(LoadMap(maybe_transitions2)),
builtins/builtins-object-gen.cc:          IntPtrConstant(TransitionArray::kSideStepTransitionsIndex)));
[Step 37: Duration 26.39 seconds| Input tokens: 1,530,576 | Output tokens: 20,158]
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ Step 38 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'read_file' with arguments: {'file_path': '/Users/tarun/v8/v8/src/objects/transitions-inl.h'}                                                                                                  │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
Command: cd /Users/tarun/v8/v8/src && wc -l '/Users/tarun/v8/v8/src/objects/transitions-inl.h'
Command: cd /Users/tarun/v8/v8/src && cat '/Users/tarun/v8/v8/src/objects/transitions-inl.h'
Observations: // Copyright 2012 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef V8_OBJECTS_TRANSITIONS_INL_H_
#define V8_OBJECTS_TRANSITIONS_INL_H_

#include <ranges>
#include <type_traits>

#include "src/objects/fixed-array-inl.h"
#include "src/objects/maybe-object-inl.h"
#include "src/objects/slots.h"
#include "src/objects/smi.h"
#include "src/objects/transitions.h"

// Has to be the last include (doesn't have include guards):
#include "src/objects/object-macros.h"

namespace v8 {
namespace internal {

// static
Tagged<TransitionArray> TransitionsAccessor::GetTransitionArray(
    Isolate* isolate, Tagged<MaybeObject> raw_transitions) {
  DCHECK_EQ(kFullTransitionArray, GetEncoding(isolate, raw_transitions));
  USE(isolate);
  return Cast<TransitionArray>(raw_transitions.GetHeapObjectAssumeStrong());
}

// static
Tagged<TransitionArray> TransitionsAccessor::GetTransitionArray(
    Isolate* isolate, DirectHandle<Map> map) {
  Tagged<MaybeObject> raw_transitions =
      map->raw_transitions(isolate, kAcquireLoad);
  return GetTransitionArray(isolate, raw_transitions);
}

Tagged<TransitionArray> TransitionsAccessor::transitions() {
  return GetTransitionArray(isolate_, raw_transitions_);
}

bool TransitionArray::HasPrototypeTransitions() {
  return get(kPrototypeTransitionsIndex, kAcquireLoad) != Smi::zero();
}

Tagged<WeakFixedArray> TransitionArray::GetPrototypeTransitions() {
  DCHECK(HasPrototypeTransitions());  // Callers must check first.
  Tagged<Object> prototype_transitions =
      get(kPrototypeTransitionsIndex, kAcquireLoad).GetHeapObjectAssumeStrong();
  return Cast<WeakFixedArray>(prototype_transitions);
}

bool TransitionArray::HasSideStepTransitions() {
  return get(kSideStepTransitionsIndex) != Smi::zero();
}

bool TransitionsAccessor::HasSideStepTransitions() {
  if (encoding() != kFullTransitionArray) {
    return false;
  }
  return transitions()->HasSideStepTransitions();
}

Tagged<Object> TransitionsAccessor::GetSideStepTransition(
    SideStepTransition::Kind kind) {
  DCHECK(HasSideStepTransitions());
  auto res = transitions()->GetSideStepTransitions()->get(
      SideStepTransition::index_of(kind));
  if (res.IsSmi()) {
    DCHECK(res == SideStepTransition::Empty ||
           res == SideStepTransition::Unreachable);
    return res.ToSmi();
  }
  Tagged<HeapObject> target;
  if (res.GetHeapObjectIfWeak(&target)) return target;
  DCHECK(res.IsCleared());
  return SideStepTransition::Empty;
}

void TransitionsAccessor::SetSideStepTransition(SideStepTransition::Kind kind,
                                                Tagged<Object> object) {
  DCHECK(HasSideStepTransitions());
  DCHECK(object == SideStepTransition::Unreachable || IsMap(object) ||
         IsCell(object));
  DCHECK_IMPLIES(IsCell(object),
                 kind == SideStepTransition::Kind::kObjectAssignValidityCell);
  DCHECK_LT(SideStepTransition::index_of(kind), SideStepTransition::kSize);
  DCHECK_GE(SideStepTransition::index_of(kind), 0);
  transitions()->GetSideStepTransitions()->set(
      SideStepTransition::index_of(kind),
      object.IsSmi() ? object : MakeWeak(object));
}

Tagged<WeakFixedArray> TransitionArray::GetSideStepTransitions() {
  DCHECK(HasSideStepTransitions());  // Callers must check first.
  Tagged<Object> transitions =
      get(kSideStepTransitionsIndex).GetHeapObjectAssumeStrong();
  return Cast<WeakFixedArray>(transitions);
}

void TransitionArray::SetSideStepTransitions(
    Tagged<WeakFixedArray> transitions) {
  DCHECK(IsWeakFixedArray(transitions));
  WeakFixedArray::set(kSideStepTransitionsIndex, transitions);
}

HeapObjectSlot TransitionArray::GetKeySlot(int transition_number) {
  DCHECK(transition_number < number_of_transitions());
  return HeapObjectSlot(RawFieldOfElementAt(ToKeyIndex(transition_number)));
}

void TransitionArray::SetPrototypeTransitions(
    Tagged<WeakFixedArray> transitions) {
  DCHECK(IsWeakFixedArray(transitions));
  WeakFixedArray::set(kPrototypeTransitionsIndex, transitions, kReleaseStore);
}

int TransitionArray::NumberOfPrototypeTransitions(
    Tagged<WeakFixedArray> proto_transitions) {
  if (proto_transitions->length() == 0) return 0;
  Tagged<MaybeObject> raw =
      proto_transitions->get(kProtoTransitionNumberOfEntriesOffset);
  return raw.ToSmi().value();
}

Tagged<Name> TransitionArray::GetKey(int transition_number) {
  DCHECK(transition_number < number_of_transitions());
  return Cast<Name>(
      get(ToKeyIndex(transition_number)).GetHeapObjectAssumeStrong());
}

Tagged<Name> TransitionsAccessor::GetKey(int transition_number) {
  switch (encoding()) {
    case kPrototypeInfo:
    case kUninitialized:
    case kMigrationTarget:
      UNREACHABLE();
      return Tagged<Name>();
    case kWeakRef: {
      Tagged<Map> map = Cast<Map>(raw_transitions_.GetHeapObjectAssumeWeak());
      return GetSimpleTransitionKey(map);
    }
    case kFullTransitionArray:
      return transitions()->GetKey(transition_number);
  }
  UNREACHABLE();
}

void TransitionArray::SetKey(int transition_number, Tagged<Name> key) {
  DCHECK(transition_number < number_of_transitions());
  WeakFixedArray::set(ToKeyIndex(transition_number), key);
}

HeapObjectSlot TransitionArray::GetTargetSlot(int transition_number) {
  DCHECK(transition_number < number_of_transitions());
  return HeapObjectSlot(RawFieldOfElementAt(ToTargetIndex(transition_number)));
}

// static
PropertyDetails TransitionsAccessor::GetTargetDetails(Tagged<Name> name,
                                                      Tagged<Map> target) {
  DCHECK(!IsSpecialTransition(GetReadOnlyRoots(), name));
  InternalIndex descriptor = target->LastAdded();
  Tagged<DescriptorArray> descriptors =
      target->instance_descriptors(kRelaxedLoad);
  // Transitions are allowed only for the last added property.
  DCHECK(descriptors->GetKey(descriptor)->Equals(name));
  return descriptors->GetDetails(descriptor);
}

PropertyDetails TransitionsAccessor::GetSimpleTargetDetails(
    Tagged<Map> transition) {
  return transition->GetLastDescriptorDetails(isolate_);
}

// static
Tagged<Name> TransitionsAccessor::GetSimpleTransitionKey(
    Tagged<Map> transition) {
  InternalIndex descriptor = transition->LastAdded();
  return transition->instance_descriptors()->GetKey(descriptor);
}

// static
Tagged<Map> TransitionsAccessor::GetTargetFromRaw(Tagged<MaybeObject> raw) {
  return Cast<Map>(raw.GetHeapObjectAssumeWeak());
}

Tagged<MaybeObject> TransitionArray::GetRawTarget(int transition_number) {
  DCHECK(transition_number < number_of_transitions());
  return get(ToTargetIndex(transition_number));
}

Tagged<Map> TransitionArray::GetTarget(int transition_number) {
  Tagged<MaybeObject> raw = GetRawTarget(transition_number);
  return TransitionsAccessor::GetTargetFromRaw(raw);
}

Tagged<Map> TransitionsAccessor::GetTarget(int transition_number) {
  switch (encoding()) {
    case kPrototypeInfo:
    case kUninitialized:
    case kMigrationTarget:
      UNREACHABLE();
      return Map();
    case kWeakRef:
      return Cast<Map>(raw_transitions_.GetHeapObjectAssumeWeak());
    case kFullTransitionArray:
      return transitions()->GetTarget(transition_number);
  }
  UNREACHABLE();
}

void TransitionArray::SetRawTarget(int transition_number,
                                   Tagged<MaybeObject> value) {
  DCHECK(transition_number < number_of_transitions());
  DCHECK(value.IsWeakOrCleared());
  DCHECK(value.IsCleared() || IsMap(value.GetHeapObjectAssumeWeak()));
  DCHECK(!value.IsCleared());
  WeakFixedArray::set(ToTargetIndex(transition_number), value);
}

bool TransitionArray::GetTargetIfExists(int transition_number, Isolate* isolate,
                                        Tagged<Map>* target) {
  Tagged<MaybeObject> raw = GetRawTarget(transition_number);
  Tagged<HeapObject> heap_object;
  // If the raw target is a Smi, then this TransitionArray is in the process of
  // being deserialized, and doesn't yet have an initialized entry for this
  // transition.
  if (raw.IsSmi()) {
    DCHECK(isolate->has_active_deserializer());
    DCHECK_EQ(raw.ToSmi(), Smi::uninitialized_deserialization_value());
    return false;
  }
  if (raw.GetHeapObjectIfStrong(&heap_object) &&
      IsUndefined(heap_object, isolate)) {
    return false;
  }
  *target = TransitionsAccessor::GetTargetFromRaw(raw);
  return true;
}

int TransitionArray::SearchNameForTesting(Tagged<Name> name,
                                          int* out_insertion_index) {
  return SearchName(name, out_insertion_index);
}

Tagged<Map> TransitionArray::SearchAndGetTargetForTesting(
    PropertyKind kind, Tagged<Name> name, PropertyAttributes attributes) {
  return SearchAndGetTarget(kind, name, attributes);
}

int TransitionArray::SearchSpecial(Tagged<Symbol> symbol,
                                   bool concurrent_search,
                                   int* out_insertion_index) {
  return SearchName(symbol, concurrent_search, out_insertion_index);
}

int TransitionArray::SearchName(Tagged<Name> name, bool concurrent_search,
                                int* out_insertion_index) {
  DCHECK(IsUniqueName(name));
  SLOW_DCHECK_IMPLIES(!concurrent_search, IsSortedNoDuplicates());

  if (number_of_transitions() == 0) {
    if (out_insertion_index != nullptr) {
      *out_insertion_index = 0;
    }
    return kNotFound;
  }

  // Do linear search for small arrays, and for searches in the background
  // thread.
  const int kMaxElementsForLinearSearch = 8;
  if (number_of_transitions() <= kMaxElementsForLinearSearch ||
      concurrent_search) {
    return LinearSearchName(name, out_insertion_index);
  }

  return BinarySearchName(name, out_insertion_index);
}

int TransitionArray::BinarySearchName(Tagged<Name> name,
                                      int* out_insertion_index) {
  int end = number_of_transitions();
  uint32_t hash = name->hash();

  // Find the first index whose key's hash is greater-than-or-equal-to the
  // search hash.
  int i = *std::ranges::lower_bound(std::views::iota(0, end), hash,
                                    std::less<>(), |&](int i) {
                                      Tagged<Name> entry = GetKey(i);
                                      return entry->hash();
                                    });

  // There may have been hash collisions, so search for the name from the first
  // index until the first non-matching hash.
  for (; i < end; ++i) {
    Tagged<Name> entry = GetKey(i);
    if (entry == name) {
      return i;
    }
    uint32_t entry_hash = entry->hash();
    if (entry_hash != hash) {
      if (out_insertion_index != nullptr) {
        *out_insertion_index = i + (entry_hash > hash ? 0 : 1);
      }
      return kNotFound;
    }
  }

  if (out_insertion_index != nullptr) {
    *out_insertion_index = end;
  }
  return kNotFound;
}

int TransitionArray::LinearSearchName(Tagged<Name> name,
                                      int* out_insertion_index) {
  int len = number_of_transitions();
  if (out_insertion_index != nullptr) {
    uint32_t hash = name->hash();
    for (int i = 0; i < len; i++) {
      Tagged<Name> entry = GetKey(i);
      if (entry == name) return i;
      if (entry->hash() > hash) {
        *out_insertion_index = i;
        return kNotFound;
      }
    }
    *out_insertion_index = len;
    return kNotFound;
  } else {
    for (int i = 0; i < len; i++) {
      if (GetKey(i) == name) return i;
    }
    return kNotFound;
  }
}

TransitionsAccessor::TransitionsAccessor(Isolate* isolate, Tagged<Map> map,
                                         bool concurrent_access)
    : isolate_(isolate),
      map_(map),
      raw_transitions_(map->raw_transitions(isolate_, kAcquireLoad)),
      encoding_(GetEncoding(isolate_, raw_transitions_)),
      concurrent_access_(concurrent_access) {
  DCHECK_IMPLIES(encoding_ == kMigrationTarget, map_->is_deprecated());
}

int TransitionsAccessor::Capacity() { return transitions()->Capacity(); }

// static
TransitionsAccessor::Encoding TransitionsAccessor::GetEncoding(
    Isolate* isolate, Tagged<MaybeObject> raw_transitions) {
  Tagged<HeapObject> heap_object;
  if (raw_transitions.IsSmi() || raw_transitions.IsCleared()) {
    return kUninitialized;
  } else if (raw_transitions.IsWeak()) {
    return kWeakRef;
  } else if (raw_transitions.GetHeapObjectIfStrong(isolate, &heap_object)) {
    if (IsTransitionArray(heap_object)) {
      return kFullTransitionArray;
    } else if (IsPrototypeInfo(heap_object)) {
      return kPrototypeInfo;
    } else {
      DCHECK(IsMap(heap_object));
      return kMigrationTarget;
    }
  } else {
    UNREACHABLE();
  }
}

// static
TransitionsAccessor::Encoding TransitionsAccessor::GetEncoding(
    Isolate* isolate, Tagged<TransitionArray> array) {
  DCHECK_EQ(GetEncoding(isolate, Tagged<MaybeObject>(array)),
            kFullTransitionArray);
  return kFullTransitionArray;
}

// static
TransitionsAccessor::Encoding TransitionsAccessor::GetEncoding(
    Isolate* isolate, DirectHandle<Map> map) {
  Tagged<MaybeObject> raw_transitions =
      map->raw_transitions(isolate, kAcquireLoad);
  return GetEncoding(isolate, raw_transitions);
}

// static
MaybeHandle<Map> TransitionsAccessor::SearchTransition(
    Isolate* isolate, DirectHandle<Map> map, Tagged<Name> name,
    PropertyKind kind, PropertyAttributes attributes) {
  Tagged<Map> result = TransitionsAccessor(isolate, *map)
                           .SearchTransition(name, kind, attributes);
  if (result.is_null()) return MaybeHandle<Map>();
  return MaybeHandle<Map>(result, isolate);
}

// static
MaybeHandle<Map> TransitionsAccessor::SearchSpecial(Isolate* isolate,
                                                    DirectHandle<Map> map,
                                                    Tagged<Symbol> name) {
  Tagged<Map> result = TransitionsAccessor(isolate, *map).SearchSpecial(name);
  if (result.is_null()) return {};
  return MaybeHandle<Map>(result, isolate);
}

int TransitionArray::number_of_transitions() const {
  if (length() < kFirstIndex) return 0;
  return get(kTransitionLengthIndex).ToSmi().value();
}

int TransitionArray::CompareKeys(Tagged<Name> key1, uint32_t hash1,
                                 PropertyKind kind1,
                                 PropertyAttributes attributes1,
                                 Tagged<Name> key2, uint32_t hash2,
                                 PropertyKind kind2,
                                 PropertyAttributes attributes2) {
  int cmp = CompareNames(key1, hash1, key2, hash2);
  if (cmp != 0) return cmp;

  return CompareDetails(kind1, attributes1, kind2, attributes2);
}

int TransitionArray::CompareNames(Tagged<Name> key1, uint32_t hash1,
                                  Tagged<Name> key2, uint32_t hash2) {
  if (key1 != key2) {
    // In case of hash collisions key1 is always "less" than key2.
    return hash1 <= hash2 ? -1 : 1;
  }

  return 0;
}

int TransitionArray::CompareDetails(PropertyKind kind1,
                                    PropertyAttributes attributes1,
                                    PropertyKind kind2,
                                    PropertyAttributes attributes2) {
  if (kind1 != kind2) {
    return static_cast<int>(kind1) < static_cast<int>(kind2) ? -1 : 1;
  }

  if (attributes1 != attributes2) {
    return static_cast<int>(attributes1) < static_cast<int>(attributes2) ? -1
                                                                         : 1;
  }

  return 0;
}

void TransitionArray::Set(int transition_number, Tagged<Name> key,
                          Tagged<MaybeObject> target) {
  WeakFixedArray::set(ToKeyIndex(transition_number), key);
  WeakFixedArray::set(ToTargetIndex(transition_number), target);
}

int TransitionArray::Capacity() {
  if (length() <= kFirstIndex) return 0;
  return (length() - kFirstIndex) / kEntrySize;
}

void TransitionArray::SetNumberOfTransitions(int number_of_transitions) {
  DCHECK(number_of_transitions <= Capacity());
  WeakFixedArray::set(kTransitionLengthIndex,
                      Smi::FromInt(number_of_transitions));
}

template <typename Char>
bool TransitionsAccessor::IsExpectedTransition(
    Tagged<Name> transition_name, Tagged<Map> transition_target,
    base::Vector<const Char> key_chars) {
  if (transition_target->NumberOfOwnDescriptors() == 0) return false;
  PropertyDetails details = GetSimpleTargetDetails(transition_target);
  if (details.location() != PropertyLocation::kField) return false;
  DCHECK_EQ(PropertyKind::kData, details.kind());
  if (details.attributes() != NONE) return false;
  if (!IsString(transition_name)) return false;
  if (!Cast<String>(transition_name)->IsEqualTo(key_chars)) return false;
  return true;
}

template <typename Char>
std::pair<Handle<String>, Handle<Map>> TransitionsAccessor::ExpectedTransition(
    base::Vector<const Char> key_chars) {
  DisallowGarbageCollection no_gc;
  switch (encoding()) {
    case kPrototypeInfo:
    case kUninitialized:
    case kMigrationTarget:
      return {Handle<String>::null(), Handle<Map>::null()};
    case kWeakRef: {
      Tagged<Map> target =
          Cast<Map>(raw_transitions_.GetHeapObjectAssumeWeak());
      Tagged<Name> name = GetSimpleTransitionKey(target);
      if (IsExpectedTransition(name, target, key_chars)) {
        return {handle(Cast<String>(name), isolate_), handle(target, isolate_)};
      }
      return {Handle<String>::null(), Handle<Map>::null()};
    }
    case kFullTransitionArray: {
      Tagged<TransitionArray> array =
          Cast<TransitionArray>(raw_transitions_.GetHeapObjectAssumeStrong());
      int entries = array->number_of_transitions();
      // Do linear search for small entries.
      const int kMaxEntriesForLinearSearch = 8;
      if (entries > kMaxEntriesForLinearSearch)
        return {Handle<String>::null(), Handle<Map>::null()};
      for (int i = entries - 1; i >= 0; i--) {
        Tagged<Name> name = array->GetKey(i);
        Tagged<Map> target = array->GetTarget(i);
        if (IsExpectedTransition(name, target, key_chars)) {
          return {handle(Cast<String>(name), isolate_),
                  handle(GetTarget(i), isolate_)};
        }
      }
      return {Handle<String>::null(), Handle<Map>::null()};
    }
  }
  UNREACHABLE();
}

template <typename Callback, typename ProtoCallback, typename SideStepCallback,
          bool with_key>
void TransitionsAccessor::ForEachTransitionWithKey(
    DisallowGarbageCollection* no_gc, Callback callback,
    ProtoCallback proto_transition_callback,
    SideStepCallback side_step_transition_callback) {
  switch (encoding()) {
    case kPrototypeInfo:
    case kUninitialized:
    case kMigrationTarget:
      return;
    case kWeakRef: {
      Tagged<Map> target =
          Cast<Map>(raw_transitions_.GetHeapObjectAssumeWeak());
      if constexpr (with_key) {
        callback(GetSimpleTransitionKey(target), target);
      } else {
        callback(target);
      }
      return;
    }
    case kFullTransitionArray: {
      base::SharedMutexGuardIf<base::kShared> scope(
          isolate_->full_transition_array_access(), concurrent_access_);
      Tagged<TransitionArray> transition_array = transitions();
      int num_transitions = transition_array->number_of_transitions();
      ReadOnlyRoots roots(isolate_);
      for (int i = 0; i < num_transitions; ++i) {
        if constexpr (with_key) {
          Tagged<Name> key = transition_array->GetKey(i);
          callback(key, GetTarget(i));
        } else {
          callback(GetTarget(i));
        }
      }
      if constexpr (!std::is_same<ProtoCallback, std::nullptr_t>::value) {
        if (transitions()->HasPrototypeTransitions()) {
          Tagged<WeakFixedArray> cache =
              transitions()->GetPrototypeTransitions();
          int length = TransitionArray::NumberOfPrototypeTransitions(cache);
          for (int i = 0; i < length; i++) {
            Tagged<MaybeObject> target =
                cache->get(TransitionArray::kProtoTransitionHeaderSize + i);
            Tagged<HeapObject> heap_object;
            if (target.GetHeapObjectIfWeak(&heap_object)) {
              proto_transition_callback(Cast<Map>(heap_object));
            }
          }
        }
      }
      if constexpr (!std::is_same<SideStepCallback, std::nullptr_t>::value) {
        if (transitions()->HasSideStepTransitions()) {
          Tagged<WeakFixedArray> cache =
              transitions()->GetSideStepTransitions();
          for (uint32_t i = SideStepTransition::kFirstMapIdx;
               i <= SideStepTransition::kLastMapIdx; i++) {
            Tagged<MaybeObject> target = cache->get(i);
            if (target.IsWeak() || target == SideStepTransition::Unreachable) {
              if constexpr (with_key) {
                side_step_transition_callback(
                    static_cast<SideStepTransition::Kind>(i),
                    target.GetHeapObjectOrSmi());
              } else {
                side_step_transition_callback(target.GetHeapObjectOrSmi());
              }
            }
          }
        }
      }

      return;
    }
  }
  UNREACHABLE();
}

}  // namespace internal
}  // namespace v8

#include "src/objects/object-macros-undef.h"

#endif  // V8_OBJECTS_TRANSITIONS_INL_H_
[Step 38: Duration 20.49 seconds| Input tokens: 1,645,528 | Output tokens: 20,326]
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ Step 39 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'ripgrep' with arguments: {'pattern': 'FindTransitionToAccessor', 'options': '-n --hidden --no-ignore-vcs .'}                                                                                  │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
Command: cd /Users/tarun/v8/v8/src && rg -n --hidden --no-ignore-vcs . 'FindTransitionToAccessor' | head -n 1000
Observations: rg: FindTransitionToAccessor: IO error for operation on FindTransitionToAccessor: No such file or directory (os error 2)
[Step 39: Duration 30.37 seconds| Input tokens: 1,751,010 | Output tokens: 20,942]
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ Step 40 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'ripgrep' with arguments: {'pattern': 'FindTransitionTo(Field|Accessor)|New(Field|DataProperty)|ReplaceTransitionTo(DataProperty|DataField)|Deprecat|Deprecated|DeprecateTransitions?',        │
│ 'options': '-n --hidden --no-ignore-vcs ./objects/map-updater.* ./objects/js-objects.* ./objects/map.* ./objects/transitions.* ./objects/descriptor-array.*'}                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'ripgrep' with arguments: {'pattern': '\\+1 map|plus one|split transition|split map|own[s]? descriptors|owns_descriptors|copy.*descriptors|descriptor.*copy|shapes diverge|diverge',           │
│ 'options': '-n --hidden --no-ignore-vcs ./objects/map-updater.* ./objects/js-objects.* ./objects/map.* ./objects/transitions.* ./objects/descriptor-array.*'}                                                │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
Command: cd /Users/tarun/v8/v8/src && rg -n --hidden --no-ignore-vcs ./objects/map-updater.* ./objects/js-objects.* ./objects/map.* ./objects/transitions.* ./objects/descriptor-array.* 'FindTransitionTo(Field|Accessor)|New(Field|DataProperty)|ReplaceTransitionTo(DataProperty|DataField)|Deprecat|Deprecated|DeprecateTransitions?' | head -n 1000
Observations: rg: FindTransitionTo(Field|Accessor)|New(Field|DataProperty)|ReplaceTransitionTo(DataProperty|DataField)|Deprecat|Deprecated|DeprecateTransitions?: No such file or directory (os error 2)
Command: cd /Users/tarun/v8/v8/src && rg -n --hidden --no-ignore-vcs ./objects/map-updater.* ./objects/js-objects.* ./objects/map.* ./objects/transitions.* ./objects/descriptor-array.* '\+1 map|plus one|split transition|split map|own[s]? descriptors|owns_descriptors|copy.*descriptors|descriptor.*copy|shapes diverge|diverge' | head -n 1000
Observations: rg: \+1 map|plus one|split transition|split map|own|s]? descriptors|owns_descriptors|copy.*descriptors|descriptor.*copy|shapes diverge|diverge: No such file or directory (os error 2)
[Step 40: Duration 25.75 seconds| Input tokens: 1,865,789 | Output tokens: 21,401]
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ Step 41 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'read_file' with arguments: {'file_path': '/Users/tarun/v8/v8/src/objects/js-objects.cc'}                                                                                                      │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
Command: cd /Users/tarun/v8/v8/src && wc -l '/Users/tarun/v8/v8/src/objects/js-objects.cc'
Observations: File '/Users/tarun/v8/v8/src/objects/js-objects.cc' has 5927 lines and is divided into 2 sections (each section is 3000 lines).
To read this file, please specify a section number between 1 and 2 using the 'section' argument.
[Step 41: Duration 12.19 seconds| Input tokens: 1,990,931 | Output tokens: 21,568]
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ Step 42 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'ripgrep' with arguments: {'pattern': 'NewDataProperty|ReplaceTransition|transition|AddDataProperty|Define|Add|SetProperty|TransitionTo|Property|Field', 'options': '-n                        │
│ /Users/tarun/v8/v8/src/objects/js-objects.cc'}                                                                                                                                                               │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
Command: cd /Users/tarun/v8/v8/src && rg -n /Users/tarun/v8/v8/src/objects/js-objects.cc 'NewDataProperty|ReplaceTransition|transition|AddDataProperty|Define|Add|SetProperty|TransitionTo|Property|Field' | head -n 1000
Observations: rg: NewDataProperty|ReplaceTransition|transition|AddDataProperty|Define|Add|SetProperty|TransitionTo|Property|Field: IO error for operation on 
NewDataProperty|ReplaceTransition|transition|AddDataProperty|Define|Add|SetProperty|TransitionTo|Property|Field: No such file or directory (os error 2)
[Step 42: Duration 7.13 seconds| Input tokens: 2,120,946 | Output tokens: 21,766]
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ Step 43 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'ripgrep' with arguments: {'pattern': 'FindTransitionToAccessor|New.*Data.*Property|NewField|ReplaceTransition|DeprecateTransition|DeprecateTransitions|Deprecated', 'options': '-n            │
│ ./objects/transitions.cc ./objects/transitions.h ./objects/transitions-inl.h ./objects/map.cc ./objects/map-updater.cc ./objects/js-objects.cc ./objects/map.h ./objects/map-inl.h'}                         │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
Command: cd /Users/tarun/v8/v8/src && rg -n ./objects/transitions.cc ./objects/transitions.h ./objects/transitions-inl.h ./objects/map.cc ./objects/map-updater.cc ./objects/js-objects.cc ./objects/map.h ./objects/map-inl.h 'FindTransitionToAccessor|New.*Data.*Property|NewField|ReplaceTransition|DeprecateTransition|DeprecateTransitions|Deprecated' | head -n 1000
Observations: rg: FindTransitionToAccessor|New.*Data.*Property|NewField|ReplaceTransition|DeprecateTransition|DeprecateTransitions|Deprecated: No such file or directory (os error 2)
[Step 43: Duration 20.37 seconds| Input tokens: 2,240,912 | Output tokens: 22,377]
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ Step 44 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'ripgrep' with arguments: {'pattern': 'FindTransitionTo(Field|Accessor)|New(Field|DataProperty)|Deprecate(Transition|Transitions)|\\+1 map|split                                               │
│ transition|Diverge|ReplaceTransitionToData(Property|Field)|TransitionToAccessor|NewDataProperty|Deprecate', 'options': '-n --hidden --no-ignore-vcs /Users/tarun/v8/v8/src/objects'}                         │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
Command: cd /Users/tarun/v8/v8/src && rg -n --hidden --no-ignore-vcs /Users/tarun/v8/v8/src/objects 'FindTransitionTo(Field|Accessor)|New(Field|DataProperty)|Deprecate(Transition|Transitions)|\+1 map|split transition|Diverge|ReplaceTransitionToData(Property|Field)|TransitionToAccessor|NewDataProperty|Deprecate' | head -n 1000
Observations: rg: FindTransitionTo(Field|Accessor)|New(Field|DataProperty)|Deprecate(Transition|Transitions)|\+1 map|split 
transition|Diverge|ReplaceTransitionToData(Property|Field)|TransitionToAccessor|NewDataProperty|Deprecate: IO error for operation on 
FindTransitionTo(Field|Accessor)|New(Field|DataProperty)|Deprecate(Transition|Transitions)|\+1 map|split 
transition|Diverge|ReplaceTransitionToData(Property|Field)|TransitionToAccessor|NewDataProperty|Deprecate: No such file or directory (os error 2)
[Step 44: Duration 28.47 seconds| Input tokens: 2,360,737 | Output tokens: 23,052]
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ Step 45 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

[1;31mGive Feedback / Get Help: https://github.com/BerriAI/litellm/issues/new[0m
LiteLLM.Info: If you need to debug this error, use `litellm._turn_on_debug()'.

Error while generating output:
litellm.RateLimitError: RateLimitError: OpenAIException - Rate limit reached for gpt-5 in organization org-lQBdrbIfGLbs233eAUwbQrrB on tokens per min (TPM): Limit 1000000, Used 906849, Requested 110615. 
Please try again in 1.047s. Visit https://platform.openai.com/account/rate-limits to learn more.
[Step 45: Duration 5.59 seconds]
Error executing request to team member 'V8Search' with arguments {'task': 'In src/objects/transitions.cc (and related headers), retrieve TransitionArray and map transitions relevant to named property changes:
FindTransitionToField/Accessor, DeprecateTransition(s), NewField/NewDataProperty transitions, handling when shapes diverge leading to deprecation and +1 map creation.'}: Error while generating output:
litellm.RateLimitError: RateLimitError: OpenAIException - Rate limit reached for gpt-5 in organization org-lQBdrbIfGLbs233eAUwbQrrB on tokens per min (TPM): Limit 1000000, Used 906849, Requested 110615. 
Please try again in 1.047s. Visit https://platform.openai.com/account/rate-limits to learn more.
Please try again or request to another team member

[1;31mGive Feedback / Get Help: https://github.com/BerriAI/litellm/issues/new[0m
LiteLLM.Info: If you need to debug this error, use `litellm._turn_on_debug()'.

Error while generating output:
litellm.RateLimitError: RateLimitError: OpenAIException - Rate limit reached for gpt-5 in organization org-lQBdrbIfGLbs233eAUwbQrrB on tokens per min (TPM): Limit 1000000, Used 905505, Requested 110539. 
Please try again in 962ms. Visit https://platform.openai.com/account/rate-limits to learn more.
[Step 46: Duration 6.29 seconds]
Error executing request to team member 'V8Search' with arguments {'task': 'In src/objects/name-dictionary-inl.h and src/objects/dictionary.h, retrieve NameDictionary mechanics relevant to slow properties: 
Lookup, Add, EnsureCapacity, FindEntry, Set, DetailsAt, and any helpers used by JSObject slow property defines. Include inline details showing how PropertyDetails are stored and probed.'}: Error while 
generating output:
litellm.RateLimitError: RateLimitError: OpenAIException - Rate limit reached for gpt-5 in organization org-lQBdrbIfGLbs233eAUwbQrrB on tokens per min (TPM): Limit 1000000, Used 905505, Requested 110539. 
Please try again in 962ms. Visit https://platform.openai.com/account/rate-limits to learn more.
Please try again or request to another team member

[1;31mGive Feedback / Get Help: https://github.com/BerriAI/litellm/issues/new[0m
LiteLLM.Info: If you need to debug this error, use `litellm._turn_on_debug()'.

Error while generating output:
litellm.RateLimitError: RateLimitError: OpenAIException - Rate limit reached for gpt-5 in organization org-lQBdrbIfGLbs233eAUwbQrrB on tokens per min (TPM): Limit 1000000, Used 890148, Requested 110658. 
Please try again in 48ms. Visit https://platform.openai.com/account/rate-limits to learn more.
[Step 47: Duration 3.36 seconds]
Error executing request to team member 'V8Search' with arguments {'task': 'Locate in V8 source the exact implementations and nearby helpers for named property stores fast/slow paths in 
src/objects/js-objects.cc. Specifically retrieve code and surrounding context (signatures + key branches) for: JSObject::PrepareForDataProperty, JSObject::NormalizeProperties, JSObject::MigrateFastToSlow, and
slow-path SetNamedProperty/Define semantics used when installing/reconfiguring a data property on a JSObject. Include line numbers and file paths if available.'}: Error while generating output:
litellm.RateLimitError: RateLimitError: OpenAIException - Rate limit reached for gpt-5 in organization org-lQBdrbIfGLbs233eAUwbQrrB on tokens per min (TPM): Limit 1000000, Used 890148, Requested 110658. 
Please try again in 48ms. Visit https://platform.openai.com/account/rate-limits to learn more.
Please try again or request to another team member
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'ripgrep' with arguments: {'pattern': 'FindTransitionTo(Field|Accessor)', 'options': '-n /Users/tarun/v8/v8/src'}                                                                              │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'ripgrep' with arguments: {'pattern': 'New(DataProperty|Field)', 'options': '-n /Users/tarun/v8/v8/src'}                                                                                       │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
Command: cd /Users/tarun/v8/v8/src && rg -n /Users/tarun/v8/v8/src 'FindTransitionTo(Field|Accessor)' | head -n 1000
│ Calling tool: 'ripgrep' with arguments: {'pattern': 'Transition(To|\\s)', 'options': '-n /Users/tarun/v8/v8/src/objects'}                                                                                    │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'ripgrep' with arguments: {'pattern': 'DeprecateTransitions?|DeprecateTransitionTree', 'options': '-n /Users/tarun/v8/v8/src'}                                                                 │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
Command: cd /Users/tarun/v8/v8/src && rg -n /Users/tarun/v8/v8/src 'New(DataProperty|Field)' | head -n 1000
Observations: rg: FindTransitionTo(Field|Accessor): IO error for operation on FindTransitionTo(Field|Accessor): No such file or directory (os error 2)
Observations: rg: New(DataProperty|Field): IO error for operation on New(DataProperty|Field): No such file or directory (os error 2)
Command: cd /Users/tarun/v8/v8/src && rg -n /Users/tarun/v8/v8/src/objects 'Transition(To|\s)' | head -n 1000
Observations: rg: Transition(To|\s): IO error for operation on Transition(To|\s): No such file or directory (os error 2)
Command: cd /Users/tarun/v8/v8/src && rg -n /Users/tarun/v8/v8/src 'DeprecateTransitions?|DeprecateTransitionTree' | head -n 1000
Observations: rg: DeprecateTransitions?|DeprecateTransitionTree: IO error for operation on DeprecateTransitions?|DeprecateTransitionTree: No such file or directory (os error 2)
[Step 48: Duration 15.53 seconds| Input tokens: 2,490,825 | Output tokens: 23,736]
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ Step 49 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'read_file' with arguments: {'file_path': '/Users/tarun/v8/v8/src/objects/map.cc'}                                                                                                             │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
Command: cd /Users/tarun/v8/v8/src && wc -l '/Users/tarun/v8/v8/src/objects/map.cc'
Command: cd /Users/tarun/v8/v8/src && cat '/Users/tarun/v8/v8/src/objects/map.cc'
Observations: // Copyright 2019 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "src/objects/map.h"

#include <optional>

#include "src/common/assert-scope.h"
#include "src/common/globals.h"
#include "src/execution/frames.h"
#include "src/execution/isolate.h"
#include "src/handles/handles-inl.h"
#include "src/handles/maybe-handles.h"
#include "src/heap/heap-layout-inl.h"
#include "src/heap/heap-write-barrier-inl.h"
#include "src/init/bootstrapper.h"
#include "src/logging/log.h"
#include "src/logging/runtime-call-stats-scope.h"
#include "src/objects/arguments-inl.h"
#include "src/objects/descriptor-array.h"
#include "src/objects/elements-kind.h"
#include "src/objects/field-type.h"
#include "src/objects/instance-type.h"
#include "src/objects/js-objects.h"
#include "src/objects/map-updater.h"
#include "src/objects/maybe-object.h"
#include "src/objects/oddball.h"
#include "src/objects/property.h"
#include "src/objects/transitions-inl.h"
#include "src/roots/roots.h"
#include "src/utils/ostreams.h"
#include "src/zone/zone-containers.h"

namespace v8::internal {

Tagged<Map> Map::GetPrototypeChainRootMap(Isolate* isolate) const {
  DisallowGarbageCollection no_alloc;
  if (IsJSReceiverMap(*this)) {
    return *this;
  }
  int constructor_function_index = GetConstructorFunctionIndex();
  if (constructor_function_index != Map::kNoConstructorFunctionIndex) {
    Tagged<Context> native_context = isolate->context()->native_context();
    Tagged<JSFunction> constructor_function =
        Cast<JSFunction>(native_context->get(constructor_function_index));
    return constructor_function->initial_map();
  }
  return ReadOnlyRoots(isolate).null_value()->map();
}

// static
std::optional<Tagged<JSFunction>> Map::GetConstructorFunction(
    Tagged<Map> map, Tagged<Context> native_context) {
  DisallowGarbageCollection no_gc;
  if (IsPrimitiveMap(map)) {
    int const constructor_function_index = map->GetConstructorFunctionIndex();
    if (constructor_function_index != kNoConstructorFunctionIndex) {
      return Cast<JSFunction>(native_context->get(constructor_function_index));
    }
  }
  return {};
}

VisitorId Map::GetVisitorId(Tagged<Map> map) {
  static_assert(kVisitorIdCount <= 256);

  const int instance_type = map->instance_type();

  if (instance_type < FIRST_NONSTRING_TYPE) {
    switch (instance_type & kStringRepresentationMask) {
      case kSeqStringTag:
        if ((instance_type & kStringEncodingMask) == kOneByteStringTag) {
          return kVisitSeqOneByteString;
        } else {
          return kVisitSeqTwoByteString;
        }

      case kConsStringTag:
        if (IsShortcutCandidate(instance_type)) {
          return kVisitShortcutCandidate;
        } else {
          return kVisitConsString;
        }

      case kSlicedStringTag:
        return kVisitSlicedString;

      case kExternalStringTag:
        return kVisitExternalString;

      case kThinStringTag:
        return kVisitThinString;
    }
    UNREACHABLE();
  }

  if (InstanceTypeChecker::IsJSApiObject(map->instance_type())) {
    return kVisitJSApiObject;
  }

  switch (instance_type) {
    case FILLER_TYPE:
      return kVisitFiller;
    case FREE_SPACE_TYPE:
      return kVisitFreeSpace;

    case EMBEDDER_DATA_ARRAY_TYPE:
      return kVisitEmbedderDataArray;

    case NAME_TO_INDEX_HASH_TABLE_TYPE:
    case REGISTERED_SYMBOL_TABLE_TYPE:
    case HASH_TABLE_TYPE:
    case ORDERED_HASH_MAP_TYPE:
    case ORDERED_HASH_SET_TYPE:
    case ORDERED_NAME_DICTIONARY_TYPE:
    case NAME_DICTIONARY_TYPE:
    case GLOBAL_DICTIONARY_TYPE:
    case NUMBER_DICTIONARY_TYPE:
    case SIMPLE_NUMBER_DICTIONARY_TYPE:
      return kVisitFixedArray;

    case SLOPPY_ARGUMENTS_ELEMENTS_TYPE:
      return kVisitSloppyArgumentsElements;

    case AWAIT_CONTEXT_TYPE:
    case BLOCK_CONTEXT_TYPE:
    case CATCH_CONTEXT_TYPE:
    case DEBUG_EVALUATE_CONTEXT_TYPE:
    case EVAL_CONTEXT_TYPE:
    case FUNCTION_CONTEXT_TYPE:
    case MODULE_CONTEXT_TYPE:
    case SCRIPT_CONTEXT_TYPE:
    case WITH_CONTEXT_TYPE:
      return kVisitContext;

    case NATIVE_CONTEXT_TYPE:
      return kVisitNativeContext;

    case EPHEMERON_HASH_TABLE_TYPE:
      return kVisitEphemeronHashTable;

    case PROPERTY_ARRAY_TYPE:
      return kVisitPropertyArray;

    case FEEDBACK_CELL_TYPE:
      return kVisitFeedbackCell;

    case FEEDBACK_METADATA_TYPE:
      return kVisitFeedbackMetadata;

    case ODDBALL_TYPE:
      return kVisitOddball;

    case HOLE_TYPE:
      return kVisitHole;

    case MAP_TYPE:
      return kVisitMap;

    case CELL_TYPE:
      return kVisitCell;

    case PROPERTY_CELL_TYPE:
      return kVisitPropertyCell;

    case CONTEXT_SIDE_PROPERTY_CELL_TYPE:
      return kVisitContextSidePropertyCell;

    case TRANSITION_ARRAY_TYPE:
      return kVisitTransitionArray;

    case JS_WEAK_MAP_TYPE:
    case JS_WEAK_SET_TYPE:
      return kVisitJSWeakCollection;

    case ACCESSOR_INFO_TYPE:
      return kVisitAccessorInfo;

    case FUNCTION_TEMPLATE_INFO_TYPE:
      return kVisitFunctionTemplateInfo;

    case OBJECT_TEMPLATE_INFO_TYPE:
      return kVisitStruct;

    case JS_PROXY_TYPE:
      return kVisitStruct;

    case SYMBOL_TYPE:
      return kVisitSymbol;

    case JS_ARRAY_BUFFER_TYPE:
      return kVisitJSArrayBuffer;

    case JS_DATA_VIEW_TYPE:
    case JS_RAB_GSAB_DATA_VIEW_TYPE:
      return kVisitJSDataViewOrRabGsabDataView;

    case JS_EXTERNAL_OBJECT_TYPE:
      return kVisitJSExternalObject;

    case JS_FUNCTION_TYPE:
    case JS_CLASS_CONSTRUCTOR_TYPE:
    case JS_PROMISE_CONSTRUCTOR_TYPE:
    case JS_REG_EXP_CONSTRUCTOR_TYPE:
    case JS_ARRAY_CONSTRUCTOR_TYPE:
#define TYPED_ARRAY_CONSTRUCTORS_SWITCH(Type, type, TYPE, Ctype) \
  case TYPE##_TYPED_ARRAY_CONSTRUCTOR_TYPE:
      TYPED_ARRAYS(TYPED_ARRAY_CONSTRUCTORS_SWITCH)
#undef TYPED_ARRAY_CONSTRUCTORS_SWITCH
      return kVisitJSFunction;

    case JS_TYPED_ARRAY_TYPE:
      return kVisitJSTypedArray;

    case SMALL_ORDERED_HASH_MAP_TYPE:
      return kVisitSmallOrderedHashMap;

    case SMALL_ORDERED_HASH_SET_TYPE:
      return kVisitSmallOrderedHashSet;

    case SMALL_ORDERED_NAME_DICTIONARY_TYPE:
      return kVisitSmallOrderedNameDictionary;

    case SWISS_NAME_DICTIONARY_TYPE:
      return kVisitSwissNameDictionary;

    case SHARED_FUNCTION_INFO_TYPE:
      return kVisitSharedFunctionInfo;

    case PREPARSE_DATA_TYPE:
      return kVisitPreparseData;

    case COVERAGE_INFO_TYPE:
      return kVisitCoverageInfo;

    // Objects that may have embedder fields but otherwise are just a regular
    // JSObject.
    case JS_PROMISE_TYPE: {
      const bool has_raw_data_fields =
          COMPRESS_POINTERS_BOOL && JSObject::GetEmbedderFieldCount(map) > 0;
      return has_raw_data_fields ? kVisitJSObject : kVisitJSObjectFast;
    }

    // Objects that are guaranteed to not have any embedder fields and just
    // behave like regular JSObject.
    case JS_ARGUMENTS_OBJECT_TYPE:
    case JS_ARRAY_ITERATOR_PROTOTYPE_TYPE:
    case JS_ARRAY_ITERATOR_TYPE:
    case JS_ARRAY_TYPE:
    case JS_ASYNC_DISPOSABLE_STACK_TYPE:
    case JS_ASYNC_FROM_SYNC_ITERATOR_TYPE:
    case JS_ASYNC_FUNCTION_OBJECT_TYPE:
    case JS_ASYNC_GENERATOR_OBJECT_TYPE:
    case JS_CONTEXT_EXTENSION_OBJECT_TYPE:
    case JS_DISPOSABLE_STACK_BASE_TYPE:
    case JS_ERROR_TYPE:
    case JS_GENERATOR_OBJECT_TYPE:
    case JS_ITERATOR_FILTER_HELPER_TYPE:
    case JS_ITERATOR_MAP_HELPER_TYPE:
    case JS_ITERATOR_TAKE_HELPER_TYPE:
    case JS_ITERATOR_DROP_HELPER_TYPE:
    case JS_ITERATOR_FLAT_MAP_HELPER_TYPE:
    case JS_ITERATOR_PROTOTYPE_TYPE:
    case JS_MAP_ITERATOR_PROTOTYPE_TYPE:
    case JS_MAP_KEY_ITERATOR_TYPE:
    case JS_MAP_KEY_VALUE_ITERATOR_TYPE:
    case JS_MAP_TYPE:
    case JS_MAP_VALUE_ITERATOR_TYPE:
    case JS_MESSAGE_OBJECT_TYPE:
    case JS_MODULE_NAMESPACE_TYPE:
    case JS_OBJECT_PROTOTYPE_TYPE:
    case JS_OBJECT_TYPE:
    case JS_PRIMITIVE_WRAPPER_TYPE:
    case JS_PROMISE_PROTOTYPE_TYPE:
    case JS_REG_EXP_PROTOTYPE_TYPE:
    case JS_REG_EXP_STRING_ITERATOR_TYPE:
    case JS_SET_ITERATOR_PROTOTYPE_TYPE:
    case JS_SET_KEY_VALUE_ITERATOR_TYPE:
    case JS_SET_PROTOTYPE_TYPE:
    case JS_SET_TYPE:
    case JS_SET_VALUE_ITERATOR_TYPE:
    case JS_SYNC_DISPOSABLE_STACK_TYPE:
    case JS_SHADOW_REALM_TYPE:
    case JS_SHARED_ARRAY_TYPE:
    case JS_SHARED_STRUCT_TYPE:
    case JS_STRING_ITERATOR_PROTOTYPE_TYPE:
    case JS_STRING_ITERATOR_TYPE:
    case JS_TEMPORAL_CALENDAR_TYPE:
    case JS_TEMPORAL_DURATION_TYPE:
    case JS_TEMPORAL_INSTANT_TYPE:
    case JS_TEMPORAL_PLAIN_DATE_TYPE:
    case JS_TEMPORAL_PLAIN_DATE_TIME_TYPE:
    case JS_TEMPORAL_PLAIN_MONTH_DAY_TYPE:
    case JS_TEMPORAL_PLAIN_TIME_TYPE:
    case JS_TEMPORAL_PLAIN_YEAR_MONTH_TYPE:
    case JS_TEMPORAL_TIME_ZONE_TYPE:
    case JS_TEMPORAL_ZONED_DATE_TIME_TYPE:
    case JS_TYPED_ARRAY_PROTOTYPE_TYPE:
    case JS_VALID_ITERATOR_WRAPPER_TYPE:
    case JS_RAW_JSON_TYPE:
#ifdef V8_INTL_SUPPORT
    case JS_V8_BREAK_ITERATOR_TYPE:
    case JS_COLLATOR_TYPE:
    case JS_DATE_TIME_FORMAT_TYPE:
    case JS_DISPLAY_NAMES_TYPE:
    case JS_DURATION_FORMAT_TYPE:
    case JS_LIST_FORMAT_TYPE:
    case JS_LOCALE_TYPE:
    case JS_NUMBER_FORMAT_TYPE:
    case JS_PLURAL_RULES_TYPE:
    case JS_RELATIVE_TIME_FORMAT_TYPE:
    case JS_SEGMENT_ITERATOR_TYPE:
    case JS_SEGMENTER_TYPE:
    case JS_SEGMENTS_TYPE:
#endif  // V8_INTL_SUPPORT
#if V8_ENABLE_WEBASSEMBLY
    case WASM_EXCEPTION_PACKAGE_TYPE:
    case WASM_MODULE_OBJECT_TYPE:
    case WASM_VALUE_OBJECT_TYPE:
#endif  // V8_ENABLE_WEBASSEMBLY
    case JS_BOUND_FUNCTION_TYPE:
    case JS_WRAPPED_FUNCTION_TYPE: {
      CHECK_EQ(0, JSObject::GetEmbedderFieldCount(map));
      return kVisitJSObjectFast;
    }
    case JS_REG_EXP_TYPE:
      return kVisitJSRegExp;

    // Objects that are used as API wrapper objects and can have embedder
    // fields. Note that there's more of these kinds (e.g. JS_ARRAY_BUFFER_TYPE)
    // but they have their own visitor id for other reasons
    case JS_API_OBJECT_TYPE:
    case JS_GLOBAL_PROXY_TYPE:
    case JS_GLOBAL_OBJECT_TYPE:
    case JS_SPECIAL_API_OBJECT_TYPE:
      return kVisitJSApiObject;

    case JS_DATE_TYPE:
      return kVisitJSDate;

    case JS_WEAK_REF_TYPE:
      return kVisitJSWeakRef;

    case WEAK_CELL_TYPE:
      return kVisitWeakCell;

    case JS_FINALIZATION_REGISTRY_TYPE:
      return kVisitJSFinalizationRegistry;

    case JS_ATOMICS_MUTEX_TYPE:
    case JS_ATOMICS_CONDITION_TYPE:
      return kVisitJSSynchronizationPrimitive;

    case HEAP_NUMBER_TYPE:
      return kVisitHeapNumber;

    case FOREIGN_TYPE:
      return kVisitForeign;

    case BIGINT_TYPE:
      return kVisitBigInt;

    case ALLOCATION_SITE_TYPE:
      return kVisitAllocationSite;

    // Here we list all structs explicitly on purpose. This forces new structs
    // to choose a VisitorId explicitly.
    case PROMISE_FULFILL_REACTION_JOB_TASK_TYPE:
    case PROMISE_REJECT_REACTION_JOB_TASK_TYPE:
    case CALLABLE_TASK_TYPE:
    case CALLBACK_TASK_TYPE:
    case PROMISE_RESOLVE_THENABLE_JOB_TASK_TYPE:
    case ACCESS_CHECK_INFO_TYPE:
    case ACCESSOR_PAIR_TYPE:
    case ALIASED_ARGUMENTS_ENTRY_TYPE:
    case ALLOCATION_MEMENTO_TYPE:
    case ARRAY_BOILERPLATE_DESCRIPTION_TYPE:
    case ASYNC_GENERATOR_REQUEST_TYPE:
    case BREAK_POINT_TYPE:
    case BREAK_POINT_INFO_TYPE:
    case CLASS_BOILERPLATE_TYPE:
    case CLASS_POSITIONS_TYPE:
    case ENUM_CACHE_TYPE:
    case ERROR_STACK_DATA_TYPE:
    case FUNCTION_TEMPLATE_RARE_DATA_TYPE:
    case INTERCEPTOR_INFO_TYPE:
    case MODULE_REQUEST_TYPE:
    case PROMISE_CAPABILITY_TYPE:
    case PROMISE_REACTION_TYPE:
    case PROPERTY_DESCRIPTOR_OBJECT_TYPE:
    case SCRIPT_TYPE:
    case SCRIPT_OR_MODULE_TYPE:
    case SOURCE_TEXT_MODULE_INFO_ENTRY_TYPE:
    case STACK_FRAME_INFO_TYPE:
    case STACK_TRACE_INFO_TYPE:
    case TEMPLATE_OBJECT_DESCRIPTION_TYPE:
    case TUPLE2_TYPE:
#if V8_ENABLE_WEBASSEMBLY
    case ASM_WASM_DATA_TYPE:
    case WASM_EXCEPTION_TAG_TYPE:
#endif
      return kVisitStruct;

    case PROTOTYPE_INFO_TYPE:
      return kVisitPrototypeInfo;

    case DEBUG_INFO_TYPE:
      return kVisitDebugInfo;

    case CALL_SITE_INFO_TYPE:
      return kVisitCallSiteInfo;

    case BYTECODE_WRAPPER_TYPE:
      return kVisitBytecodeWrapper;

    case CODE_WRAPPER_TYPE:
      return kVisitCodeWrapper;

    case REG_EXP_BOILERPLATE_DESCRIPTION_TYPE:
      return kVisitRegExpBoilerplateDescription;

    case REG_EXP_DATA_WRAPPER_TYPE:
      return kVisitRegExpDataWrapper;

    case LOAD_HANDLER_TYPE:
    case STORE_HANDLER_TYPE:
      return kVisitDataHandler;

    case SOURCE_TEXT_MODULE_TYPE:
      return kVisitSourceTextModule;
    case SYNTHETIC_MODULE_TYPE:
      return kVisitSyntheticModule;

#if V8_ENABLE_WEBASSEMBLY
    case WASM_ARRAY_TYPE:
      return kVisitWasmArray;
    case WASM_CONTINUATION_OBJECT_TYPE:
      return kVisitWasmContinuationObject;
    case WASM_MEMORY_MAP_DESCRIPTOR_TYPE:
      return kVisitWasmMemoryMapDescriptor;
    case WASM_FUNC_REF_TYPE:
      return kVisitWasmFuncRef;
    case WASM_GLOBAL_OBJECT_TYPE:
      return kVisitWasmGlobalObject;
    case WASM_INSTANCE_OBJECT_TYPE:
      return kVisitWasmInstanceObject;
    case WASM_MEMORY_OBJECT_TYPE:
      return kVisitWasmMemoryObject;
    case WASM_NULL_TYPE:
      return kVisitWasmNull;
    case WASM_RESUME_DATA_TYPE:
      return kVisitWasmResumeData;
    case WASM_STRUCT_TYPE:
      return kVisitWasmStruct;
    case WASM_SUSPENDER_OBJECT_TYPE:
      return kVisitWasmSuspenderObject;
    case WASM_SUSPENDING_OBJECT_TYPE:
      return kVisitWasmSuspendingObject;
    case WASM_TABLE_OBJECT_TYPE:
      return kVisitWasmTableObject;
    case WASM_TAG_OBJECT_TYPE:
      return kVisitWasmTagObject;
    case WASM_TYPE_INFO_TYPE:
      return kVisitWasmTypeInfo;
#endif  // V8_ENABLE_WEBASSEMBLY

#define MAKE_TQ_CASE(TYPE, Name) \
  case TYPE:                     \
    return kVisit##Name;
      TORQUE_INSTANCE_TYPE_TO_BODY_DESCRIPTOR_LIST(MAKE_TQ_CASE)
#undef MAKE_TQ_CASE

#define CASE(TypeCamelCase, TYPE_UPPER_CASE) \
  case TYPE_UPPER_CASE##_TYPE:               \
    return kVisit##TypeCamelCase;
      SIMPLE_HEAP_OBJECT_LIST2(CASE)
      CONCRETE_TRUSTED_OBJECT_TYPE_LIST2(CASE)
#undef CASE
  }
  std::string name = ToString(map->instance_type());
  FATAL("Instance type %s (code %d) not mapped to VisitorId.", name.c_str(),
        instance_type);
}

// static
MaybeObjectHandle Map::WrapFieldType(Handle<FieldType> type) {
  if (IsClass(*type)) {
    return MaybeObjectHandle::Weak(FieldType::AsClass(type));
  }
  return MaybeObjectHandle(type);
}

// static
Tagged<FieldType> Map::UnwrapFieldType(Tagged<MaybeObject> wrapped_type) {
  DCHECK(!wrapped_type.IsCleared());
  Tagged<HeapObject> heap_object;
  if (wrapped_type.GetHeapObjectIfWeak(&heap_object)) {
    return Cast<FieldType>(heap_object);
  }
  return Cast<FieldType>(wrapped_type);
}

MaybeHandle<Map> Map::CopyWithField(Isolate* isolate, DirectHandle<Map> map,
                                    DirectHandle<Name> name,
                                    Handle<FieldType> type,
                                    PropertyAttributes attributes,
                                    PropertyConstness constness,
                                    Representation representation,
                                    TransitionFlag flag) {
  DCHECK(map->instance_descriptors(isolate)
             ->Search(*name, map->NumberOfOwnDescriptors())
             .is_not_found());

  // Ensure the descriptor array does not get too big.
  if (map->NumberOfOwnDescriptors() >= kMaxNumberOfDescriptors) {
    return MaybeHandle<Map>();
  }

  // Compute the new index for new field.
  int index = map->NextFreePropertyIndex();

  if (map->instance_type() == JS_CONTEXT_EXTENSION_OBJECT_TYPE) {
    constness = PropertyConstness::kMutable;
    representation = Representation::Tagged();
    type = FieldType::Any(isolate);
  } else {
    Map::GeneralizeIfCanHaveTransitionableFastElementsKind(
        isolate, map->instance_type(), &representation, &type);
  }

  MaybeObjectHandle wrapped_type = WrapFieldType(type);

  Descriptor d = Descriptor::DataField(name, index, attributes, constness,
                                       representation, wrapped_type);
  Handle<Map> new_map = Map::CopyAddDescriptor(isolate, map, &d, flag);
  new_map->AccountAddedPropertyField();
  return new_map;
}

MaybeHandle<Map> Map::CopyWithConstant(Isolate* isolate, DirectHandle<Map> map,
                                       DirectHandle<Name> name,
                                       DirectHandle<Object> constant,
                                       PropertyAttributes attributes,
                                       TransitionFlag flag) {
  // Ensure the descriptor array does not get too big.
  if (map->NumberOfOwnDescriptors() >= kMaxNumberOfDescriptors) {
    return MaybeHandle<Map>();
  }

  Representation representation =
      Object::OptimalRepresentation(*constant, isolate);
  Handle<FieldType> type =
      Object::OptimalType(*constant, isolate, representation);
  return CopyWithField(isolate, map, name, type, attributes,
                       PropertyConstness::kConst, representation, flag);
}

bool Map::InstancesNeedRewriting(Tagged<Map> target,
                                 ConcurrencyMode cmode) const {
  int target_number_of_fields = target->NumberOfFields(cmode);
  int target_inobject = target->GetInObjectProperties();
  int target_unused = target->UnusedPropertyFields();
  int old_number_of_fields;

  return InstancesNeedRewriting(target, target_number_of_fields,
                                target_inobject, target_unused,
                                &old_number_of_fields, cmode);
}

bool Map::InstancesNeedRewriting(Tagged<Map> target,
                                 int target_number_of_fields,
                                 int target_inobject, int target_unused,
                                 int* old_number_of_fields,
                                 ConcurrencyMode cmode) const {
  // If fields were added (or removed), rewrite the instance.
  *old_number_of_fields = NumberOfFields(cmode);
  DCHECK(target_number_of_fields >= *old_number_of_fields);
  if (target_number_of_fields != *old_number_of_fields) return true;

  // If smi descriptors were replaced by double descriptors, rewrite.
  Tagged<DescriptorArray> old_desc = IsConcurrent(cmode)
                                         ? instance_descriptors(kAcquireLoad)
                                         : instance_descriptors();
  Tagged<DescriptorArray> new_desc =
      IsConcurrent(cmode) ? target->instance_descriptors(kAcquireLoad)
                          : target->instance_descriptors();
  for (InternalIndex i : IterateOwnDescriptors()) {
    if (new_desc->GetDetails(i).representation().IsDouble() !=
        old_desc->GetDetails(i).representation().IsDouble()) {
      return true;
    }
  }

  // If no fields were added, and no inobject properties were removed, setting
  // the map is sufficient.
  if (target_inobject == GetInObjectProperties()) return false;
  // In-object slack tracking may have reduced the object size of the new map.
  // In that case, succeed if all existing fields were inobject, and they still
  // fit within the new inobject size.
  DCHECK(target_inobject < GetInObjectProperties());
  if (target_number_of_fields <= target_inobject) {
    DCHECK(target_number_of_fields + target_unused == target_inobject);
    return false;
  }
  // Otherwise, properties will need to be moved to the backing store.
  return true;
}

int Map::NumberOfFields(ConcurrencyMode cmode) const {
  Tagged<DescriptorArray> descriptors = IsConcurrent(cmode)
                                            ? instance_descriptors(kAcquireLoad)
                                            : instance_descriptors();
  int result = 0;
  for (InternalIndex i : IterateOwnDescriptors()) {
    if (descriptors->GetDetails(i).location() == PropertyLocation::kField)
      result++;
  }
  return result;
}

Map::FieldCounts Map::GetFieldCounts() const {
  Tagged<DescriptorArray> descriptors = instance_descriptors();
  int mutable_count = 0;
  int const_count = 0;
  for (InternalIndex i : IterateOwnDescriptors()) {
    PropertyDetails details = descriptors->GetDetails(i);
    if (details.location() == PropertyLocation::kField) {
      switch (details.constness()) {
        case PropertyConstness::kMutable:
          mutable_count++;
          break;
        case PropertyConstness::kConst:
          const_count++;
          break;
      }
    }
  }
  return FieldCounts(mutable_count, const_count);
}

void Map::DeprecateTransitionTree(Isolate* isolate) {
  if (is_deprecated()) return;
  DisallowGarbageCollection no_gc;
  ReadOnlyRoots roots(isolate);
  TransitionsAccessor transitions(isolate, *this);
  transitions.ForEachTransition(
      &no_gc, |&](Tagged<Map> map) { map->DeprecateTransitionTree(isolate); },
      |&](Tagged<Map> map) {
        if (v8_flags.move_prototype_transitions_first) {
          map->DeprecateTransitionTree(isolate);
        }
      },
      nullptr);
  DCHECK(!IsFunctionTemplateInfo(constructor_or_back_pointer()));
  DCHECK(CanBeDeprecated());
  set_is_deprecated(true);
  if (v8_flags.log_maps) {
    LOG(isolate, MapEvent("Deprecate", direct_handle(*this, isolate), {}));
  }
  DependentCode::DeoptimizeDependencyGroups(isolate, *this,
                                            DependentCode::kTransitionGroup);
  NotifyLeafMapLayoutChange(isolate);
}

// Installs |new_descriptors| over the current instance_descriptors to ensure
// proper sharing of descriptor arrays.
void Map::ReplaceDescriptors(Isolate* isolate,
                             Tagged<DescriptorArray> new_descriptors) {
  PtrComprCageBase cage_base(isolate);
  // Don't overwrite the empty descriptor array or initial map's descriptors.
  if (NumberOfOwnDescriptors() == 0 ||
      IsUndefined(GetBackPointer(cage_base), isolate)) {
    return;
  }

  Tagged<DescriptorArray> to_replace = instance_descriptors(cage_base);
  // Replace descriptors by new_descriptors in all maps that share it. The old
  // descriptors will not be trimmed in the mark-compactor, we need to mark
  // all its elements.
  Tagged<Map> current = *this;
#ifndef V8_DISABLE_WRITE_BARRIERS
  WriteBarrier::ForDescriptorArray(to_replace,
                                   to_replace->number_of_descriptors());
#endif
  while (current->instance_descriptors(cage_base) == to_replace) {
    Tagged<Map> next;
    if (!current->TryGetBackPointer(cage_base, &next)) {
      break;  // Stop overwriting at initial map.
    }
    current->SetEnumLength(kInvalidEnumCacheSentinel);
    current->UpdateDescriptors(isolate, new_descriptors,
                               current->NumberOfOwnDescriptors());
    current = next;
  }
  set_owns_descriptors(false);
}

Tagged<Map> Map::FindRootMap(PtrComprCageBase cage_base) const {
  DisallowGarbageCollection no_gc;
  Tagged<Map> result = *this;
  while (true) {
    Tagged<Map> parent;
    if (!result->TryGetBackPointer(cage_base, &parent)) {
      // Initial map must not contain descriptors in the descriptors array
      // that do not belong to the map.
      DCHECK_LE(result->NumberOfOwnDescriptors(),
                result->instance_descriptors(cage_base, kRelaxedLoad)
                    ->number_of_descriptors());
      return result;
    }
    result = parent;
  }
}

Tagged<Map> Map::FindFieldOwner(PtrComprCageBase cage_base,
                                InternalIndex descriptor) const {
  DisallowGarbageCollection no_gc;
  DCHECK_EQ(PropertyLocation::kField,
            instance_descriptors(cage_base, kRelaxedLoad)
                ->GetDetails(descriptor)
                .location());
  Tagged<Map> result = *this;
  while (true) {
    Tagged<Map> parent;
    if (!result->TryGetBackPointer(cage_base, &parent)) break;
    if (parent->NumberOfOwnDescriptors() <= descriptor.as_int()) break;
    result = parent;
  }
  return result;
}

namespace {

Tagged<Map> SearchMigrationTarget(Isolate* isolate, Tagged<Map> old_map) {
  DisallowGarbageCollection no_gc;

  Tagged<Map> target = old_map;
  do {
    target = TransitionsAccessor(isolate, target).GetMigrationTarget();
  } while (!target.is_null() && target->is_deprecated());
  if (target.is_null()) return Map();

  SLOW_DCHECK(MapUpdater::TryUpdateNoLock(
                  isolate, old_map, ConcurrencyMode::kSynchronous) == target);
  return target;
}
}  // namespace

// static
MaybeHandle<Map> Map::TryUpdate(Isolate* isolate, Handle<Map> old_map) {
  DisallowGarbageCollection no_gc;
  DisallowDeoptimization no_deoptimization(isolate);

  if (!old_map->is_deprecated()) return old_map;

  if (v8_flags.fast_map_update) {
    Tagged<Map> target_map = SearchMigrationTarget(isolate, *old_map);
    if (!target_map.is_null()) {
      return handle(target_map, isolate);
    }
  }

  std::optional<Tagged<Map>> new_map = MapUpdater::TryUpdateNoLock(
      isolate, *old_map, ConcurrencyMode::kSynchronous);
  if (!new_map.has_value()) return MaybeHandle<Map>();
  if (v8_flags.fast_map_update) {
    TransitionsAccessor::SetMigrationTarget(isolate, old_map, new_map.value());
  }
  return handle(new_map.value(), isolate);
}

Tagged<Map> Map::TryReplayPropertyTransitions(Isolate* isolate,
                                              Tagged<Map> old_map,
                                              ConcurrencyMode cmode) {
  DisallowGarbageCollection no_gc;

  const int root_nof = NumberOfOwnDescriptors();
  const int old_nof = old_map->NumberOfOwnDescriptors();
  // TODO(jgruber,chromium:1239009): The main thread should use non-atomic
  // reads, but this currently leads to odd behavior (see the linked bug).
  // Investigate and fix this properly. Also below and in called functions.
  Tagged<DescriptorArray> old_descriptors =
      old_map->instance_descriptors(isolate, kAcquireLoad);

  Tagged<Map> new_map = *this;
  for (InternalIndex i : InternalIndex::Range(root_nof, old_nof)) {
    PropertyDetails old_details = old_descriptors->GetDetails(i);
    Tagged<Map> transition =
        TransitionsAccessor(isolate, new_map, IsConcurrent(cmode))
            .SearchTransition(old_descriptors->GetKey(i), old_details.kind(),
                              old_details.attributes());
    if (transition.is_null()) return Map();
    new_map = transition;
    Tagged<DescriptorArray> new_descriptors =
        new_map->instance_descriptors(isolate, kAcquireLoad);

    PropertyDetails new_details = new_descriptors->GetDetails(i);
    DCHECK_EQ(old_details.kind(), new_details.kind());
    DCHECK_EQ(old_details.attributes(), new_details.attributes());
    if (!IsGeneralizableTo(old_details.constness(), new_details.constness())) {
      return Map();
    }
    DCHECK(IsGeneralizableTo(old_details.location(), new_details.location()));
    if (!old_details.representation().fits_into(new_details.representation())) {
      return Map();
    }
    if (new_details.location() == PropertyLocation::kField) {
      if (new_details.kind() == PropertyKind::kData) {
        Tagged<FieldType> new_type = new_descriptors->GetFieldType(i);
        DCHECK_EQ(PropertyKind::kData, old_details.kind());
        DCHECK_EQ(PropertyLocation::kField, old_details.location());
        Tagged<FieldType> old_type = old_descriptors->GetFieldType(i);
        if (!FieldType::NowIs(old_type, new_type)) {
          return Map();
        }
      } else {
        DCHECK_EQ(PropertyKind::kAccessor, new_details.kind());
#ifdef DEBUG
        Tagged<FieldType> new_type = new_descriptors->GetFieldType(i);
        DCHECK(IsAny(new_type));
#endif
        UNREACHABLE();
      }
    } else {
      DCHECK_EQ(PropertyLocation::kDescriptor, new_details.location());
      if (old_details.location() == PropertyLocation::kField ||
          old_descriptors->GetStrongValue(i) !=
              new_descriptors->GetStrongValue(i)) {
        return Map();
      }
    }
  }
  if (new_map->NumberOfOwnDescriptors() != old_nof) return Map();
  return new_map;
}

// static
template <template <typename> typename HandleType>
  requires(std::is_convertible_v<HandleType<Map>, DirectHandle<Map>>)
HandleType<Map> Map::Update(Isolate* isolate, HandleType<Map> map) {
  if (!map->is_deprecated()) return map;
  if (v8_flags.fast_map_update) {
    Tagged<Map> target_map = SearchMigrationTarget(isolate, *map);
    if (!target_map.is_null()) {
      return HandleType<Map>(target_map, isolate);
    }
  }
  if constexpr (std::is_convertible_v<HandleType<Map>, Handle<Map>>) {
    return MapUpdater{isolate, map}.Update();
  } else {
    return MapUpdater{isolate, indirect_handle(map, isolate)}.Update();
  }
}

template V8_EXPORT_PRIVATE DirectHandle<Map> Map::Update(Isolate* isolate,
                                                         DirectHandle<Map> map);
template V8_EXPORT_PRIVATE IndirectHandle<Map> Map::Update(
    Isolate* isolate, IndirectHandle<Map> map);

void Map::EnsureDescriptorSlack(Isolate* isolate, DirectHandle<Map> map,
                                int slack) {
  // Only supports adding slack to owned descriptors.
  CHECK(map->owns_descriptors());

  DirectHandle<DescriptorArray> descriptors(map->instance_descriptors(isolate),
                                            isolate);
  int old_size = map->NumberOfOwnDescriptors();
  if (slack <= descriptors->number_of_slack_descriptors()) return;

  DirectHandle<DescriptorArray> new_descriptors =
      DescriptorArray::CopyUpTo(isolate, descriptors, old_size, slack);

  DisallowGarbageCollection no_gc;
  if (old_size == 0) {
    map->UpdateDescriptors(isolate, *new_descriptors,
                           map->NumberOfOwnDescriptors());
    return;
  }

  // If the source descriptors had an enum cache we copy it. This ensures
  // that the maps to which we push the new descriptor array back can rely
  // on a cache always being available once it is set. If the map has more
  // enumerated descriptors than available in the original cache, the cache
  // will be lazily replaced by the extended cache when needed.
  new_descriptors->CopyEnumCacheFrom(*descriptors);

  // Replace descriptors by new_descriptors in all maps that share it. The old
  // descriptors will not be trimmed in the mark-compactor, we need to mark
  // all its elements.
#ifndef V8_DISABLE_WRITE_BARRIERS
  WriteBarrier::ForDescriptorArray(*descriptors,
                                   descriptors->number_of_descriptors());
#endif

  // Update the descriptors from {map} (inclusive) until the initial map
  // (exclusive). In the case that {map} is the initial map, update it.
  map->UpdateDescriptors(isolate, *new_descriptors,
                         map->NumberOfOwnDescriptors());
  Tagged<Object> next = map->GetBackPointer();
  if (IsUndefined(next, isolate)) return;

  Tagged<Map> current = Cast<Map>(next);
  while (current->instance_descriptors(isolate) == *descriptors) {
    next = current->GetBackPointer();
    if (IsUndefined(next, isolate)) break;
    current->UpdateDescriptors(isolate, *new_descriptors,
                               current->NumberOfOwnDescriptors());
    current = Cast<Map>(next);
  }
}

// static
Handle<Map> Map::GetObjectCreateMap(Isolate* isolate,
                                    DirectHandle<JSPrototype> prototype) {
  Handle<Map> map(isolate->native_context()->object_function()->initial_map(),
                  isolate);
  if (map->prototype() == *prototype) return map;
  if (IsNull(*prototype, isolate)) {
    return isolate->slow_object_with_null_prototype_map();
  }
  if (IsJSObjectThatCanBeTrackedAsPrototype(*prototype)) {
    DirectHandle<JSObject> js_prototype = Cast<JSObject>(prototype);
    if (!js_prototype->map()->is_prototype_map()) {
      JSObject::OptimizeAsPrototype(js_prototype);
    }
    DirectHandle<PrototypeInfo> info =
        Map::GetOrCreatePrototypeInfo(js_prototype, isolate);
    // TODO(verwaest): Use inobject slack tracking for this map.
    Tagged<HeapObject> map_obj;
    if (info->ObjectCreateMap().GetHeapObjectIfWeak(&map_obj)) {
      map = handle(Cast<Map>(map_obj), isolate);
    } else {
      map = Map::CopyInitialMap(isolate, map);
      Map::SetPrototype(isolate, map, prototype);
      PrototypeInfo::SetObjectCreateMap(info, map, isolate);
    }
    return map;
  }

  return Map::TransitionRootMapToPrototypeForNewObject(isolate, map, prototype);
}

// static
Handle<Map> Map::GetDerivedMap(Isolate* isolate, DirectHandle<Map> from,
                               DirectHandle<JSReceiver> prototype) {
  DCHECK(IsUndefined(from->GetBackPointer()));

  if (IsJSObjectThatCanBeTrackedAsPrototype(*prototype)) {
    DirectHandle<JSObject> js_prototype = Cast<JSObject>(prototype);
    if (!js_prototype->map()->is_prototype_map()) {
      JSObject::OptimizeAsPrototype(js_prototype);
    }
    DirectHandle<PrototypeInfo> info =
        Map::GetOrCreatePrototypeInfo(js_prototype, isolate);
    Tagged<HeapObject> map_obj;
    Handle<Map> map;
    if (info->GetDerivedMap(from).GetHeapObjectIfWeak(&map_obj)) {
      map = handle(Cast<Map>(map_obj), isolate);
    } else {
      map = Map::CopyInitialMap(isolate, from);
      map->set_new_target_is_base(false);
      if (map->prototype() != *prototype) {
        Map::SetPrototype(isolate, map, prototype);
      }
      PrototypeInfo::AddDerivedMap(info, map, isolate);
    }
    return map;
  }

  // The TransitionToPrototype map will not have new_target_is_base reset. But
  // we don't need it to for proxies.
  return Map::TransitionRootMapToPrototypeForNewObject(isolate, from,
                                                       prototype);
}

static bool ContainsMap(MapHandlesSpan maps, Tagged<Map> map) {
  DCHECK(!map.is_null());
  for (DirectHandle<Map> current : maps) {
    if (!current.is_null() && *current == map) return true;
  }
  return false;
}

static bool HasElementsKind(MapHandlesSpan maps, ElementsKind elements_kind) {
  for (DirectHandle<Map> current : maps) {
    if (!current.is_null() && current->elements_kind() == elements_kind)
      return true;
  }
  return false;
}

Tagged<Map> Map::FindElementsKindTransitionedMap(Isolate* isolate,
                                                 MapHandlesSpan candidates,
                                                 ConcurrencyMode cmode) {
  DisallowGarbageCollection no_gc;

  if (IsDetached(isolate)) return Map();

  ElementsKind kind = elements_kind();
  bool is_packed = IsFastPackedElementsKind(kind);

  Tagged<Map> transition;
  if (IsTransitionableFastElementsKind(kind)) {
    // Check the state of the root map.
    Tagged<Map> root_map = FindRootMap(isolate);
    if (!EquivalentToForElementsKindTransition(root_map, cmode)) return Map();
    root_map = root_map->LookupElementsTransitionMap(isolate, kind, cmode);
    DCHECK(!root_map.is_null());
    // Starting from the next existing elements kind transition try to
    // replay the property transitions that does not involve instance rewriting
    // (ElementsTransitionAndStoreStub does not support that).
    for (root_map = root_map->ElementsTransitionMap(isolate, cmode);
         !root_map.is_null() && root_map->has_fast_elements();
         root_map = root_map->ElementsTransitionMap(isolate, cmode)) {
      // If root_map's elements kind doesn't match any of the elements kind in
      // the candidates there is no need to do any additional work.
      if (!HasElementsKind(candidates, root_map->elements_kind())) continue;
      Tagged<Map> current =
          root_map->TryReplayPropertyTransitions(isolate, *this, cmode);
      if (current.is_null()) continue;
      if (InstancesNeedRewriting(current, cmode)) continue;

      const bool current_is_packed =
          IsFastPackedElementsKind(current->elements_kind());
      if (ContainsMap(candidates, current) &&
          (is_packed || !current_is_packed)) {
        transition = current;
        is_packed = is_packed && current_is_packed;
      }
    }
  }
  return transition;
}

static Tagged<Map> FindClosestElementsTransition(Isolate* isolate,
                                                 Tagged<Map> map,
                                                 ElementsKind to_kind,
                                                 ConcurrencyMode cmode) {
  DisallowGarbageCollection no_gc;
  // Ensure we are requested to search elements kind transition "near the root".
  DCHECK_EQ(map->FindRootMap(isolate)->NumberOfOwnDescriptors(),
            map->NumberOfOwnDescriptors());
  Tagged<Map> current_map = map;

  ElementsKind kind = map->elements_kind();
  while (kind != to_kind) {
    Tagged<Map> next_map = current_map->ElementsTransitionMap(isolate, cmode);
    if (next_map.is_null()) return current_map;
    kind = next_map->elements_kind();
    current_map = next_map;
  }

  DCHECK_EQ(to_kind, current_map->elements_kind());
  return current_map;
}

Tagged<Map> Map::LookupElementsTransitionMap(Isolate* isolate,
                                             ElementsKind to_kind,
                                             ConcurrencyMode cmode) {
  Tagged<Map> to_map =
      FindClosestElementsTransition(isolate, *this, to_kind, cmode);
  if (to_map->elements_kind() == to_kind) return to_map;
  return Map();
}

bool Map::IsMapInArrayPrototypeChain(Isolate* isolate) const {
  if (isolate->initial_array_prototype()->map() == *this) {
    return true;
  }

  if (isolate->initial_object_prototype()->map() == *this) {
    return true;
  }

  return false;
}

Handle<Map> Map::TransitionElementsTo(Isolate* isolate, Handle<Map> map,
                                      ElementsKind to_kind) {
  ElementsKind from_kind = map->elements_kind();
  if (from_kind == to_kind) return map;

  Tagged<Context> native_context = isolate->context()->native_context();
  if (from_kind == FAST_SLOPPY_ARGUMENTS_ELEMENTS) {
    if (*map == native_context->fast_aliased_arguments_map()) {
      DCHECK_EQ(SLOW_SLOPPY_ARGUMENTS_ELEMENTS, to_kind);
      return handle(native_context->slow_aliased_arguments_map(), isolate);
    }
  } else if (from_kind == SLOW_SLOPPY_ARGUMENTS_ELEMENTS) {
    if (*map == native_context->slow_aliased_arguments_map()) {
      DCHECK_EQ(FAST_SLOPPY_ARGUMENTS_ELEMENTS, to_kind);
      return handle(native_context->fast_aliased_arguments_map(), isolate);
    }
  } else if (IsFastElementsKind(from_kind) && IsFastElementsKind(to_kind)) {
    // Reuse map transitions for JSArrays.
    DisallowGarbageCollection no_gc;
    if (native_context->GetInitialJSArrayMap(from_kind) == *map) {
      Tagged<Object> maybe_transitioned_map =
          native_context->get(Context::ArrayMapIndex(to_kind));
      if (IsMap(maybe_transitioned_map)) {
        return handle(Cast<Map>(maybe_transitioned_map), isolate);
      }
    }
  }

  DCHECK(!IsUndefined(*map, isolate));
  // Check if we can go back in the elements kind transition chain.
  if (IsHoleyElementsKind(from_kind) &&
      to_kind == GetPackedElementsKind(from_kind) &&
      IsMap(map->GetBackPointer()) &&
      Cast<Map>(map->GetBackPointer())->elements_kind() == to_kind) {
    return handle(Cast<Map>(map->GetBackPointer()), isolate);
  }

  bool allow_store_transition = IsTransitionElementsKind(from_kind);
  // Only store fast element maps in ascending generality.
  if (IsFastElementsKind(to_kind)) {
    allow_store_transition =
        allow_store_transition && IsTransitionableFastElementsKind(from_kind) &&
        IsMoreGeneralElementsKindTransition(from_kind, to_kind);
  }

  if (!allow_store_transition) {
    return Map::CopyAsElementsKind(isolate, map, to_kind, OMIT_TRANSITION);
  }

  return MapUpdater{isolate, map}.ReconfigureElementsKind(to_kind);
}

static Handle<Map> AddMissingElementsTransitions(Isolate* isolate,
                                                 Handle<Map> map,
                                                 ElementsKind to_kind) {
  DCHECK(IsTransitionElementsKind(map->elements_kind()));

  Handle<Map> current_map = map;

  ElementsKind kind = map->elements_kind();
  TransitionFlag flag;
  if (map->IsDetached(isolate)) {
    flag = OMIT_TRANSITION;
  } else {
    flag = INSERT_TRANSITION;
    if (IsFastElementsKind(kind)) {
      while (kind != to_kind && !IsTerminalElementsKind(kind)) {
        kind = GetNextTransitionElementsKind(kind);
        current_map = Map::CopyAsElementsKind(isolate, current_map, kind, flag);
      }
    }
  }

  // In case we are exiting the fast elements kind system, just add the map in
  // the end.
  if (kind != to_kind) {
    current_map = Map::CopyAsElementsKind(isolate, current_map, to_kind, flag);
  }

  DCHECK(current_map->elements_kind() == to_kind);
  return current_map;
}

// static
std::optional<Tagged<Map>> Map::TryAsElementsKind(Isolate* isolate,
                                                  DirectHandle<Map> map,
                                                  ElementsKind kind,
                                                  ConcurrencyMode cmode) {
  Tagged<Map> closest_map =
      FindClosestElementsTransition(isolate, *map, kind, cmode);
  if (closest_map->elements_kind() != kind) return {};
  return closest_map;
}

// static
Handle<Map> Map::AsElementsKind(Isolate* isolate, DirectHandle<Map> map,
                                ElementsKind kind) {
  Handle<Map> closest_map(
      FindClosestElementsTransition(isolate, *map, kind,
                                    ConcurrencyMode::kSynchronous),
      isolate);

  if (closest_map->elements_kind() == kind) {
    return closest_map;
  }

  return AddMissingElementsTransitions(isolate, closest_map, kind);
}

int Map::NumberOfEnumerableProperties() const {
  int result = 0;
  Tagged<DescriptorArray> descs = instance_descriptors(kRelaxedLoad);
  for (InternalIndex i : IterateOwnDescriptors()) {
    if ((int{descs->GetDetails(i).attributes()} & ONLY_ENUMERABLE) == 0 &&
        !Object::FilterKey(descs->GetKey(i), ENUMERABLE_STRINGS)) {
      result++;
    }
  }
  return result;
}

int Map::NextFreePropertyIndex() const {
  int number_of_own_descriptors = NumberOfOwnDescriptors();
  Tagged<DescriptorArray> descs = instance_descriptors(kRelaxedLoad);
  // Search properties backwards to find the last field.
  for (int i = number_of_own_descriptors - 1; i >= 0; --i) {
    PropertyDetails details = descs->GetDetails(InternalIndex(i));
    if (details.location() == PropertyLocation::kField) {
      return details.field_index() + details.field_width_in_words();
    }
  }
  return 0;
}

bool Map::OnlyHasSimpleProperties() const {
  // Wrapped string elements aren't explicitly stored in the elements backing
  // store, but are loaded indirectly from the underlying string.
  return !IsStringWrapperElementsKind(elements_kind()) &&
         !IsSpecialReceiverMap(*this) && !is_dictionary_map();
}

bool Map::ShouldCheckForReadOnlyElementsInPrototypeChain(Isolate* isolate) {
  // If this map has TypedArray elements kind, we won't look at the prototype
  // chain, so we can return early.
  if (IsTypedArrayElementsKind(elements_kind())) return false;

  for (PrototypeIterator iter(isolate, *this); !iter.IsAtEnd();
       iter.Advance()) {
    // Be conservative, don't look into any JSReceivers that may have custom
    // elements. For example, into JSProxies, String wrappers (which have have
    // non-configurable, non-writable elements), API objects, etc.
    if (IsCustomElementsReceiverMap(iter.GetCurrent()->map())) return true;

    Tagged<JSObject> current = iter.GetCurrent<JSObject>();
    ElementsKind elements_kind = current->GetElementsKind(isolate);
    // If this prototype has TypedArray elements kind, we won't look any further
    // in the prototype chain, so we can return early.
    if (IsTypedArrayElementsKind(elements_kind)) return false;
    if (IsFrozenElementsKind(elements_kind)) return true;

    if (IsDictionaryElementsKind(elements_kind) &&
        current->element_dictionary(isolate)->requires_slow_elements()) {
      return true;
    }

    if (IsSlowArgumentsElementsKind(elements_kind)) {
      Tagged<SloppyArgumentsElements> elements =
          Cast<SloppyArgumentsElements>(current->elements(isolate));
      Tagged<Object> arguments = elements->arguments();
      if (Cast<NumberDictionary>(arguments)->requires_slow_elements()) {
        return true;
      }
    }
  }

  return false;
}

Handle<Map> Map::RawCopy(Isolate* isolate, DirectHandle<Map> src_handle,
                         int instance_size, int inobject_properties) {
  Handle<Map> result = isolate->factory()->NewMap(
      src_handle, src_handle->instance_type(), instance_size,
      TERMINAL_FAST_ELEMENTS_KIND, inobject_properties);

  // We have to set the bitfields before any potential GCs could happen because
  // heap verification might fail otherwise.
  {
    DisallowGarbageCollection no_gc;
    Tagged<Map> src = *src_handle;
    Tagged<Map> raw = *result;
    raw->set_constructor_or_back_pointer(src->GetConstructorRaw());
    raw->set_bit_field(src->bit_field());
    raw->set_bit_field2(src->bit_field2());
    int new_bit_field3 = src->bit_field3();
    new_bit_field3 = Bits3::OwnsDescriptorsBit::update(new_bit_field3, true);
    new_bit_field3 =
        Bits3::NumberOfOwnDescriptorsBits::update(new_bit_field3, 0);
    new_bit_field3 = Bits3::EnumLengthBits::update(new_bit_field3,
                                                   kInvalidEnumCacheSentinel);
    new_bit_field3 = Bits3::IsDeprecatedBit::update(new_bit_field3, false);
    new_bit_field3 =
        Bits3::IsInRetainedMapListBit::update(new_bit_field3, false);
    if (!src->is_dictionary_map()) {
      new_bit_field3 = Bits3::IsUnstableBit::update(new_bit_field3, false);
    }
    // Same as bit_field comment above.
    raw->set_bit_field3(new_bit_field3);
    raw->clear_padding();
  }
  DirectHandle<JSPrototype> prototype(src_handle->prototype(), isolate);
  Map::SetPrototype(isolate, result, prototype);
  return result;
}

Handle<Map> Map::Normalize(Isolate* isolate, DirectHandle<Map> fast_map,
                           ElementsKind new_elements_kind,
                           DirectHandle<JSPrototype> new_prototype,
                           PropertyNormalizationMode mode, bool use_cache,
                           const char* reason) {
  DCHECK(!fast_map->is_dictionary_map());

  Tagged<Map> meta_map = fast_map->map();
  if (fast_map->is_prototype_map()) {
    use_cache = false;
  }
  DirectHandle<NormalizedMapCache> cache;
  if (use_cache) {
    Tagged<Object> normalized_map_cache =
        meta_map->native_context()->normalized_map_cache();
    use_cache = !IsUndefined(normalized_map_cache, isolate);
    if (use_cache) {
      cache = Cast<NormalizedMapCache>(
          direct_handle(normalized_map_cache, isolate));
    }
  }

  Handle<Map> new_map;
  if (use_cache && cache
                       ->Get(isolate, fast_map, new_elements_kind,
                             new_prototype.is_null() ? fast_map->prototype()
                                                     : *new_prototype,
                             mode)
                       .ToHandle(&new_map)) {
#ifdef VERIFY_HEAP
    if (v8_flags.verify_heap) new_map->DictionaryMapVerify(isolate);
#endif
#ifdef ENABLE_SLOW_DCHECKS
    if (v8_flags.enable_slow_asserts) {
      // The cached map should match newly created normalized map bit-by-bit,
      // except for the code cache, which can contain some ICs which can be
      // applied to the shared map, dependent code and weak cell cache.
      DirectHandle<Map> fresh = Map::CopyNormalized(isolate, fast_map, mode);
      fresh->set_elements_kind(new_elements_kind);
      if (!new_prototype.is_null()) {
        Map::SetPrototype(isolate, fresh, new_prototype);
      }

      static_assert(Map::kPrototypeValidityCellOffset ==
                    Map::kDependentCodeOffset + kTaggedSize);
      DCHECK_EQ(0, memcmp(reinterpret_cast<void*>(fresh->address()),
                          reinterpret_cast<void*>(new_map->address()),
                          Map::kBitField3Offset));
      // The IsInRetainedMapListBit might be different if the {new_map}
      // that we got from the {cache} was already embedded into optimized
      // code somewhere.
      // The IsMigrationTargetBit might be different if the {new_map} from
      // {cache} has already been marked as a migration target.
      constexpr int ignored_bit_field3_bits =
          Bits3::IsInRetainedMapListBit::kMask |
          Bits3::IsMigrationTargetBit::kMask;
      DCHECK_EQ(fresh->bit_field3() & ~ignored_bit_field3_bits,
                new_map->bit_field3() & ~ignored_bit_field3_bits);
      int offset = Map::kBitField3Offset + kInt32Size;
      DCHECK_EQ(0, memcmp(reinterpret_cast<void*>(fresh->address() + offset),
                          reinterpret_cast<void*>(new_map->address() + offset),
                          Map::kDependentCodeOffset - offset));
      offset = Map::kPrototypeValidityCellOffset + kTaggedSize;
      if (new_map->is_prototype_map()) {
        // For prototype maps, the PrototypeInfo is not copied.
        static_assert(Map::kTransitionsOrPrototypeInfoOffset ==
                      Map::kPrototypeValidityCellOffset + kTaggedSize);
        offset = kTransitionsOrPrototypeInfoOffset + kTaggedSize;
        DCHECK_EQ(fresh->raw_transitions(), Smi::zero());
      }
      DCHECK_EQ(0, memcmp(reinterpret_cast<void*>(fresh->address() + offset),
                          reinterpret_cast<void*>(new_map->address() + offset),
                          Map::kSize - offset));
    }
#endif
    if (v8_flags.log_maps) {
      LOG(isolate, MapEvent("NormalizeCached", fast_map, new_map, reason));
    }
  } else {
    new_map = Map::CopyNormalized(isolate, fast_map, mode);
    new_map->set_elements_kind(new_elements_kind);
    if (!new_prototype.is_null()) {
      Map::SetPrototype(isolate, new_map, new_prototype);
      DCHECK(new_map->is_dictionary_map() && !new_map->is_deprecated());
    }
    if (use_cache) {
      cache->Set(isolate, fast_map, new_map);
    }
    if (v8_flags.log_maps) {
      LOG(isolate, MapEvent("Normalize", fast_map, new_map, reason));
    }
  }
  fast_map->NotifyLeafMapLayoutChange(isolate);
  return new_map;
}

Handle<Map> Map::CopyNormalized(Isolate* isolate, DirectHandle<Map> map,
                                PropertyNormalizationMode mode) {
  int new_instance_size = map->instance_size();
  if (mode == CLEAR_INOBJECT_PROPERTIES) {
    new_instance_size -= map->GetInObjectProperties() * kTaggedSize;
  }

  Handle<Map> result = RawCopy(
      isolate, map, new_instance_size,
      mode == CLEAR_INOBJECT_PROPERTIES ? 0 : map->GetInObjectProperties());
  {
    DisallowGarbageCollection no_gc;
    Tagged<Map> raw = *result;
    // Clear the unused_property_fields explicitly as this field should not
    // be accessed for normalized maps.
    raw->SetInObjectUnusedPropertyFields(0);
    raw->set_is_dictionary_map(true);
    raw->set_is_migration_target(false);
    raw->set_may_have_interesting_properties(true);
    raw->set_construction_counter(kNoSlackTracking);
  }

#ifdef VERIFY_HEAP
  if (v8_flags.verify_heap) result->DictionaryMapVerify(isolate);
#endif

  return result;
}

// Return an immutable prototype exotic object version of the input map.
// Never even try to cache it in the transition tree, as it is intended
// for the global object and its prototype chain, and excluding it saves
// memory on the map transition tree.

// static
Handle<Map> Map::TransitionToImmutableProto(Isolate* isolate,
                                            DirectHandle<Map> map) {
  Handle<Map> new_map = Map::Copy(isolate, map, "ImmutablePrototype");
  new_map->set_is_immutable_proto(true);
  return new_map;
}

namespace {
void EnsureInitialMap(Isolate* isolate, DirectHandle<Map> map) {
#ifdef DEBUG
  Tagged<Object> maybe_constructor = map->GetConstructor();
  DCHECK((IsJSFunction(maybe_constructor) &&
          *map == Cast<JSFunction>(maybe_constructor)->initial_map()) ||
         // Below are the exceptions to the check above.
         // |Function|'s initial map is a |sloppy_function_map| but
         // other function map variants such as sloppy with name or readonly
         // prototype or various strict function maps variants, etc. also
         // have Function as a constructor.
         *map == *isolate->strict_function_map() ||
         *map == *isolate->strict_function_with_name_map() ||
         // Same applies to |GeneratorFunction|'s initial map and generator
         // function map variants.
         *map == *isolate->generator_function_with_name_map() ||
         // Same applies to |AsyncFunction|'s initial map and other async
         // function map variants.
         *map == *isolate->async_function_with_name_map());
#endif
  // Initial maps must not contain descriptors in the descriptors array
  // that do not belong to the map.
  DCHECK_EQ(map->NumberOfOwnDescriptors(),
            map->instance_descriptors(isolate)->number_of_descriptors());
}
}  // namespace

// static
Handle<Map> Map::CopyInitialMapNormalized(Isolate* isolate,
                                          DirectHandle<Map> map,
                                          PropertyNormalizationMode mode) {
  EnsureInitialMap(isolate, map);
  return CopyNormalized(isolate, map, mode);
}

// static
Handle<Map> Map::CopyInitialMap(Isolate* isolate, DirectHandle<Map> map,
                                int instance_size, int inobject_properties,
                                int unused_property_fields) {
  EnsureInitialMap(isolate, map);

  Handle<Map> result =
      RawCopy(isolate, map, instance_size, inobject_properties);

  // Please note instance_type and instance_size are set when allocated.
  result->SetInObjectUnusedPropertyFields(unused_property_fields);

  int number_of_own_descriptors = map->NumberOfOwnDescriptors();
  if (number_of_own_descriptors > 0) {
    // The copy will use the same descriptors array without ownership.
    Tagged<DescriptorArray> descriptors = map->instance_descriptors(isolate);
    result->set_owns_descriptors(false);
    result->UpdateDescriptors(isolate, descriptors, number_of_own_descriptors);

    DCHECK_EQ(result->NumberOfFields(ConcurrencyMode::kSynchronous),
              result->GetInObjectProperties() - result->UnusedPropertyFields());
  }

  return result;
}

Handle<Map> Map::CopyDropDescriptors(Isolate* isolate, DirectHandle<Map> map) {
  Handle<Map> result =
      RawCopy(isolate, map, map->instance_size(),
              IsJSObjectMap(*map) ? map->GetInObjectProperties() : 0);

  // Please note instance_type and instance_size are set when allocated.
  if (IsJSObjectMap(*map)) {
    result->CopyUnusedPropertyFields(*map);
  }
  map->NotifyLeafMapLayoutChange(isolate);
  return result;
}

Handle<Map> Map::ShareDescriptor(Isolate* isolate, DirectHandle<Map> map,
                                 DirectHandle<DescriptorArray> descriptors,
                                 Descriptor* descriptor) {
  // Sanity check. This path is only to be taken if the map owns its descriptor
  // array, implying that its NumberOfOwnDescriptors equals the number of
  // descriptors in the descriptor array.
  DCHECK_EQ(map->NumberOfOwnDescriptors(),
            map->instance_descriptors(isolate)->number_of_descriptors());

  Handle<Map> result = CopyDropDescriptors(isolate, map);
  DirectHandle<Name> name = descriptor->GetKey();

  // Properly mark the {result} if the {name} is an "interesting symbol".
  if (name->IsInteresting(isolate)) {
    result->set_may_have_interesting_properties(true);
  }

  // Ensure there's space for the new descriptor in the shared descriptor array.
  if (descriptors->number_of_slack_descriptors() == 0) {
    int old_size = descriptors->number_of_descriptors();
    if (old_size == 0) {
      descriptors = DescriptorArray::Allocate(isolate, 0, 1);
    } else {
      int slack = SlackForArraySize(old_size, kMaxNumberOfDescriptors);
      EnsureDescriptorSlack(isolate, map, slack);
      descriptors = direct_handle(map->instance_descriptors(isolate), isolate);
    }
  }

  {
    DisallowGarbageCollection no_gc;
    descriptors->Append(descriptor);
    result->InitializeDescriptors(isolate, *descriptors);
  }

  DCHECK(result->NumberOfOwnDescriptors() == map->NumberOfOwnDescriptors() + 1);
  ConnectTransition(isolate, map, result, name, SIMPLE_PROPERTY_TRANSITION);

  return result;
}

void Map::ConnectTransition(Isolate* isolate, DirectHandle<Map> parent,
                            DirectHandle<Map> child, DirectHandle<Name> name,
                            TransitionKindFlag transition_kind,
                            bool force_connect) {
  DCHECK_EQ(parent->map(), child->map());
  DCHECK_IMPLIES(name->IsInteresting(isolate),
                 child->may_have_interesting_properties());
  DCHECK_IMPLIES(parent->may_have_interesting_properties(),
                 child->may_have_interesting_properties());
  if (!IsUndefined(parent->GetBackPointer(), isolate)) {
    parent->set_owns_descriptors(false);
  } else if (!parent->IsDetached(isolate)) {
    // |parent| is initial map and it must not contain descriptors in the
    // descriptors array that do not belong to the map.
    DCHECK_EQ(parent->NumberOfOwnDescriptors(),
              parent->instance_descriptors(isolate)->number_of_descriptors());
  }
  if (parent->IsDetached(isolate) && !force_connect) {
    DCHECK(child->IsDetached(isolate));
    if (v8_flags.log_maps) {
      LOG(isolate, MapEvent("Transition", parent, child, "prototype", name));
    }
  } else {
    TransitionsAccessor::Insert(isolate, parent, name, child, transition_kind);
    if (v8_flags.log_maps) {
      LOG(isolate, MapEvent("Transition", parent, child, "", name));
    }
  }
}

Handle<Map> Map::CopyReplaceDescriptors(
    Isolate* isolate, DirectHandle<Map> map,
    DirectHandle<DescriptorArray> descriptors, TransitionFlag flag,
    MaybeDirectHandle<Name> maybe_name, const char* reason,
    TransitionKindFlag transition_kind) {
  DCHECK(descriptors->IsSortedNoDuplicates());

  Handle<Map> result = CopyDropDescriptors(isolate, map);
  bool is_connected = false;

  // Properly mark the {result} if the {name} is an "interesting symbol".
  DirectHandle<Name> name;
  if (maybe_name.ToHandle(&name) && name->IsInteresting(isolate)) {
    result->set_may_have_interesting_properties(true);
  }

  if (map->is_prototype_map()) {
    result->InitializeDescriptors(isolate, *descriptors);
  } else {
    if (flag == INSERT_TRANSITION &&
        TransitionsAccessor::CanHaveMoreTransitions(isolate, map)) {
      result->InitializeDescriptors(isolate, *descriptors);

      DCHECK(!maybe_name.is_null());
      ConnectTransition(isolate, map, result, name, transition_kind);
      is_connected = true;
    } else if ((transition_kind == PROTOTYPE_TRANSITION &&
                v8_flags.move_prototype_transitions_first) ||
               isolate->bootstrapper()->IsActive()) {
      // Prototype transitions are always between root maps. UpdatePrototype
      // uses the MapUpdater and instance migration. Thus, field generalization
      // is allowed to happen lazily.
      DCHECK_IMPLIES(transition_kind == PROTOTYPE_TRANSITION,
                     IsUndefined(map->GetBackPointer()));
      result->InitializeDescriptors(isolate, *descriptors);
    } else {
      DCHECK_IMPLIES(transition_kind == PROTOTYPE_TRANSITION,
                     !v8_flags.move_prototype_transitions_first);
      descriptors->GeneralizeAllFields(transition_kind == PROTOTYPE_TRANSITION);
      result->InitializeDescriptors(isolate, *descriptors);
    }
  }
  if (v8_flags.log_maps && !is_connected) {
    LOG(isolate,
        MapEvent("ReplaceDescriptors", map, result, reason,
                 maybe_name.is_null() ? DirectHandle<HeapObject>() : name));
  }
  return result;
}

// Creates transition tree starting from |split_map| and adding all descriptors
// starting from descriptor with index |split_map|.NumberOfOwnDescriptors().
// The way how it is done is tricky because of GC and special descriptors
// marking logic.
Handle<Map> Map::AddMissingTransitions(
    Isolate* isolate, DirectHandle<Map> split_map,
    DirectHandle<DescriptorArray> descriptors) {
  DCHECK(descriptors->IsSortedNoDuplicates());
  int split_nof = split_map->NumberOfOwnDescriptors();
  int nof_descriptors = descriptors->number_of_descriptors();
  CHECK_LT(split_nof, nof_descriptors);

  // Start with creating last map which will own full descriptors array.
  // This is necessary to guarantee that GC will mark the whole descriptor
  // array if any of the allocations happening below fail.
  // Number of unused properties is temporarily incorrect and the layout
  // descriptor could unnecessarily be in slow mode but we will fix after
  // all the other intermediate maps are created.
  // Also the last map might have interesting symbols, we temporarily set
  // the flag and clear it right before the descriptors are installed. This
  // makes heap verification happy and ensures the flag ends up accurate.
  Handle<Map> last_map = CopyDropDescriptors(isolate, split_map);
  last_map->InitializeDescriptors(isolate, *descriptors);
  last_map->SetInObjectUnusedPropertyFields(0);
  last_map->set_may_have_interesting_properties(true);

  // During creation of intermediate maps we violate descriptors sharing
  // invariant since the last map is not yet connected to the transition tree
  // we create here. But it is safe because GC never trims map's descriptors
  // if there are no dead transitions from that map and this is exactly the
  // case for all the intermediate maps we create here.
  DirectHandle<Map> map = split_map;
  for (InternalIndex i : InternalIndex::Range(split_nof, nof_descriptors - 1)) {
    DirectHandle<Map> new_map = CopyDropDescriptors(isolate, map);
    // Force connection of these maps to prevent split_map being a root map to
    // be treated as detached.
    InstallDescriptors(isolate, map, new_map, i, descriptors,
                       /* force_connect */ true);
    DCHECK_EQ(*new_map->GetBackPointer(), *map);
    map = new_map;
  }
  map->NotifyLeafMapLayoutChange(isolate);
  last_map->set_may_have_interesting_properties(false);
  InstallDescriptors(isolate, map, last_map, InternalIndex(nof_descriptors - 1),
                     descriptors);
  return last_map;
}

// Since this method is used to rewrite an existing transition tree, it can
// always insert transitions without checking.
void Map::InstallDescriptors(Isolate* isolate, DirectHandle<Map> parent,
                             DirectHandle<Map> child,
                             InternalIndex new_descriptor,
                             DirectHandle<DescriptorArray> descriptors,
                             bool force_connect) {
  DCHECK(descriptors->IsSortedNoDuplicates());

  child->SetInstanceDescriptors(isolate, *descriptors,
                                new_descriptor.as_int() + 1);
  child->CopyUnusedPropertyFields(*parent);
  PropertyDetails details = descriptors->GetDetails(new_descriptor);
  if (details.location() == PropertyLocation::kField) {
    child->AccountAddedPropertyField();
  }

  DirectHandle<Name> name(descriptors->GetKey(new_descriptor), isolate);
  if (parent->may_have_interesting_properties() ||
      name->IsInteresting(isolate)) {
    child->set_may_have_interesting_properties(true);
  }
  ConnectTransition(isolate, parent, child, name, SIMPLE_PROPERTY_TRANSITION,
                    force_connect);
}

Handle<Map> Map::CopyAsElementsKind(Isolate* isolate, DirectHandle<Map> map,
                                    ElementsKind kind, TransitionFlag flag) {
  // Only certain objects are allowed to have non-terminal fast transitional
  // elements kinds.
  DCHECK(IsJSObjectMap(*map));
  DCHECK_IMPLIES(
      !map->CanHaveFastTransitionableElementsKind(),
      IsDictionaryElementsKind(kind) || IsTerminalElementsKind(kind));

  Tagged<Map> maybe_elements_transition_map;
  if (flag == INSERT_TRANSITION) {
    // Ensure we are requested to add elements kind transition "near the root".
    DCHECK_EQ(map->FindRootMap(isolate)->NumberOfOwnDescriptors(),
              map->NumberOfOwnDescriptors());

    maybe_elements_transition_map =
        map->ElementsTransitionMap(isolate, ConcurrencyMode::kSynchronous);
    DCHECK(maybe_elements_transition_map.is_null() ||
           (maybe_elements_transition_map->elements_kind() ==
                DICTIONARY_ELEMENTS &&
            kind == DICTIONARY_ELEMENTS));
    DCHECK(!IsFastElementsKind(kind) ||
           IsMoreGeneralElementsKindTransition(map->elements_kind(), kind));
    DCHECK(kind != map->elements_kind());
  }

  bool insert_transition =
      flag == INSERT_TRANSITION &&
      TransitionsAccessor::CanHaveMoreTransitions(isolate, map) &&
      maybe_elements_transition_map.is_null();

  if (insert_transition) {
    Handle<Map> new_map = CopyForElementsTransition(isolate, map);
    new_map->set_elements_kind(kind);

    DirectHandle<Name> name = isolate->factory()->elements_transition_symbol();
    ConnectTransition(isolate, map, new_map, name, SPECIAL_TRANSITION);
    return new_map;
  }

  // Create a new free-floating map only if we are not allowed to store it.
  Handle<Map> new_map = Copy(isolate, map, "CopyAsElementsKind");
  new_map->set_elements_kind(kind);
  return new_map;
}

Handle<Map> Map::AsLanguageMode(Isolate* isolate, Handle<Map> initial_map,
                                DirectHandle<SharedFunctionInfo> shared_info) {
  DCHECK(InstanceTypeChecker::IsJSFunction(initial_map->instance_type()));
  // Initial map for sloppy mode function is stored in the function
  // constructor. Initial maps for strict mode are cached as special transitions
  // using |strict_function_transition_symbol| as a key.
  if (is_sloppy(shared_info->language_mode())) return initial_map;

  DirectHandle<Map> function_map(Cast<Map>(isolate->native_context()->get(
                                     shared_info->function_map_index())),
                                 isolate);

  static_assert(LanguageModeSize == 2);
  DCHECK_EQ(LanguageMode::kStrict, shared_info->language_mode());
  DirectHandle<Symbol> transition_symbol =
      isolate->factory()->strict_function_transition_symbol();
  MaybeHandle<Map> maybe_transition = TransitionsAccessor::SearchSpecial(
      isolate, initial_map, *transition_symbol);
  if (!maybe_transition.is_null()) {
    return maybe_transition.ToHandleChecked();
  }
  initial_map->NotifyLeafMapLayoutChange(isolate);

  // Create new map taking descriptors from the |function_map| and all
  // the other details from the |initial_map|.
  Handle<Map> map =
      Map::CopyInitialMap(isolate, function_map, initial_map->instance_size(),
                          initial_map->GetInObjectProperties(),
                          initial_map->UnusedPropertyFields());
  map->SetConstructor(initial_map->GetConstructor());
  map->set_prototype(initial_map->prototype());
  map->set_construction_counter(initial_map->construction_counter());

  if (TransitionsAccessor::CanHaveMoreTransitions(isolate, initial_map)) {
    Map::ConnectTransition(isolate, initial_map, map, transition_symbol,
                           SPECIAL_TRANSITION);
  }
  return map;
}

Handle<Map> Map::CopyForElementsTransition(Isolate* isolate,
                                           DirectHandle<Map> map) {
  DCHECK(!map->IsDetached(isolate));
  DCHECK(!map->is_dictionary_map());
  Handle<Map> new_map = CopyDropDescriptors(isolate, map);

  if (map->owns_descriptors()) {
    // In case the map owned its own descriptors, share the descriptors and
    // transfer ownership to the new map.
    // The properties did not change, so reuse descriptors.
    map->set_owns_descriptors(false);
    new_map->InitializeDescriptors(isolate, map->instance_descriptors(isolate));
  } else {
    // In case the map did not own its own descriptors, a split is forced by
    // copying the map; creating a new descriptor array cell.
    DirectHandle<DescriptorArray> descriptors(
        map->instance_descriptors(isolate), isolate);
    int number_of_own_descriptors = map->NumberOfOwnDescriptors();
    DirectHandle<DescriptorArray> new_descriptors = DescriptorArray::CopyUpTo(
        isolate, descriptors, number_of_own_descriptors);
    new_map->InitializeDescriptors(isolate, *new_descriptors);
  }
  return new_map;
}

Handle<Map> Map::CopyForPrototypeTransition(
    Isolate* isolate, DirectHandle<Map> map,
    DirectHandle<JSPrototype> prototype) {
  // For simplicity we always copy descriptors although it would be possible to
  // share them in some situations.
  Handle<Map> new_map =
      Copy(isolate, map, "TransitionToPrototype", PROTOTYPE_TRANSITION);
  Map::SetPrototype(isolate, new_map, prototype);
  return new_map;
}

Handle<Map> Map::Copy(Isolate* isolate, DirectHandle<Map> map,
                      const char* reason, TransitionKindFlag kind) {
  DirectHandle<DescriptorArray> descriptors(map->instance_descriptors(isolate),
                                            isolate);
  int number_of_own_descriptors = map->NumberOfOwnDescriptors();
  DirectHandle<DescriptorArray> new_descriptors = DescriptorArray::CopyUpTo(
      isolate, descriptors, number_of_own_descriptors);
  auto res =
      CopyReplaceDescriptors(isolate, map, new_descriptors, OMIT_TRANSITION,
                             MaybeDirectHandle<Name>(), reason, kind);
  return res;
}

Handle<Map> Map::Create(Isolate* isolate, int inobject_properties) {
  Handle<Map> copy_handle =
      Copy(isolate,
           direct_handle(isolate->object_function()->initial_map(), isolate),
           "MapCreate");
  DisallowGarbageCollection no_gc;
  Tagged<Map> copy = *copy_handle;

  // Check that we do not overflow the instance size when adding the extra
  // inobject properties. If the instance size overflows, we allocate as many
  // properties as we can as inobject properties.
  if (inobject_properties > JSObject::kMaxInObjectProperties) {
    inobject_properties = JSObject::kMaxInObjectProperties;
  }

  int new_instance_size =
      JSObject::kHeaderSize + kTaggedSize * inobject_properties;

  // Adjust the map with the extra inobject properties.
  copy->set_instance_size(new_instance_size);
  copy->SetInObjectPropertiesStartInWords(JSObject::kHeaderSize / kTaggedSize);
  DCHECK_EQ(copy->GetInObjectProperties(), inobject_properties);
  copy->SetInObjectUnusedPropertyFields(inobject_properties);
  copy->set_visitor_id(Map::GetVisitorId(copy));

  return copy_handle;
}

Handle<Map> Map::CopyForPreventExtensions(
    Isolate* isolate, DirectHandle<Map> map, PropertyAttributes attrs_to_add,
    DirectHandle<Symbol> transition_marker, const char* reason,
    bool old_map_is_dictionary_elements_kind) {
  int num_descriptors = map->NumberOfOwnDescriptors();
  DirectHandle<DescriptorArray> new_desc =
      DescriptorArray::CopyUpToAddAttributes(
          isolate, direct_handle(map->instance_descriptors(isolate), isolate),
          num_descriptors, attrs_to_add);
  // Do not track transitions during bootstrapping.
  TransitionFlag flag =
      isolate->bootstrapper()->IsActive() ? OMIT_TRANSITION : INSERT_TRANSITION;
  Handle<Map> new_map =
      CopyReplaceDescriptors(isolate, map, new_desc, flag, transition_marker,
                             reason, SPECIAL_TRANSITION);
  new_map->set_is_extensible(false);
  if (!IsTypedArrayOrRabGsabTypedArrayElementsKind(map->elements_kind())) {
    ElementsKind new_kind = IsStringWrapperElementsKind(map->elements_kind())
                                ? SLOW_STRING_WRAPPER_ELEMENTS
                                : DICTIONARY_ELEMENTS;
    if (v8_flags.enable_sealed_frozen_elements_kind &&
        !old_map_is_dictionary_elements_kind) {
      switch (map->elements_kind()) {
        case PACKED_ELEMENTS:
          if (attrs_to_add == SEALED) {
            new_kind = PACKED_SEALED_ELEMENTS;
          } else if (attrs_to_add == FROZEN) {
            new_kind = PACKED_FROZEN_ELEMENTS;
          } else {
            new_kind = PACKED_NONEXTENSIBLE_ELEMENTS;
          }
          break;
        case PACKED_NONEXTENSIBLE_ELEMENTS:
          if (attrs_to_add == SEALED) {
            new_kind = PACKED_SEALED_ELEMENTS;
          } else if (attrs_to_add == FROZEN) {
            new_kind = PACKED_FROZEN_ELEMENTS;
          }
          break;
        case PACKED_SEALED_ELEMENTS:
          if (attrs_to_add == FROZEN) {
            new_kind = PACKED_FROZEN_ELEMENTS;
          }
          break;
        case HOLEY_ELEMENTS:
          if (attrs_to_add == SEALED) {
            new_kind = HOLEY_SEALED_ELEMENTS;
          } else if (attrs_to_add == FROZEN) {
            new_kind = HOLEY_FROZEN_ELEMENTS;
          } else {
            new_kind = HOLEY_NONEXTENSIBLE_ELEMENTS;
          }
          break;
        case HOLEY_NONEXTENSIBLE_ELEMENTS:
          if (attrs_to_add == SEALED) {
            new_kind = HOLEY_SEALED_ELEMENTS;
          } else if (attrs_to_add == FROZEN) {
            new_kind = HOLEY_FROZEN_ELEMENTS;
          }
          break;
        case HOLEY_SEALED_ELEMENTS:
          if (attrs_to_add == FROZEN) {
            new_kind = HOLEY_FROZEN_ELEMENTS;
          }
          break;
        default:
          break;
      }
    }
    new_map->set_elements_kind(new_kind);
  }
  return new_map;
}

namespace {

bool CanHoldValue(Tagged<DescriptorArray> descriptors, InternalIndex descriptor,
                  PropertyConstness constness, Tagged<Object> value) {
  PropertyDetails details = descriptors->GetDetails(descriptor);
  if (details.location() == PropertyLocation::kField) {
    if (details.kind() == PropertyKind::kData) {
      return IsGeneralizableTo(constness, details.constness()) &&
             Object::FitsRepresentation(value, details.representation()) &&
             FieldType::NowContains(descriptors->GetFieldType(descriptor),
                                    value);
    } else {
      DCHECK_EQ(PropertyKind::kAccessor, details.kind());
      return false;
    }

  } else {
    DCHECK_EQ(PropertyLocation::kDescriptor, details.location());
    DCHECK_EQ(PropertyConstness::kConst, details.constness());
    DCHECK_EQ(PropertyKind::kAccessor, details.kind());
    return false;
  }
  UNREACHABLE();
}

Handle<Map> UpdateDescriptorForValue(Isolate* isolate, Handle<Map> map,
                                     InternalIndex descriptor,
                                     PropertyConstness constness,
                                     DirectHandle<Object> value) {
  if (CanHoldValue(map->instance_descriptors(isolate), descriptor, constness,
                   *value)) {
    return map;
  }

  PropertyAttributes attributes =
      map->instance_descriptors(isolate)->GetDetails(descriptor).attributes();
  Representation representation =
      Object::OptimalRepresentation(*value, isolate);
  Handle<FieldType> type = Object::OptimalType(*value, isolate, representation);

  MapUpdater mu(isolate, map);
  return mu.ReconfigureToDataField(descriptor, attributes, constness,
                                   representation, type);
}

}  // namespace

// static
Handle<Map> Map::PrepareForDataProperty(Isolate* isolate, Handle<Map> map,
                                        InternalIndex descriptor,
                                        PropertyConstness constness,
                                        DirectHandle<Object> value) {
  // The map should already be fully updated before storing the property.
  DCHECK(!map->is_deprecated());
  // Dictionaries can store any property value.
  DCHECK(!map->is_dictionary_map());
  return UpdateDescriptorForValue(isolate, map, descriptor, constness, value);
}

Handle<Map> Map::TransitionToDataProperty(
    Isolate* isolate, DirectHandle<Map> map, DirectHandle<Name> name,
    DirectHandle<Object> value, PropertyAttributes attributes,
    PropertyConstness constness, StoreOrigin store_origin) {
  RCS_SCOPE(isolate,
            map->IsDetached(isolate)
                ? RuntimeCallCounterId::kPrototypeMap_TransitionToDataProperty
                : RuntimeCallCounterId::kMap_TransitionToDataProperty);

  DCHECK(IsUniqueName(*name));
  DCHECK(!map->is_dictionary_map());

  // Migrate to the newest map before storing the property.
  map = Update(isolate, map);

  MaybeHandle<Map> maybe_transition = TransitionsAccessor::SearchTransition(
      isolate, map, *name, PropertyKind::kData, attributes);
  Handle<Map> transition;
  if (maybe_transition.ToHandle(&transition)) {
    InternalIndex descriptor = transition->LastAdded();

    DCHECK_EQ(attributes, transition->instance_descriptors(isolate)
                              ->GetDetails(descriptor)
                              .attributes());

    return UpdateDescriptorForValue(isolate, transition, descriptor, constness,
                                    value);
  }

  // Do not track transitions during bootstrapping.
  TransitionFlag flag =
      isolate->bootstrapper()->IsActive() ? OMIT_TRANSITION : INSERT_TRANSITION;
  MaybeHandle<Map> maybe_map;
  if (!map->TooManyFastProperties(store_origin)) {
    Representation representation =
        Object::OptimalRepresentation(*value, isolate);
    Handle<FieldType> type =
        Object::OptimalType(*value, isolate, representation);
    maybe_map = Map::CopyWithField(isolate, map, name, type, attributes,
                                   constness, representation, flag);
  }

  Handle<Map> result;
  if (!maybe_map.ToHandle(&result)) {
    const char* reason = "TooManyFastProperties";
#if V8_TRACE_MAPS
    std::unique_ptr<base::ScopedVector<char>> buffer;
    if (v8_flags.log_maps) {
      base::ScopedVector<char> name_buffer(100);
      name->NameShortPrint(name_buffer);
      buffer.reset(new base::ScopedVector<char>(128));
      SNPrintF(*buffer, "TooManyFastProperties %s", name_buffer.begin());
      reason = buffer->begin();
    }
#endif
    DirectHandle<Object> maybe_constructor(map->GetConstructor(), isolate);
    if (v8_flags.feedback_normalization && map->new_target_is_base() &&
        IsJSFunction(*maybe_constructor) &&
        !Cast<JSFunction>(*maybe_constructor)->shared()->native()) {
      auto constructor = Cast<JSFunction>(maybe_constructor);
      DCHECK_NE(*constructor, constructor->native_context()->object_function());
      DirectHandle<Map> initial_map(constructor->initial_map(), isolate);
      result = Map::Normalize(isolate, initial_map, CLEAR_INOBJECT_PROPERTIES,
                              reason);
      initial_map->DeprecateTransitionTree(isolate);
      DirectHandle<JSReceiver> prototype(Cast<JSReceiver>(result->prototype()),
                                         isolate);
      JSFunction::SetInitialMap(isolate, constructor, result, prototype);

      // Deoptimize all code that embeds the previous initial map.
      DependentCode::DeoptimizeDependencyGroups(
          isolate, *initial_map, DependentCode::kInitialMapChangedGroup);
      if (!result->EquivalentToForNormalization(*map,
                                                CLEAR_INOBJECT_PROPERTIES)) {
        result =
            Map::Normalize(isolate, map, CLEAR_INOBJECT_PROPERTIES, reason);
      }
    } else {
      result = Map::Normalize(isolate, map, CLEAR_INOBJECT_PROPERTIES, reason);
    }
  }

  return result;
}

Handle<Map> Map::TransitionToAccessorProperty(Isolate* isolate, Handle<Map> map,
                                              DirectHandle<Name> name,
                                              InternalIndex descriptor,
                                              DirectHandle<Object> getter,
                                              DirectHandle<Object> setter,
                                              PropertyAttributes attributes) {
  RCS_SCOPE(
      isolate,
      map->IsDetached(isolate)
          ? RuntimeCallCounterId::kPrototypeMap_TransitionToAccessorProperty
          : RuntimeCallCounterId::kMap_TransitionToAccessorProperty);

  // At least one of the accessors needs to be a new value.
  DCHECK(!IsNull(*getter, isolate) || !IsNull(*setter, isolate));
  DCHECK(IsUniqueName(*name));

  // Migrate to the newest map before transitioning to the new property.
  map = Update(isolate, map);

  // Dictionary maps can always have additional data properties.
  if (map->is_dictionary_map()) return map;

  PropertyNormalizationMode mode = map->is_prototype_map()
                                       ? KEEP_INOBJECT_PROPERTIES
                                       : CLEAR_INOBJECT_PROPERTIES;

  MaybeHandle<Map> maybe_transition = TransitionsAccessor::SearchTransition(
      isolate, map, *name, PropertyKind::kAccessor, attributes);
  Handle<Map> transition;
  if (maybe_transition.ToHandle(&transition)) {
    Tagged<DescriptorArray> descriptors =
        transition->instance_descriptors(isolate);
    InternalIndex last_descriptor = transition->LastAdded();
    DCHECK(descriptors->GetKey(last_descriptor)->Equals(*name));

    DCHECK_EQ(PropertyKind::kAccessor,
              descriptors->GetDetails(last_descriptor).kind());
    DCHECK_EQ(attributes,
              descriptors->GetDetails(last_descriptor).attributes());

    DirectHandle<Object> maybe_pair(
        descriptors->GetStrongValue(last_descriptor), isolate);
    if (!IsAccessorPair(*maybe_pair)) {
      return Map::Normalize(isolate, map, mode,
                            "TransitionToAccessorFromNonPair");
    }

    auto pair = Cast<AccessorPair>(maybe_pair);
    if (!pair->Equals(*getter, *setter)) {
      return Map::Normalize(isolate, map, mode,
                            "TransitionToDifferentAccessor");
    }

    return transition;
  }

  DirectHandle<AccessorPair> pair;
  Tagged<DescriptorArray> old_descriptors = map->instance_descriptors(isolate);
  if (descriptor.is_found()) {
    if (descriptor != map->LastAdded()) {
      return Map::Normalize(isolate, map, mode, "AccessorsOverwritingNonLast");
    }
    PropertyDetails old_details = old_descriptors->GetDetails(descriptor);
    if (old_details.kind() != PropertyKind::kAccessor) {
      return Map::Normalize(isolate, map, mode,
                            "AccessorsOverwritingNonAccessors");
    }

    if (old_details.attributes() != attributes) {
      return Map::Normalize(isolate, map, mode, "AccessorsWithAttributes");
    }

    DirectHandle<Object> maybe_pair(old_descriptors->GetStrongValue(descriptor),
                                    isolate);
    if (!IsAccessorPair(*maybe_pair)) {
      return Map::Normalize(isolate, map, mode, "AccessorsOverwritingNonPair");
    }

    auto current_pair = Cast<AccessorPair>(maybe_pair);
    if (current_pair->Equals(*getter, *setter)) return map;

    bool overwriting_accessor = false;
    if (!IsNull(*getter, isolate) &&
        !IsNull(current_pair->get(ACCESSOR_GETTER), isolate) &&
        current_pair->get(ACCESSOR_GETTER) != *getter) {
      overwriting_accessor = true;
    }
    if (!IsNull(*setter, isolate) &&
        !IsNull(current_pair->get(ACCESSOR_SETTER), isolate) &&
        current_pair->get(ACCESSOR_SETTER) != *setter) {
      overwriting_accessor = true;
    }
    if (overwriting_accessor) {
      return Map::Normalize(isolate, map, mode,
                            "AccessorsOverwritingAccessors");
    }

    pair = AccessorPair::Copy(isolate, Cast<AccessorPair>(maybe_pair));
  } else if (map->NumberOfOwnDescriptors() >= kMaxNumberOfDescriptors ||
             map->TooManyFastProperties(StoreOrigin::kNamed)) {
    return Map::Normalize(isolate, map, CLEAR_INOBJECT_PROPERTIES,
                          "TooManyAccessors");
  } else {
    pair = isolate->factory()->NewAccessorPair();
  }

  pair->SetComponents(*getter, *setter);

  // Do not track transitions during bootstrapping.
  TransitionFlag flag =
      isolate->bootstrapper()->IsActive() ? OMIT_TRANSITION : INSERT_TRANSITION;
  Descriptor d = Descriptor::AccessorConstant(name, pair, attributes);
  return Map::CopyInsertDescriptor(isolate, map, &d, flag);
}

Handle<Map> Map::CopyAddDescriptor(Isolate* isolate, DirectHandle<Map> map,
                                   Descriptor* descriptor,
                                   TransitionFlag flag) {
  DirectHandle<DescriptorArray> descriptors(map->instance_descriptors(isolate),
                                            isolate);

  // Share descriptors only if map owns descriptors and is not an initial map.
  if (flag == INSERT_TRANSITION && map->owns_descriptors() &&
      !IsUndefined(map->GetBackPointer(), isolate) &&
      TransitionsAccessor::CanHaveMoreTransitions(isolate, map)) {
    return ShareDescriptor(isolate, map, descriptors, descriptor);
  }

  int nof = map->NumberOfOwnDescriptors();
  DirectHandle<DescriptorArray> new_descriptors =
      DescriptorArray::CopyUpTo(isolate, descriptors, nof, 1);
  new_descriptors->Append(descriptor);

  return CopyReplaceDescriptors(isolate, map, new_descriptors, flag,
                                descriptor->GetKey(), "CopyAddDescriptor",
                                SIMPLE_PROPERTY_TRANSITION);
}

Handle<Map> Map::CopyInsertDescriptor(Isolate* isolate, DirectHandle<Map> map,
                                      Descriptor* descriptor,
                                      TransitionFlag flag) {
  DirectHandle<DescriptorArray> old_descriptors(
      map->instance_descriptors(isolate), isolate);

  // We replace the key if it is already present.
  InternalIndex index =
      old_descriptors->SearchWithCache(isolate, *descriptor->GetKey(), *map);
  if (index.is_found()) {
    return CopyReplaceDescriptor(isolate, map, old_descriptors, descriptor,
                                 index, flag);
  }
  return CopyAddDescriptor(isolate, map, descriptor, flag);
}

Handle<Map> Map::CopyReplaceDescriptor(
    Isolate* isolate, DirectHandle<Map> map,
    DirectHandle<DescriptorArray> descriptors, Descriptor* descriptor,
    InternalIndex insertion_index, TransitionFlag flag) {
  DirectHandle<Name> key = descriptor->GetKey();
  DCHECK_EQ(*key, descriptors->GetKey(insertion_index));
  // This function does not support replacing property fields as
  // that would break property field counters.
  DCHECK_NE(PropertyLocation::kField, descriptor->GetDetails().location());
  DCHECK_NE(PropertyLocation::kField,
            descriptors->GetDetails(insertion_index).location());

  DirectHandle<DescriptorArray> new_descriptors = DescriptorArray::CopyUpTo(
      isolate, descriptors, map->NumberOfOwnDescriptors());

  new_descriptors->Replace(insertion_index, descriptor);

  TransitionKindFlag simple_flag =
      (insertion_index.as_int() == descriptors->number_of_descriptors() - 1)
          ? SIMPLE_PROPERTY_TRANSITION
          : PROPERTY_TRANSITION;
  return CopyReplaceDescriptors(isolate, map, new_descriptors, flag, key,
                                "CopyReplaceDescriptor", simple_flag);
}

int Map::Hash(Isolate* isolate, Tagged<HeapObject> prototype) {
  // For performance reasons we only hash the 2 most variable fields of a map:
  // prototype and bit_field2.

  int prototype_hash;
  if (IsNull(prototype)) {
    // No identity hash for null, so just pick a random number.
    prototype_hash = 1;
  } else {
    Tagged<JSReceiver> receiver = Cast<JSReceiver>(prototype);
    prototype_hash = receiver->GetOrCreateIdentityHash(isolate).value();
  }

  return prototype_hash ^ bit_field2();
}

namespace {

bool CheckEquivalentModuloProto(const Tagged<Map> first,
                                const Tagged<Map> second) {
  return first->GetConstructorRaw() == second->GetConstructorRaw() &&
         first->instance_type() == second->instance_type() &&
         first->bit_field() == second->bit_field() &&
         first->is_extensible() == second->is_extensible() &&
         first->new_target_is_base() == second->new_target_is_base();
}

}  // namespace

bool Map::EquivalentToForTransition(
    const Tagged<Map> other, ConcurrencyMode cmode,
    DirectHandle<HeapObject> new_prototype) const {
  CHECK_EQ(GetConstructor(), other->GetConstructor());
  CHECK_EQ(instance_type(), other->instance_type());

  if (bit_field() != other->bit_field()) return false;
  if (new_prototype.is_null()) {
    if (prototype() != other->prototype()) return false;
  } else {
    if (*new_prototype != other->prototype()) return false;
  }
  if (new_target_is_base() != other->new_target_is_base()) return false;
  if (InstanceTypeChecker::IsJSFunction(instance_type())) {
    // JSFunctions require more checks to ensure that sloppy function is
    // not equivalent to strict function.
    int nof =
        std::min(NumberOfOwnDescriptors(), other->NumberOfOwnDescriptors());
    Tagged<DescriptorArray> this_descriptors =
        IsConcurrent(cmode) ? instance_descriptors(kAcquireLoad)
                            : instance_descriptors();
    Tagged<DescriptorArray> that_descriptors =
        IsConcurrent(cmode) ? other->instance_descriptors(kAcquireLoad)
                            : other->instance_descriptors();
    return this_descriptors->IsEqualUpTo(that_descriptors, nof);
  }
  return true;
}

bool Map::EquivalentToForElementsKindTransition(const Tagged<Map> other,
                                                ConcurrencyMode cmode) const {
  if (!EquivalentToForTransition(other, cmode)) {
    return false;
  }
#ifdef DEBUG
  // Ensure that we don't try to generate elements kind transitions from maps
  // with fields that may be generalized in-place. This must already be handled
  // during addition of a new field.
  Tagged<DescriptorArray> descriptors = IsConcurrent(cmode)
                                            ? instance_descriptors(kAcquireLoad)
                                            : instance_descriptors();
  for (InternalIndex i : IterateOwnDescriptors()) {
    PropertyDetails details = descriptors->GetDetails(i);
    if (details.location() == PropertyLocation::kField) {
      DCHECK(IsMostGeneralFieldType(details.representation(),
                                    descriptors->GetFieldType(i)));
    }
  }
#endif
  return true;
}

bool Map::EquivalentToForNormalization(const Tagged<Map> other,
                                       ElementsKind elements_kind,
                                       Tagged<HeapObject> other_prototype,
                                       PropertyNormalizationMode mode) const {
  int properties =
      mode == CLEAR_INOBJECT_PROPERTIES ? 0 : other->GetInObjectProperties();
  // Make sure the elements_kind bits are in bit_field2.
  DCHECK_EQ(this->elements_kind(),
            Map::Bits2::ElementsKindBits::decode(bit_field2()));
  int adjusted_other_bit_field2 =
      Map::Bits2::ElementsKindBits::update(other->bit_field2(), elements_kind);
  return CheckEquivalentModuloProto(*this, other) &&
         prototype() == other_prototype &&
         bit_field2() == adjusted_other_bit_field2 &&
         GetInObjectProperties() == properties &&
         JSObject::GetEmbedderFieldCount(*this) ==
             JSObject::GetEmbedderFieldCount(other);
}

int Map::ComputeMinObjectSlack(Isolate* isolate) {
  // Has to be an initial map.
  DCHECK(IsUndefined(GetBackPointer(), isolate));

  int slack = UnusedPropertyFields();
  TransitionsAccessor transitions(isolate, *this);
  TransitionsAccessor::TraverseCallback callback = |&](Tagged<Map> map) {
    slack = std::min(slack, map->UnusedPropertyFields());
  };
  transitions.TraverseTransitionTree(callback);
  return slack;
}

void Map::SetInstanceDescriptors(Isolate* isolate,
                                 Tagged<DescriptorArray> descriptors,
                                 int number_of_own_descriptors,
                                 WriteBarrierMode barrier_mode) {
  DCHECK_IMPLIES(barrier_mode == WriteBarrierMode::SKIP_WRITE_BARRIER,
                 HeapLayout::InReadOnlySpace(descriptors));
  set_instance_descriptors(descriptors, kReleaseStore, barrier_mode);
  SetNumberOfOwnDescriptors(number_of_own_descriptors);
#ifndef V8_DISABLE_WRITE_BARRIERS
  WriteBarrier::ForDescriptorArray(descriptors, number_of_own_descriptors);
#endif
}

// static
Handle<PrototypeInfo> Map::GetOrCreatePrototypeInfo(
    DirectHandle<JSObject> prototype, Isolate* isolate) {
  DCHECK(IsJSObjectThatCanBeTrackedAsPrototype(*prototype));
  {
    Tagged<PrototypeInfo> prototype_info;
    if (prototype->map()->TryGetPrototypeInfo(&prototype_info)) {
      return handle(prototype_info, isolate);
    }
  }
  Handle<PrototypeInfo> proto_info = isolate->factory()->NewPrototypeInfo();
  prototype->map()->set_prototype_info(*proto_info, kReleaseStore);
  return proto_info;
}

// static
Handle<PrototypeInfo> Map::GetOrCreatePrototypeInfo(
    DirectHandle<Map> prototype_map, Isolate* isolate) {
  {
    Tagged<Object> maybe_proto_info = prototype_map->prototype_info();
    if (PrototypeInfo::IsPrototypeInfoFast(maybe_proto_info)) {
      return handle(Cast<PrototypeInfo>(maybe_proto_info), isolate);
    }
  }
  Handle<PrototypeInfo> proto_info = isolate->factory()->NewPrototypeInfo();
  prototype_map->set_prototype_info(*proto_info, kReleaseStore);
  return proto_info;
}

// static
void Map::SetShouldBeFastPrototypeMap(DirectHandle<Map> map, bool value,
                                      Isolate* isolate) {
  DCHECK(map->is_prototype_map());
  if (value == false && !map->has_prototype_info()) {
    // "False" is the implicit default value, so there's nothing to do.
    return;
  }
  GetOrCreatePrototypeInfo(map, isolate)->set_should_be_fast_map(value);
}

// static
Handle<UnionOf<Smi, Cell>> Map::GetOrCreatePrototypeChainValidityCell(
    DirectHandle<Map> map, Isolate* isolate) {
  DirectHandle<Object> maybe_prototype;
  if (IsJSGlobalObjectMap(*map)) {
    DCHECK(map->is_prototype_map());
    // Global object is prototype of a global proxy and therefore we can
    // use its validity cell for guarding global object's prototype change.
    maybe_prototype = isolate->global_object();
  } else {
    maybe_prototype = direct_handle(
        map->GetPrototypeChainRootMap(isolate)->prototype(), isolate);
  }
  if (!IsJSObjectThatCanBeTrackedAsPrototype(*maybe_prototype)) {
    return handle(Map::kPrototypeChainValidSmi, isolate);
  }
  auto prototype = Cast<JSObject>(maybe_prototype);
  // Ensure the prototype is registered with its own prototypes so its cell
  // will be invalidated when necessary.
  JSObject::LazyRegisterPrototypeUser(direct_handle(prototype->map(), isolate),
                                      isolate);

  Tagged<Object> maybe_cell =
      prototype->map()->prototype_validity_cell(kRelaxedLoad);
  // Return existing cell if it's still valid.
  if (IsCell(maybe_cell)) {
    Tagged<Cell> cell = Cast<Cell>(maybe_cell);
    if (cell->value() == Map::kPrototypeChainValidSmi) {
      return handle(cell, isolate);
    }
  }
  // Otherwise create a new cell.
  Handle<Cell> cell = isolate->factory()->NewCell(Map::kPrototypeChainValidSmi);
  prototype->map()->set_prototype_validity_cell(*cell, kRelaxedStore);
  return cell;
}

// static
bool Map::IsPrototypeChainInvalidated(Tagged<Map> map) {
  DCHECK(map->is_prototype_map());
  Tagged<Object> maybe_cell = map->prototype_validity_cell(kRelaxedLoad);
  if (IsCell(maybe_cell)) {
    Tagged<Cell> cell = Cast<Cell>(maybe_cell);
    return cell->value() != Map::kPrototypeChainValidSmi;
  }
  return true;
}

// static
void Map::SetPrototype(Isolate* isolate, DirectHandle<Map> map,
                       DirectHandle<JSPrototype> prototype,
                       bool enable_prototype_setup_mode) {
  RCS_SCOPE(isolate, RuntimeCallCounterId::kMap_SetPrototype);

  if (IsJSObjectThatCanBeTrackedAsPrototype(*prototype)) {
    DirectHandle<JSObject> prototype_jsobj = Cast<JSObject>(prototype);
    JSObject::OptimizeAsPrototype(prototype_jsobj, enable_prototype_setup_mode);
  } else {
    DCHECK(IsNull(*prototype, isolate) || IsJSProxy(*prototype) ||
           IsWasmObject(*prototype) ||
           HeapLayout::InWritableSharedSpace(*prototype));
  }

  WriteBarrierMode wb_mode =
      IsNull(*prototype, isolate) ? SKIP_WRITE_BARRIER : UPDATE_WRITE_BARRIER;
  map->set_prototype(*prototype, wb_mode);
}

void Map::StartInobjectSlackTracking() {
  DCHECK(!this->IsInobjectSlackTrackingInProgress());
  if (UnusedPropertyFields() == 0) return;
  set_construction_counter(Map::kSlackTrackingCounterStart);
}

Handle<Map> Map::TransitionRootMapToPrototypeForNewObject(
    Isolate* isolate, DirectHandle<Map> map,
    DirectHandle<JSPrototype> prototype) {
  DCHECK(IsUndefined(map->GetBackPointer()));
  Handle<Map> new_map = TransitionToUpdatePrototype(isolate, map, prototype);
  if (new_map->GetBackPointer() != *map &&
      map->IsInobjectSlackTrackingInProgress()) {
    // Advance the construction count on the base map to keep it in sync with
    // the transitioned map.
    map->InobjectSlackTrackingStep(isolate);
  }
  return new_map;
}

Handle<Map> Map::TransitionToUpdatePrototype(
    Isolate* isolate, DirectHandle<Map> map,
    DirectHandle<JSPrototype> prototype) {
  Handle<Map> new_map;
  DCHECK_IMPLIES(v8_flags.move_prototype_transitions_first,
                 IsUndefined(map->GetBackPointer()));
  if (auto maybe_map = TransitionsAccessor::GetPrototypeTransition(
          isolate, *map, *prototype)) {
    new_map = handle(*maybe_map, isolate);
  } else {
    new_map = CopyForPrototypeTransition(isolate, map, prototype);
    if (!map->IsDetached(isolate)) {
      TransitionsAccessor::PutPrototypeTransition(isolate, map, prototype,
                                                  new_map);
    }
  }
  DCHECK_IMPLIES(map->IsInobjectSlackTrackingInProgress(),
                 new_map->IsInobjectSlackTrackingInProgress());
  CHECK_IMPLIES(map->IsInobjectSlackTrackingInProgress(),
                map->construction_counter() <= new_map->construction_counter());
  return new_map;
}

Handle<NormalizedMapCache> NormalizedMapCache::New(Isolate* isolate) {
  Handle<WeakFixedArray> array(
      isolate->factory()->NewWeakFixedArray(kEntries, AllocationType::kOld));
  return Cast<NormalizedMapCache>(array);
}

MaybeHandle<Map> NormalizedMapCache::Get(Isolate* isolate,
                                         DirectHandle<Map> fast_map,
                                         ElementsKind elements_kind,
                                         Tagged<HeapObject> prototype,
                                         PropertyNormalizationMode mode) {
  DisallowGarbageCollection no_gc;
  Tagged<MaybeObject> value =
      WeakFixedArray::get(GetIndex(isolate, *fast_map, *prototype));
  Tagged<HeapObject> heap_object;
  if (!value.GetHeapObjectIfWeak(&heap_object)) {
    return MaybeHandle<Map>();
  }

  Tagged<Map> normalized_map = Cast<Map>(heap_object);
  CHECK(normalized_map->is_dictionary_map());
  if (!normalized_map->EquivalentToForNormalization(*fast_map, elements_kind,
                                                    prototype, mode)) {
    return MaybeHandle<Map>();
  }
  return handle(normalized_map, isolate);
}

void NormalizedMapCache::Set(Isolate* isolate, DirectHandle<Map> fast_map,
                             DirectHandle<Map> normalized_map) {
  DisallowGarbageCollection no_gc;
  DCHECK(normalized_map->is_dictionary_map());
  WeakFixedArray::set(GetIndex(isolate, *fast_map, normalized_map->prototype()),
                      MakeWeak(*normalized_map));
}

}  // namespace v8::internal
[Step 49: Duration 11.53 seconds| Input tokens: 2,621,852 | Output tokens: 24,029]
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ Step 50 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

[1;31mGive Feedback / Get Help: https://github.com/BerriAI/litellm/issues/new[0m
LiteLLM.Info: If you need to debug this error, use `litellm._turn_on_debug()'.

Error while generating output:
litellm.RateLimitError: RateLimitError: OpenAIException - Rate limit reached for gpt-5 in organization org-lQBdrbIfGLbs233eAUwbQrrB on tokens per min (TPM): Limit 1000000, Used 882216, Requested 135829. 
Please try again in 1.082s. Visit https://platform.openai.com/account/rate-limits to learn more.
[Step 50: Duration 7.17 seconds]
Error executing request to team member 'V8Search' with arguments {'task': 'In src/ic/store-ic.cc, find StoreIC::Store and StoreIC::UpdateCaches implementations, all handler installation code paths 
(monomorphic/polymorphic/megamorphic), runtime fallback triggers (misses, deoptimizing conditions), and any dictionary/slow handler paths for named property stores. Return code excerpts with file paths and 
approximate line numbers.'}: Error while generating output:
litellm.RateLimitError: RateLimitError: OpenAIException - Rate limit reached for gpt-5 in organization org-lQBdrbIfGLbs233eAUwbQrrB on tokens per min (TPM): Limit 1000000, Used 882216, Requested 135829. 
Please try again in 1.082s. Visit https://platform.openai.com/account/rate-limits to learn more.
Please try again or request to another team member
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'read_file' with arguments: {'file_path': '/Users/tarun/v8/v8/src/objects/map.cc'}                                                                                                             │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
Command: cd /Users/tarun/v8/v8/src && wc -l '/Users/tarun/v8/v8/src/objects/map.cc'
Command: cd /Users/tarun/v8/v8/src && cat '/Users/tarun/v8/v8/src/objects/map.cc'
Observations: // Copyright 2019 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "src/objects/map.h"

#include <optional>

#include "src/common/assert-scope.h"
#include "src/common/globals.h"
#include "src/execution/frames.h"
#include "src/execution/isolate.h"
#include "src/handles/handles-inl.h"
#include "src/handles/maybe-handles.h"
#include "src/heap/heap-layout-inl.h"
#include "src/heap/heap-write-barrier-inl.h"
#include "src/init/bootstrapper.h"
#include "src/logging/log.h"
#include "src/logging/runtime-call-stats-scope.h"
#include "src/objects/arguments-inl.h"
#include "src/objects/descriptor-array.h"
#include "src/objects/elements-kind.h"
#include "src/objects/field-type.h"
#include "src/objects/instance-type.h"
#include "src/objects/js-objects.h"
#include "src/objects/map-updater.h"
#include "src/objects/maybe-object.h"
#include "src/objects/oddball.h"
#include "src/objects/property.h"
#include "src/objects/transitions-inl.h"
#include "src/roots/roots.h"
#include "src/utils/ostreams.h"
#include "src/zone/zone-containers.h"

namespace v8::internal {

Tagged<Map> Map::GetPrototypeChainRootMap(Isolate* isolate) const {
  DisallowGarbageCollection no_alloc;
  if (IsJSReceiverMap(*this)) {
    return *this;
  }
  int constructor_function_index = GetConstructorFunctionIndex();
  if (constructor_function_index != Map::kNoConstructorFunctionIndex) {
    Tagged<Context> native_context = isolate->context()->native_context();
    Tagged<JSFunction> constructor_function =
        Cast<JSFunction>(native_context->get(constructor_function_index));
    return constructor_function->initial_map();
  }
  return ReadOnlyRoots(isolate).null_value()->map();
}

// static
std::optional<Tagged<JSFunction>> Map::GetConstructorFunction(
    Tagged<Map> map, Tagged<Context> native_context) {
  DisallowGarbageCollection no_gc;
  if (IsPrimitiveMap(map)) {
    int const constructor_function_index = map->GetConstructorFunctionIndex();
    if (constructor_function_index != kNoConstructorFunctionIndex) {
      return Cast<JSFunction>(native_context->get(constructor_function_index));
    }
  }
  return {};
}

VisitorId Map::GetVisitorId(Tagged<Map> map) {
  static_assert(kVisitorIdCount <= 256);

  const int instance_type = map->instance_type();

  if (instance_type < FIRST_NONSTRING_TYPE) {
    switch (instance_type & kStringRepresentationMask) {
      case kSeqStringTag:
        if ((instance_type & kStringEncodingMask) == kOneByteStringTag) {
          return kVisitSeqOneByteString;
        } else {
          return kVisitSeqTwoByteString;
        }

      case kConsStringTag:
        if (IsShortcutCandidate(instance_type)) {
          return kVisitShortcutCandidate;
        } else {
          return kVisitConsString;
        }

      case kSlicedStringTag:
        return kVisitSlicedString;

      case kExternalStringTag:
        return kVisitExternalString;

      case kThinStringTag:
        return kVisitThinString;
    }
    UNREACHABLE();
  }

  if (InstanceTypeChecker::IsJSApiObject(map->instance_type())) {
    return kVisitJSApiObject;
  }

  switch (instance_type) {
    case FILLER_TYPE:
      return kVisitFiller;
    case FREE_SPACE_TYPE:
      return kVisitFreeSpace;

    case EMBEDDER_DATA_ARRAY_TYPE:
      return kVisitEmbedderDataArray;

    case NAME_TO_INDEX_HASH_TABLE_TYPE:
    case REGISTERED_SYMBOL_TABLE_TYPE:
    case HASH_TABLE_TYPE:
    case ORDERED_HASH_MAP_TYPE:
    case ORDERED_HASH_SET_TYPE:
    case ORDERED_NAME_DICTIONARY_TYPE:
    case NAME_DICTIONARY_TYPE:
    case GLOBAL_DICTIONARY_TYPE:
    case NUMBER_DICTIONARY_TYPE:
    case SIMPLE_NUMBER_DICTIONARY_TYPE:
      return kVisitFixedArray;

    case SLOPPY_ARGUMENTS_ELEMENTS_TYPE:
      return kVisitSloppyArgumentsElements;

    case AWAIT_CONTEXT_TYPE:
    case BLOCK_CONTEXT_TYPE:
    case CATCH_CONTEXT_TYPE:
    case DEBUG_EVALUATE_CONTEXT_TYPE:
    case EVAL_CONTEXT_TYPE:
    case FUNCTION_CONTEXT_TYPE:
    case MODULE_CONTEXT_TYPE:
    case SCRIPT_CONTEXT_TYPE:
    case WITH_CONTEXT_TYPE:
      return kVisitContext;

    case NATIVE_CONTEXT_TYPE:
      return kVisitNativeContext;

    case EPHEMERON_HASH_TABLE_TYPE:
      return kVisitEphemeronHashTable;

    case PROPERTY_ARRAY_TYPE:
      return kVisitPropertyArray;

    case FEEDBACK_CELL_TYPE:
      return kVisitFeedbackCell;

    case FEEDBACK_METADATA_TYPE:
      return kVisitFeedbackMetadata;

    case ODDBALL_TYPE:
      return kVisitOddball;

    case HOLE_TYPE:
      return kVisitHole;

    case MAP_TYPE:
      return kVisitMap;

    case CELL_TYPE:
      return kVisitCell;

    case PROPERTY_CELL_TYPE:
      return kVisitPropertyCell;

    case CONTEXT_SIDE_PROPERTY_CELL_TYPE:
      return kVisitContextSidePropertyCell;

    case TRANSITION_ARRAY_TYPE:
      return kVisitTransitionArray;

    case JS_WEAK_MAP_TYPE:
    case JS_WEAK_SET_TYPE:
      return kVisitJSWeakCollection;

    case ACCESSOR_INFO_TYPE:
      return kVisitAccessorInfo;

    case FUNCTION_TEMPLATE_INFO_TYPE:
      return kVisitFunctionTemplateInfo;

    case OBJECT_TEMPLATE_INFO_TYPE:
      return kVisitStruct;

    case JS_PROXY_TYPE:
      return kVisitStruct;

    case SYMBOL_TYPE:
      return kVisitSymbol;

    case JS_ARRAY_BUFFER_TYPE:
      return kVisitJSArrayBuffer;

    case JS_DATA_VIEW_TYPE:
    case JS_RAB_GSAB_DATA_VIEW_TYPE:
      return kVisitJSDataViewOrRabGsabDataView;

    case JS_EXTERNAL_OBJECT_TYPE:
      return kVisitJSExternalObject;

    case JS_FUNCTION_TYPE:
    case JS_CLASS_CONSTRUCTOR_TYPE:
    case JS_PROMISE_CONSTRUCTOR_TYPE:
    case JS_REG_EXP_CONSTRUCTOR_TYPE:
    case JS_ARRAY_CONSTRUCTOR_TYPE:
#define TYPED_ARRAY_CONSTRUCTORS_SWITCH(Type, type, TYPE, Ctype) \
  case TYPE##_TYPED_ARRAY_CONSTRUCTOR_TYPE:
      TYPED_ARRAYS(TYPED_ARRAY_CONSTRUCTORS_SWITCH)
#undef TYPED_ARRAY_CONSTRUCTORS_SWITCH
      return kVisitJSFunction;

    case JS_TYPED_ARRAY_TYPE:
      return kVisitJSTypedArray;

    case SMALL_ORDERED_HASH_MAP_TYPE:
      return kVisitSmallOrderedHashMap;

    case SMALL_ORDERED_HASH_SET_TYPE:
      return kVisitSmallOrderedHashSet;

    case SMALL_ORDERED_NAME_DICTIONARY_TYPE:
      return kVisitSmallOrderedNameDictionary;

    case SWISS_NAME_DICTIONARY_TYPE:
      return kVisitSwissNameDictionary;

    case SHARED_FUNCTION_INFO_TYPE:
      return kVisitSharedFunctionInfo;

    case PREPARSE_DATA_TYPE:
      return kVisitPreparseData;

    case COVERAGE_INFO_TYPE:
      return kVisitCoverageInfo;

    // Objects that may have embedder fields but otherwise are just a regular
    // JSObject.
    case JS_PROMISE_TYPE: {
      const bool has_raw_data_fields =
          COMPRESS_POINTERS_BOOL && JSObject::GetEmbedderFieldCount(map) > 0;
      return has_raw_data_fields ? kVisitJSObject : kVisitJSObjectFast;
    }

    // Objects that are guaranteed to not have any embedder fields and just
    // behave like regular JSObject.
    case JS_ARGUMENTS_OBJECT_TYPE:
    case JS_ARRAY_ITERATOR_PROTOTYPE_TYPE:
    case JS_ARRAY_ITERATOR_TYPE:
    case JS_ARRAY_TYPE:
    case JS_ASYNC_DISPOSABLE_STACK_TYPE:
    case JS_ASYNC_FROM_SYNC_ITERATOR_TYPE:
    case JS_ASYNC_FUNCTION_OBJECT_TYPE:
    case JS_ASYNC_GENERATOR_OBJECT_TYPE:
    case JS_CONTEXT_EXTENSION_OBJECT_TYPE:
    case JS_DISPOSABLE_STACK_BASE_TYPE:
    case JS_ERROR_TYPE:
    case JS_GENERATOR_OBJECT_TYPE:
    case JS_ITERATOR_FILTER_HELPER_TYPE:
    case JS_ITERATOR_MAP_HELPER_TYPE:
    case JS_ITERATOR_TAKE_HELPER_TYPE:
    case JS_ITERATOR_DROP_HELPER_TYPE:
    case JS_ITERATOR_FLAT_MAP_HELPER_TYPE:
    case JS_ITERATOR_PROTOTYPE_TYPE:
    case JS_MAP_ITERATOR_PROTOTYPE_TYPE:
    case JS_MAP_KEY_ITERATOR_TYPE:
    case JS_MAP_KEY_VALUE_ITERATOR_TYPE:
    case JS_MAP_TYPE:
    case JS_MAP_VALUE_ITERATOR_TYPE:
    case JS_MESSAGE_OBJECT_TYPE:
    case JS_MODULE_NAMESPACE_TYPE:
    case JS_OBJECT_PROTOTYPE_TYPE:
    case JS_OBJECT_TYPE:
    case JS_PRIMITIVE_WRAPPER_TYPE:
    case JS_PROMISE_PROTOTYPE_TYPE:
    case JS_REG_EXP_PROTOTYPE_TYPE:
    case JS_REG_EXP_STRING_ITERATOR_TYPE:
    case JS_SET_ITERATOR_PROTOTYPE_TYPE:
    case JS_SET_KEY_VALUE_ITERATOR_TYPE:
    case JS_SET_PROTOTYPE_TYPE:
    case JS_SET_TYPE:
    case JS_SET_VALUE_ITERATOR_TYPE:
    case JS_SYNC_DISPOSABLE_STACK_TYPE:
    case JS_SHADOW_REALM_TYPE:
    case JS_SHARED_ARRAY_TYPE:
    case JS_SHARED_STRUCT_TYPE:
    case JS_STRING_ITERATOR_PROTOTYPE_TYPE:
    case JS_STRING_ITERATOR_TYPE:
    case JS_TEMPORAL_CALENDAR_TYPE:
    case JS_TEMPORAL_DURATION_TYPE:
    case JS_TEMPORAL_INSTANT_TYPE:
    case JS_TEMPORAL_PLAIN_DATE_TYPE:
    case JS_TEMPORAL_PLAIN_DATE_TIME_TYPE:
    case JS_TEMPORAL_PLAIN_MONTH_DAY_TYPE:
    case JS_TEMPORAL_PLAIN_TIME_TYPE:
    case JS_TEMPORAL_PLAIN_YEAR_MONTH_TYPE:
    case JS_TEMPORAL_TIME_ZONE_TYPE:
    case JS_TEMPORAL_ZONED_DATE_TIME_TYPE:
    case JS_TYPED_ARRAY_PROTOTYPE_TYPE:
    case JS_VALID_ITERATOR_WRAPPER_TYPE:
    case JS_RAW_JSON_TYPE:
#ifdef V8_INTL_SUPPORT
    case JS_V8_BREAK_ITERATOR_TYPE:
    case JS_COLLATOR_TYPE:
    case JS_DATE_TIME_FORMAT_TYPE:
    case JS_DISPLAY_NAMES_TYPE:
    case JS_DURATION_FORMAT_TYPE:
    case JS_LIST_FORMAT_TYPE:
    case JS_LOCALE_TYPE:
    case JS_NUMBER_FORMAT_TYPE:
    case JS_PLURAL_RULES_TYPE:
    case JS_RELATIVE_TIME_FORMAT_TYPE:
    case JS_SEGMENT_ITERATOR_TYPE:
    case JS_SEGMENTER_TYPE:
    case JS_SEGMENTS_TYPE:
#endif  // V8_INTL_SUPPORT
#if V8_ENABLE_WEBASSEMBLY
    case WASM_EXCEPTION_PACKAGE_TYPE:
    case WASM_MODULE_OBJECT_TYPE:
    case WASM_VALUE_OBJECT_TYPE:
#endif  // V8_ENABLE_WEBASSEMBLY
    case JS_BOUND_FUNCTION_TYPE:
    case JS_WRAPPED_FUNCTION_TYPE: {
      CHECK_EQ(0, JSObject::GetEmbedderFieldCount(map));
      return kVisitJSObjectFast;
    }
    case JS_REG_EXP_TYPE:
      return kVisitJSRegExp;

    // Objects that are used as API wrapper objects and can have embedder
    // fields. Note that there's more of these kinds (e.g. JS_ARRAY_BUFFER_TYPE)
    // but they have their own visitor id for other reasons
    case JS_API_OBJECT_TYPE:
    case JS_GLOBAL_PROXY_TYPE:
    case JS_GLOBAL_OBJECT_TYPE:
    case JS_SPECIAL_API_OBJECT_TYPE:
      return kVisitJSApiObject;

    case JS_DATE_TYPE:
      return kVisitJSDate;

    case JS_WEAK_REF_TYPE:
      return kVisitJSWeakRef;

    case WEAK_CELL_TYPE:
      return kVisitWeakCell;

    case JS_FINALIZATION_REGISTRY_TYPE:
      return kVisitJSFinalizationRegistry;

    case JS_ATOMICS_MUTEX_TYPE:
    case JS_ATOMICS_CONDITION_TYPE:
      return kVisitJSSynchronizationPrimitive;

    case HEAP_NUMBER_TYPE:
      return kVisitHeapNumber;

    case FOREIGN_TYPE:
      return kVisitForeign;

    case BIGINT_TYPE:
      return kVisitBigInt;

    case ALLOCATION_SITE_TYPE:
      return kVisitAllocationSite;

    // Here we list all structs explicitly on purpose. This forces new structs
    // to choose a VisitorId explicitly.
    case PROMISE_FULFILL_REACTION_JOB_TASK_TYPE:
    case PROMISE_REJECT_REACTION_JOB_TASK_TYPE:
    case CALLABLE_TASK_TYPE:
    case CALLBACK_TASK_TYPE:
    case PROMISE_RESOLVE_THENABLE_JOB_TASK_TYPE:
    case ACCESS_CHECK_INFO_TYPE:
    case ACCESSOR_PAIR_TYPE:
    case ALIASED_ARGUMENTS_ENTRY_TYPE:
    case ALLOCATION_MEMENTO_TYPE:
    case ARRAY_BOILERPLATE_DESCRIPTION_TYPE:
    case ASYNC_GENERATOR_REQUEST_TYPE:
    case BREAK_POINT_TYPE:
    case BREAK_POINT_INFO_TYPE:
    case CLASS_BOILERPLATE_TYPE:
    case CLASS_POSITIONS_TYPE:
    case ENUM_CACHE_TYPE:
    case ERROR_STACK_DATA_TYPE:
    case FUNCTION_TEMPLATE_RARE_DATA_TYPE:
    case INTERCEPTOR_INFO_TYPE:
    case MODULE_REQUEST_TYPE:
    case PROMISE_CAPABILITY_TYPE:
    case PROMISE_REACTION_TYPE:
    case PROPERTY_DESCRIPTOR_OBJECT_TYPE:
    case SCRIPT_TYPE:
    case SCRIPT_OR_MODULE_TYPE:
    case SOURCE_TEXT_MODULE_INFO_ENTRY_TYPE:
    case STACK_FRAME_INFO_TYPE:
    case STACK_TRACE_INFO_TYPE:
    case TEMPLATE_OBJECT_DESCRIPTION_TYPE:
    case TUPLE2_TYPE:
#if V8_ENABLE_WEBASSEMBLY
    case ASM_WASM_DATA_TYPE:
    case WASM_EXCEPTION_TAG_TYPE:
#endif
      return kVisitStruct;

    case PROTOTYPE_INFO_TYPE:
      return kVisitPrototypeInfo;

    case DEBUG_INFO_TYPE:
      return kVisitDebugInfo;

    case CALL_SITE_INFO_TYPE:
      return kVisitCallSiteInfo;

    case BYTECODE_WRAPPER_TYPE:
      return kVisitBytecodeWrapper;

    case CODE_WRAPPER_TYPE:
      return kVisitCodeWrapper;

    case REG_EXP_BOILERPLATE_DESCRIPTION_TYPE:
      return kVisitRegExpBoilerplateDescription;

    case REG_EXP_DATA_WRAPPER_TYPE:
      return kVisitRegExpDataWrapper;

    case LOAD_HANDLER_TYPE:
    case STORE_HANDLER_TYPE:
      return kVisitDataHandler;

    case SOURCE_TEXT_MODULE_TYPE:
      return kVisitSourceTextModule;
    case SYNTHETIC_MODULE_TYPE:
      return kVisitSyntheticModule;

#if V8_ENABLE_WEBASSEMBLY
    case WASM_ARRAY_TYPE:
      return kVisitWasmArray;
    case WASM_CONTINUATION_OBJECT_TYPE:
      return kVisitWasmContinuationObject;
    case WASM_MEMORY_MAP_DESCRIPTOR_TYPE:
      return kVisitWasmMemoryMapDescriptor;
    case WASM_FUNC_REF_TYPE:
      return kVisitWasmFuncRef;
    case WASM_GLOBAL_OBJECT_TYPE:
      return kVisitWasmGlobalObject;
    case WASM_INSTANCE_OBJECT_TYPE:
      return kVisitWasmInstanceObject;
    case WASM_MEMORY_OBJECT_TYPE:
      return kVisitWasmMemoryObject;
    case WASM_NULL_TYPE:
      return kVisitWasmNull;
    case WASM_RESUME_DATA_TYPE:
      return kVisitWasmResumeData;
    case WASM_STRUCT_TYPE:
      return kVisitWasmStruct;
    case WASM_SUSPENDER_OBJECT_TYPE:
      return kVisitWasmSuspenderObject;
    case WASM_SUSPENDING_OBJECT_TYPE:
      return kVisitWasmSuspendingObject;
    case WASM_TABLE_OBJECT_TYPE:
      return kVisitWasmTableObject;
    case WASM_TAG_OBJECT_TYPE:
      return kVisitWasmTagObject;
    case WASM_TYPE_INFO_TYPE:
      return kVisitWasmTypeInfo;
#endif  // V8_ENABLE_WEBASSEMBLY

#define MAKE_TQ_CASE(TYPE, Name) \
  case TYPE:                     \
    return kVisit##Name;
      TORQUE_INSTANCE_TYPE_TO_BODY_DESCRIPTOR_LIST(MAKE_TQ_CASE)
#undef MAKE_TQ_CASE

#define CASE(TypeCamelCase, TYPE_UPPER_CASE) \
  case TYPE_UPPER_CASE##_TYPE:               \
    return kVisit##TypeCamelCase;
      SIMPLE_HEAP_OBJECT_LIST2(CASE)
      CONCRETE_TRUSTED_OBJECT_TYPE_LIST2(CASE)
#undef CASE
  }
  std::string name = ToString(map->instance_type());
  FATAL("Instance type %s (code %d) not mapped to VisitorId.", name.c_str(),
        instance_type);
}

// static
MaybeObjectHandle Map::WrapFieldType(Handle<FieldType> type) {
  if (IsClass(*type)) {
    return MaybeObjectHandle::Weak(FieldType::AsClass(type));
  }
  return MaybeObjectHandle(type);
}

// static
Tagged<FieldType> Map::UnwrapFieldType(Tagged<MaybeObject> wrapped_type) {
  DCHECK(!wrapped_type.IsCleared());
  Tagged<HeapObject> heap_object;
  if (wrapped_type.GetHeapObjectIfWeak(&heap_object)) {
    return Cast<FieldType>(heap_object);
  }
  return Cast<FieldType>(wrapped_type);
}

MaybeHandle<Map> Map::CopyWithField(Isolate* isolate, DirectHandle<Map> map,
                                    DirectHandle<Name> name,
                                    Handle<FieldType> type,
                                    PropertyAttributes attributes,
                                    PropertyConstness constness,
                                    Representation representation,
                                    TransitionFlag flag) {
  DCHECK(map->instance_descriptors(isolate)
             ->Search(*name, map->NumberOfOwnDescriptors())
             .is_not_found());

  // Ensure the descriptor array does not get too big.
  if (map->NumberOfOwnDescriptors() >= kMaxNumberOfDescriptors) {
    return MaybeHandle<Map>();
  }

  // Compute the new index for new field.
  int index = map->NextFreePropertyIndex();

  if (map->instance_type() == JS_CONTEXT_EXTENSION_OBJECT_TYPE) {
    constness = PropertyConstness::kMutable;
    representation = Representation::Tagged();
    type = FieldType::Any(isolate);
  } else {
    Map::GeneralizeIfCanHaveTransitionableFastElementsKind(
        isolate, map->instance_type(), &representation, &type);
  }

  MaybeObjectHandle wrapped_type = WrapFieldType(type);

  Descriptor d = Descriptor::DataField(name, index, attributes, constness,
                                       representation, wrapped_type);
  Handle<Map> new_map = Map::CopyAddDescriptor(isolate, map, &d, flag);
  new_map->AccountAddedPropertyField();
  return new_map;
}

MaybeHandle<Map> Map::CopyWithConstant(Isolate* isolate, DirectHandle<Map> map,
                                       DirectHandle<Name> name,
                                       DirectHandle<Object> constant,
                                       PropertyAttributes attributes,
                                       TransitionFlag flag) {
  // Ensure the descriptor array does not get too big.
  if (map->NumberOfOwnDescriptors() >= kMaxNumberOfDescriptors) {
    return MaybeHandle<Map>();
  }

  Representation representation =
      Object::OptimalRepresentation(*constant, isolate);
  Handle<FieldType> type =
      Object::OptimalType(*constant, isolate, representation);
  return CopyWithField(isolate, map, name, type, attributes,
                       PropertyConstness::kConst, representation, flag);
}

bool Map::InstancesNeedRewriting(Tagged<Map> target,
                                 ConcurrencyMode cmode) const {
  int target_number_of_fields = target->NumberOfFields(cmode);
  int target_inobject = target->GetInObjectProperties();
  int target_unused = target->UnusedPropertyFields();
  int old_number_of_fields;

  return InstancesNeedRewriting(target, target_number_of_fields,
                                target_inobject, target_unused,
                                &old_number_of_fields, cmode);
}

bool Map::InstancesNeedRewriting(Tagged<Map> target,
                                 int target_number_of_fields,
                                 int target_inobject, int target_unused,
                                 int* old_number_of_fields,
                                 ConcurrencyMode cmode) const {
  // If fields were added (or removed), rewrite the instance.
  *old_number_of_fields = NumberOfFields(cmode);
  DCHECK(target_number_of_fields >= *old_number_of_fields);
  if (target_number_of_fields != *old_number_of_fields) return true;

  // If smi descriptors were replaced by double descriptors, rewrite.
  Tagged<DescriptorArray> old_desc = IsConcurrent(cmode)
                                         ? instance_descriptors(kAcquireLoad)
                                         : instance_descriptors();
  Tagged<DescriptorArray> new_desc =
      IsConcurrent(cmode) ? target->instance_descriptors(kAcquireLoad)
                          : target->instance_descriptors();
  for (InternalIndex i : IterateOwnDescriptors()) {
    if (new_desc->GetDetails(i).representation().IsDouble() !=
        old_desc->GetDetails(i).representation().IsDouble()) {
      return true;
    }
  }

  // If no fields were added, and no inobject properties were removed, setting
  // the map is sufficient.
  if (target_inobject == GetInObjectProperties()) return false;
  // In-object slack tracking may have reduced the object size of the new map.
  // In that case, succeed if all existing fields were inobject, and they still
  // fit within the new inobject size.
  DCHECK(target_inobject < GetInObjectProperties());
  if (target_number_of_fields <= target_inobject) {
    DCHECK(target_number_of_fields + target_unused == target_inobject);
    return false;
  }
  // Otherwise, properties will need to be moved to the backing store.
  return true;
}

int Map::NumberOfFields(ConcurrencyMode cmode) const {
  Tagged<DescriptorArray> descriptors = IsConcurrent(cmode)
                                            ? instance_descriptors(kAcquireLoad)
                                            : instance_descriptors();
  int result = 0;
  for (InternalIndex i : IterateOwnDescriptors()) {
    if (descriptors->GetDetails(i).location() == PropertyLocation::kField)
      result++;
  }
  return result;
}

Map::FieldCounts Map::GetFieldCounts() const {
  Tagged<DescriptorArray> descriptors = instance_descriptors();
  int mutable_count = 0;
  int const_count = 0;
  for (InternalIndex i : IterateOwnDescriptors()) {
    PropertyDetails details = descriptors->GetDetails(i);
    if (details.location() == PropertyLocation::kField) {
      switch (details.constness()) {
        case PropertyConstness::kMutable:
          mutable_count++;
          break;
        case PropertyConstness::kConst:
          const_count++;
          break;
      }
    }
  }
  return FieldCounts(mutable_count, const_count);
}

void Map::DeprecateTransitionTree(Isolate* isolate) {
  if (is_deprecated()) return;
  DisallowGarbageCollection no_gc;
  ReadOnlyRoots roots(isolate);
  TransitionsAccessor transitions(isolate, *this);
  transitions.ForEachTransition(
      &no_gc, |&](Tagged<Map> map) { map->DeprecateTransitionTree(isolate); },
      |&](Tagged<Map> map) {
        if (v8_flags.move_prototype_transitions_first) {
          map->DeprecateTransitionTree(isolate);
        }
      },
      nullptr);
  DCHECK(!IsFunctionTemplateInfo(constructor_or_back_pointer()));
  DCHECK(CanBeDeprecated());
  set_is_deprecated(true);
  if (v8_flags.log_maps) {
    LOG(isolate, MapEvent("Deprecate", direct_handle(*this, isolate), {}));
  }
  DependentCode::DeoptimizeDependencyGroups(isolate, *this,
                                            DependentCode::kTransitionGroup);
  NotifyLeafMapLayoutChange(isolate);
}

// Installs |new_descriptors| over the current instance_descriptors to ensure
// proper sharing of descriptor arrays.
void Map::ReplaceDescriptors(Isolate* isolate,
                             Tagged<DescriptorArray> new_descriptors) {
  PtrComprCageBase cage_base(isolate);
  // Don't overwrite the empty descriptor array or initial map's descriptors.
  if (NumberOfOwnDescriptors() == 0 ||
      IsUndefined(GetBackPointer(cage_base), isolate)) {
    return;
  }

  Tagged<DescriptorArray> to_replace = instance_descriptors(cage_base);
  // Replace descriptors by new_descriptors in all maps that share it. The old
  // descriptors will not be trimmed in the mark-compactor, we need to mark
  // all its elements.
  Tagged<Map> current = *this;
#ifndef V8_DISABLE_WRITE_BARRIERS
  WriteBarrier::ForDescriptorArray(to_replace,
                                   to_replace->number_of_descriptors());
#endif
  while (current->instance_descriptors(cage_base) == to_replace) {
    Tagged<Map> next;
    if (!current->TryGetBackPointer(cage_base, &next)) {
      break;  // Stop overwriting at initial map.
    }
    current->SetEnumLength(kInvalidEnumCacheSentinel);
    current->UpdateDescriptors(isolate, new_descriptors,
                               current->NumberOfOwnDescriptors());
    current = next;
  }
  set_owns_descriptors(false);
}

Tagged<Map> Map::FindRootMap(PtrComprCageBase cage_base) const {
  DisallowGarbageCollection no_gc;
  Tagged<Map> result = *this;
  while (true) {
    Tagged<Map> parent;
    if (!result->TryGetBackPointer(cage_base, &parent)) {
      // Initial map must not contain descriptors in the descriptors array
      // that do not belong to the map.
      DCHECK_LE(result->NumberOfOwnDescriptors(),
                result->instance_descriptors(cage_base, kRelaxedLoad)
                    ->number_of_descriptors());
      return result;
    }
    result = parent;
  }
}

Tagged<Map> Map::FindFieldOwner(PtrComprCageBase cage_base,
                                InternalIndex descriptor) const {
  DisallowGarbageCollection no_gc;
  DCHECK_EQ(PropertyLocation::kField,
            instance_descriptors(cage_base, kRelaxedLoad)
                ->GetDetails(descriptor)
                .location());
  Tagged<Map> result = *this;
  while (true) {
    Tagged<Map> parent;
    if (!result->TryGetBackPointer(cage_base, &parent)) break;
    if (parent->NumberOfOwnDescriptors() <= descriptor.as_int()) break;
    result = parent;
  }
  return result;
}

namespace {

Tagged<Map> SearchMigrationTarget(Isolate* isolate, Tagged<Map> old_map) {
  DisallowGarbageCollection no_gc;

  Tagged<Map> target = old_map;
  do {
    target = TransitionsAccessor(isolate, target).GetMigrationTarget();
  } while (!target.is_null() && target->is_deprecated());
  if (target.is_null()) return Map();

  SLOW_DCHECK(MapUpdater::TryUpdateNoLock(
                  isolate, old_map, ConcurrencyMode::kSynchronous) == target);
  return target;
}
}  // namespace

// static
MaybeHandle<Map> Map::TryUpdate(Isolate* isolate, Handle<Map> old_map) {
  DisallowGarbageCollection no_gc;
  DisallowDeoptimization no_deoptimization(isolate);

  if (!old_map->is_deprecated()) return old_map;

  if (v8_flags.fast_map_update) {
    Tagged<Map> target_map = SearchMigrationTarget(isolate, *old_map);
    if (!target_map.is_null()) {
      return handle(target_map, isolate);
    }
  }

  std::optional<Tagged<Map>> new_map = MapUpdater::TryUpdateNoLock(
      isolate, *old_map, ConcurrencyMode::kSynchronous);
  if (!new_map.has_value()) return MaybeHandle<Map>();
  if (v8_flags.fast_map_update) {
    TransitionsAccessor::SetMigrationTarget(isolate, old_map, new_map.value());
  }
  return handle(new_map.value(), isolate);
}

Tagged<Map> Map::TryReplayPropertyTransitions(Isolate* isolate,
                                              Tagged<Map> old_map,
                                              ConcurrencyMode cmode) {
  DisallowGarbageCollection no_gc;

  const int root_nof = NumberOfOwnDescriptors();
  const int old_nof = old_map->NumberOfOwnDescriptors();
  // TODO(jgruber,chromium:1239009): The main thread should use non-atomic
  // reads, but this currently leads to odd behavior (see the linked bug).
  // Investigate and fix this properly. Also below and in called functions.
  Tagged<DescriptorArray> old_descriptors =
      old_map->instance_descriptors(isolate, kAcquireLoad);

  Tagged<Map> new_map = *this;
  for (InternalIndex i : InternalIndex::Range(root_nof, old_nof)) {
    PropertyDetails old_details = old_descriptors->GetDetails(i);
    Tagged<Map> transition =
        TransitionsAccessor(isolate, new_map, IsConcurrent(cmode))
            .SearchTransition(old_descriptors->GetKey(i), old_details.kind(),
                              old_details.attributes());
    if (transition.is_null()) return Map();
    new_map = transition;
    Tagged<DescriptorArray> new_descriptors =
        new_map->instance_descriptors(isolate, kAcquireLoad);

    PropertyDetails new_details = new_descriptors->GetDetails(i);
    DCHECK_EQ(old_details.kind(), new_details.kind());
    DCHECK_EQ(old_details.attributes(), new_details.attributes());
    if (!IsGeneralizableTo(old_details.constness(), new_details.constness())) {
      return Map();
    }
    DCHECK(IsGeneralizableTo(old_details.location(), new_details.location()));
    if (!old_details.representation().fits_into(new_details.representation())) {
      return Map();
    }
    if (new_details.location() == PropertyLocation::kField) {
      if (new_details.kind() == PropertyKind::kData) {
        Tagged<FieldType> new_type = new_descriptors->GetFieldType(i);
        DCHECK_EQ(PropertyKind::kData, old_details.kind());
        DCHECK_EQ(PropertyLocation::kField, old_details.location());
        Tagged<FieldType> old_type = old_descriptors->GetFieldType(i);
        if (!FieldType::NowIs(old_type, new_type)) {
          return Map();
        }
      } else {
        DCHECK_EQ(PropertyKind::kAccessor, new_details.kind());
#ifdef DEBUG
        Tagged<FieldType> new_type = new_descriptors->GetFieldType(i);
        DCHECK(IsAny(new_type));
#endif
        UNREACHABLE();
      }
    } else {
      DCHECK_EQ(PropertyLocation::kDescriptor, new_details.location());
      if (old_details.location() == PropertyLocation::kField ||
          old_descriptors->GetStrongValue(i) !=
              new_descriptors->GetStrongValue(i)) {
        return Map();
      }
    }
  }
  if (new_map->NumberOfOwnDescriptors() != old_nof) return Map();
  return new_map;
}

// static
template <template <typename> typename HandleType>
  requires(std::is_convertible_v<HandleType<Map>, DirectHandle<Map>>)
HandleType<Map> Map::Update(Isolate* isolate, HandleType<Map> map) {
  if (!map->is_deprecated()) return map;
  if (v8_flags.fast_map_update) {
    Tagged<Map> target_map = SearchMigrationTarget(isolate, *map);
    if (!target_map.is_null()) {
      return HandleType<Map>(target_map, isolate);
    }
  }
  if constexpr (std::is_convertible_v<HandleType<Map>, Handle<Map>>) {
    return MapUpdater{isolate, map}.Update();
  } else {
    return MapUpdater{isolate, indirect_handle(map, isolate)}.Update();
  }
}

template V8_EXPORT_PRIVATE DirectHandle<Map> Map::Update(Isolate* isolate,
                                                         DirectHandle<Map> map);
template V8_EXPORT_PRIVATE IndirectHandle<Map> Map::Update(
    Isolate* isolate, IndirectHandle<Map> map);

void Map::EnsureDescriptorSlack(Isolate* isolate, DirectHandle<Map> map,
                                int slack) {
  // Only supports adding slack to owned descriptors.
  CHECK(map->owns_descriptors());

  DirectHandle<DescriptorArray> descriptors(map->instance_descriptors(isolate),
                                            isolate);
  int old_size = map->NumberOfOwnDescriptors();
  if (slack <= descriptors->number_of_slack_descriptors()) return;

  DirectHandle<DescriptorArray> new_descriptors =
      DescriptorArray::CopyUpTo(isolate, descriptors, old_size, slack);

  DisallowGarbageCollection no_gc;
  if (old_size == 0) {
    map->UpdateDescriptors(isolate, *new_descriptors,
                           map->NumberOfOwnDescriptors());
    return;
  }

  // If the source descriptors had an enum cache we copy it. This ensures
  // that the maps to which we push the new descriptor array back can rely
  // on a cache always being available once it is set. If the map has more
  // enumerated descriptors than available in the original cache, the cache
  // will be lazily replaced by the extended cache when needed.
  new_descriptors->CopyEnumCacheFrom(*descriptors);

  // Replace descriptors by new_descriptors in all maps that share it. The old
  // descriptors will not be trimmed in the mark-compactor, we need to mark
  // all its elements.
#ifndef V8_DISABLE_WRITE_BARRIERS
  WriteBarrier::ForDescriptorArray(*descriptors,
                                   descriptors->number_of_descriptors());
#endif

  // Update the descriptors from {map} (inclusive) until the initial map
  // (exclusive). In the case that {map} is the initial map, update it.
  map->UpdateDescriptors(isolate, *new_descriptors,
                         map->NumberOfOwnDescriptors());
  Tagged<Object> next = map->GetBackPointer();
  if (IsUndefined(next, isolate)) return;

  Tagged<Map> current = Cast<Map>(next);
  while (current->instance_descriptors(isolate) == *descriptors) {
    next = current->GetBackPointer();
    if (IsUndefined(next, isolate)) break;
    current->UpdateDescriptors(isolate, *new_descriptors,
                               current->NumberOfOwnDescriptors());
    current = Cast<Map>(next);
  }
}

// static
Handle<Map> Map::GetObjectCreateMap(Isolate* isolate,
                                    DirectHandle<JSPrototype> prototype) {
  Handle<Map> map(isolate->native_context()->object_function()->initial_map(),
                  isolate);
  if (map->prototype() == *prototype) return map;
  if (IsNull(*prototype, isolate)) {
    return isolate->slow_object_with_null_prototype_map();
  }
  if (IsJSObjectThatCanBeTrackedAsPrototype(*prototype)) {
    DirectHandle<JSObject> js_prototype = Cast<JSObject>(prototype);
    if (!js_prototype->map()->is_prototype_map()) {
      JSObject::OptimizeAsPrototype(js_prototype);
    }
    DirectHandle<PrototypeInfo> info =
        Map::GetOrCreatePrototypeInfo(js_prototype, isolate);
    // TODO(verwaest): Use inobject slack tracking for this map.
    Tagged<HeapObject> map_obj;
    if (info->ObjectCreateMap().GetHeapObjectIfWeak(&map_obj)) {
      map = handle(Cast<Map>(map_obj), isolate);
    } else {
      map = Map::CopyInitialMap(isolate, map);
      Map::SetPrototype(isolate, map, prototype);
      PrototypeInfo::SetObjectCreateMap(info, map, isolate);
    }
    return map;
  }

  return Map::TransitionRootMapToPrototypeForNewObject(isolate, map, prototype);
}

// static
Handle<Map> Map::GetDerivedMap(Isolate* isolate, DirectHandle<Map> from,
                               DirectHandle<JSReceiver> prototype) {
  DCHECK(IsUndefined(from->GetBackPointer()));

  if (IsJSObjectThatCanBeTrackedAsPrototype(*prototype)) {
    DirectHandle<JSObject> js_prototype = Cast<JSObject>(prototype);
    if (!js_prototype->map()->is_prototype_map()) {
      JSObject::OptimizeAsPrototype(js_prototype);
    }
    DirectHandle<PrototypeInfo> info =
        Map::GetOrCreatePrototypeInfo(js_prototype, isolate);
    Tagged<HeapObject> map_obj;
    Handle<Map> map;
    if (info->GetDerivedMap(from).GetHeapObjectIfWeak(&map_obj)) {
      map = handle(Cast<Map>(map_obj), isolate);
    } else {
      map = Map::CopyInitialMap(isolate, from);
      map->set_new_target_is_base(false);
      if (map->prototype() != *prototype) {
        Map::SetPrototype(isolate, map, prototype);
      }
      PrototypeInfo::AddDerivedMap(info, map, isolate);
    }
    return map;
  }

  // The TransitionToPrototype map will not have new_target_is_base reset. But
  // we don't need it to for proxies.
  return Map::TransitionRootMapToPrototypeForNewObject(isolate, from,
                                                       prototype);
}

static bool ContainsMap(MapHandlesSpan maps, Tagged<Map> map) {
  DCHECK(!map.is_null());
  for (DirectHandle<Map> current : maps) {
    if (!current.is_null() && *current == map) return true;
  }
  return false;
}

static bool HasElementsKind(MapHandlesSpan maps, ElementsKind elements_kind) {
  for (DirectHandle<Map> current : maps) {
    if (!current.is_null() && current->elements_kind() == elements_kind)
      return true;
  }
  return false;
}

Tagged<Map> Map::FindElementsKindTransitionedMap(Isolate* isolate,
                                                 MapHandlesSpan candidates,
                                                 ConcurrencyMode cmode) {
  DisallowGarbageCollection no_gc;

  if (IsDetached(isolate)) return Map();

  ElementsKind kind = elements_kind();
  bool is_packed = IsFastPackedElementsKind(kind);

  Tagged<Map> transition;
  if (IsTransitionableFastElementsKind(kind)) {
    // Check the state of the root map.
    Tagged<Map> root_map = FindRootMap(isolate);
    if (!EquivalentToForElementsKindTransition(root_map, cmode)) return Map();
    root_map = root_map->LookupElementsTransitionMap(isolate, kind, cmode);
    DCHECK(!root_map.is_null());
    // Starting from the next existing elements kind transition try to
    // replay the property transitions that does not involve instance rewriting
    // (ElementsTransitionAndStoreStub does not support that).
    for (root_map = root_map->ElementsTransitionMap(isolate, cmode);
         !root_map.is_null() && root_map->has_fast_elements();
         root_map = root_map->ElementsTransitionMap(isolate, cmode)) {
      // If root_map's elements kind doesn't match any of the elements kind in
      // the candidates there is no need to do any additional work.
      if (!HasElementsKind(candidates, root_map->elements_kind())) continue;
      Tagged<Map> current =
          root_map->TryReplayPropertyTransitions(isolate, *this, cmode);
      if (current.is_null()) continue;
      if (InstancesNeedRewriting(current, cmode)) continue;

      const bool current_is_packed =
          IsFastPackedElementsKind(current->elements_kind());
      if (ContainsMap(candidates, current) &&
          (is_packed || !current_is_packed)) {
        transition = current;
        is_packed = is_packed && current_is_packed;
      }
    }
  }
  return transition;
}

static Tagged<Map> FindClosestElementsTransition(Isolate* isolate,
                                                 Tagged<Map> map,
                                                 ElementsKind to_kind,
                                                 ConcurrencyMode cmode) {
  DisallowGarbageCollection no_gc;
  // Ensure we are requested to search elements kind transition "near the root".
  DCHECK_EQ(map->FindRootMap(isolate)->NumberOfOwnDescriptors(),
            map->NumberOfOwnDescriptors());
  Tagged<Map> current_map = map;

  ElementsKind kind = map->elements_kind();
  while (kind != to_kind) {
    Tagged<Map> next_map = current_map->ElementsTransitionMap(isolate, cmode);
    if (next_map.is_null()) return current_map;
    kind = next_map->elements_kind();
    current_map = next_map;
  }

  DCHECK_EQ(to_kind, current_map->elements_kind());
  return current_map;
}

Tagged<Map> Map::LookupElementsTransitionMap(Isolate* isolate,
                                             ElementsKind to_kind,
                                             ConcurrencyMode cmode) {
  Tagged<Map> to_map =
      FindClosestElementsTransition(isolate, *this, to_kind, cmode);
  if (to_map->elements_kind() == to_kind) return to_map;
  return Map();
}

bool Map::IsMapInArrayPrototypeChain(Isolate* isolate) const {
  if (isolate->initial_array_prototype()->map() == *this) {
    return true;
  }

  if (isolate->initial_object_prototype()->map() == *this) {
    return true;
  }

  return false;
}

Handle<Map> Map::TransitionElementsTo(Isolate* isolate, Handle<Map> map,
                                      ElementsKind to_kind) {
  ElementsKind from_kind = map->elements_kind();
  if (from_kind == to_kind) return map;

  Tagged<Context> native_context = isolate->context()->native_context();
  if (from_kind == FAST_SLOPPY_ARGUMENTS_ELEMENTS) {
    if (*map == native_context->fast_aliased_arguments_map()) {
      DCHECK_EQ(SLOW_SLOPPY_ARGUMENTS_ELEMENTS, to_kind);
      return handle(native_context->slow_aliased_arguments_map(), isolate);
    }
  } else if (from_kind == SLOW_SLOPPY_ARGUMENTS_ELEMENTS) {
    if (*map == native_context->slow_aliased_arguments_map()) {
      DCHECK_EQ(FAST_SLOPPY_ARGUMENTS_ELEMENTS, to_kind);
      return handle(native_context->fast_aliased_arguments_map(), isolate);
    }
  } else if (IsFastElementsKind(from_kind) && IsFastElementsKind(to_kind)) {
    // Reuse map transitions for JSArrays.
    DisallowGarbageCollection no_gc;
    if (native_context->GetInitialJSArrayMap(from_kind) == *map) {
      Tagged<Object> maybe_transitioned_map =
          native_context->get(Context::ArrayMapIndex(to_kind));
      if (IsMap(maybe_transitioned_map)) {
        return handle(Cast<Map>(maybe_transitioned_map), isolate);
      }
    }
  }

  DCHECK(!IsUndefined(*map, isolate));
  // Check if we can go back in the elements kind transition chain.
  if (IsHoleyElementsKind(from_kind) &&
      to_kind == GetPackedElementsKind(from_kind) &&
      IsMap(map->GetBackPointer()) &&
      Cast<Map>(map->GetBackPointer())->elements_kind() == to_kind) {
    return handle(Cast<Map>(map->GetBackPointer()), isolate);
  }

  bool allow_store_transition = IsTransitionElementsKind(from_kind);
  // Only store fast element maps in ascending generality.
  if (IsFastElementsKind(to_kind)) {
    allow_store_transition =
        allow_store_transition && IsTransitionableFastElementsKind(from_kind) &&
        IsMoreGeneralElementsKindTransition(from_kind, to_kind);
  }

  if (!allow_store_transition) {
    return Map::CopyAsElementsKind(isolate, map, to_kind, OMIT_TRANSITION);
  }

  return MapUpdater{isolate, map}.ReconfigureElementsKind(to_kind);
}

static Handle<Map> AddMissingElementsTransitions(Isolate* isolate,
                                                 Handle<Map> map,
                                                 ElementsKind to_kind) {
  DCHECK(IsTransitionElementsKind(map->elements_kind()));

  Handle<Map> current_map = map;

  ElementsKind kind = map->elements_kind();
  TransitionFlag flag;
  if (map->IsDetached(isolate)) {
    flag = OMIT_TRANSITION;
  } else {
    flag = INSERT_TRANSITION;
    if (IsFastElementsKind(kind)) {
      while (kind != to_kind && !IsTerminalElementsKind(kind)) {
        kind = GetNextTransitionElementsKind(kind);
        current_map = Map::CopyAsElementsKind(isolate, current_map, kind, flag);
      }
    }
  }

  // In case we are exiting the fast elements kind system, just add the map in
  // the end.
  if (kind != to_kind) {
    current_map = Map::CopyAsElementsKind(isolate, current_map, to_kind, flag);
  }

  DCHECK(current_map->elements_kind() == to_kind);
  return current_map;
}

// static
std::optional<Tagged<Map>> Map::TryAsElementsKind(Isolate* isolate,
                                                  DirectHandle<Map> map,
                                                  ElementsKind kind,
                                                  ConcurrencyMode cmode) {
  Tagged<Map> closest_map =
      FindClosestElementsTransition(isolate, *map, kind, cmode);
  if (closest_map->elements_kind() != kind) return {};
  return closest_map;
}

// static
Handle<Map> Map::AsElementsKind(Isolate* isolate, DirectHandle<Map> map,
                                ElementsKind kind) {
  Handle<Map> closest_map(
      FindClosestElementsTransition(isolate, *map, kind,
                                    ConcurrencyMode::kSynchronous),
      isolate);

  if (closest_map->elements_kind() == kind) {
    return closest_map;
  }

  return AddMissingElementsTransitions(isolate, closest_map, kind);
}

int Map::NumberOfEnumerableProperties() const {
  int result = 0;
  Tagged<DescriptorArray> descs = instance_descriptors(kRelaxedLoad);
  for (InternalIndex i : IterateOwnDescriptors()) {
    if ((int{descs->GetDetails(i).attributes()} & ONLY_ENUMERABLE) == 0 &&
        !Object::FilterKey(descs->GetKey(i), ENUMERABLE_STRINGS)) {
      result++;
    }
  }
  return result;
}

int Map::NextFreePropertyIndex() const {
  int number_of_own_descriptors = NumberOfOwnDescriptors();
  Tagged<DescriptorArray> descs = instance_descriptors(kRelaxedLoad);
  // Search properties backwards to find the last field.
  for (int i = number_of_own_descriptors - 1; i >= 0; --i) {
    PropertyDetails details = descs->GetDetails(InternalIndex(i));
    if (details.location() == PropertyLocation::kField) {
      return details.field_index() + details.field_width_in_words();
    }
  }
  return 0;
}

bool Map::OnlyHasSimpleProperties() const {
  // Wrapped string elements aren't explicitly stored in the elements backing
  // store, but are loaded indirectly from the underlying string.
  return !IsStringWrapperElementsKind(elements_kind()) &&
         !IsSpecialReceiverMap(*this) && !is_dictionary_map();
}

bool Map::ShouldCheckForReadOnlyElementsInPrototypeChain(Isolate* isolate) {
  // If this map has TypedArray elements kind, we won't look at the prototype
  // chain, so we can return early.
  if (IsTypedArrayElementsKind(elements_kind())) return false;

  for (PrototypeIterator iter(isolate, *this); !iter.IsAtEnd();
       iter.Advance()) {
    // Be conservative, don't look into any JSReceivers that may have custom
    // elements. For example, into JSProxies, String wrappers (which have have
    // non-configurable, non-writable elements), API objects, etc.
    if (IsCustomElementsReceiverMap(iter.GetCurrent()->map())) return true;

    Tagged<JSObject> current = iter.GetCurrent<JSObject>();
    ElementsKind elements_kind = current->GetElementsKind(isolate);
    // If this prototype has TypedArray elements kind, we won't look any further
    // in the prototype chain, so we can return early.
    if (IsTypedArrayElementsKind(elements_kind)) return false;
    if (IsFrozenElementsKind(elements_kind)) return true;

    if (IsDictionaryElementsKind(elements_kind) &&
        current->element_dictionary(isolate)->requires_slow_elements()) {
      return true;
    }

    if (IsSlowArgumentsElementsKind(elements_kind)) {
      Tagged<SloppyArgumentsElements> elements =
          Cast<SloppyArgumentsElements>(current->elements(isolate));
      Tagged<Object> arguments = elements->arguments();
      if (Cast<NumberDictionary>(arguments)->requires_slow_elements()) {
        return true;
      }
    }
  }

  return false;
}

Handle<Map> Map::RawCopy(Isolate* isolate, DirectHandle<Map> src_handle,
                         int instance_size, int inobject_properties) {
  Handle<Map> result = isolate->factory()->NewMap(
      src_handle, src_handle->instance_type(), instance_size,
      TERMINAL_FAST_ELEMENTS_KIND, inobject_properties);

  // We have to set the bitfields before any potential GCs could happen because
  // heap verification might fail otherwise.
  {
    DisallowGarbageCollection no_gc;
    Tagged<Map> src = *src_handle;
    Tagged<Map> raw = *result;
    raw->set_constructor_or_back_pointer(src->GetConstructorRaw());
    raw->set_bit_field(src->bit_field());
    raw->set_bit_field2(src->bit_field2());
    int new_bit_field3 = src->bit_field3();
    new_bit_field3 = Bits3::OwnsDescriptorsBit::update(new_bit_field3, true);
    new_bit_field3 =
        Bits3::NumberOfOwnDescriptorsBits::update(new_bit_field3, 0);
    new_bit_field3 = Bits3::EnumLengthBits::update(new_bit_field3,
                                                   kInvalidEnumCacheSentinel);
    new_bit_field3 = Bits3::IsDeprecatedBit::update(new_bit_field3, false);
    new_bit_field3 =
        Bits3::IsInRetainedMapListBit::update(new_bit_field3, false);
    if (!src->is_dictionary_map()) {
      new_bit_field3 = Bits3::IsUnstableBit::update(new_bit_field3, false);
    }
    // Same as bit_field comment above.
    raw->set_bit_field3(new_bit_field3);
    raw->clear_padding();
  }
  DirectHandle<JSPrototype> prototype(src_handle->prototype(), isolate);
  Map::SetPrototype(isolate, result, prototype);
  return result;
}

Handle<Map> Map::Normalize(Isolate* isolate, DirectHandle<Map> fast_map,
                           ElementsKind new_elements_kind,
                           DirectHandle<JSPrototype> new_prototype,
                           PropertyNormalizationMode mode, bool use_cache,
                           const char* reason) {
  DCHECK(!fast_map->is_dictionary_map());

  Tagged<Map> meta_map = fast_map->map();
  if (fast_map->is_prototype_map()) {
    use_cache = false;
  }
  DirectHandle<NormalizedMapCache> cache;
  if (use_cache) {
    Tagged<Object> normalized_map_cache =
        meta_map->native_context()->normalized_map_cache();
    use_cache = !IsUndefined(normalized_map_cache, isolate);
    if (use_cache) {
      cache = Cast<NormalizedMapCache>(
          direct_handle(normalized_map_cache, isolate));
    }
  }

  Handle<Map> new_map;
  if (use_cache && cache
                       ->Get(isolate, fast_map, new_elements_kind,
                             new_prototype.is_null() ? fast_map->prototype()
                                                     : *new_prototype,
                             mode)
                       .ToHandle(&new_map)) {
#ifdef VERIFY_HEAP
    if (v8_flags.verify_heap) new_map->DictionaryMapVerify(isolate);
#endif
#ifdef ENABLE_SLOW_DCHECKS
    if (v8_flags.enable_slow_asserts) {
      // The cached map should match newly created normalized map bit-by-bit,
      // except for the code cache, which can contain some ICs which can be
      // applied to the shared map, dependent code and weak cell cache.
      DirectHandle<Map> fresh = Map::CopyNormalized(isolate, fast_map, mode);
      fresh->set_elements_kind(new_elements_kind);
      if (!new_prototype.is_null()) {
        Map::SetPrototype(isolate, fresh, new_prototype);
      }

      static_assert(Map::kPrototypeValidityCellOffset ==
                    Map::kDependentCodeOffset + kTaggedSize);
      DCHECK_EQ(0, memcmp(reinterpret_cast<void*>(fresh->address()),
                          reinterpret_cast<void*>(new_map->address()),
                          Map::kBitField3Offset));
      // The IsInRetainedMapListBit might be different if the {new_map}
      // that we got from the {cache} was already embedded into optimized
      // code somewhere.
      // The IsMigrationTargetBit might be different if the {new_map} from
      // {cache} has already been marked as a migration target.
      constexpr int ignored_bit_field3_bits =
          Bits3::IsInRetainedMapListBit::kMask |
          Bits3::IsMigrationTargetBit::kMask;
      DCHECK_EQ(fresh->bit_field3() & ~ignored_bit_field3_bits,
                new_map->bit_field3() & ~ignored_bit_field3_bits);
      int offset = Map::kBitField3Offset + kInt32Size;
      DCHECK_EQ(0, memcmp(reinterpret_cast<void*>(fresh->address() + offset),
                          reinterpret_cast<void*>(new_map->address() + offset),
                          Map::kDependentCodeOffset - offset));
      offset = Map::kPrototypeValidityCellOffset + kTaggedSize;
      if (new_map->is_prototype_map()) {
        // For prototype maps, the PrototypeInfo is not copied.
        static_assert(Map::kTransitionsOrPrototypeInfoOffset ==
                      Map::kPrototypeValidityCellOffset + kTaggedSize);
        offset = kTransitionsOrPrototypeInfoOffset + kTaggedSize;
        DCHECK_EQ(fresh->raw_transitions(), Smi::zero());
      }
      DCHECK_EQ(0, memcmp(reinterpret_cast<void*>(fresh->address() + offset),
                          reinterpret_cast<void*>(new_map->address() + offset),
                          Map::kSize - offset));
    }
#endif
    if (v8_flags.log_maps) {
      LOG(isolate, MapEvent("NormalizeCached", fast_map, new_map, reason));
    }
  } else {
    new_map = Map::CopyNormalized(isolate, fast_map, mode);
    new_map->set_elements_kind(new_elements_kind);
    if (!new_prototype.is_null()) {
      Map::SetPrototype(isolate, new_map, new_prototype);
      DCHECK(new_map->is_dictionary_map() && !new_map->is_deprecated());
    }
    if (use_cache) {
      cache->Set(isolate, fast_map, new_map);
    }
    if (v8_flags.log_maps) {
      LOG(isolate, MapEvent("Normalize", fast_map, new_map, reason));
    }
  }
  fast_map->NotifyLeafMapLayoutChange(isolate);
  return new_map;
}

Handle<Map> Map::CopyNormalized(Isolate* isolate, DirectHandle<Map> map,
                                PropertyNormalizationMode mode) {
  int new_instance_size = map->instance_size();
  if (mode == CLEAR_INOBJECT_PROPERTIES) {
    new_instance_size -= map->GetInObjectProperties() * kTaggedSize;
  }

  Handle<Map> result = RawCopy(
      isolate, map, new_instance_size,
      mode == CLEAR_INOBJECT_PROPERTIES ? 0 : map->GetInObjectProperties());
  {
    DisallowGarbageCollection no_gc;
    Tagged<Map> raw = *result;
    // Clear the unused_property_fields explicitly as this field should not
    // be accessed for normalized maps.
    raw->SetInObjectUnusedPropertyFields(0);
    raw->set_is_dictionary_map(true);
    raw->set_is_migration_target(false);
    raw->set_may_have_interesting_properties(true);
    raw->set_construction_counter(kNoSlackTracking);
  }

#ifdef VERIFY_HEAP
  if (v8_flags.verify_heap) result->DictionaryMapVerify(isolate);
#endif

  return result;
}

// Return an immutable prototype exotic object version of the input map.
// Never even try to cache it in the transition tree, as it is intended
// for the global object and its prototype chain, and excluding it saves
// memory on the map transition tree.

// static
Handle<Map> Map::TransitionToImmutableProto(Isolate* isolate,
                                            DirectHandle<Map> map) {
  Handle<Map> new_map = Map::Copy(isolate, map, "ImmutablePrototype");
  new_map->set_is_immutable_proto(true);
  return new_map;
}

namespace {
void EnsureInitialMap(Isolate* isolate, DirectHandle<Map> map) {
#ifdef DEBUG
  Tagged<Object> maybe_constructor = map->GetConstructor();
  DCHECK((IsJSFunction(maybe_constructor) &&
          *map == Cast<JSFunction>(maybe_constructor)->initial_map()) ||
         // Below are the exceptions to the check above.
         // |Function|'s initial map is a |sloppy_function_map| but
         // other function map variants such as sloppy with name or readonly
         // prototype or various strict function maps variants, etc. also
         // have Function as a constructor.
         *map == *isolate->strict_function_map() ||
         *map == *isolate->strict_function_with_name_map() ||
         // Same applies to |GeneratorFunction|'s initial map and generator
         // function map variants.
         *map == *isolate->generator_function_with_name_map() ||
         // Same applies to |AsyncFunction|'s initial map and other async
         // function map variants.
         *map == *isolate->async_function_with_name_map());
#endif
  // Initial maps must not contain descriptors in the descriptors array
  // that do not belong to the map.
  DCHECK_EQ(map->NumberOfOwnDescriptors(),
            map->instance_descriptors(isolate)->number_of_descriptors());
}
}  // namespace

// static
Handle<Map> Map::CopyInitialMapNormalized(Isolate* isolate,
                                          DirectHandle<Map> map,
                                          PropertyNormalizationMode mode) {
  EnsureInitialMap(isolate, map);
  return CopyNormalized(isolate, map, mode);
}

// static
Handle<Map> Map::CopyInitialMap(Isolate* isolate, DirectHandle<Map> map,
                                int instance_size, int inobject_properties,
                                int unused_property_fields) {
  EnsureInitialMap(isolate, map);

  Handle<Map> result =
      RawCopy(isolate, map, instance_size, inobject_properties);

  // Please note instance_type and instance_size are set when allocated.
  result->SetInObjectUnusedPropertyFields(unused_property_fields);

  int number_of_own_descriptors = map->NumberOfOwnDescriptors();
  if (number_of_own_descriptors > 0) {
    // The copy will use the same descriptors array without ownership.
    Tagged<DescriptorArray> descriptors = map->instance_descriptors(isolate);
    result->set_owns_descriptors(false);
    result->UpdateDescriptors(isolate, descriptors, number_of_own_descriptors);

    DCHECK_EQ(result->NumberOfFields(ConcurrencyMode::kSynchronous),
              result->GetInObjectProperties() - result->UnusedPropertyFields());
  }

  return result;
}

Handle<Map> Map::CopyDropDescriptors(Isolate* isolate, DirectHandle<Map> map) {
  Handle<Map> result =
      RawCopy(isolate, map, map->instance_size(),
              IsJSObjectMap(*map) ? map->GetInObjectProperties() : 0);

  // Please note instance_type and instance_size are set when allocated.
  if (IsJSObjectMap(*map)) {
    result->CopyUnusedPropertyFields(*map);
  }
  map->NotifyLeafMapLayoutChange(isolate);
  return result;
}

Handle<Map> Map::ShareDescriptor(Isolate* isolate, DirectHandle<Map> map,
                                 DirectHandle<DescriptorArray> descriptors,
                                 Descriptor* descriptor) {
  // Sanity check. This path is only to be taken if the map owns its descriptor
  // array, implying that its NumberOfOwnDescriptors equals the number of
  // descriptors in the descriptor array.
  DCHECK_EQ(map->NumberOfOwnDescriptors(),
            map->instance_descriptors(isolate)->number_of_descriptors());

  Handle<Map> result = CopyDropDescriptors(isolate, map);
  DirectHandle<Name> name = descriptor->GetKey();

  // Properly mark the {result} if the {name} is an "interesting symbol".
  if (name->IsInteresting(isolate)) {
    result->set_may_have_interesting_properties(true);
  }

  // Ensure there's space for the new descriptor in the shared descriptor array.
  if (descriptors->number_of_slack_descriptors() == 0) {
    int old_size = descriptors->number_of_descriptors();
    if (old_size == 0) {
      descriptors = DescriptorArray::Allocate(isolate, 0, 1);
    } else {
      int slack = SlackForArraySize(old_size, kMaxNumberOfDescriptors);
      EnsureDescriptorSlack(isolate, map, slack);
      descriptors = direct_handle(map->instance_descriptors(isolate), isolate);
    }
  }

  {
    DisallowGarbageCollection no_gc;
    descriptors->Append(descriptor);
    result->InitializeDescriptors(isolate, *descriptors);
  }

  DCHECK(result->NumberOfOwnDescriptors() == map->NumberOfOwnDescriptors() + 1);
  ConnectTransition(isolate, map, result, name, SIMPLE_PROPERTY_TRANSITION);

  return result;
}

void Map::ConnectTransition(Isolate* isolate, DirectHandle<Map> parent,
                            DirectHandle<Map> child, DirectHandle<Name> name,
                            TransitionKindFlag transition_kind,
                            bool force_connect) {
  DCHECK_EQ(parent->map(), child->map());
  DCHECK_IMPLIES(name->IsInteresting(isolate),
                 child->may_have_interesting_properties());
  DCHECK_IMPLIES(parent->may_have_interesting_properties(),
                 child->may_have_interesting_properties());
  if (!IsUndefined(parent->GetBackPointer(), isolate)) {
    parent->set_owns_descriptors(false);
  } else if (!parent->IsDetached(isolate)) {
    // |parent| is initial map and it must not contain descriptors in the
    // descriptors array that do not belong to the map.
    DCHECK_EQ(parent->NumberOfOwnDescriptors(),
              parent->instance_descriptors(isolate)->number_of_descriptors());
  }
  if (parent->IsDetached(isolate) && !force_connect) {
    DCHECK(child->IsDetached(isolate));
    if (v8_flags.log_maps) {
      LOG(isolate, MapEvent("Transition", parent, child, "prototype", name));
    }
  } else {
    TransitionsAccessor::Insert(isolate, parent, name, child, transition_kind);
    if (v8_flags.log_maps) {
      LOG(isolate, MapEvent("Transition", parent, child, "", name));
    }
  }
}

Handle<Map> Map::CopyReplaceDescriptors(
    Isolate* isolate, DirectHandle<Map> map,
    DirectHandle<DescriptorArray> descriptors, TransitionFlag flag,
    MaybeDirectHandle<Name> maybe_name, const char* reason,
    TransitionKindFlag transition_kind) {
  DCHECK(descriptors->IsSortedNoDuplicates());

  Handle<Map> result = CopyDropDescriptors(isolate, map);
  bool is_connected = false;

  // Properly mark the {result} if the {name} is an "interesting symbol".
  DirectHandle<Name> name;
  if (maybe_name.ToHandle(&name) && name->IsInteresting(isolate)) {
    result->set_may_have_interesting_properties(true);
  }

  if (map->is_prototype_map()) {
    result->InitializeDescriptors(isolate, *descriptors);
  } else {
    if (flag == INSERT_TRANSITION &&
        TransitionsAccessor::CanHaveMoreTransitions(isolate, map)) {
      result->InitializeDescriptors(isolate, *descriptors);

      DCHECK(!maybe_name.is_null());
      ConnectTransition(isolate, map, result, name, transition_kind);
      is_connected = true;
    } else if ((transition_kind == PROTOTYPE_TRANSITION &&
                v8_flags.move_prototype_transitions_first) ||
               isolate->bootstrapper()->IsActive()) {
      // Prototype transitions are always between root maps. UpdatePrototype
      // uses the MapUpdater and instance migration. Thus, field generalization
      // is allowed to happen lazily.
      DCHECK_IMPLIES(transition_kind == PROTOTYPE_TRANSITION,
                     IsUndefined(map->GetBackPointer()));
      result->InitializeDescriptors(isolate, *descriptors);
    } else {
      DCHECK_IMPLIES(transition_kind == PROTOTYPE_TRANSITION,
                     !v8_flags.move_prototype_transitions_first);
      descriptors->GeneralizeAllFields(transition_kind == PROTOTYPE_TRANSITION);
      result->InitializeDescriptors(isolate, *descriptors);
    }
  }
  if (v8_flags.log_maps && !is_connected) {
    LOG(isolate,
        MapEvent("ReplaceDescriptors", map, result, reason,
                 maybe_name.is_null() ? DirectHandle<HeapObject>() : name));
  }
  return result;
}

// Creates transition tree starting from |split_map| and adding all descriptors
// starting from descriptor with index |split_map|.NumberOfOwnDescriptors().
// The way how it is done is tricky because of GC and special descriptors
// marking logic.
Handle<Map> Map::AddMissingTransitions(
    Isolate* isolate, DirectHandle<Map> split_map,
    DirectHandle<DescriptorArray> descriptors) {
  DCHECK(descriptors->IsSortedNoDuplicates());
  int split_nof = split_map->NumberOfOwnDescriptors();
  int nof_descriptors = descriptors->number_of_descriptors();
  CHECK_LT(split_nof, nof_descriptors);

  // Start with creating last map which will own full descriptors array.
  // This is necessary to guarantee that GC will mark the whole descriptor
  // array if any of the allocations happening below fail.
  // Number of unused properties is temporarily incorrect and the layout
  // descriptor could unnecessarily be in slow mode but we will fix after
  // all the other intermediate maps are created.
  // Also the last map might have interesting symbols, we temporarily set
  // the flag and clear it right before the descriptors are installed. This
  // makes heap verification happy and ensures the flag ends up accurate.
  Handle<Map> last_map = CopyDropDescriptors(isolate, split_map);
  last_map->InitializeDescriptors(isolate, *descriptors);
  last_map->SetInObjectUnusedPropertyFields(0);
  last_map->set_may_have_interesting_properties(true);

  // During creation of intermediate maps we violate descriptors sharing
  // invariant since the last map is not yet connected to the transition tree
  // we create here. But it is safe because GC never trims map's descriptors
  // if there are no dead transitions from that map and this is exactly the
  // case for all the intermediate maps we create here.
  DirectHandle<Map> map = split_map;
  for (InternalIndex i : InternalIndex::Range(split_nof, nof_descriptors - 1)) {
    DirectHandle<Map> new_map = CopyDropDescriptors(isolate, map);
    // Force connection of these maps to prevent split_map being a root map to
    // be treated as detached.
    InstallDescriptors(isolate, map, new_map, i, descriptors,
                       /* force_connect */ true);
    DCHECK_EQ(*new_map->GetBackPointer(), *map);
    map = new_map;
  }
  map->NotifyLeafMapLayoutChange(isolate);
  last_map->set_may_have_interesting_properties(false);
  InstallDescriptors(isolate, map, last_map, InternalIndex(nof_descriptors - 1),
                     descriptors);
  return last_map;
}

// Since this method is used to rewrite an existing transition tree, it can
// always insert transitions without checking.
void Map::InstallDescriptors(Isolate* isolate, DirectHandle<Map> parent,
                             DirectHandle<Map> child,
                             InternalIndex new_descriptor,
                             DirectHandle<DescriptorArray> descriptors,
                             bool force_connect) {
  DCHECK(descriptors->IsSortedNoDuplicates());

  child->SetInstanceDescriptors(isolate, *descriptors,
                                new_descriptor.as_int() + 1);
  child->CopyUnusedPropertyFields(*parent);
  PropertyDetails details = descriptors->GetDetails(new_descriptor);
  if (details.location() == PropertyLocation::kField) {
    child->AccountAddedPropertyField();
  }

  DirectHandle<Name> name(descriptors->GetKey(new_descriptor), isolate);
  if (parent->may_have_interesting_properties() ||
      name->IsInteresting(isolate)) {
    child->set_may_have_interesting_properties(true);
  }
  ConnectTransition(isolate, parent, child, name, SIMPLE_PROPERTY_TRANSITION,
                    force_connect);
}

Handle<Map> Map::CopyAsElementsKind(Isolate* isolate, DirectHandle<Map> map,
                                    ElementsKind kind, TransitionFlag flag) {
  // Only certain objects are allowed to have non-terminal fast transitional
  // elements kinds.
  DCHECK(IsJSObjectMap(*map));
  DCHECK_IMPLIES(
      !map->CanHaveFastTransitionableElementsKind(),
      IsDictionaryElementsKind(kind) || IsTerminalElementsKind(kind));

  Tagged<Map> maybe_elements_transition_map;
  if (flag == INSERT_TRANSITION) {
    // Ensure we are requested to add elements kind transition "near the root".
    DCHECK_EQ(map->FindRootMap(isolate)->NumberOfOwnDescriptors(),
              map->NumberOfOwnDescriptors());

    maybe_elements_transition_map =
        map->ElementsTransitionMap(isolate, ConcurrencyMode::kSynchronous);
    DCHECK(maybe_elements_transition_map.is_null() ||
           (maybe_elements_transition_map->elements_kind() ==
                DICTIONARY_ELEMENTS &&
            kind == DICTIONARY_ELEMENTS));
    DCHECK(!IsFastElementsKind(kind) ||
           IsMoreGeneralElementsKindTransition(map->elements_kind(), kind));
    DCHECK(kind != map->elements_kind());
  }

  bool insert_transition =
      flag == INSERT_TRANSITION &&
      TransitionsAccessor::CanHaveMoreTransitions(isolate, map) &&
      maybe_elements_transition_map.is_null();

  if (insert_transition) {
    Handle<Map> new_map = CopyForElementsTransition(isolate, map);
    new_map->set_elements_kind(kind);

    DirectHandle<Name> name = isolate->factory()->elements_transition_symbol();
    ConnectTransition(isolate, map, new_map, name, SPECIAL_TRANSITION);
    return new_map;
  }

  // Create a new free-floating map only if we are not allowed to store it.
  Handle<Map> new_map = Copy(isolate, map, "CopyAsElementsKind");
  new_map->set_elements_kind(kind);
  return new_map;
}

Handle<Map> Map::AsLanguageMode(Isolate* isolate, Handle<Map> initial_map,
                                DirectHandle<SharedFunctionInfo> shared_info) {
  DCHECK(InstanceTypeChecker::IsJSFunction(initial_map->instance_type()));
  // Initial map for sloppy mode function is stored in the function
  // constructor. Initial maps for strict mode are cached as special transitions
  // using |strict_function_transition_symbol| as a key.
  if (is_sloppy(shared_info->language_mode())) return initial_map;

  DirectHandle<Map> function_map(Cast<Map>(isolate->native_context()->get(
                                     shared_info->function_map_index())),
                                 isolate);

  static_assert(LanguageModeSize == 2);
  DCHECK_EQ(LanguageMode::kStrict, shared_info->language_mode());
  DirectHandle<Symbol> transition_symbol =
      isolate->factory()->strict_function_transition_symbol();
  MaybeHandle<Map> maybe_transition = TransitionsAccessor::SearchSpecial(
      isolate, initial_map, *transition_symbol);
  if (!maybe_transition.is_null()) {
    return maybe_transition.ToHandleChecked();
  }
  initial_map->NotifyLeafMapLayoutChange(isolate);

  // Create new map taking descriptors from the |function_map| and all
  // the other details from the |initial_map|.
  Handle<Map> map =
      Map::CopyInitialMap(isolate, function_map, initial_map->instance_size(),
                          initial_map->GetInObjectProperties(),
                          initial_map->UnusedPropertyFields());
  map->SetConstructor(initial_map->GetConstructor());
  map->set_prototype(initial_map->prototype());
  map->set_construction_counter(initial_map->construction_counter());

  if (TransitionsAccessor::CanHaveMoreTransitions(isolate, initial_map)) {
    Map::ConnectTransition(isolate, initial_map, map, transition_symbol,
                           SPECIAL_TRANSITION);
  }
  return map;
}

Handle<Map> Map::CopyForElementsTransition(Isolate* isolate,
                                           DirectHandle<Map> map) {
  DCHECK(!map->IsDetached(isolate));
  DCHECK(!map->is_dictionary_map());
  Handle<Map> new_map = CopyDropDescriptors(isolate, map);

  if (map->owns_descriptors()) {
    // In case the map owned its own descriptors, share the descriptors and
    // transfer ownership to the new map.
    // The properties did not change, so reuse descriptors.
    map->set_owns_descriptors(false);
    new_map->InitializeDescriptors(isolate, map->instance_descriptors(isolate));
  } else {
    // In case the map did not own its own descriptors, a split is forced by
    // copying the map; creating a new descriptor array cell.
    DirectHandle<DescriptorArray> descriptors(
        map->instance_descriptors(isolate), isolate);
    int number_of_own_descriptors = map->NumberOfOwnDescriptors();
    DirectHandle<DescriptorArray> new_descriptors = DescriptorArray::CopyUpTo(
        isolate, descriptors, number_of_own_descriptors);
    new_map->InitializeDescriptors(isolate, *new_descriptors);
  }
  return new_map;
}

Handle<Map> Map::CopyForPrototypeTransition(
    Isolate* isolate, DirectHandle<Map> map,
    DirectHandle<JSPrototype> prototype) {
  // For simplicity we always copy descriptors although it would be possible to
  // share them in some situations.
  Handle<Map> new_map =
      Copy(isolate, map, "TransitionToPrototype", PROTOTYPE_TRANSITION);
  Map::SetPrototype(isolate, new_map, prototype);
  return new_map;
}

Handle<Map> Map::Copy(Isolate* isolate, DirectHandle<Map> map,
                      const char* reason, TransitionKindFlag kind) {
  DirectHandle<DescriptorArray> descriptors(map->instance_descriptors(isolate),
                                            isolate);
  int number_of_own_descriptors = map->NumberOfOwnDescriptors();
  DirectHandle<DescriptorArray> new_descriptors = DescriptorArray::CopyUpTo(
      isolate, descriptors, number_of_own_descriptors);
  auto res =
      CopyReplaceDescriptors(isolate, map, new_descriptors, OMIT_TRANSITION,
                             MaybeDirectHandle<Name>(), reason, kind);
  return res;
}

Handle<Map> Map::Create(Isolate* isolate, int inobject_properties) {
  Handle<Map> copy_handle =
      Copy(isolate,
           direct_handle(isolate->object_function()->initial_map(), isolate),
           "MapCreate");
  DisallowGarbageCollection no_gc;
  Tagged<Map> copy = *copy_handle;

  // Check that we do not overflow the instance size when adding the extra
  // inobject properties. If the instance size overflows, we allocate as many
  // properties as we can as inobject properties.
  if (inobject_properties > JSObject::kMaxInObjectProperties) {
    inobject_properties = JSObject::kMaxInObjectProperties;
  }

  int new_instance_size =
      JSObject::kHeaderSize + kTaggedSize * inobject_properties;

  // Adjust the map with the extra inobject properties.
  copy->set_instance_size(new_instance_size);
  copy->SetInObjectPropertiesStartInWords(JSObject::kHeaderSize / kTaggedSize);
  DCHECK_EQ(copy->GetInObjectProperties(), inobject_properties);
  copy->SetInObjectUnusedPropertyFields(inobject_properties);
  copy->set_visitor_id(Map::GetVisitorId(copy));

  return copy_handle;
}

Handle<Map> Map::CopyForPreventExtensions(
    Isolate* isolate, DirectHandle<Map> map, PropertyAttributes attrs_to_add,
    DirectHandle<Symbol> transition_marker, const char* reason,
    bool old_map_is_dictionary_elements_kind) {
  int num_descriptors = map->NumberOfOwnDescriptors();
  DirectHandle<DescriptorArray> new_desc =
      DescriptorArray::CopyUpToAddAttributes(
          isolate, direct_handle(map->instance_descriptors(isolate), isolate),
          num_descriptors, attrs_to_add);
  // Do not track transitions during bootstrapping.
  TransitionFlag flag =
      isolate->bootstrapper()->IsActive() ? OMIT_TRANSITION : INSERT_TRANSITION;
  Handle<Map> new_map =
      CopyReplaceDescriptors(isolate, map, new_desc, flag, transition_marker,
                             reason, SPECIAL_TRANSITION);
  new_map->set_is_extensible(false);
  if (!IsTypedArrayOrRabGsabTypedArrayElementsKind(map->elements_kind())) {
    ElementsKind new_kind = IsStringWrapperElementsKind(map->elements_kind())
                                ? SLOW_STRING_WRAPPER_ELEMENTS
                                : DICTIONARY_ELEMENTS;
    if (v8_flags.enable_sealed_frozen_elements_kind &&
        !old_map_is_dictionary_elements_kind) {
      switch (map->elements_kind()) {
        case PACKED_ELEMENTS:
          if (attrs_to_add == SEALED) {
            new_kind = PACKED_SEALED_ELEMENTS;
          } else if (attrs_to_add == FROZEN) {
            new_kind = PACKED_FROZEN_ELEMENTS;
          } else {
            new_kind = PACKED_NONEXTENSIBLE_ELEMENTS;
          }
          break;
        case PACKED_NONEXTENSIBLE_ELEMENTS:
          if (attrs_to_add == SEALED) {
            new_kind = PACKED_SEALED_ELEMENTS;
          } else if (attrs_to_add == FROZEN) {
            new_kind = PACKED_FROZEN_ELEMENTS;
          }
          break;
        case PACKED_SEALED_ELEMENTS:
          if (attrs_to_add == FROZEN) {
            new_kind = PACKED_FROZEN_ELEMENTS;
          }
          break;
        case HOLEY_ELEMENTS:
          if (attrs_to_add == SEALED) {
            new_kind = HOLEY_SEALED_ELEMENTS;
          } else if (attrs_to_add == FROZEN) {
            new_kind = HOLEY_FROZEN_ELEMENTS;
          } else {
            new_kind = HOLEY_NONEXTENSIBLE_ELEMENTS;
          }
          break;
        case HOLEY_NONEXTENSIBLE_ELEMENTS:
          if (attrs_to_add == SEALED) {
            new_kind = HOLEY_SEALED_ELEMENTS;
          } else if (attrs_to_add == FROZEN) {
            new_kind = HOLEY_FROZEN_ELEMENTS;
          }
          break;
        case HOLEY_SEALED_ELEMENTS:
          if (attrs_to_add == FROZEN) {
            new_kind = HOLEY_FROZEN_ELEMENTS;
          }
          break;
        default:
          break;
      }
    }
    new_map->set_elements_kind(new_kind);
  }
  return new_map;
}

namespace {

bool CanHoldValue(Tagged<DescriptorArray> descriptors, InternalIndex descriptor,
                  PropertyConstness constness, Tagged<Object> value) {
  PropertyDetails details = descriptors->GetDetails(descriptor);
  if (details.location() == PropertyLocation::kField) {
    if (details.kind() == PropertyKind::kData) {
      return IsGeneralizableTo(constness, details.constness()) &&
             Object::FitsRepresentation(value, details.representation()) &&
             FieldType::NowContains(descriptors->GetFieldType(descriptor),
                                    value);
    } else {
      DCHECK_EQ(PropertyKind::kAccessor, details.kind());
      return false;
    }

  } else {
    DCHECK_EQ(PropertyLocation::kDescriptor, details.location());
    DCHECK_EQ(PropertyConstness::kConst, details.constness());
    DCHECK_EQ(PropertyKind::kAccessor, details.kind());
    return false;
  }
  UNREACHABLE();
}

Handle<Map> UpdateDescriptorForValue(Isolate* isolate, Handle<Map> map,
                                     InternalIndex descriptor,
                                     PropertyConstness constness,
                                     DirectHandle<Object> value) {
  if (CanHoldValue(map->instance_descriptors(isolate), descriptor, constness,
                   *value)) {
    return map;
  }

  PropertyAttributes attributes =
      map->instance_descriptors(isolate)->GetDetails(descriptor).attributes();
  Representation representation =
      Object::OptimalRepresentation(*value, isolate);
  Handle<FieldType> type = Object::OptimalType(*value, isolate, representation);

  MapUpdater mu(isolate, map);
  return mu.ReconfigureToDataField(descriptor, attributes, constness,
                                   representation, type);
}

}  // namespace

// static
Handle<Map> Map::PrepareForDataProperty(Isolate* isolate, Handle<Map> map,
                                        InternalIndex descriptor,
                                        PropertyConstness constness,
                                        DirectHandle<Object> value) {
  // The map should already be fully updated before storing the property.
  DCHECK(!map->is_deprecated());
  // Dictionaries can store any property value.
  DCHECK(!map->is_dictionary_map());
  return UpdateDescriptorForValue(isolate, map, descriptor, constness, value);
}

Handle<Map> Map::TransitionToDataProperty(
    Isolate* isolate, DirectHandle<Map> map, DirectHandle<Name> name,
    DirectHandle<Object> value, PropertyAttributes attributes,
    PropertyConstness constness, StoreOrigin store_origin) {
  RCS_SCOPE(isolate,
            map->IsDetached(isolate)
                ? RuntimeCallCounterId::kPrototypeMap_TransitionToDataProperty
                : RuntimeCallCounterId::kMap_TransitionToDataProperty);

  DCHECK(IsUniqueName(*name));
  DCHECK(!map->is_dictionary_map());

  // Migrate to the newest map before storing the property.
  map = Update(isolate, map);

  MaybeHandle<Map> maybe_transition = TransitionsAccessor::SearchTransition(
      isolate, map, *name, PropertyKind::kData, attributes);
  Handle<Map> transition;
  if (maybe_transition.ToHandle(&transition)) {
    InternalIndex descriptor = transition->LastAdded();

    DCHECK_EQ(attributes, transition->instance_descriptors(isolate)
                              ->GetDetails(descriptor)
                              .attributes());

    return UpdateDescriptorForValue(isolate, transition, descriptor, constness,
                                    value);
  }

  // Do not track transitions during bootstrapping.
  TransitionFlag flag =
      isolate->bootstrapper()->IsActive() ? OMIT_TRANSITION : INSERT_TRANSITION;
  MaybeHandle<Map> maybe_map;
  if (!map->TooManyFastProperties(store_origin)) {
    Representation representation =
        Object::OptimalRepresentation(*value, isolate);
    Handle<FieldType> type =
        Object::OptimalType(*value, isolate, representation);
    maybe_map = Map::CopyWithField(isolate, map, name, type, attributes,
                                   constness, representation, flag);
  }

  Handle<Map> result;
  if (!maybe_map.ToHandle(&result)) {
    const char* reason = "TooManyFastProperties";
#if V8_TRACE_MAPS
    std::unique_ptr<base::ScopedVector<char>> buffer;
    if (v8_flags.log_maps) {
      base::ScopedVector<char> name_buffer(100);
      name->NameShortPrint(name_buffer);
      buffer.reset(new base::ScopedVector<char>(128));
      SNPrintF(*buffer, "TooManyFastProperties %s", name_buffer.begin());
      reason = buffer->begin();
    }
#endif
    DirectHandle<Object> maybe_constructor(map->GetConstructor(), isolate);
    if (v8_flags.feedback_normalization && map->new_target_is_base() &&
        IsJSFunction(*maybe_constructor) &&
        !Cast<JSFunction>(*maybe_constructor)->shared()->native()) {
      auto constructor = Cast<JSFunction>(maybe_constructor);
      DCHECK_NE(*constructor, constructor->native_context()->object_function());
      DirectHandle<Map> initial_map(constructor->initial_map(), isolate);
      result = Map::Normalize(isolate, initial_map, CLEAR_INOBJECT_PROPERTIES,
                              reason);
      initial_map->DeprecateTransitionTree(isolate);
      DirectHandle<JSReceiver> prototype(Cast<JSReceiver>(result->prototype()),
                                         isolate);
      JSFunction::SetInitialMap(isolate, constructor, result, prototype);

      // Deoptimize all code that embeds the previous initial map.
      DependentCode::DeoptimizeDependencyGroups(
          isolate, *initial_map, DependentCode::kInitialMapChangedGroup);
      if (!result->EquivalentToForNormalization(*map,
                                                CLEAR_INOBJECT_PROPERTIES)) {
        result =
            Map::Normalize(isolate, map, CLEAR_INOBJECT_PROPERTIES, reason);
      }
    } else {
      result = Map::Normalize(isolate, map, CLEAR_INOBJECT_PROPERTIES, reason);
    }
  }

  return result;
}

Handle<Map> Map::TransitionToAccessorProperty(Isolate* isolate, Handle<Map> map,
                                              DirectHandle<Name> name,
                                              InternalIndex descriptor,
                                              DirectHandle<Object> getter,
                                              DirectHandle<Object> setter,
                                              PropertyAttributes attributes) {
  RCS_SCOPE(
      isolate,
      map->IsDetached(isolate)
          ? RuntimeCallCounterId::kPrototypeMap_TransitionToAccessorProperty
          : RuntimeCallCounterId::kMap_TransitionToAccessorProperty);

  // At least one of the accessors needs to be a new value.
  DCHECK(!IsNull(*getter, isolate) || !IsNull(*setter, isolate));
  DCHECK(IsUniqueName(*name));

  // Migrate to the newest map before transitioning to the new property.
  map = Update(isolate, map);

  // Dictionary maps can always have additional data properties.
  if (map->is_dictionary_map()) return map;

  PropertyNormalizationMode mode = map->is_prototype_map()
                                       ? KEEP_INOBJECT_PROPERTIES
                                       : CLEAR_INOBJECT_PROPERTIES;

  MaybeHandle<Map> maybe_transition = TransitionsAccessor::SearchTransition(
      isolate, map, *name, PropertyKind::kAccessor, attributes);
  Handle<Map> transition;
  if (maybe_transition.ToHandle(&transition)) {
    Tagged<DescriptorArray> descriptors =
        transition->instance_descriptors(isolate);
    InternalIndex last_descriptor = transition->LastAdded();
    DCHECK(descriptors->GetKey(last_descriptor)->Equals(*name));

    DCHECK_EQ(PropertyKind::kAccessor,
              descriptors->GetDetails(last_descriptor).kind());
    DCHECK_EQ(attributes,
              descriptors->GetDetails(last_descriptor).attributes());

    DirectHandle<Object> maybe_pair(
        descriptors->GetStrongValue(last_descriptor), isolate);
    if (!IsAccessorPair(*maybe_pair)) {
      return Map::Normalize(isolate, map, mode,
                            "TransitionToAccessorFromNonPair");
    }

    auto pair = Cast<AccessorPair>(maybe_pair);
    if (!pair->Equals(*getter, *setter)) {
      return Map::Normalize(isolate, map, mode,
                            "TransitionToDifferentAccessor");
    }

    return transition;
  }

  DirectHandle<AccessorPair> pair;
  Tagged<DescriptorArray> old_descriptors = map->instance_descriptors(isolate);
  if (descriptor.is_found()) {
    if (descriptor != map->LastAdded()) {
      return Map::Normalize(isolate, map, mode, "AccessorsOverwritingNonLast");
    }
    PropertyDetails old_details = old_descriptors->GetDetails(descriptor);
    if (old_details.kind() != PropertyKind::kAccessor) {
      return Map::Normalize(isolate, map, mode,
                            "AccessorsOverwritingNonAccessors");
    }

    if (old_details.attributes() != attributes) {
      return Map::Normalize(isolate, map, mode, "AccessorsWithAttributes");
    }

    DirectHandle<Object> maybe_pair(old_descriptors->GetStrongValue(descriptor),
                                    isolate);
    if (!IsAccessorPair(*maybe_pair)) {
      return Map::Normalize(isolate, map, mode, "AccessorsOverwritingNonPair");
    }

    auto current_pair = Cast<AccessorPair>(maybe_pair);
    if (current_pair->Equals(*getter, *setter)) return map;

    bool overwriting_accessor = false;
    if (!IsNull(*getter, isolate) &&
        !IsNull(current_pair->get(ACCESSOR_GETTER), isolate) &&
        current_pair->get(ACCESSOR_GETTER) != *getter) {
      overwriting_accessor = true;
    }
    if (!IsNull(*setter, isolate) &&
        !IsNull(current_pair->get(ACCESSOR_SETTER), isolate) &&
        current_pair->get(ACCESSOR_SETTER) != *setter) {
      overwriting_accessor = true;
    }
    if (overwriting_accessor) {
      return Map::Normalize(isolate, map, mode,
                            "AccessorsOverwritingAccessors");
    }

    pair = AccessorPair::Copy(isolate, Cast<AccessorPair>(maybe_pair));
  } else if (map->NumberOfOwnDescriptors() >= kMaxNumberOfDescriptors ||
             map->TooManyFastProperties(StoreOrigin::kNamed)) {
    return Map::Normalize(isolate, map, CLEAR_INOBJECT_PROPERTIES,
                          "TooManyAccessors");
  } else {
    pair = isolate->factory()->NewAccessorPair();
  }

  pair->SetComponents(*getter, *setter);

  // Do not track transitions during bootstrapping.
  TransitionFlag flag =
      isolate->bootstrapper()->IsActive() ? OMIT_TRANSITION : INSERT_TRANSITION;
  Descriptor d = Descriptor::AccessorConstant(name, pair, attributes);
  return Map::CopyInsertDescriptor(isolate, map, &d, flag);
}

Handle<Map> Map::CopyAddDescriptor(Isolate* isolate, DirectHandle<Map> map,
                                   Descriptor* descriptor,
                                   TransitionFlag flag) {
  DirectHandle<DescriptorArray> descriptors(map->instance_descriptors(isolate),
                                            isolate);

  // Share descriptors only if map owns descriptors and is not an initial map.
  if (flag == INSERT_TRANSITION && map->owns_descriptors() &&
      !IsUndefined(map->GetBackPointer(), isolate) &&
      TransitionsAccessor::CanHaveMoreTransitions(isolate, map)) {
    return ShareDescriptor(isolate, map, descriptors, descriptor);
  }

  int nof = map->NumberOfOwnDescriptors();
  DirectHandle<DescriptorArray> new_descriptors =
      DescriptorArray::CopyUpTo(isolate, descriptors, nof, 1);
  new_descriptors->Append(descriptor);

  return CopyReplaceDescriptors(isolate, map, new_descriptors, flag,
                                descriptor->GetKey(), "CopyAddDescriptor",
                                SIMPLE_PROPERTY_TRANSITION);
}

Handle<Map> Map::CopyInsertDescriptor(Isolate* isolate, DirectHandle<Map> map,
                                      Descriptor* descriptor,
                                      TransitionFlag flag) {
  DirectHandle<DescriptorArray> old_descriptors(
      map->instance_descriptors(isolate), isolate);

  // We replace the key if it is already present.
  InternalIndex index =
      old_descriptors->SearchWithCache(isolate, *descriptor->GetKey(), *map);
  if (index.is_found()) {
    return CopyReplaceDescriptor(isolate, map, old_descriptors, descriptor,
                                 index, flag);
  }
  return CopyAddDescriptor(isolate, map, descriptor, flag);
}

Handle<Map> Map::CopyReplaceDescriptor(
    Isolate* isolate, DirectHandle<Map> map,
    DirectHandle<DescriptorArray> descriptors, Descriptor* descriptor,
    InternalIndex insertion_index, TransitionFlag flag) {
  DirectHandle<Name> key = descriptor->GetKey();
  DCHECK_EQ(*key, descriptors->GetKey(insertion_index));
  // This function does not support replacing property fields as
  // that would break property field counters.
  DCHECK_NE(PropertyLocation::kField, descriptor->GetDetails().location());
  DCHECK_NE(PropertyLocation::kField,
            descriptors->GetDetails(insertion_index).location());

  DirectHandle<DescriptorArray> new_descriptors = DescriptorArray::CopyUpTo(
      isolate, descriptors, map->NumberOfOwnDescriptors());

  new_descriptors->Replace(insertion_index, descriptor);

  TransitionKindFlag simple_flag =
      (insertion_index.as_int() == descriptors->number_of_descriptors() - 1)
          ? SIMPLE_PROPERTY_TRANSITION
          : PROPERTY_TRANSITION;
  return CopyReplaceDescriptors(isolate, map, new_descriptors, flag, key,
                                "CopyReplaceDescriptor", simple_flag);
}

int Map::Hash(Isolate* isolate, Tagged<HeapObject> prototype) {
  // For performance reasons we only hash the 2 most variable fields of a map:
  // prototype and bit_field2.

  int prototype_hash;
  if (IsNull(prototype)) {
    // No identity hash for null, so just pick a random number.
    prototype_hash = 1;
  } else {
    Tagged<JSReceiver> receiver = Cast<JSReceiver>(prototype);
    prototype_hash = receiver->GetOrCreateIdentityHash(isolate).value();
  }

  return prototype_hash ^ bit_field2();
}

namespace {

bool CheckEquivalentModuloProto(const Tagged<Map> first,
                                const Tagged<Map> second) {
  return first->GetConstructorRaw() == second->GetConstructorRaw() &&
         first->instance_type() == second->instance_type() &&
         first->bit_field() == second->bit_field() &&
         first->is_extensible() == second->is_extensible() &&
         first->new_target_is_base() == second->new_target_is_base();
}

}  // namespace

bool Map::EquivalentToForTransition(
    const Tagged<Map> other, ConcurrencyMode cmode,
    DirectHandle<HeapObject> new_prototype) const {
  CHECK_EQ(GetConstructor(), other->GetConstructor());
  CHECK_EQ(instance_type(), other->instance_type());

  if (bit_field() != other->bit_field()) return false;
  if (new_prototype.is_null()) {
    if (prototype() != other->prototype()) return false;
  } else {
    if (*new_prototype != other->prototype()) return false;
  }
  if (new_target_is_base() != other->new_target_is_base()) return false;
  if (InstanceTypeChecker::IsJSFunction(instance_type())) {
    // JSFunctions require more checks to ensure that sloppy function is
    // not equivalent to strict function.
    int nof =
        std::min(NumberOfOwnDescriptors(), other->NumberOfOwnDescriptors());
    Tagged<DescriptorArray> this_descriptors =
        IsConcurrent(cmode) ? instance_descriptors(kAcquireLoad)
                            : instance_descriptors();
    Tagged<DescriptorArray> that_descriptors =
        IsConcurrent(cmode) ? other->instance_descriptors(kAcquireLoad)
                            : other->instance_descriptors();
    return this_descriptors->IsEqualUpTo(that_descriptors, nof);
  }
  return true;
}

bool Map::EquivalentToForElementsKindTransition(const Tagged<Map> other,
                                                ConcurrencyMode cmode) const {
  if (!EquivalentToForTransition(other, cmode)) {
    return false;
  }
#ifdef DEBUG
  // Ensure that we don't try to generate elements kind transitions from maps
  // with fields that may be generalized in-place. This must already be handled
  // during addition of a new field.
  Tagged<DescriptorArray> descriptors = IsConcurrent(cmode)
                                            ? instance_descriptors(kAcquireLoad)
                                            : instance_descriptors();
  for (InternalIndex i : IterateOwnDescriptors()) {
    PropertyDetails details = descriptors->GetDetails(i);
    if (details.location() == PropertyLocation::kField) {
      DCHECK(IsMostGeneralFieldType(details.representation(),
                                    descriptors->GetFieldType(i)));
    }
  }
#endif
  return true;
}

bool Map::EquivalentToForNormalization(const Tagged<Map> other,
                                       ElementsKind elements_kind,
                                       Tagged<HeapObject> other_prototype,
                                       PropertyNormalizationMode mode) const {
  int properties =
      mode == CLEAR_INOBJECT_PROPERTIES ? 0 : other->GetInObjectProperties();
  // Make sure the elements_kind bits are in bit_field2.
  DCHECK_EQ(this->elements_kind(),
            Map::Bits2::ElementsKindBits::decode(bit_field2()));
  int adjusted_other_bit_field2 =
      Map::Bits2::ElementsKindBits::update(other->bit_field2(), elements_kind);
  return CheckEquivalentModuloProto(*this, other) &&
         prototype() == other_prototype &&
         bit_field2() == adjusted_other_bit_field2 &&
         GetInObjectProperties() == properties &&
         JSObject::GetEmbedderFieldCount(*this) ==
             JSObject::GetEmbedderFieldCount(other);
}

int Map::ComputeMinObjectSlack(Isolate* isolate) {
  // Has to be an initial map.
  DCHECK(IsUndefined(GetBackPointer(), isolate));

  int slack = UnusedPropertyFields();
  TransitionsAccessor transitions(isolate, *this);
  TransitionsAccessor::TraverseCallback callback = |&](Tagged<Map> map) {
    slack = std::min(slack, map->UnusedPropertyFields());
  };
  transitions.TraverseTransitionTree(callback);
  return slack;
}

void Map::SetInstanceDescriptors(Isolate* isolate,
                                 Tagged<DescriptorArray> descriptors,
                                 int number_of_own_descriptors,
                                 WriteBarrierMode barrier_mode) {
  DCHECK_IMPLIES(barrier_mode == WriteBarrierMode::SKIP_WRITE_BARRIER,
                 HeapLayout::InReadOnlySpace(descriptors));
  set_instance_descriptors(descriptors, kReleaseStore, barrier_mode);
  SetNumberOfOwnDescriptors(number_of_own_descriptors);
#ifndef V8_DISABLE_WRITE_BARRIERS
  WriteBarrier::ForDescriptorArray(descriptors, number_of_own_descriptors);
#endif
}

// static
Handle<PrototypeInfo> Map::GetOrCreatePrototypeInfo(
    DirectHandle<JSObject> prototype, Isolate* isolate) {
  DCHECK(IsJSObjectThatCanBeTrackedAsPrototype(*prototype));
  {
    Tagged<PrototypeInfo> prototype_info;
    if (prototype->map()->TryGetPrototypeInfo(&prototype_info)) {
      return handle(prototype_info, isolate);
    }
  }
  Handle<PrototypeInfo> proto_info = isolate->factory()->NewPrototypeInfo();
  prototype->map()->set_prototype_info(*proto_info, kReleaseStore);
  return proto_info;
}

// static
Handle<PrototypeInfo> Map::GetOrCreatePrototypeInfo(
    DirectHandle<Map> prototype_map, Isolate* isolate) {
  {
    Tagged<Object> maybe_proto_info = prototype_map->prototype_info();
    if (PrototypeInfo::IsPrototypeInfoFast(maybe_proto_info)) {
      return handle(Cast<PrototypeInfo>(maybe_proto_info), isolate);
    }
  }
  Handle<PrototypeInfo> proto_info = isolate->factory()->NewPrototypeInfo();
  prototype_map->set_prototype_info(*proto_info, kReleaseStore);
  return proto_info;
}

// static
void Map::SetShouldBeFastPrototypeMap(DirectHandle<Map> map, bool value,
                                      Isolate* isolate) {
  DCHECK(map->is_prototype_map());
  if (value == false && !map->has_prototype_info()) {
    // "False" is the implicit default value, so there's nothing to do.
    return;
  }
  GetOrCreatePrototypeInfo(map, isolate)->set_should_be_fast_map(value);
}

// static
Handle<UnionOf<Smi, Cell>> Map::GetOrCreatePrototypeChainValidityCell(
    DirectHandle<Map> map, Isolate* isolate) {
  DirectHandle<Object> maybe_prototype;
  if (IsJSGlobalObjectMap(*map)) {
    DCHECK(map->is_prototype_map());
    // Global object is prototype of a global proxy and therefore we can
    // use its validity cell for guarding global object's prototype change.
    maybe_prototype = isolate->global_object();
  } else {
    maybe_prototype = direct_handle(
        map->GetPrototypeChainRootMap(isolate)->prototype(), isolate);
  }
  if (!IsJSObjectThatCanBeTrackedAsPrototype(*maybe_prototype)) {
    return handle(Map::kPrototypeChainValidSmi, isolate);
  }
  auto prototype = Cast<JSObject>(maybe_prototype);
  // Ensure the prototype is registered with its own prototypes so its cell
  // will be invalidated when necessary.
  JSObject::LazyRegisterPrototypeUser(direct_handle(prototype->map(), isolate),
                                      isolate);

  Tagged<Object> maybe_cell =
      prototype->map()->prototype_validity_cell(kRelaxedLoad);
  // Return existing cell if it's still valid.
  if (IsCell(maybe_cell)) {
    Tagged<Cell> cell = Cast<Cell>(maybe_cell);
    if (cell->value() == Map::kPrototypeChainValidSmi) {
      return handle(cell, isolate);
    }
  }
  // Otherwise create a new cell.
  Handle<Cell> cell = isolate->factory()->NewCell(Map::kPrototypeChainValidSmi);
  prototype->map()->set_prototype_validity_cell(*cell, kRelaxedStore);
  return cell;
}

// static
bool Map::IsPrototypeChainInvalidated(Tagged<Map> map) {
  DCHECK(map->is_prototype_map());
  Tagged<Object> maybe_cell = map->prototype_validity_cell(kRelaxedLoad);
  if (IsCell(maybe_cell)) {
    Tagged<Cell> cell = Cast<Cell>(maybe_cell);
    return cell->value() != Map::kPrototypeChainValidSmi;
  }
  return true;
}

// static
void Map::SetPrototype(Isolate* isolate, DirectHandle<Map> map,
                       DirectHandle<JSPrototype> prototype,
                       bool enable_prototype_setup_mode) {
  RCS_SCOPE(isolate, RuntimeCallCounterId::kMap_SetPrototype);

  if (IsJSObjectThatCanBeTrackedAsPrototype(*prototype)) {
    DirectHandle<JSObject> prototype_jsobj = Cast<JSObject>(prototype);
    JSObject::OptimizeAsPrototype(prototype_jsobj, enable_prototype_setup_mode);
  } else {
    DCHECK(IsNull(*prototype, isolate) || IsJSProxy(*prototype) ||
           IsWasmObject(*prototype) ||
           HeapLayout::InWritableSharedSpace(*prototype));
  }

  WriteBarrierMode wb_mode =
      IsNull(*prototype, isolate) ? SKIP_WRITE_BARRIER : UPDATE_WRITE_BARRIER;
  map->set_prototype(*prototype, wb_mode);
}

void Map::StartInobjectSlackTracking() {
  DCHECK(!this->IsInobjectSlackTrackingInProgress());
  if (UnusedPropertyFields() == 0) return;
  set_construction_counter(Map::kSlackTrackingCounterStart);
}

Handle<Map> Map::TransitionRootMapToPrototypeForNewObject(
    Isolate* isolate, DirectHandle<Map> map,
    DirectHandle<JSPrototype> prototype) {
  DCHECK(IsUndefined(map->GetBackPointer()));
  Handle<Map> new_map = TransitionToUpdatePrototype(isolate, map, prototype);
  if (new_map->GetBackPointer() != *map &&
      map->IsInobjectSlackTrackingInProgress()) {
    // Advance the construction count on the base map to keep it in sync with
    // the transitioned map.
    map->InobjectSlackTrackingStep(isolate);
  }
  return new_map;
}

Handle<Map> Map::TransitionToUpdatePrototype(
    Isolate* isolate, DirectHandle<Map> map,
    DirectHandle<JSPrototype> prototype) {
  Handle<Map> new_map;
  DCHECK_IMPLIES(v8_flags.move_prototype_transitions_first,
                 IsUndefined(map->GetBackPointer()));
  if (auto maybe_map = TransitionsAccessor::GetPrototypeTransition(
          isolate, *map, *prototype)) {
    new_map = handle(*maybe_map, isolate);
  } else {
    new_map = CopyForPrototypeTransition(isolate, map, prototype);
    if (!map->IsDetached(isolate)) {
      TransitionsAccessor::PutPrototypeTransition(isolate, map, prototype,
                                                  new_map);
    }
  }
  DCHECK_IMPLIES(map->IsInobjectSlackTrackingInProgress(),
                 new_map->IsInobjectSlackTrackingInProgress());
  CHECK_IMPLIES(map->IsInobjectSlackTrackingInProgress(),
                map->construction_counter() <= new_map->construction_counter());
  return new_map;
}

Handle<NormalizedMapCache> NormalizedMapCache::New(Isolate* isolate) {
  Handle<WeakFixedArray> array(
      isolate->factory()->NewWeakFixedArray(kEntries, AllocationType::kOld));
  return Cast<NormalizedMapCache>(array);
}

MaybeHandle<Map> NormalizedMapCache::Get(Isolate* isolate,
                                         DirectHandle<Map> fast_map,
                                         ElementsKind elements_kind,
                                         Tagged<HeapObject> prototype,
                                         PropertyNormalizationMode mode) {
  DisallowGarbageCollection no_gc;
  Tagged<MaybeObject> value =
      WeakFixedArray::get(GetIndex(isolate, *fast_map, *prototype));
  Tagged<HeapObject> heap_object;
  if (!value.GetHeapObjectIfWeak(&heap_object)) {
    return MaybeHandle<Map>();
  }

  Tagged<Map> normalized_map = Cast<Map>(heap_object);
  CHECK(normalized_map->is_dictionary_map());
  if (!normalized_map->EquivalentToForNormalization(*fast_map, elements_kind,
                                                    prototype, mode)) {
    return MaybeHandle<Map>();
  }
  return handle(normalized_map, isolate);
}

void NormalizedMapCache::Set(Isolate* isolate, DirectHandle<Map> fast_map,
                             DirectHandle<Map> normalized_map) {
  DisallowGarbageCollection no_gc;
  DCHECK(normalized_map->is_dictionary_map());
  WeakFixedArray::set(GetIndex(isolate, *fast_map, normalized_map->prototype()),
                      MakeWeak(*normalized_map));
}

}  // namespace v8::internal
[Step 51: Duration 19.93 seconds| Input tokens: 2,753,195 | Output tokens: 24,322]
Error executing request to team member 'V8Search' with arguments {'task': 'In src/objects/map-updater.cc, extract the MapUpdater class core logic: constructor inputs, Update() or equivalent driver, cases for 
reconfiguring properties (accessor<->data, attribute/constness changes), representation generalization, field kind transitions, deprecation criteria, target map selection or normalization bailout. Provide 
representative code blocks and function names with paths/lines.'}: cannot access local variable 'final_answer' where it is not associated with a value
Please try again or request to another team member
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'ripgrep' with arguments: {'pattern':                                                                                                                                                          │
│ 'NewDataProperty|NewField|FindTransitionToAccessor|DeprecateTransition|DeprecateTransitions|ReplaceTransitionToData(Property|Field)|FindTransitionToField|CopyWithField|CopyAddDescriptor|CopyReplaceDescrip │
│ tor|OwnsDescriptors|split map|+1 map|one child|single transition|simple transition', 'options': '-n --hidden --no-ignore-vcs'}                                                                               │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
Command: cd /Users/tarun/v8/v8/src && rg -n --hidden --no-ignore-vcs 'NewDataProperty|NewField|FindTransitionToAccessor|DeprecateTransition|DeprecateTransitions|ReplaceTransitionToData(Property|Field)|FindTransitionToField|CopyWithField|CopyAddDescriptor|CopyReplaceDescriptor|OwnsDescriptors|split map|+1 map|one child|single transition|simple transition' | head -n 1000
Observations: rg: regex parse error:
    (?:NewDataProperty|NewField|FindTransitionToAccessor|DeprecateTransition|DeprecateTransitions|ReplaceTransitionToData(Property|Field)|FindTransitionToField|CopyWithField|CopyAddDescriptor|CopyReplaceDescr
iptor|OwnsDescriptors|split map|+1 map|one child|single transition|simple transition)
                                                                                                                                                                                                                
                                ^
error: repetition operator missing expression
[Step 52: Duration 34.37 seconds| Input tokens: 2,883,595 | Output tokens: 25,319]
Error executing request to team member 'V8Search' with arguments {'task': 'In src/objects/property-details.h, extract the encoding of PropertyDetails and Representation/FieldType, including representation 
generalization rules (Smi -> Double -> Tagged/Any), attributes, constness, and helper methods that determine transitionability. Include any constants or enums defining representation lattice.'}: cannot access
local variable 'final_answer' where it is not associated with a value
Please try again or request to another team member
[Step 1: Duration 206.83 seconds| Input tokens: 3,043 | Output tokens: 2,350]
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ Step 2 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'V8Search' with arguments: {'task': 'Stage 1 scoping query. Please locate and extract the key definitions and core control-flow for the named property store pipeline across these             │
│ files/functions (keep output concise to avoid rate limits):\n\n- src/objects/js-objects.cc: JSObject::PrepareForDataProperty, JSObject::NormalizeProperties, JSObject::MigrateFastToSlow, and                │
│ SetNamedProperty slow-path helpers.\n- src/objects/map-updater.cc: MapUpdater (reconfigure property kind accessor↔data, attribute/constness changes, representation generalization), map deprecations and    │
│ target map selection.\n- src/ic/store-ic.cc: StoreIC::Store and StoreIC::UpdateCaches, handler installation (mono/poly/mega) and runtime fallback conditions.\n- src/objects/name-dictionary-inl.h and       │
│ src/objects/dictionary.h: NameDictionary mechanics for slow properties (FindEntry, Add, Rehash triggers, Capacity/Load limits).\n- src/objects/property-details.h: Representation generalization,            │
│ attributes, constness fields and helper methods.\n- src/objects/transitions.cc: TransitionArray transitions for fields/accessors, DeprecateTransition(s), NewDataProperty/Field transitions, +1 map          │
│ creation, divergence handling.\n\nReturn for each item: file path, function/class name, brief signature, and 3-5 bullet key points of what it does and important conditionals/flags relevant to named        │
│ property stores.'}                                                                                                                                                                                           │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────── New run - V8Search ─────────────────────────────────────────────────────────────────────────────────────────────╮
│                                                                                                                                                                                                              │
│ You're a helpful agent named 'V8Search'.                                                                                                                                                                     │
│ You have been submitted this task by your manager.                                                                                                                                                           │
│ ---                                                                                                                                                                                                          │
│ Task:                                                                                                                                                                                                        │
│ Stage 1 scoping query. Please locate and extract the key definitions and core control-flow for the named property store pipeline across these files/functions (keep output concise to avoid rate limits):    │
│                                                                                                                                                                                                              │
│ - src/objects/js-objects.cc: JSObject::PrepareForDataProperty, JSObject::NormalizeProperties, JSObject::MigrateFastToSlow, and SetNamedProperty slow-path helpers.                                           │
│ - src/objects/map-updater.cc: MapUpdater (reconfigure property kind accessor↔data, attribute/constness changes, representation generalization), map deprecations and target map selection.                   │
│ - src/ic/store-ic.cc: StoreIC::Store and StoreIC::UpdateCaches, handler installation (mono/poly/mega) and runtime fallback conditions.                                                                       │
│ - src/objects/name-dictionary-inl.h and src/objects/dictionary.h: NameDictionary mechanics for slow properties (FindEntry, Add, Rehash triggers, Capacity/Load limits).                                      │
│ - src/objects/property-details.h: Representation generalization, attributes, constness fields and helper methods.                                                                                            │
│ - src/objects/transitions.cc: TransitionArray transitions for fields/accessors, DeprecateTransition(s), NewDataProperty/Field transitions, +1 map creation, divergence handling.                             │
│                                                                                                                                                                                                              │
│ Return for each item: file path, function/class name, brief signature, and 3-5 bullet key points of what it does and important conditionals/flags relevant to named property stores.                         │
│ ---                                                                                                                                                                                                          │
│ You're helping your manager solve a wider task: so make sure to not provide a one-line answer, but give as much information as possible to give them a clear understanding of the answer.                    │
│                                                                                                                                                                                                              │
│ Your final_answer WILL HAVE to contain these parts:                                                                                                                                                          │
│ ### 1. Task outcome (short version):                                                                                                                                                                         │
│ ### 2. Task outcome (extremely detailed version):                                                                                                                                                            │
│ ### 3. Additional context (if relevant):                                                                                                                                                                     │
│                                                                                                                                                                                                              │
│ Put all these in your final_answer tool, everything that you do not pass as an argument to final_answer will be lost.                                                                                        │
│ And even if your task resolution is not successful, please return as much context as possible, so that your manager can act upon this feedback.                                                              │
│                                                                                                                                                                                                              │
╰─ LiteLLMModel - gpt-5 ───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ Step 1 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
[Step 1: Duration 8.84 seconds]
[Step 2: Duration 44.33 seconds| Input tokens: 6,297 | Output tokens: 4,460]
[Step 3: Duration 345.33 seconds| Input tokens: 26,575 | Output tokens: 4,267]
Traceback (most recent call last):
  File "/Users/tarun/vrig/fuzzillai/Sources/Agentic_System/rises-the-fog.py", line 101, in <module>
    sys.exit(main())
             ~~~~^^
  File "/Users/tarun/vrig/fuzzillai/Sources/Agentic_System/rises-the-fog.py", line 95, in main
    a.system.start_system()
    ~~~~~~~~~~~~~~~~~~~~~^^
  File "/Users/tarun/vrig/fuzzillai/Sources/Agentic_System/agents/FoG.py", line 251, in start_system
    result = self.run_task(
        task_description="Initialize Root Manager orchestration",
    ...<5 lines>...
        }
    )
  File "/Users/tarun/vrig/fuzzillai/Sources/Agentic_System/agents/BaseAgent.py", line 323, in run_task
    agent_output = manager_agent.run(prompt)
  File "/Users/tarun/vrig/fuzzillai/Sources/Agentic_System/agents/BaseAgent.py", line 292, in _wrapped_run
    result = orig_run(prompt, *args, **kwargs)
  File "/Users/tarun/vrig/fuzzillai/.venv/lib/python3.14/site-packages/smolagents/agents.py", line 503, in run
    steps = list(self._run_stream(task=self.task, max_steps=max_steps, images=images))
  File "/Users/tarun/vrig/fuzzillai/.venv/lib/python3.14/site-packages/smolagents/agents.py", line 582, in _run_stream
    for output in self._step_stream(action_step):
                  ~~~~~~~~~~~~~~~~~^^^^^^^^^^^^^
  File "/Users/tarun/vrig/fuzzillai/.venv/lib/python3.14/site-packages/smolagents/agents.py", line 1322, in _step_stream
    for output in self.process_tool_calls(chat_message, memory_step):
                  ~~~~~~~~~~~~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Users/tarun/vrig/fuzzillai/.venv/lib/python3.14/site-packages/smolagents/agents.py", line 1407, in process_tool_calls
    tool_output = process_single_tool_call(tool_call)
  File "/Users/tarun/vrig/fuzzillai/.venv/lib/python3.14/site-packages/smolagents/agents.py", line 1376, in process_single_tool_call
    tool_call_result = self.execute_tool_call(tool_name, tool_arguments)
  File "/Users/tarun/vrig/fuzzillai/.venv/lib/python3.14/site-packages/smolagents/agents.py", line 1474, in execute_tool_call
    return tool(**arguments) if is_managed_agent else tool(**arguments, sanitize_inputs_outputs=True)
           ~~~~^^^^^^^^^^^^^
  File "/Users/tarun/vrig/fuzzillai/.venv/lib/python3.14/site-packages/smolagents/agents.py", line 877, in __call__
    result = self.run(full_task, **kwargs)
  File "/Users/tarun/vrig/fuzzillai/.venv/lib/python3.14/site-packages/smolagents/agents.py", line 503, in run
    steps = list(self._run_stream(task=self.task, max_steps=max_steps, images=images))
  File "/Users/tarun/vrig/fuzzillai/.venv/lib/python3.14/site-packages/smolagents/agents.py", line 582, in _run_stream
    for output in self._step_stream(action_step):
                  ~~~~~~~~~~~~~~~~~^^^^^^^^^^^^^
  File "/Users/tarun/vrig/fuzzillai/.venv/lib/python3.14/site-packages/smolagents/agents.py", line 1322, in _step_stream
    for output in self.process_tool_calls(chat_message, memory_step):
                  ~~~~~~~~~~~~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Users/tarun/vrig/fuzzillai/.venv/lib/python3.14/site-packages/smolagents/agents.py", line 1407, in process_tool_calls
    tool_output = process_single_tool_call(tool_call)
  File "/Users/tarun/vrig/fuzzillai/.venv/lib/python3.14/site-packages/smolagents/agents.py", line 1376, in process_single_tool_call
    tool_call_result = self.execute_tool_call(tool_name, tool_arguments)
  File "/Users/tarun/vrig/fuzzillai/.venv/lib/python3.14/site-packages/smolagents/agents.py", line 1474, in execute_tool_call
    return tool(**arguments) if is_managed_agent else tool(**arguments, sanitize_inputs_outputs=True)
           ~~~~^^^^^^^^^^^^^
  File "/Users/tarun/vrig/fuzzillai/.venv/lib/python3.14/site-packages/smolagents/agents.py", line 877, in __call__
    result = self.run(full_task, **kwargs)
  File "/Users/tarun/vrig/fuzzillai/.venv/lib/python3.14/site-packages/smolagents/agents.py", line 503, in run
    steps = list(self._run_stream(task=self.task, max_steps=max_steps, images=images))
  File "/Users/tarun/vrig/fuzzillai/.venv/lib/python3.14/site-packages/smolagents/agents.py", line 582, in _run_stream
    for output in self._step_stream(action_step):
                  ~~~~~~~~~~~~~~~~~^^^^^^^^^^^^^
  File "/Users/tarun/vrig/fuzzillai/.venv/lib/python3.14/site-packages/smolagents/agents.py", line 1290, in _step_stream
    chat_message: ChatMessage = self.model.generate(
                                ~~~~~~~~~~~~~~~~~~~^
        input_messages,
        ^^^^^^^^^^^^^^^
        stop_sequences=["Observation:", "Calling tools:"],
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        tools_to_call_from=self.tools_and_managed_agents,
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    )
    ^
  File "/Users/tarun/vrig/fuzzillai/.venv/lib/python3.14/site-packages/smolagents/models.py", line 1243, in generate
    response = self.client.completion(**completion_kwargs)
  File "/Users/tarun/vrig/fuzzillai/Sources/Agentic_System/agents/BaseAgent.py", line 164, in wrapped_completion
    result = original_completion(*args, **kwargs)
  File "/Users/tarun/vrig/fuzzillai/.venv/lib/python3.14/site-packages/litellm/utils.py", line 1244, in wrapper
    result = original_function(*args, **kwargs)
  File "/Users/tarun/vrig/fuzzillai/.venv/lib/python3.14/site-packages/litellm/main.py", line 2125, in completion
    response = openai_chat_completions.completion(
        model=model,
    ...<16 lines>...
        shared_session=shared_session,
    )
  File "/Users/tarun/vrig/fuzzillai/.venv/lib/python3.14/site-packages/litellm/llms/openai/openai.py", line 673, in completion
    ) = self.make_sync_openai_chat_completion_request(
        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^
        openai_client=openai_client,
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    ...<2 lines>...
        logging_obj=logging_obj,
        ^^^^^^^^^^^^^^^^^^^^^^^^
    )
    ^
  File "/Users/tarun/vrig/fuzzillai/.venv/lib/python3.14/site-packages/litellm/litellm_core_utils/logging_utils.py", line 237, in sync_wrapper
    result = func(*args, **kwargs)
  File "/Users/tarun/vrig/fuzzillai/.venv/lib/python3.14/site-packages/litellm/llms/openai/openai.py", line 471, in make_sync_openai_chat_completion_request
    raw_response = openai_client.chat.completions.with_raw_response.create(
        **data, timeout=timeout
    )
  File "/Users/tarun/vrig/fuzzillai/.venv/lib/python3.14/site-packages/openai/_legacy_response.py", line 364, in wrapped
    return cast(LegacyAPIResponse[R], func(*args, **kwargs))
                                      ~~~~^^^^^^^^^^^^^^^^^
  File "/Users/tarun/vrig/fuzzillai/.venv/lib/python3.14/site-packages/openai/_utils/_utils.py", line 286, in wrapper
    return func(*args, **kwargs)
  File "/Users/tarun/vrig/fuzzillai/.venv/lib/python3.14/site-packages/openai/resources/chat/completions/completions.py", line 1156, in create
    return self._post(
           ~~~~~~~~~~^
        "/chat/completions",
        ^^^^^^^^^^^^^^^^^^^^
    ...<46 lines>...
        stream_cls=Stream[ChatCompletionChunk],
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    )
    ^
  File "/Users/tarun/vrig/fuzzillai/.venv/lib/python3.14/site-packages/openai/_base_client.py", line 1259, in post
    return cast(ResponseT, self.request(cast_to, opts, stream=stream, stream_cls=stream_cls))
                           ~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Users/tarun/vrig/fuzzillai/.venv/lib/python3.14/site-packages/openai/_base_client.py", line 982, in request
    response = self._client.send(
        request,
        stream=stream or self._should_stream_response_body(request=request),
        **kwargs,
    )
  File "/Users/tarun/vrig/fuzzillai/.venv/lib/python3.14/site-packages/httpx/_client.py", line 914, in send
    response = self._send_handling_auth(
        request,
    ...<2 lines>...
        history=[],
    )
  File "/Users/tarun/vrig/fuzzillai/.venv/lib/python3.14/site-packages/httpx/_client.py", line 942, in _send_handling_auth
    response = self._send_handling_redirects(
        request,
        follow_redirects=follow_redirects,
        history=history,
    )
  File "/Users/tarun/vrig/fuzzillai/.venv/lib/python3.14/site-packages/httpx/_client.py", line 979, in _send_handling_redirects
    response = self._send_single_request(request)
  File "/Users/tarun/vrig/fuzzillai/.venv/lib/python3.14/site-packages/httpx/_client.py", line 1014, in _send_single_request
    response = transport.handle_request(request)
  File "/Users/tarun/vrig/fuzzillai/.venv/lib/python3.14/site-packages/httpx/_transports/default.py", line 250, in handle_request
    resp = self._pool.handle_request(req)
  File "/Users/tarun/vrig/fuzzillai/.venv/lib/python3.14/site-packages/httpcore/_sync/connection_pool.py", line 256, in handle_request
    raise exc from None
  File "/Users/tarun/vrig/fuzzillai/.venv/lib/python3.14/site-packages/httpcore/_sync/connection_pool.py", line 236, in handle_request
    response = connection.handle_request(
        pool_request.request
    )
  File "/Users/tarun/vrig/fuzzillai/.venv/lib/python3.14/site-packages/httpcore/_sync/connection.py", line 103, in handle_request
    return self._connection.handle_request(request)
           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^^^^^^^^^
  File "/Users/tarun/vrig/fuzzillai/.venv/lib/python3.14/site-packages/httpcore/_sync/http11.py", line 136, in handle_request
    raise exc
  File "/Users/tarun/vrig/fuzzillai/.venv/lib/python3.14/site-packages/httpcore/_sync/http11.py", line 106, in handle_request
    ) = self._receive_response_headers(**kwargs)
        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^^^^^^^^^^
  File "/Users/tarun/vrig/fuzzillai/.venv/lib/python3.14/site-packages/httpcore/_sync/http11.py", line 177, in _receive_response_headers
    event = self._receive_event(timeout=timeout)
  File "/Users/tarun/vrig/fuzzillai/.venv/lib/python3.14/site-packages/httpcore/_sync/http11.py", line 217, in _receive_event
    data = self._network_stream.read(
        self.READ_NUM_BYTES, timeout=timeout
    )
  File "/Users/tarun/vrig/fuzzillai/.venv/lib/python3.14/site-packages/httpcore/_backends/sync.py", line 128, in read
    return self._sock.recv(max_bytes)
           ~~~~~~~~~~~~~~~^^^^^^^^^^^
  File "/opt/homebrew/Cellar/python@3.14/3.14.0/Frameworks/Python.framework/Versions/3.14/lib/python3.14/ssl.py", line 1285, in recv
    return self.read(buflen)
           ~~~~~~~~~^^^^^^^^
  File "/opt/homebrew/Cellar/python@3.14/3.14.0/Frameworks/Python.framework/Versions/3.14/lib/python3.14/ssl.py", line 1140, in read
    return self._sslobj.read(len)
           ~~~~~~~~~~~~~~~~~^^^^^
KeyboardInterrupt
