I must go in; the fog is rising
Initializing FatherOfGod
[DEBUG] Root manager prompt set. Custom prompt length: 2001, Full template length: 3388
[DEBUG] Prompt starts with: # ROLE

You are a root manager of a complex multi-agent system whose goal is to produce FuzzIL Progr...
╭─────────────────────────────────────────────────────────────────────────────── New run - FatherOfGeorge ───────────────────────────────────────────────────────────────────────────────╮
│                                                                                                                                                                                        │
│ Task: Initialize Root Manager orchestration                                                                                                                                            │
│                                                                                                                                                                                        │
│ Context:                                                                                                                                                                               │
│ - PickSection: Select a promising V8 code region to analyze                                                                                                                            │
│ - FatherOfGeorge: Primary orchestrator of the system, coordinates between analysis and program generation                                                                              │
│ - CodeAnalyzer: Analyze V8 code and knowledge bases to guide the program template building                                                                                             │
│ - ProgramBuilder: Generate Fuzzilli program templates for fuzzing a specific code region                                                                                               │
│                                                                                                                                                                                        │
╰─ LiteLLMModel - gpt-5 ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ Step 1 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'PickSection' with arguments: {'task': 'Select a single primary V8 JIT-adjacent code region that is both (a) highly fuzzable from plain JavaScript/FuzzIL and (b)        │
│ historically prone to type/IC/ElementsKind issues. Provide concrete entry points and file/function references. Guidelines and deliverables:\n\nScope and constraints:\n- Focus on      │
│ JS-to-optimized JIT interactions (Ignition -> Maglev -> TurboFan), inline caches (Load/Store/Keyed), elements transitions, and builtin fast paths. Prefer code reachable via common    │
│ Array/TypedArray/Object builtins rather than exotic features requiring special harnesses.\n- Exclude pure WASM engine internals and features requiring external embedding/harness.\n-  │
│ Aim for areas with: elements kind transitions (packed/holey, smi/double/object), length/capacity growth, inbounds/out-of-bounds edge handling, species/prototype lookups, deopts, and  │
│ feedback vector mutations.\n\nEvaluation criteria:\n- Multiple controllable knobs from JS (array lengths, holes, prototype mutations, map changes, %Deopt-style behaviors via patterns │
│ that trigger deopt, etc.).\n- Clear linkage to IC handlers and TurboFan lowering/reduction passes (e.g., JSCreateLowering, Map/Elements transitions, SimplifiedLowering,               │
│ TypedArray/Array builtins lowering, AccessInfo computations).\n- Presence of both fast-path and slow-path transitions that can be toggled via JS shapes.\n\nDeliverable format:\n1)    │
│ Primary pick\n- Name/subsystem: concise title\n- Rationale: why this is high value for fuzzing\n- V8 loci (files/functions): exact file paths and notable functions (e.g., src/ic/*,   │
│ src/builtins/*, src/compiler/*).\n- Triggering JS patterns: concrete operations (e.g., Array.prototype.push/slice/splice, keyed stores of mixed types, prototype swaps, length         │
│ manipulation, hole creation, comparator functions for sort, etc.).\n- Preconditions/shape constraints: elements kinds, maps, Smi vs HeapNumber, sealed/frozen, length writable,        │
│ etc.\n- JIT linkage: relevant IC stubs/handlers and TurboFan reducers/typer nodes.\n- Fuzz knobs: list of toggles/parameters we can vary in FuzzIL (types, lengths, holes, prototype   │
│ changes, getters/setters, species, side-effectful comparator, etc.).\n- Bug classes to target: e.g., type confusion across ElementsKind, out-of-bounds during capacity growth,         │
│ incorrect hole handling, stale feedback/IC state, deopt mishandling.\n- Minimal seed snippet: short JS demonstrating entry into the fast path and showing how to flip to slow          │
│ path.\n\n2) Two alternates (brief)\n- Name/subsystem, key files, and 2-3 sentence rationale + main JS knobs.\n\nSelect one primary and provide rich enough detail that CodeAnalyzer    │
│ can immediately begin Stage 1 planning grounded in actual files/functions.'}                                                                                                           │
╰────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────── New run - PickSection ─────────────────────────────────────────────────────────────────────────────────╮
│                                                                                                                                                                                        │
│ You're a helpful agent named 'PickSection'.                                                                                                                                            │
│ You have been submitted this task by your manager.                                                                                                                                     │
│ ---                                                                                                                                                                                    │
│ Task:                                                                                                                                                                                  │
│ Select a single primary V8 JIT-adjacent code region that is both (a) highly fuzzable from plain JavaScript/FuzzIL and (b) historically prone to type/IC/ElementsKind issues. Provide   │
│ concrete entry points and file/function references. Guidelines and deliverables:                                                                                                       │
│                                                                                                                                                                                        │
│ Scope and constraints:                                                                                                                                                                 │
│ - Focus on JS-to-optimized JIT interactions (Ignition -> Maglev -> TurboFan), inline caches (Load/Store/Keyed), elements transitions, and builtin fast paths. Prefer code reachable    │
│ via common Array/TypedArray/Object builtins rather than exotic features requiring special harnesses.                                                                                   │
│ - Exclude pure WASM engine internals and features requiring external embedding/harness.                                                                                                │
│ - Aim for areas with: elements kind transitions (packed/holey, smi/double/object), length/capacity growth, inbounds/out-of-bounds edge handling, species/prototype lookups, deopts,    │
│ and feedback vector mutations.                                                                                                                                                         │
│                                                                                                                                                                                        │
│ Evaluation criteria:                                                                                                                                                                   │
│ - Multiple controllable knobs from JS (array lengths, holes, prototype mutations, map changes, %Deopt-style behaviors via patterns that trigger deopt, etc.).                          │
│ - Clear linkage to IC handlers and TurboFan lowering/reduction passes (e.g., JSCreateLowering, Map/Elements transitions, SimplifiedLowering, TypedArray/Array builtins lowering,       │
│ AccessInfo computations).                                                                                                                                                              │
│ - Presence of both fast-path and slow-path transitions that can be toggled via JS shapes.                                                                                              │
│                                                                                                                                                                                        │
│ Deliverable format:                                                                                                                                                                    │
│ 1) Primary pick                                                                                                                                                                        │
│ - Name/subsystem: concise title                                                                                                                                                        │
│ - Rationale: why this is high value for fuzzing                                                                                                                                        │
│ - V8 loci (files/functions): exact file paths and notable functions (e.g., src/ic/*, src/builtins/*, src/compiler/*).                                                                  │
│ - Triggering JS patterns: concrete operations (e.g., Array.prototype.push/slice/splice, keyed stores of mixed types, prototype swaps, length manipulation, hole creation, comparator   │
│ functions for sort, etc.).                                                                                                                                                             │
│ - Preconditions/shape constraints: elements kinds, maps, Smi vs HeapNumber, sealed/frozen, length writable, etc.                                                                       │
│ - JIT linkage: relevant IC stubs/handlers and TurboFan reducers/typer nodes.                                                                                                           │
│ - Fuzz knobs: list of toggles/parameters we can vary in FuzzIL (types, lengths, holes, prototype changes, getters/setters, species, side-effectful comparator, etc.).                  │
│ - Bug classes to target: e.g., type confusion across ElementsKind, out-of-bounds during capacity growth, incorrect hole handling, stale feedback/IC state, deopt mishandling.          │
│ - Minimal seed snippet: short JS demonstrating entry into the fast path and showing how to flip to slow path.                                                                          │
│                                                                                                                                                                                        │
│ 2) Two alternates (brief)                                                                                                                                                              │
│ - Name/subsystem, key files, and 2-3 sentence rationale + main JS knobs.                                                                                                               │
│                                                                                                                                                                                        │
│ Select one primary and provide rich enough detail that CodeAnalyzer can immediately begin Stage 1 planning grounded in actual files/functions.                                         │
│ ---                                                                                                                                                                                    │
│ You're helping your manager solve a wider task: so make sure to not provide a one-line answer, but give as much information as possible to give them a clear understanding of the      │
│ answer.                                                                                                                                                                                │
│                                                                                                                                                                                        │
│ Your final_answer WILL HAVE to contain these parts:                                                                                                                                    │
│ ### 1. Task outcome (short version):                                                                                                                                                   │
│ ### 2. Task outcome (extremely detailed version):                                                                                                                                      │
│ ### 3. Additional context (if relevant):                                                                                                                                               │
│                                                                                                                                                                                        │
│ Put all these in your final_answer tool, everything that you do not pass as an argument to final_answer will be lost.                                                                  │
│ And even if your task resolution is not successful, please return as much context as possible, so that your manager can act upon this feedback.                                        │
│                                                                                                                                                                                        │
╰─ LiteLLMModel - gpt-5-mini ────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ Step 1 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'get_random_entry_data' with arguments: {}                                                                                                                               │
╰────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
Observations: this is entry data for regress/regress-489151
{"js": "// Copyright 2015 the V8 project authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE 
file.\n\nthis.__proto__ = Array.prototype;\nObject.freeze(this);\nfunction __f_0() {\n  for (var __v_0 = 0; __v_0 < 10; __v_0++) {\n    this.length = 1;\n  }\n}\n __f_0();\n", 
"Fuzzilli": "v0 <- CreateNamedVariable 'Array', 'none'\nv1 <- GetProperty v0, 'prototype'\nv2 <- LoadThis\nSetProperty v2, '__proto__', v1\nv3 <- LoadThis\nv4 <- CreateNamedVariable 
'Object', 'none'\nv5 <- CallMethod v4, 'freeze', |v3]\nv6 <- BeginPlainFunction -> \n    BeginForLoopInitializer\n        v7 <- LoadInteger '0'\n    BeginForLoopCondition -> v8\n        
v9 <- LoadInteger '10'\n        v10 <- Compare v8, '<', v9\n    BeginForLoopAfterthought v10 -> v11\n        v12 <- UnaryOperation v11, '++'\n    BeginForLoopBody -> v13\n        v14 <- 
LoadInteger '1'\n        v15 <- LoadThis\n        SetProperty v15, 'length', v14\n    EndForLoop\nEndPlainFunction\nv16 <- CallFunction v6, |]\n\n\nthis.__proto__ = 
Array.prototype;\nObject.freeze(this);\nfunction __f_0() {\n    for (let i8 = 0; i8 < 10; i8++) {\n        this.length = 1;\n    }\n}\n__f_0();", "execution_data": "Concurrent maglev has
been disabled for tracing.\n|generated bytecode for function:  (0x37c95f1da429 <SharedFunctionInfo>)]\nBytecode length: 54\nParameter count 1\nRegister count 4\nFrame size 32\n         
0xfcbfd9b5778 @    0 : 13 00             LdaConstant |0]\n         0xfcbfd9b577a @    2 : d1                Star1\n         0xfcbfd9b577b @    3 : 1b fe f7          Mov <closure>, r2\n  
0 E> 0xfcbfd9b577e @    6 : 6e 6c 01 f8 02    CallRuntime |DeclareGlobals], r1-r2\n  168 S> 0xfcbfd9b5783 @   11 : 23 01 00          LdaGlobal |1], |0]\n         0xfcbfd9b5786 @   14 : 
d1                Star1\n  185 E> 0xfcbfd9b5787 @   15 : 23 02 02          LdaGlobal |2], |2]\n         0xfcbfd9b578a @   18 : d0                Star2\n  191 E> 0xfcbfd9b578b @   19 : 33
f7 03 04       GetNamedProperty r2, |3], |4]\n  183 E> 0xfcbfd9b578f @   23 : 39 f8 04 06       SetNamedProperty r1, |4], |6]\n  202 S> 0xfcbfd9b5793 @   27 : 23 05 08          LdaGlobal
|5], |8]\n         0xfcbfd9b5796 @   30 : d0                Star2\n  209 E> 0xfcbfd9b5797 @   31 : 33 f7 06 0a       GetNamedProperty r2, |6], |10]\n         0xfcbfd9b579b @   35 : d1   
Star1\n         0xfcbfd9b579c @   36 : 23 01 00          LdaGlobal |1], |0]\n         0xfcbfd9b579f @   39 : cf                Star3\n  209 E> 0xfcbfd9b57a0 @   40 : 67 f8 f7 f6 0c    
CallProperty1 r1, r2, r3, |12]\n  315 S> 0xfcbfd9b57a5 @   45 : 23 07 0e          LdaGlobal |7], |14]\n         0xfcbfd9b57a8 @   48 : d1                Star1\n  315 E> 0xfcbfd9b57a9 @  
49 : 6a f8 10          CallUndefinedReceiver0 r1, |16]\n         0xfcbfd9b57ac @   52 : d2                Star0\n  324 S> 0xfcbfd9b57ad @   53 : b7                Return\nConstant pool 
(size = 8)\n0xfcbfd9b56e9: |TrustedFixedArray]\n - map: 0x00f808040ab9 <Map(TRUSTED_FIXED_ARRAY_TYPE)>\n - length: 8\n           0: 0x37c95f1da4b1 <FixedArray|2]>\n           1: 
0x00f808047421 <String|4]: #this>\n           2: 0x00f808045551 <String|5]: #Array>\n           3: 0x00f8080418a1 <String|9]: #prototype>\n           4: 0x00f808046cb9 <String|9]: 
#__proto__>\n           5: 0x00f808046ac1 <String|6]: #Object>\n           6: 0x2056107c5739 <String|6]: #freeze>\n           7: 0x37c95f1da3d9 <String|5]: #__f_0>\nHandler Table (size =
0)\nSource Position Table (size = 26)\n0x0fcbfd9b57b1 <Other heap object (TRUSTED_BYTE_ARRAY_TYPE)>\n|generated bytecode for function: __f_0 (0x37c95f1da4d1 <SharedFunctionInfo 
__f_0>)]\nBytecode length: 26\nParameter count 1\nRegister count 1\nFrame size 8\n  261 S> 0xfcbfd9b5838 @    0 : 0c                LdaZero\n         0xfcbfd9b5839 @    1 : d2           
Star0\n  270 S> 0xfcbfd9b583a @    2 : 0d 0a             LdaSmi |10]\n  270 E> 0xfcbfd9b583c @    4 : 77 f9 00          TestLessThan r0, |0]\n         0xfcbfd9b583f @    7 : a6 11       
JumpIfFalse |17] (0xfcbfd9b5850 @ 24)\n  291 S> 0xfcbfd9b5841 @    9 : 0d 01             LdaSmi |1]\n  303 E> 0xfcbfd9b5843 @   11 : 39 02 00 01       SetNamedProperty <this>, |0], |1]\n
281 S> 0xfcbfd9b5847 @   15 : 0b f9             Ldar r0\n         0xfcbfd9b5849 @   17 : 59 03             Inc |3]\n         0xfcbfd9b584b @   19 : d2                Star0\n  244 E> 
0xfcbfd9b584c @   20 : 95 12 00 04       JumpLoop |18], |0], |4] (0xfcbfd9b583a @ 2)\n         0xfcbfd9b5850 @   24 : 0e                LdaUndefined\n  312 S> 0xfcbfd9b5851 @   25 : b7  
Return\nConstant pool (size = 1)\n0xfcbfd9b57e1: |TrustedFixedArray]\n - map: 0x00f808040ab9 <Map(TRUSTED_FIXED_ARRAY_TYPE)>\n - length: 1\n           0: 0x00f8080418d9 <String|6]: 
#length>\nHandler Table (size = 0)\nSource Position Table (size = 21)\n0x0fcbfd9b5859 <Other heap object (TRUSTED_BYTE_ARRAY_TYPE)>\n"}
[Step 1: Duration 3.63 seconds| Input tokens: 1,786 | Output tokens: 85]
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ Step 2 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'search_js_file_name_by_pattern' with arguments: {'pattern': '489151'}                                                                                                   │
╰────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
Observations: regress/regress-489151
[Step 2: Duration 5.85 seconds| Input tokens: 5,623 | Output tokens: 305]
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ Step 3 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'get_js_entry_data_by_name' with arguments: {'file_name': 'regress/regress-489151'}                                                                                      │
╰────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
Observations: {"js": "// Copyright 2015 the V8 project authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE 
file.\n\nthis.__proto__ = Array.prototype;\nObject.freeze(this);\nfunction __f_0() {\n  for (var __v_0 = 0; __v_0 < 10; __v_0++) {\n    this.length = 1;\n  }\n}\n __f_0();\n", 
"Fuzzilli": "v0 <- CreateNamedVariable 'Array', 'none'\nv1 <- GetProperty v0, 'prototype'\nv2 <- LoadThis\nSetProperty v2, '__proto__', v1\nv3 <- LoadThis\nv4 <- CreateNamedVariable 
'Object', 'none'\nv5 <- CallMethod v4, 'freeze', |v3]\nv6 <- BeginPlainFunction -> \n    BeginForLoopInitializer\n        v7 <- LoadInteger '0'\n    BeginForLoopCondition -> v8\n        
v9 <- LoadInteger '10'\n        v10 <- Compare v8, '<', v9\n    BeginForLoopAfterthought v10 -> v11\n        v12 <- UnaryOperation v11, '++'\n    BeginForLoopBody -> v13\n        v14 <- 
LoadInteger '1'\n        v15 <- LoadThis\n        SetProperty v15, 'length', v14\n    EndForLoop\nEndPlainFunction\nv16 <- CallFunction v6, |]\n\n\nthis.__proto__ = 
Array.prototype;\nObject.freeze(this);\nfunction __f_0() {\n    for (let i8 = 0; i8 < 10; i8++) {\n        this.length = 1;\n    }\n}\n__f_0();", "execution_data": "Concurrent maglev has
been disabled for tracing.\n|generated bytecode for function:  (0x37c95f1da429 <SharedFunctionInfo>)]\nBytecode length: 54\nParameter count 1\nRegister count 4\nFrame size 32\n         
0xfcbfd9b5778 @    0 : 13 00             LdaConstant |0]\n         0xfcbfd9b577a @    2 : d1                Star1\n         0xfcbfd9b577b @    3 : 1b fe f7          Mov <closure>, r2\n  
0 E> 0xfcbfd9b577e @    6 : 6e 6c 01 f8 02    CallRuntime |DeclareGlobals], r1-r2\n  168 S> 0xfcbfd9b5783 @   11 : 23 01 00          LdaGlobal |1], |0]\n         0xfcbfd9b5786 @   14 : 
d1                Star1\n  185 E> 0xfcbfd9b5787 @   15 : 23 02 02          LdaGlobal |2], |2]\n         0xfcbfd9b578a @   18 : d0                Star2\n  191 E> 0xfcbfd9b578b @   19 : 33
f7 03 04       GetNamedProperty r2, |3], |4]\n  183 E> 0xfcbfd9b578f @   23 : 39 f8 04 06       SetNamedProperty r1, |4], |6]\n  202 S> 0xfcbfd9b5793 @   27 : 23 05 08          LdaGlobal
|5], |8]\n         0xfcbfd9b5796 @   30 : d0                Star2\n  209 E> 0xfcbfd9b5797 @   31 : 33 f7 06 0a       GetNamedProperty r2, |6], |10]\n         0xfcbfd9b579b @   35 : d1   
Star1\n         0xfcbfd9b579c @   36 : 23 01 00          LdaGlobal |1], |0]\n         0xfcbfd9b579f @   39 : cf                Star3\n  209 E> 0xfcbfd9b57a0 @   40 : 67 f8 f7 f6 0c    
CallProperty1 r1, r2, r3, |12]\n  315 S> 0xfcbfd9b57a5 @   45 : 23 07 0e          LdaGlobal |7], |14]\n         0xfcbfd9b57a8 @   48 : d1                Star1\n  315 E> 0xfcbfd9b57a9 @  
49 : 6a f8 10          CallUndefinedReceiver0 r1, |16]\n         0xfcbfd9b57ac @   52 : d2                Star0\n  324 S> 0xfcbfd9b57ad @   53 : b7                Return\nConstant pool 
(size = 8)\n0xfcbfd9b56e9: |TrustedFixedArray]\n - map: 0x00f808040ab9 <Map(TRUSTED_FIXED_ARRAY_TYPE)>\n - length: 8\n           0: 0x37c95f1da4b1 <FixedArray|2]>\n           1: 
0x00f808047421 <String|4]: #this>\n           2: 0x00f808045551 <String|5]: #Array>\n           3: 0x00f8080418a1 <String|9]: #prototype>\n           4: 0x00f808046cb9 <String|9]: 
#__proto__>\n           5: 0x00f808046ac1 <String|6]: #Object>\n           6: 0x2056107c5739 <String|6]: #freeze>\n           7: 0x37c95f1da3d9 <String|5]: #__f_0>\nHandler Table (size =
0)\nSource Position Table (size = 26)\n0x0fcbfd9b57b1 <Other heap object (TRUSTED_BYTE_ARRAY_TYPE)>\n|generated bytecode for function: __f_0 (0x37c95f1da4d1 <SharedFunctionInfo 
__f_0>)]\nBytecode length: 26\nParameter count 1\nRegister count 1\nFrame size 8\n  261 S> 0xfcbfd9b5838 @    0 : 0c                LdaZero\n         0xfcbfd9b5839 @    1 : d2           
Star0\n  270 S> 0xfcbfd9b583a @    2 : 0d 0a             LdaSmi |10]\n  270 E> 0xfcbfd9b583c @    4 : 77 f9 00          TestLessThan r0, |0]\n         0xfcbfd9b583f @    7 : a6 11       
JumpIfFalse |17] (0xfcbfd9b5850 @ 24)\n  291 S> 0xfcbfd9b5841 @    9 : 0d 01             LdaSmi |1]\n  303 E> 0xfcbfd9b5843 @   11 : 39 02 00 01       SetNamedProperty <this>, |0], |1]\n
281 S> 0xfcbfd9b5847 @   15 : 0b f9             Ldar r0\n         0xfcbfd9b5849 @   17 : 59 03             Inc |3]\n         0xfcbfd9b584b @   19 : d2                Star0\n  244 E> 
0xfcbfd9b584c @   20 : 95 12 00 04       JumpLoop |18], |0], |4] (0xfcbfd9b583a @ 2)\n         0xfcbfd9b5850 @   24 : 0e                LdaUndefined\n  312 S> 0xfcbfd9b5851 @   25 : b7  
Return\nConstant pool (size = 1)\n0xfcbfd9b57e1: |TrustedFixedArray]\n - map: 0x00f808040ab9 <Map(TRUSTED_FIXED_ARRAY_TYPE)>\n - length: 1\n           0: 0x00f8080418d9 <String|6]: 
#length>\nHandler Table (size = 0)\nSource Position Table (size = 21)\n0x0fcbfd9b5859 <Other heap object (TRUSTED_BYTE_ARRAY_TYPE)>\n"}
[Step 3: Duration 3.43 seconds| Input tokens: 9,504 | Output tokens: 467]
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ Step 4 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'search_knowledge_base' with arguments: {'query': 'elements kind transition ElementsKind ElementsTransition KeyedStoreIC StoreIC LoadIC TypedArray Array builtins        │
│ AccessInfo TurboFan lowering Map transition feedback vector deopt inline cache', 'top_k': 5, 'topic_filter': 'v8'}                                                                     │
╰────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
Observations: |
  {
    "topic": "V8 JavaScript Engine",
    "file": "v8/v8.dev/docs/hidden-classes.txt",
    "similarity": 0.476,
    "content_preview": "Topic: V8 JavaScript Engine\nFile: v8/v8.dev/docs/hidden-classes.txt\n\nMaps (Hidden Classes) in V8 \u00b7 V8 V8 Show navigation Home Blog Docs Tools JS/Wasm 
features Research Maps (Hidden Classes) in V8 Let's show how V8 builds it's hidden classes. The principal data structures are: Map : the hidden class itself. It's the first pointer value
in an object and therefore allows easy comparison to see if two objects have the same class. DescriptorArray : The full list of properties that this class has along with information 
about them. In some cases, the property value is even in this array. TransitionArray : An array of \"edges\" from this Map to sibling Maps. Each edge is a property name, and should be 
thought of as \"if I were to add a property with this name to the current class, what class would I transition to?\" Because many Map objects only have one transition to another one (ie,
they are \"transitional\" maps, only used on the way to something else), V8 doesn't always create a full-blown TransitionArray for it. Instead it'll just link directly to this \"next\" 
Map . The system has to do a bit of spelunking in the DescriptorArray of the Map being pointed to in order to figure out the name attached to the transition. This is an extremely rich 
subject. It's also subject to change, though, if you understand the concepts in this article future change should be incrementally understandable. Why have hidden classes? # V8 could do 
without hidden classes, sure. It would treat each object as a bag of properties. However, a very useful principle would have been left laying around: the principal of intelligent design.
V8 surmises that you'll only create so many different kinds of objects. And each kind of object will be used in what can eventually be seen to be stereotypical ways. I say \"eventually 
be seen\" because the JavaScript language is a scripting language, not a pre-compiled one. So V8 never knows what will come next. To make use of intelligent design (that is, the 
assumption that there is a mind behind the code coming in), V8 has to watch and wait, letting the sense of structure seep in. The hidden class mechanism is the principal means to do 
this. Of course, it presupposes a sophisticated listening mechanism, and these are the Inline Caches (ICs) about which much has been written. So, if you are convinced this is good and 
necessary work, follow me! An example # function Peak ( name , height , extra ) { this . name = name ; this . height = height ; if ( isNaN ( extra ) ) { this . experience = extra ; } 
else { this . prominence = extra ; } } m1 = new Peak ( \"Matterhorn\" , 4478 , 1040 ) ; m2 = new Peak ( \"Wendelstein\" , 1838 , \"good\" ) ; With this code we've already got an 
interesting map tree from the root map (also known as the initial map) which is attached to the function Peak : Each blue box is a map, starting with the initial map. This is the map of 
the object returned if somehow, we managed to run the function Peak without adding a single property. The follow-on maps are the ones that result by adding the properties given by the 
names on the edges between maps. Each map has a list of the properties associated with an object of that map. Furthermore, it describes the exact location of each property. Finally, from
one of these maps, say, Map3 which is the hidden class of the object you'll get if you passed a number for the extra argument in Peak() , you can follow a back link up all the way to the
initial map. Let's draw it again with this extra information. The annotation (i0), (i1), means in-object field location 0, 1, etc: Now, if you spend time examining these maps before 
you've created at least 7 Peak objects, you'll encounter slack tracking which can be confusing. I have another article about that. Just create 7 more objects and it will be finished. At 
this point, your Peak objects will have exactly 3 in-object properties, with no possibility to add more directly in the object. Any additional properties will be offloaded to the 
object's property backing store. It's just an array of property values, whose index comes from the map (Well, technically, from the DescriptorArray attached to the map). Let's add a 
property to m2 on a new line, and look again at the map tree: m2 . cost = \"one arm, one leg\" ; I snuck something in here. Notice that all of the properties are annotated with 
\"const,\" which means that from V8's point of view, nobody ever changed them since the constructor, so they can be considered constants once they've been initialized. TurboFan (the 
optimizing compiler) loves this. Say m2 is referenced as a constant global by a function. Then the lookup of m2.cost can be done at compile time, since the field is marked as constant. 
I'll return to this later in the article. Notice that property \"cost\" is marked as const p0 , which means it's a constant property stored at index zero in the properties backing store 
rather than in the object directly. This is because we have no more room in the object. This information is visible in %DebugPrint(m2) : d8> %DebugPrint(m2); DebugPrint: 0x2f9488e9: 
|JS_OBJECT_TYPE] - map: 0x219473fd <Map(HOLEY_ELEMENTS)> |FastProperties] - prototype: 0x2f94876d <Object map = 0x21947335> - elements: 0x419421a1 <FixedArray|0]> |HOLEY_ELEMENTS] - 
properties: 0x2f94aecd <PropertyArray|3]> { 0x419446f9: |String] in ReadOnlySpace: #name: 0x237125e1 <String|11]: #Wendelstein> (const data field 0) 0x23712581: |String] in OldSpace: 
#height: 1838 (const data field 1) 0x23712865: |String] in OldSpace: #experience: 0x237125f9 <String|4]: #good> (const data field 2) 0x23714515: |String] in OldSpace: #cost: 0x23714525 
<String|16]: #one arm, one leg> (const data field 3) properties|0] } ... {name: \"Wendelstein\", height: 1, experience: \"good\", cost: \"one arm, one leg\"} d8> You can see that we have
4 properties, all marked as const. The first 3 in the object, and the last in properties|0] which means the first slot of the properties backing store. We can look at that: d8> 
%DebugPrintPtr(0x2f94aecd) DebugPrint: 0x2f94aecd: |PropertyArray] - map: 0x41942be9 <Map> - length: 3 - hash: 0 0: 0x23714525 <String|16]: #one arm, one leg> 1-2: 0x41942329 <undefined>
The extra properties are there just in case you decide to add more all of a sudden. The real structure # There are different things we could do at this point, but since you must really 
like V8, having read this far, I'd like to try drawing the real data structures we use, the ones mentioned at the beginning of Map , DescriptorArray , and TransitionArray . Now that you 
have some idea of the hidden class concept being built up behind the scenes, you may as well bind your thinking more closely to the code through the right names and structures. Let me 
try and reproduce that last figure in V8's representation. First I'm going to draw the DescriptorArrays , which hold the list of properties for a given Map. These arrays can be shared --
the key to that is that the Map itself knows how many properties it is allowed to look at in the DescriptorArray. Since the properties are in the order they were added in time, these 
arrays can be shared by several maps. See: Notice that Map1 , Map2 , and Map3 all point to DescriptorArray1 . The number next to the \"descriptors\" field in each Map indicates how many 
fields over in the DescriptorArray belong to the Map. So Map1 , which only knows about the \"name\" property, looks only at the first property listed in DescriptorArray1 . Whereas Map2 
has two properties, \"name\" and \"height.\" So it looks at the first and second items in DescriptorArray1 (name and height). This kind of sharing saves a lot of space. Naturally, we 
can't share where there is a split. There is a transition from Map2 over to Map4 if the \"experience\" property is added, and over to Map3 if the \"prominence\" property is added. You 
can see Map4 and Map5 sharing DescriptorArray2 in the same way that DescriptorArray1 was shared among three Maps. The only thing missing from our \"true to life\" diagram is the 
TransitionArray which is still metaphorical at this point. Let's change that. I took the liberty of removing the back pointer lines, which cleans things up a bit. Just remember that from
any Map in the tree, you can walk up the tree, too. The diagram rewards study. Question: what would happen if a new property \"rating\" was added after \"name\" instead of going on to 
\"height\" and other properties? Answer : Map1 would get a real TransitionArray so as to keep track of the bifurcation. If property height is added, we should transition to Map2 . 
However, if property rating is added, we should go to a new map, Map6 . This map would need a new DescriptorArray that mentions name and rating . The object has extra free slots at this 
point in the object (only one of three is used), so property rating will be given one of those slots. I checked my answer with the help of %DebugPrintPtr() , and drew the following: No 
need to beg me to stop, I see that this is the upper limit of such diagrams! But I think you can get a sense of how the parts move. Just imagine if after adding this ersatz property 
rating , we continued on with height , experience and cost . Well, we'd have to create maps Map7 , Map8 and Map9 . Because we insisted on adding this property in the middle of an 
established chain of maps, we will duplicate much structure. I don't have the heart to make that drawing -- though if you send it to me I will add it to this document :). I used the 
handy DreamPuf project to make the diagrams easily. Here is a link to the previous diagram. TurboFan and const properties # Thus far, all these fields are marked in the DescriptorArray 
as const . Let's play with this. Run the following code on a debug build: // run as: // d8 --allow-natives-syntax --no-lazy-feedback-allocation --code-comments --print-opt-code function 
Peak ( name , height ) { this . name = name ; this . height = height ; } let m1 = new Peak ( \"Matterhorn\" , 4478 ) ; m2 = new Peak ( \"Wendelstein\" , 1838 ) ; // Make sure slack 
tracking finishes. for ( let i = 0 ; i < 7 ; i ++ ) new Peak ( \"blah\" , i ) ; m2 . cost = \"one arm, one leg\" ; function foo ( a ) { return m2 . cost ; } foo ( 3 ) ; foo ( 3 ) ; % 
OptimizeFunctionOnNextCall ( foo ) ; foo ( 3 ) ; You'll get a printout of optimized function foo() . The code is very short. You'll see at the end of the function: ... 40 mov 
eax,0x2a812499 ;; object: 0x2a812499 <String|16]: #one arm, one leg> 45 mov esp,ebp 47 pop ebp 48 ret 0x8 ;; return \"one arm, one leg\"! TurboFan, being a cheeky devil, just directly 
inserted the value of m2.cost . Well how do you like that! Of course, after that last call to foo() you could insert this line: m2 . cost = \"priceless\" ; What do you think will happen?
One thing for sure, we can't let foo() stay as it is. It would return the wrong answer. Re-run the program, but add flag --trace-deopt so you'll be told when optimized code is removed 
from the system. After the printout of the optimized foo() , you'll see these lines: |marking dependent code 0x5c684901 0x21e525b9 <SharedFunctionInfo foo> (opt #0) for deoptimization, 
reason: field-const] |deoptimize marked code in all contexts] Wow. If you force re-optimization you'll get code that is not quite as good, but still benefits greatly from the Map 
structure we've been describing. Remember from our diagrams that property cost is the first property in the properties backing store for an object. Well, it may have lost it's const 
designation, but we still have it's address. Basically, in an object with map Map5 , which we'll certainly verify that global variable m2 still has, we only have to-- load the properties
backing store, and read out the first array element. Let's see that. Add this code below the last line: // Force reoptimization of foo(). foo ( 3 ) ; % OptimizeFunctionOnNextCall ( foo )
; foo ( 3 ) ; Now have a look at the code produced: ... 40 mov ecx,0x42cc8901 ;; object: 0x42cc8901 <Peak map = 0x3d5873ad> 45 mov ecx,|ecx+0x3] ;; Load the properties backing store 48 
mov eax,|ecx+0x7] ;; Get the first element. 4b mov esp,ebp 4d pop ebp 4e ret 0x8 ;; return it in register eax! Why heck. That's exactly what we said should happen. Perhaps we are 
beginning to Know. TurboFan is also smart enough to deoptimize if variable m2 ever changes to a different class. You can watch the latest optimized code deoptimize again with something 
droll like: m2 = 42 ; // heh. Where to go from here # Many options. Map migration. Dictionary mode (aka \"slow mode\"). Lots to explore in this area and I hope you enjoy yourself as much
as I do -- thanks for reading! Branding Terms Privacy Twitter Edit this page on GitHub Except as otherwise noted, any code samples from the V8 project are licensed under V8\u2019s 
BSD-style license . Other content on this page is licensed under the Creative Commons Attribution 3.0 License . For details, see our site policies ."
  },
  {
    "topic": "V8 JavaScript Engine",
    "file": "v8/v8.dev/blog/spread-elements.txt",
    "similarity": 0.456,
    "content_preview": "Topic: V8 JavaScript Engine\nFile: v8/v8.dev/blog/spread-elements.txt\n\nSpeeding up spread elements \u00b7 V8 V8 Show navigation Home Blog Docs Tools JS/Wasm 
features Research Speeding up spread elements Published 04 December 2018 \u00b7 Tagged with ECMAScript benchmarks During his three-months internship on the V8 team, Hai Dang worked on 
improving the performance of |...array] , |...string] , |...set] , |...map.keys()] , and |...map.values()] (when the spread elements are at the start of the array literal). He even made 
Array.from(iterable) much faster as well. This article explains some of the gory details of his changes, which are included in V8 starting with v7.2. Spread elements # Spread elements 
are components of array literals that have the form ...iterable . They were introduced in ES2015 as a way to create arrays from iterable objects. For example, the array literal |1, 
...arr, 4, ...b] creates an array whose first element is 1 followed by the elements of the array arr , then 4 , and finally the elements of the array b : const a = | 2 , 3 ] ; const b = 
| 5 , 6 , 7 ] ; const result = | 1 , ... a , 4 , ... b ] ; // \u2192 |1, 2, 3, 4, 5, 6, 7] As another example, any string can be spread to create an array of its characters (Unicode code
points): const str = '\u3053\u3093\u306b\u3061\u306f' ; const result = | ... str ] ; // \u2192 |'\u3053', '\u3093', '\u306b', '\u3061', '\u306f'] Similarly, any set can be spread to 
create an array of its elements, sorted by insertion order: const s = new Set ( ) ; s . add ( 'V8' ) ; s . add ( 'TurboFan' ) ; const result = | ... s ] ; // \u2192 |'V8', 'TurboFan'] In
general, the spread elements syntax ...x in an array literal assumes that x provides an iterator (accessible through x|Symbol.iterator]() ). This iterator is then used to obtain the 
elements to be inserted into the resulting array. The simple use case of spreading an array arr into a new array, without adding any further elements before or behind, |...arr] , is 
considered a concise, idiomatic way to shallow-clone arr in ES2015. Unfortunately, in V8, the performance of this idiom lagged far behind its ES5 counterpart. The goal of Hai\u2019s 
internship was to change that! Why is (or were!) spread elements slow? # There are many ways to shallow-clone an array arr . For instance, you can use arr.slice() , or arr.concat() , or 
|...arr] . Or, you can write your own clone function that employs a standard for -loop: function clone ( arr ) { // Pre-allocate the correct number of elements, to avoid // having to 
grow the array. const result = new Array ( arr . length ) ; for ( let i = 0 ; i < arr . length ; i ++ ) { result | i ] = arr | i ] ; } return result ; } Ideally, all these options would 
have similar performance characteristics. Unfortunately, if you pick |...arr] in V8, it is (or was ) likely to be slower than clone ! The reason is that V8 essentially transpiles 
|...arr] into an iteration like the following: function ( arr ) { const result = | ] ; const iterator = arr | Symbol . iterator ] ( ) ; const next = iterator . next ; for ( ; ; ) { const
iteratorResult = next . call ( iterator ) ; if ( iteratorResult . done ) break ; result . push ( iteratorResult . value ) ; } return result ; } This code is generally slower than clone 
for a few reasons: It needs to create the iterator at the beginning by loading and evaluating the Symbol.iterator property. It needs to create and query the iteratorResult object at 
every step. It grows the result array at every step of the iteration by calling push , thus repeatedly reallocating the backing store. The reason for using such an implementation is 
that, as mentioned earlier, spreading can be done not only on arrays but, in fact, on arbitrary iterable objects, and must follow the iteration protocol . Nevertheless, V8 should be 
smart enough to recognize if the object being spread is an array such that it can perform the elements extraction at a lower level and thereby: avoid the creation of the iterator object,
avoid the creation of the iterator result objects, and avoid continuously growing and thus reallocating the result array (we know the number of elements in advance). We implemented this 
simple idea using CSA for fast arrays, i.e. arrays with one of the six most common elements kinds . The optimization applies for the common real-world scenario where the spread occurs at
the start of the array literal, e.g. |...foo] . As shown in the graph below, this new fast path yields roughly a 3\u00d7 performance improvement for spreading an array of length 100,000,
making it about 25% faster than the hand-written clone loop. Performance improvement of spreading a fast array Note: While not shown here, the fast path also applies when the spread 
elements are followed by other components (e.g. |...arr, 1, 2, 3] ), but not when they are preceded by others (e.g. |1, 2, 3, ...arr] ). Tread carefully down that fast path # That\u2019s
clearly an impressive speedup, but we must be very careful about when it is correct to take this fast path: JavaScript allows the programmer to modify the iteration behavior of objects 
(even arrays) in various ways. Because spread elements are specified to use the iteration protocol, we need to ensure that such modifications are respected. We do so by avoiding the fast
path completely whenever the original iteration machinery has been mutated. For example, this includes situations like the following. Own Symbol.iterator property # Normally, an array 
arr does not have its own Symbol.iterator property, so when looking up that symbol, it will be found on the array\u2019s prototype. In the example below, the prototype is bypassed by 
defining the Symbol.iterator property directly on arr itself. After this modification, looking up Symbol.iterator on arr results in an empty iterator, and thus the spread of arr yields 
no elements and the array literal evaluates to an empty array. const arr = | 1 , 2 , 3 ] ; arr | Symbol . iterator ] = function ( ) { return { next : function ( ) { return { done : true 
} ; } } ; } ; const result = | ... arr ] ; // \u2192 |] Modified %ArrayIteratorPrototype% # The next method can also be modified directly on %ArrayIteratorPrototype% , the prototype of 
array iterators (which affects all arrays). Object . getPrototypeOf ( | ] | Symbol . iterator ] ( ) ) . next = function ( ) { return { done : true } ; } const arr = | 1 , 2 , 3 ] ; const
result = | ... arr ] ; // \u2192 |] Dealing with holey arrays # Extra care is also needed when copying arrays with holes, i.e., arrays like |'a', , 'c'] that are missing some elements. 
Spreading such an array, by virtue of adhering to the iteration protocol, does not preserve the holes but instead fills them with the values found in the array\u2019s prototype at the 
corresponding indices. By default there are no elements in an array\u2019s prototype, which means that any holes are filled with undefined . For example, |...|'a', , 'c']] evaluates to a
new array |'a', undefined, 'c'] . Our fast path is smart enough to handle holes in this default situation. Instead of blindly copying the input array\u2019s backing store, it watches out
for holes and takes care of converting them to undefined values. The graph below contains measurements for an input array of length 100,000 containing only (tagged) 600 integers \u2014 
the rest are holes. It shows that spreading such a holey array is now over 4\u00d7 faster than using the clone function. (They used to be roughly on par, but this is not shown in the 
graph). Note that although slice is included in this graph, the comparison with it is unfair because slice has a different semantics for holey arrays: it preserves all the holes, so it 
has much less work to do. Performance improvement of spreading a holey array of integers ( HOLEY_SMI_ELEMENTS ) The filling of holes with undefined that our fast path has to perform is 
not as simple as it sounds: it may require converting the whole array to a different elements kind. The next graph measures such a situation. The setup is the same as above, except that 
this time the 600 array elements are unboxed doubles and the array has the HOLEY_DOUBLE_ELEMENTS elements kind. Since this elements kind cannot hold tagged values such as undefined , 
spreading involves a costly elements kind transition, which is why the score for |...a] is much lower than in the previous graph. Nevertheless, it is still much faster than clone(a) . 
Performance improvement of spreading a holey array of doubles ( HOLEY_DOUBLE_ELEMENTS ) Spreading strings, sets, and maps # The idea of skipping the iterator object and avoiding growing 
the result array equally applies to spreading other standard data types. Indeed, we implemented similar fast paths for primitive strings, for sets, and for maps, each time taking care to
bypass them in the presence of modified iteration behavior. Concerning sets, the fast path supports not only spreading a set directly (|...set]), but also spreading its keys iterator ( 
|...set.keys()] ) and its values iterator ( |...set.values()] ). In our micro-benchmarks, these operations are now about 18\u00d7 faster than before. The fast path for maps is similar 
but does not support spreading a map directly ( |...map] ), because we consider this an uncommon operation. For the same reason, neither fast path supports the entries() iterator. In our
micro-benchmarks, these operations are now about 14\u00d7 faster than before. For spreading strings ( |...string] ), we measured a roughly 5\u00d7 improvement, as shown in the graph 
below by the purple and green lines. Note that this is even faster than a TurboFan-optimized for-of-loop (TurboFan understands string iteration and can generate optimized code for it), 
represented by the blue and pink lines. The reason for having two plots in each case is that the micro-benchmarks operate on two different string representations (one-byte strings and 
two-byte strings). Performance improvement of spreading a string Performance improvement of spreading a set with 100,000 integers (magenta, about 18\u00d7), shown here in comparison with
a for - of loop (red) Improving Array.from performance # Fortunately, our fast paths for spread elements can be reused for Array.from in the case where Array.from is called with an 
iterable object and without a mapping function, for example, Array.from(|1, 2, 3]) . The reuse is possible because in this case, the behavior of Array.from is exactly the same as that of
spreading. It results in an enormous performance improvement, shown below for an array with 100 doubles. Performance improvement of Array.from(array) where array contains 100 doubles 
Conclusion # V8 v7.2 / Chrome 72 greatly improves the performance of spread elements when they occur at the front of the array literal, for example |...x] or |...x, 1, 2] . The 
improvement applies to spreading arrays, primitive strings, sets, maps keys, maps values, and \u2014 by extension \u2014 to Array.from(x) . Posted by Hai Dang & Georg Neis. Retweet this 
article! Branding Terms Privacy Twitter Edit this page on GitHub Except as otherwise noted, any code samples from the V8 project are licensed under V8\u2019s BSD-style license . Other 
content on this page is licensed under the Creative Commons Attribution 3.0 License . For details, see our site policies ."
  },
  {
    "topic": "V8 JavaScript Engine",
    "file": "v8/v8.dev/tools/v8.7/map-processor.txt",
    "similarity": 0.446,
    "content_preview": "Topic: V8 JavaScript Engine\nFile: v8/v8.dev/tools/v8.7/map-processor.txt\n\nV8 Map Explorer Drag and drop a v8.log file into this area, or click to choose from 
disk. Stats Timeline Frequency Transitions Search Map by Address Search Selected Map Instructions Visualize Map trees that have been gathered using path/to/d8 $FILE --trace-maps . You 
can inspect the transition tree in DevTools by looking at document.state.timeline.values . Keyboard Shortcuts SHIFT + Arrow Up Follow Map transition forward (first child) SHIFT + Arrow 
Down Follow Map transition backwards Arrow Up Go to previous Map chunk Arrow Down Go to next Map in chunk Arrow Left Go to previous chunk Arrow Right Go to next chunk + Timeline zoom in 
- Timeline zoom out"
  },
  {
    "topic": "V8 JavaScript Engine",
    "file": "v8/v8.dev/blog/elements-kinds.txt",
    "similarity": 0.445,
    "content_preview": "Topic: V8 JavaScript Engine\nFile: v8/v8.dev/blog/elements-kinds.txt\n\nElements kinds in V8 \u00b7 V8 V8 Show navigation Home Blog Docs Tools JS/Wasm features 
Research Elements kinds in V8 Published 12 September 2017 \u00b7 Tagged with internals presentations Note: If you prefer watching a presentation over reading articles, then enjoy the 
video below! JavaScript objects can have arbitrary properties associated with them. The names of object properties can contain any character. One of the interesting cases that a 
JavaScript engine can choose to optimize for are properties whose names are purely numeric, most specifically array indices . In V8, properties with integer names \u2014 the most common 
form of which are objects generated by the Array constructor \u2014 are handled specially. Although in many circumstances these numerically-indexed properties behave just like other 
properties, V8 chooses to store them separately from non-numeric properties for optimization purposes. Internally, V8 even gives these properties a special name: elements . Objects have 
properties that map to values, whereas arrays have indices that map to elements. Although these internals are never directly exposed to JavaScript developers, they explain why certain 
code patterns are faster than others. Common elements kinds # While running JavaScript code, V8 keeps track of what kind of elements each array contains. This information allows V8 to 
optimize any operations on the array specifically for this type of element. For example, when you call reduce , map , or forEach on an array, V8 can optimize those operations based on 
what kind of elements the array contains. Take this array, for example: const array = | 1 , 2 , 3 ] ; What kinds of elements does it contain? If you\u2019d ask the typeof operator, it 
would tell you the array contains number s. At the language-level, that\u2019s all you get: JavaScript doesn\u2019t distinguish between integers, floats, and doubles \u2014 they\u2019re 
all just numbers. However, at the engine level, we can make more precise distinctions. The elements kind for this array is PACKED_SMI_ELEMENTS . In V8, the term Smi refers to the 
particular format used to store small integers. (We\u2019ll get to the PACKED part in a minute.) Later adding a floating-point number to the same array transitions it to a more generic 
elements kind: const array = | 1 , 2 , 3 ] ; // elements kind: PACKED_SMI_ELEMENTS array . push ( 4.56 ) ; // elements kind: PACKED_DOUBLE_ELEMENTS Adding a string literal to the array 
changes its elements kind once again. const array = | 1 , 2 , 3 ] ; // elements kind: PACKED_SMI_ELEMENTS array . push ( 4.56 ) ; // elements kind: PACKED_DOUBLE_ELEMENTS array . push ( 
'x' ) ; // elements kind: PACKED_ELEMENTS We\u2019ve seen three distinct elements kinds so far, with the following basic types: Sm all i ntegers, also known as Smi. Doubles, for 
floating-point numbers and integers that cannot be represented as a Smi. Regular elements, for values that cannot be represented as Smi or doubles. Note that doubles form a more general 
variant of Smi, and regular elements are another generalization on top of doubles. The set of numbers that can be represented as a Smi is a subset of the numbers that can be represented 
as a double. What\u2019s important here is that elements kind transitions only go in one direction: from specific (e.g. PACKED_SMI_ELEMENTS ) to more general (e.g. PACKED_ELEMENTS ). 
Once an array is marked as PACKED_ELEMENTS , it cannot go back to PACKED_DOUBLE_ELEMENTS , for example. So far, we\u2019ve learned the following: V8 assigns an elements kind to each 
array. The elements kind of an array is not set in stone \u2014 it can change at runtime. In the earlier example, we transitioned from PACKED_SMI_ELEMENTS to PACKED_ELEMENTS . Elements 
kind transitions can only go from specific kinds to more general kinds. PACKED vs. HOLEY kinds # So far, we\u2019ve only been dealing with dense or packed arrays. Creating holes in the 
array (i.e. making the array sparse) downgrades the elements kind to its \u201choley\u201d variant: const array = | 1 , 2 , 3 , 4.56 , 'x' ] ; // elements kind: PACKED_ELEMENTS array . 
length ; // 5 array | 9 ] = 1 ; // array|5] until array|8] are now holes // elements kind: HOLEY_ELEMENTS V8 makes this distinction because operations on packed arrays can be optimized 
more aggressively than operations on holey arrays. For packed arrays, most operations can be performed efficiently. In comparison, operations on holey arrays require additional checks 
and expensive lookups on the prototype chain. Each of the basic elements kinds we\u2019ve seen so far (i.e. Smis, doubles, and regular elements) comes in two flavors: the packed and the 
holey version. Not only can we transition from, say, PACKED_SMI_ELEMENTS to PACKED_DOUBLE_ELEMENTS , we can also transition from any PACKED kind to its HOLEY counterpart. To recap: The 
most common elements kinds come in PACKED and HOLEY flavors. Operations on packed arrays are more efficient than operations on holey arrays. Elements kinds can transition from PACKED to 
HOLEY flavors. The elements kind lattice # V8 implements this tag transitioning system as a lattice . Here\u2019s a simplified visualization of that featuring only the most common 
elements kinds: It\u2019s only possible to transition downwards through the lattice. Once a single floating-point number is added to an array of Smis, it is marked as DOUBLE, even if you
later overwrite the float with a Smi. Similarly, once a hole is created in an array, it\u2019s marked as holey forever, even when you fill it later. Update @ 2025-02-28: There is now an 
exception to this for Array.prototype.fill specifically . V8 currently distinguishes 21 different elements kinds , each of which comes with its own set of possible optimizations. In 
general, more specific elements kinds enable more fine-grained optimizations. The further down the elements kind is in the lattice, the slower manipulations of that object might be. For 
optimal performance, avoid needlessly transitioning to less specific types \u2014 stick to the most specific one that\u2019s applicable to your situation. Performance tips # In most 
cases, elements kind tracking works invisibly under the hood and you don\u2019t need to worry about it. But here are a few things you can do to get the greatest possible benefit from the
system. Avoid reading beyond the length of the array # Somewhat unexpectedly (given the title of this post), our #1 performance tip is not directly related to elements kind tracking 
(although what happens under the hood is a bit similar). Reading beyond the length of an array can have a surprising performance impact, e.g. reading array|42] when array.length === 5 . 
In this case, the array index 42 is out of bounds, the property is not present on the array itself, and so the JavaScript engine has to perform expensive prototype chain lookups. Once a 
load has run into this situation, V8 remembers that \u201cthis load needs to deal with special cases\u201d, and it will never be as fast again as it was before reading out-of-bounds. 
Don\u2019t write your loops like this: // Don\u2019t do this! for ( let i = 0 , item ; ( item = items | i ] ) != null ; i ++ ) { doSomething ( item ) ; } This code reads all the elements
in the array, and then one more. It only ends once it finds an undefined or null element. (jQuery uses this pattern in a few places.) Instead, write your loops the old-fashioned way, and
just keep iterating until you hit the last element. for ( let index = 0 ; index < items . length ; index ++ ) { const item = items | index ] ; doSomething ( item ) ; } When the 
collection you\u2019re looping over is iterable (as is the case for arrays and NodeList s), that\u2019s even better: just use for-of . for ( const item of items ) { doSomething ( item ) 
; } For arrays specifically, you could use the forEach built-in: items . forEach ( ( item ) => { doSomething ( item ) ; } ) ; Nowadays, the performance of both for-of and forEach is on 
par with the old-fashioned for loop. Avoid reading beyond the array\u2019s length! In this case, V8\u2019s bounds check fails, the check to see if the property is present fails, and then
V8 needs to look up the prototype chain. The impact is even worse when you then accidentally use the value in computations, e.g.: function Maximum ( array ) { let max = 0 ; for ( let i =
0 ; i <= array . length ; i ++ ) { // BAD COMPARISON! if ( array | i ] > max ) max = array | i ] ; } return max ; } Here, the last iteration reads beyond the array\u2019s length, which 
returns undefined , which taints not just the load but also the comparison: instead of comparing only numbers, it now has to deal with special cases. Fixing the termination condition to 
the proper i < array.length yields a 6\u00d7 performance improvement for this example (measured on arrays with 10,000 elements, so the number of iterations only drops by 0.01%). Avoid 
elements kind transitions # In general, if you need to perform lots of operations on an array, try sticking to an elements kind that\u2019s as specific as possible, so that V8 can 
optimize those operations as much as possible. This is harder than it seems. For example, just adding -0 to an array of small integers is enough to transition it to 
PACKED_DOUBLE_ELEMENTS . const array = | 3 , 2 , 1 , + 0 ] ; // PACKED_SMI_ELEMENTS array . push ( - 0 ) ; // PACKED_DOUBLE_ELEMENTS As a result, any future operations on this array are 
optimized in a completely different way than they would be for Smis. Avoid -0 , unless you explicitly need to differentiate -0 and +0 in your code. (You probably don\u2019t.) The same 
thing goes for NaN and Infinity . They are represented as doubles, so adding a single NaN or Infinity to an array of SMI_ELEMENTS transitions it to DOUBLE_ELEMENTS . const array = | 3 , 
2 , 1 ] ; // PACKED_SMI_ELEMENTS array . push ( NaN , Infinity ) ; // PACKED_DOUBLE_ELEMENTS If you\u2019re planning on performing lots of operations on an array of integers, consider 
normalizing -0 and blocking NaN and Infinity when initializing the values. That way, the array sticks to the PACKED_SMI_ELEMENTS kind. This one-time normalization cost can be worth the 
later optimizations. In fact, if you\u2019re doing mathematical operations on an array of numbers, consider using a TypedArray. We have specialized elements kinds for those, too. Prefer 
arrays over array-like objects # Some objects in JavaScript \u2014 especially in the DOM \u2014 look like arrays although they aren\u2019t proper arrays. It\u2019s possible to create 
array-like objects yourself: const arrayLike = { } ; arrayLike | 0 ] = 'a' ; arrayLike | 1 ] = 'b' ; arrayLike | 2 ] = 'c' ; arrayLike . length = 3 ; This object has a length and 
supports indexed element access (just like an array!) but it lacks array methods such as forEach on its prototype. It\u2019s still possible to call array generics on it, though: Array . 
prototype . forEach . call ( arrayLike , ( value , index ) => { console . log ( ` ${ index } : ${ value } ` ) ; } ) ; // This logs '0: a', then '1: b', and finally '2: c'. This code 
calls the Array.prototype.forEach built-in on the array-like object, and it works as expected. However, this is slower than calling forEach on a proper array, which is highly optimized 
in V8. If you plan on using array built-ins on this object more than once, consider turning it into an actual array beforehand: const actualArray = Array . prototype . slice . call ( 
arrayLike , 0 ) ; actualArray . forEach ( ( value , index ) => { console . log ( ` ${ index } : ${ value } ` ) ; } ) ; // This logs '0: a', then '1: b', and finally '2: c'. The one-time 
conversion cost can be worth the later optimizations, especially if you plan on performing lots of operations on the array. The arguments object, for example, is an array-like object. 
It\u2019s possible to call array builtins on it, but such operations won\u2019t be fully optimized the way they could be for a proper array. const logArgs = function ( ) { Array . 
prototype . forEach . call ( arguments , ( value , index ) => { console . log ( ` ${ index } : ${ value } ` ) ; } ) ; } ; logArgs ( 'a' , 'b' , 'c' ) ; // This logs '0: a', then '1: b', 
and finally '2: c'. ES2015 rest parameters can help here. They produce proper arrays that can be used instead of the array-like arguments objects in an elegant way. const logArgs = ( ...
args ) => { args . forEach ( ( value , index ) => { console . log ( ` ${ index } : ${ value } ` ) ; } ) ; } ; logArgs ( 'a' , 'b' , 'c' ) ; // This logs '0: a', then '1: b', and finally 
'2: c'. Nowadays, there\u2019s no good reason to use the arguments object directly. In general, avoid array-like objects whenever possible and use proper arrays instead. Avoid 
polymorphism # If you have code that handles arrays of many different elements kinds, it can lead to polymorphic operations that are slower than a version of the code that only operates 
on a single elements kind. Consider the following example, where a library function is called with various elements kinds. (Note that this is not the native Array.prototype.forEach , 
which has its own set of optimizations on top of the elements kinds-specific optimizations discussed in this article.) const each = ( array , callback ) => { for ( let index = 0 ; index 
< array . length ; ++ index ) { const item = array | index ] ; callback ( item ) ; } } ; const doSomething = ( item ) => console . log ( item ) ; each ( | ] , ( ) => { } ) ; each ( | 'a'
, 'b' , 'c' ] , doSomething ) ; // `each` is called with `PACKED_ELEMENTS`. V8 uses an inline cache // (or \u201cIC\u201d) to remember that `each` is called with this particular // 
elements kind. V8 is optimistic and assumes that the // `array.length` and `array|index]` accesses inside the `each` // function are monomorphic (i.e. only ever receive a single kind // 
of elements) until proven otherwise. For every future call to // `each`, V8 checks if the elements kind is `PACKED_ELEMENTS`. If // so, V8 can re-use the previously-generated code. If 
not, more work // is needed. each ( | 1.1 , 2.2 , 3.3 ] , doSomething ) ; // `each` is called with `PACKED_DOUBLE_ELEMENTS`. Because V8 has // now seen different elements kinds passed to
`each` in its IC, the // `array.length` and `array|index]` accesses inside the `each` // function get marked as polymorphic. V8 now needs an additional // check every time `each` gets 
called: one for `PACKED_ELEMENTS` // (like before), a new one for `PACKED_DOUBLE_ELEMENTS`, and one for // any other elements kinds (like before). This incurs a performance // hit. each 
( | 1 , 2 , 3 ] , doSomething ) ; // `each` is called with `PACKED_SMI_ELEMENTS`. This triggers another // degree of polymorphism. There are now three different elements // kinds in the 
IC for `each`. For every `each` call from now on, yet // another elements kind check is needed to re-use the generated code // for `PACKED_SMI_ELEMENTS`. This comes at a performance 
cost. Built-in methods (such as Array.prototype.forEach ) can deal with this kind of polymorphism much more efficiently, so consider using them instead of userland library functions in 
performance-sensitive situations. Another example of monomorphism vs. polymorphism in V8 involves object shapes, also known as the hidden class of an object. To learn about that case, 
check out Vyacheslav\u2019s article . Avoid creating holes # For real-world coding patterns, the performance difference between accessing holey or packed arrays is usually too small to 
matter or even be measurable. If (and that\u2019s a big \u201cif\u201d!) your performance measurements indicate that saving every last machine instruction in optimized code is worth it, 
then you can try to keep your arrays in packed-elements mode. Let\u2019s say we\u2019re trying to create an array, for example: const array = new Array ( 3 ) ; // The array is sparse at 
this point, so it gets marked as // `HOLEY_SMI_ELEMENTS`, i.e. the most specific possibility given // the current information. array | 0 ] = 'a' ; // Hold up, that\u2019s a string 
instead of a small integer\u2026 So the kind // transitions to `HOLEY_ELEMENTS`. array | 1 ] = 'b' ; array | 2 ] = 'c' ; // At this point, all three positions in the array are filled, so
// the array is packed (i.e. no longer sparse). However, we cannot // transition to a more specific kind such as `PACKED_ELEMENTS`. The // elements kind remains `HOLEY_ELEMENTS`. Once 
the array is marked as holey, it remains holey forever \u2014 even if all its elements are present later! A better way of creating an array is to use a literal instead: const array = | 
'a' , 'b' , 'c' ] ; // elements kind: PACKED_ELEMENTS If you don\u2019t know all the values ahead of time, create an empty array, and later push the values to it. const array = | ] ; // 
\u2026 array . push ( someValue ) ; // \u2026 array . push ( someOtherValue ) ; This approach ensures that the array never transitions to a holey elements kind. As a result, V8 can 
potentially generate ever so slightly faster optimized code for some operations on this array. Debugging elements kinds # To figure out a given object\u2019s \u201celements kind\u201d, 
get a debug build of d8 (either by building from source in debug mode or by grabbing a precompiled binary using jsvu ), and run: out/x64.debug/d8 --allow-natives-syntax This opens a d8 
REPL in which special functions such as %DebugPrint(object) are available. The \u201celements\u201d field in its output reveals the \u201celements kind\u201d of any object you pass to 
it. d8 > const array = | 1 , 2 , 3 ] ; % DebugPrint ( array ) ; DebugPrint : 0x1fbbad30fd71 : | JSArray ] - map = 0x10a6f8a038b1 | FastProperties ] - prototype = 0x1212bb687ec1 - 
elements = 0x1fbbad30fd19 < FixedArray | 3 ] > | PACKED_SMI_ELEMENTS ( COW ) ] - length = 3 - properties = 0x219eb0702241 < FixedArray | 0 ] > { #length : 0x219eb0764ac9 < AccessorInfo >
( const accessor descriptor ) } - elements = 0x1fbbad30fd19 < FixedArray | 3 ] > { 0 : 1 1 : 2 2 : 3 } | \u2026 ] Note that \u201cCOW\u201d stands for copy-on-write , which is yet 
another internal optimization. Don\u2019t worry about that for now \u2014 that\u2019s a topic for another blog post! Another useful flag that\u2019s available in debug builds is 
--trace-elements-transitions . Enable it to let V8 inform you whenever any elements kind transition takes place. $ cat my-script.js const array = | 1 , 2 , 3 ] ; array | 3 ] = 4.56 ; $ 
out/x64.debug/d8 --trace-elements-transitions my-script.js elements transition | PACKED_SMI_ELEMENTS - > PACKED_DOUBLE_ELEMENTS ] in ~+34 at x.js:2 for 0x1df87228c911 < JSArray | 3 ] > 
from 0x1df87228c889 < FixedArray | 3 ] > to 0x1df87228c941 < FixedDoubleArray | 22 ] > Posted by Mathias Bynens ( @mathias ). Retweet this article! Branding Terms Privacy Twitter Edit 
this page on GitHub Except as otherwise noted, any code samples from the V8 project are licensed under V8\u2019s BSD-style license . Other content on this page is licensed under the 
Creative Commons Attribution 3.0 License . For details, see our site policies ."
  },
  {
    "topic": "V8 JavaScript Engine",
    "file": "v8/v8.dev/blog/react-cliff.txt",
    "similarity": 0.442,
    "content_preview": "Topic: V8 JavaScript Engine\nFile: v8/v8.dev/blog/react-cliff.txt\n\nThe story of a V8 performance cliff in React \u00b7 V8 V8 Show navigation Home Blog Docs 
Tools JS/Wasm features Research The story of a V8 performance cliff in React Published 28 August 2019 \u00b7 Tagged with internals presentations Previously , we discussed how JavaScript 
engines optimize object and array access through the use of Shapes and Inline Caches, and we\u2019ve explored how engines speed up prototype property access in particular. This article 
describes how V8 chooses optimal in-memory representations for various JavaScript values, and how that impacts the shape machinery \u2014 all of which helps explain a recent V8 
performance cliff in React core . Note: If you prefer watching a presentation over reading articles, then enjoy the video below! If not, skip the video and read on. \u201cJavaScript 
engine fundamentals: the good, the bad, and the ugly\u201d as presented by Mathias Bynens and Benedikt Meurer at AgentConf 2019. JavaScript types # Every JavaScript value has exactly one
of (currently) eight different types: Number , String , Symbol , BigInt , Boolean , Undefined , Null , and Object . With one notable exception, these types are observable in JavaScript 
through the typeof operator: typeof 42 ; // \u2192 'number' typeof 'foo' ; // \u2192 'string' typeof Symbol ( 'bar' ) ; // \u2192 'symbol' typeof 42n ; // \u2192 'bigint' typeof true ; 
// \u2192 'boolean' typeof undefined ; // \u2192 'undefined' typeof null ; // \u2192 'object' \ud83e\udd14 typeof { x : 42 } ; // \u2192 'object' typeof null returns 'object' , and not 
'null' , despite Null being a type of its own. To understand why, consider that the set of all JavaScript types is divided into two groups: objects (i.e. the Object type) primitives 
(i.e. any non-object value) As such, null means \u201cno object value\u201d, whereas undefined means \u201cno value\u201d. Following this line of thought, Brendan Eich designed 
JavaScript to make typeof return 'object' for all values on the right-hand side, i.e. all objects and null values, in the spirit of Java. That\u2019s why typeof null === 'object' despite
the spec having a separate Null type. Value representation # JavaScript engines must be able to represent arbitrary JavaScript values in memory. However, it\u2019s important to note that
the JavaScript type of a value is separate from how JavaScript engines represent that value in memory. The value 42 , for example, has type number in JavaScript. typeof 42 ; // \u2192 
'number' There are several ways to represent an integer number like 42 in memory: representation bits two\u2019s complement 8-bit 0010 1010 two\u2019s complement 32-bit 0000 0000 0000 
0000 0000 0000 0010 1010 packed binary-coded decimal (BCD) 0100 0010 32-bit IEEE-754 floating-point 0100 0010 0010 1000 0000 0000 0000 0000 64-bit IEEE-754 floating-point 0100 0000 0100 
0101 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 ECMAScript standardizes numbers as 64-bit floating-point values, also known as double precision floating-point or Float64
. However, that doesn\u2019t mean that JavaScript engines store numbers in Float64 representation all the time \u2014 doing so would be terribly inefficient! Engines can choose other 
internal representations, as long as the observable behavior matches Float64 exactly. Most numbers in real-world JavaScript applications happen to be valid ECMAScript array indices , 
i.e. integer values in the range from 0 to 2\u00b3\u00b2\u22122. array | 0 ] ; // Smallest possible array index. array | 42 ] ; array | 2 ** 32 - 2 ] ; // Greatest possible array index. 
JavaScript engines can choose an optimal in-memory representation for such numbers to optimize code that accesses array elements by index. For the processor to do the memory access 
operation, the array index must be available in two\u2019s complement . Representing array indices as Float64 instead would be wasteful, as the engine would then have to convert back and
forth between Float64 and two\u2019s complement every time someone accesses an array element. The 32-bit two\u2019s complement representation is not just useful for array operations. In 
general, processors execute integer operations much faster than floating-point operations . That\u2019s why in the next example, the first loop is easily twice as fast compared to the 
second loop. for ( let i = 0 ; i < 1000 ; ++ i ) { // fast \ud83d\ude80 } for ( let i = 0.1 ; i < 1000.1 ; ++ i ) { // slow \ud83d\udc0c } The same goes for operations as well. The 
performance of the modulo operator in the next piece of code depends on whether you\u2019re dealing with integers or not. const remainder = value % divisor ; // Fast \ud83d\ude80 if 
`value` and `divisor` are represented as integers, // slow \ud83d\udc0c otherwise. If both operands are represented as integers, the CPU can compute the result very efficiently. V8 has 
additional fast-paths for the cases where the divisor is a power of two. For values represented as floats, the computation is much more complex and takes a lot longer. Because integer 
operations generally execute much faster than floating-point operations, It would seem that engines could just always use two\u2019s complement for all integers and all results of 
integer operations. Unfortunately, that would be a violation of the ECMAScript specification! ECMAScript standardizes on Float64, and so certain integer operations actually produce 
floats . It\u2019s important that JS engines produce the correct results in such cases. // Float64 has a safe integer range of 53 bits. Beyond that range, // you must lose precision. 2 
** 53 === 2 ** 53 + 1 ; // \u2192 true // Float64 supports negative zeros, so -1 * 0 must be -0, but // there\u2019s no way to represent negative zero in two\u2019s complement. - 1 * 0 
=== - 0 ; // \u2192 true // Float64 has infinities which can be produced through division // by zero. 1 / 0 === Infinity ; // \u2192 true - 1 / 0 === - Infinity ; // \u2192 true // 
Float64 also has NaNs. 0 / 0 === NaN ; Even though the values on the left-hand side are integers, all the values on the right are floats. This is why none of the above operations can be 
performed correctly using 32-bit two\u2019s complement. JavaScript engines have to take special care to make sure that integer operations fall back appropriately to produce the fancy 
Float64 results. For small integers in the 31-bit signed integer range, V8 uses a special representation called Smi . Anything that is not a Smi is represented as a HeapObject , which is
the address of some entity in memory. For numbers, we use a special kind of HeapObject , the so-called HeapNumber , to represent numbers that aren\u2019t inside the Smi range. - Infinity
// HeapNumber - ( 2 ** 30 ) - 1 // HeapNumber - ( 2 ** 30 ) // Smi - 42 // Smi - 0 // HeapNumber 0 // Smi 4.2 // HeapNumber 42 // Smi 2 ** 30 - 1 // Smi 2 ** 30 // HeapNumber Infinity //
HeapNumber NaN // HeapNumber As the above example shows, some JavaScript numbers are represented as Smi s, and others are represented as HeapNumber s. V8 is specifically optimized for 
Smi s, because small integers are so common in real-world JavaScript programs. Smi s don\u2019t need to be allocated as dedicated entities in memory, and enable fast integer operations 
in general. The important take-away here is that even values with the same JavaScript type can be represented in completely different ways behind the scenes, as an optimization. Smi vs. 
HeapNumber vs. MutableHeapNumber # Here\u2019s how that works under the hood. Let\u2019s say you have the following object: const o = { x : 42 , // Smi y : 4.2 , // HeapNumber } ; The 
value 42 for x can be encoded as Smi , so it can be stored inside of the object itself. The value 4.2 on the other hand needs a separate entity to hold the value, and the object points 
to that entity. Now, let\u2019s say we run the following JavaScript snippet: o . x += 10 ; // \u2192 o.x is now 52 o . y += 1 ; // \u2192 o.y is now 5.2 In this case, the value of x can 
be updated in-place, since the new value 52 also fits the Smi range. However, the new value of y=5.2 does not fit into a Smi and is also different from the previous value 4.2 , so V8 has
to allocate a new HeapNumber entity for the assignment to y . HeapNumber s are not mutable, which enables certain optimizations. For example, if we assign y s value to x : o . x = o . y 
; // \u2192 o.x is now 5.2 \u2026we can now just link to the same HeapNumber instead of allocating a new one for the same value. One downside to HeapNumber s being immutable is that it 
would be slow to update fields with values outside the Smi range often, like in the following example: // Create a `HeapNumber` instance. const o = { x : 0.1 } ; for ( let i = 0 ; i < 5 
; ++ i ) { // Create an additional `HeapNumber` instance. o . x += 1 ; } The first line would create a HeapNumber instance with the initial value 0.1 . The loop body changes this value 
to 1.1 , 2.1 , 3.1 , 4.1 , and finally 5.1 , creating a total of six HeapNumber instances along the way, five of which are garbage once the loop finishes. To avoid this problem, V8 
provides a way to update non- Smi number fields in-place as well, as an optimization. When a numeric field holds values outside the Smi range, V8 marks that field as a Double field on 
the shape, and allocates a so-called MutableHeapNumber that holds the actual value encoded as Float64. When your field\u2019s value changes, V8 no longer needs to allocate a new 
HeapNumber , but instead can just update the MutableHeapNumber in-place. However, there\u2019s a catch to this approach as well. Since the value of a MutableHeapNumber can change, 
it\u2019s important that these are not passed around. For example, if you assign o.x to some other variable y , you wouldn\u2019t want the value of y to change the next time o.x changes 
\u2014 that would be a violation of the JavaScript spec! So when o.x is accessed, the number must be re-boxed into a regular HeapNumber before assigning it to y . For floats, V8 performs
all the above-mentioned \u201cboxing\u201d magic behind the scenes. But for small integers it would be wasteful to go with the MutableHeapNumber approach, since Smi is a more efficient 
representation. const object = { x : 1 } ; // \u2192 no \u201cboxing\u201d for `x` in object object . x += 1 ; // \u2192 update the value of `x` inside object To avoid the inefficiency, 
all we have to do for small integers is mark the field on the shape as Smi representation, and simply update the number value in place as long as it fits the small integer range. Shape 
deprecations and migrations # So what if a field initially contains a Smi , but later holds a number outside the small integer range? Like in this case, with two objects both using the 
same shape where x is represented as Smi initially: const a = { x : 1 } ; const b = { x : 2 } ; // \u2192 objects have `x` as `Smi` field now b . x = 0.2 ; // \u2192 `b.x` is now 
represented as a `Double` y = a . x ; This starts out with two objects pointing to the same shape, where x is marked as Smi representation: When b.x changes to Double representation, V8 
allocates a new shape where x is assigned Double representation, and which points back to the empty shape. V8 also allocates a MutableHeapNumber to hold the new value 0.2 for the x 
property. Then we update the object b to point to this new shape, and change the slot in the object to point to the previously allocated MutableHeapNumber at offset 0. And finally, we 
mark the old shape as deprecated and unlink it from the transition tree. This is done by having a new transition for 'x' from the empty shape to the newly-created shape. We cannot 
completely remove the old shape at this point, since it is still used by a , and it would be way too expensive to traverse the memory to find all objects pointing to the old shape and 
update them eagerly. Instead V8 does this lazily: any property access or assignment to a migrates it to the new shape first. The idea is to eventually make the deprecated shape 
unreachable and to have the garbage collector remove it. A trickier case occurs if the field that changes representation is not the last one in the chain: const o = { x : 1 , y : 2 , z :
3 , } ; o . y = 0.1 ; In that case V8 needs to find the so-called split shape , which is the last shape in the chain before the relevant property gets introduced. Here we\u2019re 
changing y , so we need to find the last shape that doesn't have y , which in our example is the shape that introduced x . Starting from the split shape, we create a new transition chain
for y which replays all the previous transitions, but with 'y' being marked as Double representation. And we use this new transition chain for y , marking the old subtree as deprecated. 
In the last step we migrate the instance o to the new shape, using a MutableHeapNumber to hold the value of y now. This way, new objects do not take the old path, and once all references
to the old shape are gone, the deprecated shape part of the tree disappears. Extensibility and integrity-level transitions # Object.preventExtensions() prevents new properties from ever 
being added to an object. If you try, it throws an exception. (If you\u2019re not in strict mode, it doesn\u2019t throw but it silently does nothing.) const object = { x : 1 } ; Object .
preventExtensions ( object ) ; object . y = 2 ; // TypeError: Cannot add property y; // object is not extensible Object.seal does the same as Object.preventExtensions , but it also marks
all properties as non-configurable, meaning you can\u2019t delete them, or change their enumerability, configurability, or writability. const object = { x : 1 } ; Object . seal ( object 
) ; object . y = 2 ; // TypeError: Cannot add property y; // object is not extensible delete object . x ; // TypeError: Cannot delete property x Object.freeze does the same as 
Object.seal , but it also prevents the values of existing properties from being changed by marking them non-writable. const object = { x : 1 } ; Object . freeze ( object ) ; object . y =
2 ; // TypeError: Cannot add property y; // object is not extensible delete object . x ; // TypeError: Cannot delete property x object . x = 3 ; // TypeError: Cannot assign to read-only 
property x Let\u2019s consider this concrete example, with two objects which both have a single property x , and where we then prevent any further extensions to the second object. const 
a = { x : 1 } ; const b = { x : 2 } ; Object . preventExtensions ( b ) ; It starts out like we already know, transitioning from the empty shape to a new shape that holds the property 'x'
(represented as Smi ). When we prevent extensions to b , we perform a special transition to a new shape which is marked as non-extensible. This special transition doesn\u2019t introduce 
any new property \u2014 it\u2019s really just a marker. Note how we can\u2019t just update the shape with x in-place, since that is needed by the other object a , which is still 
extensible. The React performance issue # Let\u2019s put it all together and use what we learned to understand the recent React issue #14365 . When the React team profiled a real-world 
application, they spotted an odd V8 performance cliff that affected React\u2019s core. Here\u2019s a simplified repro for the bug: const o = { x : 1 , y : 2 } ; Object . 
preventExtensions ( o ) ; o . y = 0.2 ; We have an object with two fields that have Smi representation. We prevent any further extensions to the object, and eventually force the second 
field to Double representation. As we learned before, this creates roughly the following setup: Both properties are marked as Smi representation, and the final transition is the 
extensibility transition to mark the shape as non-extensible. Now we need to change y to Double representation, which means we need to again start by finding the split shape. In this 
case, it\u2019s the shape that introduced x . But now V8 got confused, since the split shape was extensible while the current shape was marked as non-extensible. And V8 didn\u2019t 
really know how to replay the transitions properly in this case. So V8 essentially just gave up trying to make sense of this, and instead created a separate shape that is not connected 
to the existing shape tree and not shared with any other objects. Think of it as an orphaned shape : You can imagine it\u2019s pretty bad if this happens to lots of objects, since that 
renders the whole shape system useless. In the case of React, here\u2019s what happened: each FiberNode has a couple of fields that are supposed to hold timestamps when profiling is 
turned on. class FiberNode { constructor ( ) { this . actualStartTime = 0 ; Object . preventExtensions ( this ) ; } } const node1 = new FiberNode ( ) ; const node2 = new FiberNode ( ) ; 
These fields (such as actualStartTime ) are initialized with 0 or -1 , and thus start out with Smi representation. But later, actual floating-point timestamps from performance.now() are 
stored in these fields, causing them to go to Double representation, since they don\u2019t fit into a Smi . On top of that, React also prevents extensions to FiberNode instances. 
Initially the simplified example above looked like this: There are two instances sharing a shape tree, all working as intended. But then, as you store the real timestamp, V8 gets 
confused finding the split shape: V8 assigns a new orphaned shape to node1 , and the same thing happens to node2 some time later, resulting in two orphan islands , each with their own 
disjoint shapes. Many real-world React apps don\u2019t just have two, but rather tens of thousands of these FiberNode s. As you can imagine, this situation was not particularly great for
V8\u2019s performance. Luckily, we\u2019ve fixed this performance cliff in V8 v7.4 , and we\u2019re looking into making field representation changes cheaper to remove any remaining 
performance cliffs. With the fix, V8 now does the right thing: The two FiberNode instances point to the non-extensible shape where 'actualStartTime' is a Smi field. When the first 
assignment to node1.actualStartTime happens, a new transition chain is created and the previous chain is marked as deprecated: Note how the extensibility transition is now properly 
replayed in the new chain. After the assignment to node2.actualStartTime , both nodes refer to the new shape, and the deprecated part of the transition tree can be cleaned up by the 
garbage collector. Note: You might think all this shape deprecation/migration is complex, and you\u2019d be right. In fact, we have a suspicion that on real-world websites it causes more
issues (in terms of performance, memory use, and complexity) than it helps, particularly since with pointer compression we\u2019ll no longer be able to use it to store double-valued 
fields in-line in the object. So, we\u2019re hoping to remove V8\u2019s shape deprecation mechanism entirely . You could say it\u2019s *puts on sunglasses* being deprecated. 
YEEEAAAHHH\u2026 The React team mitigated the problem on their end by making sure that all the time and duration fields on FiberNode s start out with Double representation: class 
FiberNode { constructor ( ) { // Force `Double` representation from the start. this . actualStartTime = Number . NaN ; // Later, you can still initialize to the value you want: this . 
actualStartTime = 0 ; Object . preventExtensions ( this ) ; } } const node1 = new FiberNode ( ) ; const node2 = new FiberNode ( ) ; Instead of Number.NaN , any floating-point value that 
doesn\u2019t fit the Smi range could be used. Examples include 0.000001 , Number.MIN_VALUE , -0 , and Infinity . It\u2019s worth pointing out that the concrete React bug was V8-specific 
and that in general, developers shouldn\u2019t optimize for a specific version of a JavaScript engine. Still, it\u2019s nice to have a handle when things don't work. Keep in mind that 
the JavaScript engine performs some magic under the hood, and you can help it by not mixing types if possible. For example, don\u2019t initialize your numeric fields with null , as that 
disables all the benefits from the field representation tracking, and it makes your code more readable: // Don\u2019t do this! class Point { x = null ; y = null ; } const p = new Point (
) ; p . x = 0.1 ; p . y = 402 ; In other words, write readable code, and performance will follow! Take-aways # We\u2019ve covered the following in this deep-dive: JavaScript 
distinguishes between \u201cprimitives\u201d and \u201cobjects\u201d, and typeof is a liar. Even values with the same JavaScript type can have different representations behind the 
scenes. V8 tries to find the optimal representation for every property in your JavaScript programs. We\u2019ve discussed how V8 deals with shape deprecations and migrations, including 
extensibility transitions. Based on this knowledge, we identified some practical JavaScript coding tips that can help boost performance: Always initialize your objects in the same way, 
so that shapes can be effective. Choose sensible initial values for your fields to help JavaScript engines with representation selection. Posted by Benedikt Meurer ( @bmeurer ) and 
Mathias Bynens ( @mathias ). Retweet this article! Branding Terms Privacy Twitter Edit this page on GitHub Except as otherwise noted, any code samples from the V8 project are licensed 
under V8\u2019s BSD-style license . Other content on this page is licensed under the Creative Commons Attribution 3.0 License . For details, see our site policies ."
  }
]
[Step 4: Duration 5.51 seconds| Input tokens: 15,439 | Output tokens: 793]
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ Step 5 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'search_knowledge_base' with arguments: {'query': "KeyedStoreIC KeyedLoadIC StoreIC LoadIC ElementsTransition src/ic src/builtins TurboFan lowering AccessInfo JSBuiltin │
│ Lowering Map transition feedback vector deopt 'KeyedStoreIC' 'StoreIC' 'KeyedLoadIC' 'elements transition' 'AccessInfo'", 'top_k': 5, 'topic_filter': 'v8'}                            │
╰────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
Observations: |
  {
    "topic": "V8 JavaScript Engine",
    "file": "v8/v8.dev/docs/turbofan.txt",
    "similarity": 0.459,
    "content_preview": "Topic: V8 JavaScript Engine\nFile: v8/v8.dev/docs/turbofan.txt\n\nTurboFan \u00b7 V8 V8 Show navigation Home Blog Docs Tools JS/Wasm features Research TurboFan 
TurboFan is one of V8\u2019s optimizing compilers leveraging a concept called \u201cSea of Nodes\u201d . One of V8\u2019s blog posts offers a high-level overview of TurboFan . More 
details can be found in the following resources. Articles and blog posts # A tale of TurboFan Ignition + TurboFan and ES2015 An introduction to speculative optimization in V8 Talks # 
CodeStubAssembler: Redux An overview of the TurboFan compiler TurboFan IR TurboFan\u2019s JIT Design Fast arithmetic for dynamic languages Deoptimization in V8 TurboFan: a new code 
generation architecture for V8 ( video ) An internship on laziness (+ blog post ) Design documents # These are design documents that are mostly concerned with TurboFan internals. 
Function context specialization Rest parameters and arguments exotic objects optimization plan TurboFan developer tools integration TurboFan inlining TurboFan inlining heuristics 
TurboFan redundant bounds and overflow check elimination Lazy deoptimization without code patching Register allocator Projection nodes in TurboFan Related design documents # These are 
design documents that also affect TurboFan in a significant way. Computed property names (re)design document ES2015 and beyond performance plan Iterator builtins design document Making 
ES2015 classes fast RegExp builtins (re)design document Spread call performance Branding Terms Privacy Twitter Edit this page on GitHub Except as otherwise noted, any code samples from 
the V8 project are licensed under V8\u2019s BSD-style license . Other content on this page is licensed under the Creative Commons Attribution 3.0 License . For details, see our site 
policies ."
  },
  {
    "topic": "V8 JavaScript Engine",
    "file": "v8/v8.dev/tools/v8.7/map-processor.txt",
    "similarity": 0.449,
    "content_preview": "Topic: V8 JavaScript Engine\nFile: v8/v8.dev/tools/v8.7/map-processor.txt\n\nV8 Map Explorer Drag and drop a v8.log file into this area, or click to choose from 
disk. Stats Timeline Frequency Transitions Search Map by Address Search Selected Map Instructions Visualize Map trees that have been gathered using path/to/d8 $FILE --trace-maps . You 
can inspect the transition tree in DevTools by looking at document.state.timeline.values . Keyboard Shortcuts SHIFT + Arrow Up Follow Map transition forward (first child) SHIFT + Arrow 
Down Follow Map transition backwards Arrow Up Go to previous Map chunk Arrow Down Go to next Map in chunk Arrow Left Go to previous chunk Arrow Right Go to next chunk + Timeline zoom in 
- Timeline zoom out"
  },
  {
    "topic": "V8 JavaScript Engine",
    "file": "v8/v8.dev/blog/turbofan-jit.txt",
    "similarity": 0.448,
    "content_preview": "Topic: V8 JavaScript Engine\nFile: v8/v8.dev/blog/turbofan-jit.txt\n\nDigging into the TurboFan JIT \u00b7 V8 V8 Show navigation Home Blog Docs Tools JS/Wasm 
features Research Digging into the TurboFan JIT Published 13 July 2015 \u00b7 Tagged with internals Last week we announced that we\u2019ve turned on TurboFan for certain types of 
JavaScript. In this post we wanted to dig deeper into the design of TurboFan. Performance has always been at the core of V8\u2019s strategy. TurboFan combines a cutting-edge intermediate
representation with a multi-layered translation and optimization pipeline to generate better quality machine code than what was previously possible with the CrankShaft JIT. Optimizations
in TurboFan are more numerous, more sophisticated, and more thoroughly applied than in CrankShaft, enabling fluid code motion, control flow optimizations, and precise numerical range 
analysis, all of which were more previously unattainable. A layered architecture # Compilers tend to become complex over time as new language features are supported, new optimizations 
are added, and new computer architectures are targeted. With TurboFan, we've taken lessons from many compilers and developed a layered architecture to allow the compiler to cope with 
these demands over time. A clearer separation between the source-level language (JavaScript), the VM's capabilities (V8), and the architecture's intricacies (from x86 to ARM to MIPS) 
allows for cleaner and more robust code. Layering allows those working on the compiler to reason locally when implementing optimizations and features, as well as write more effective 
unit tests. It also saves code. Each of the 7 target architectures supported by TurboFan requires fewer than 3,000 lines of platform-specific code, versus 13,000-16,000 in CrankShaft. 
This enabled engineers at ARM, Intel, MIPS, and IBM to contribute to TurboFan in a much more effective way. TurboFan is able to more easily support all of the coming features of ES6 
because its flexible design separates the JavaScript frontend from the architecture-dependent backends. More sophisticated optimizations # The TurboFan JIT implements more aggressive 
optimizations than CrankShaft through a number of advanced techniques. JavaScript enters the compiler pipeline in a mostly unoptimized form and is translated and optimized to 
progressively lower forms until machine code is generated. The centerpiece of the design is a more relaxed sea-of-nodes internal representation (IR) of the code which allows more 
effective reordering and optimization. Example TurboFan graph Numerical range analysis helps TurboFan understand number-crunching code much better. The graph-based IR allows most 
optimizations to be expressed as simple local reductions which are easier to write and test independently. An optimization engine applies these local rules in a systematic and thorough 
way. Transitioning out of the graphical representation involves an innovative scheduling algorithm that makes use of the reordering freedom to move code out of loops and into less 
frequently executed paths. Finally, architecture-specific optimizations like complex instruction selection exploit features of each target platform for the best quality code. Delivering 
a new level of performance # We're already seeing some great speedups with TurboFan, but there's still a ton of work to do. Stay tuned as we enable more optimizations and turn TurboFan 
on for more types of code! Posted by Ben L. Titzer, Software Engineer and TurboFan Mechanic. Branding Terms Privacy Twitter Edit this page on GitHub Except as otherwise noted, any code 
samples from the V8 project are licensed under V8\u2019s BSD-style license . Other content on this page is licensed under the Creative Commons Attribution 3.0 License . For details, see 
our site policies ."
  },
  {
    "topic": "V8 JavaScript Engine",
    "file": "v8/v8.dev/blog/v8-lite.txt",
    "similarity": 0.442,
    "content_preview": "Topic: V8 JavaScript Engine\nFile: v8/v8.dev/blog/v8-lite.txt\n\nA lighter V8 \u00b7 V8 V8 Show navigation Home Blog Docs Tools JS/Wasm features Research A 
lighter V8 Published 12 September 2019 \u00b7 Tagged with internals memory presentations In late 2018 we started a project called V8 Lite, aimed at dramatically reducing V8\u2019s memory
usage. Initially this project was envisioned as a separate Lite mode of V8 specifically aimed at low-memory mobile devices or embedder use-cases that care more about reduced memory usage
than throughput execution speed. However, in the process of this work, we realized that many of the memory optimizations we had made for this Lite mode could be brought over to regular 
V8 thereby benefiting all users of V8. In this post we highlight some of the key optimizations we developed and the memory savings they provided in real-world workloads. Note: If you 
prefer watching a presentation over reading articles, then enjoy the video below! If not, skip the video and read on. \u201cV8 Lite \u2060\u2014 slimming down JavaScript memory\u201d as 
presented by Ross McIlroy at BlinkOn 10. Lite mode # In order to optimize V8\u2019s memory usage, we first needed to understand how memory is used by V8 and what object types contribute 
a large proportion of V8\u2019s heap size. We used V8\u2019s memory visualization tools to trace heap composition across a number of typical web pages. Percentage of V8\u2019s heap used 
by different object types when loading Times of India. In doing so, we determined that a significant portion of V8\u2019s heap was dedicated to objects that aren\u2019t essential to 
JavaScript execution, but are used to optimize JavaScript execution and handle exceptional situations. Examples include: optimized code; type feedback used to determine how to optimize 
the code; redundant metadata for bindings between C++ and JavaScript objects; metadata only required during exceptional circumstances such as stack trace symbolization; and bytecode for 
functions that are only executed a few times during page loading. As a result of this, we started work on a Lite mode of V8 that trades off speed of JavaScript execution against improved
memory savings by vastly reducing the allocation of these optional objects. A number of the Lite mode changes could be made by configuring existing V8 settings, for example, disabling 
V8\u2019s TurboFan optimizing compiler. However, others required more involved changes to V8. In particular, we decided that since Lite mode doesn\u2019t optimize code, we could avoid 
collection of type feedback required by the optimizing compiler. When executing code in the Ignition interpreter, V8 collects feedback about the types of operands which are passed to 
various operations (e.g., + or o.foo ), in order to tailor later optimization to those types. This information is stored in feedback vectors which contribute a significant portion of 
V8\u2019s heap memory usage. Lite mode could avoid allocating these feedback vectors, however the interpreter and parts of V8\u2019s inline-cache infrastructure expected feedback vectors
to be available, and so required considerable refactoring to be able to support this feedback-free execution. Lite mode launched in V8 v7.3 and provides a 22% reduction in typical web 
page heap size compared to V8 v7.1 by disabling code optimization, not allocating feedback vectors and performed aging of seldom executed bytecode (described below). This is a nice 
result for those applications that explicitly want to trade off performance for better memory usage. However in the process of doing this work we realized that we could achieve most of 
the memory savings of Lite mode with none of the performance impact by making V8 lazier. Lazy feedback allocation # Disabling feedback vector allocation entirely not only prevents 
optimization of code by V8\u2019s TurboFan compiler, but also prevents V8 from performing inline caching of common operations, such as object property loads in the Ignition interpreter. 
As such, doing so caused a significant regression to V8\u2019s execution time, reducing page-load-time by 12% and increasing the CPU time used by V8 by 120% on typical interactive web 
page scenarios. To bring most of these savings to regular V8 without these regressions, we instead moved to an approach where we lazily allocate feedback vectors after the function has 
executed a certain amount of bytecode (currently 1KB). Since most functions aren\u2019t executed very often, we avoid feedback vector allocation in most cases, but quickly allocate them 
where needed to avoid performance regressions and still allow code to be optimized. One additional complication with this approach is related to the fact that feedback vectors form a 
tree, with the feedback vectors for inner functions being held as entries in their outer function\u2019s feedback vector. This is necessary so that newly created function closures 
receive the same feedback vector array as all other closures created for the same function. With lazy allocation of feedback vectors we can\u2019t form this tree using feedback vectors, 
since there is no guarantee that an outer function will have allocated its feedback vector by the time an inner function does so. To address this, we created a new 
ClosureFeedbackCellArray to maintain this tree, then swap out a function\u2019s ClosureFeedbackCellArray with a full FeedbackVector when it becomes hot. Feedback vector trees before and 
after lazy feedback allocation. Our lab experiments and in-the-field telemetry showed no performance regressions for lazy feedback on desktop, and on mobile platforms we actually saw a 
performance improvement on low-end devices due to a reduction in garbage collection. As such, we have enabled lazy feedback allocation in all builds of V8, including Lite mode where the 
slight regression in memory compared to our original no-feedback allocation approach is more than compensated by the improvement in real world performance. Lazy source positions # When 
compiling bytecode from JavaScript, source position tables are generated that tie bytecode sequences to character positions within the JavaScript source code. However, this information 
is only needed when symbolizing exceptions or performing developer tasks such as debugging, and so is rarely used. To avoid this waste, we now compile bytecode without collecting source 
positions (assuming no debugger or profiler is attached). The source positions are only collected when a stack trace is actually generated, for instance when calling Error.stack or 
printing an exception\u2019s stack trace to the console. This does have some cost, as generating source positions requires the function to be reparsed and compiled, however most websites
don\u2019t symbolize stack traces in production and therefore don\u2019t see any observable performance impact. One issue we had to address with this work was to require repeatable 
bytecode generation, which had not previously been guaranteed. If V8 generates different bytecode when collecting source positions compared to the original code, then the source 
positions do not line up and stack traces could point to the wrong position in the source code. In certain circumstances V8 could generate different bytecode depending on whether a 
function was eagerly or lazily compiled , due to some parser information being lost between the initial eager parse of a function, and later lazy compilation. These mismatches were 
mostly benign, for example losing track of the fact that a variable is immutable and therefore not being able to optimize it as such. However some of the mismatches uncovered by this 
work did have the potential to cause incorrect code execution in certain circumstances. As a result, we fixed these mismatches and added checks and a stress mode to ensure that eager and
lazy compilation of a function always produce consistent outputs, giving us greater confidence in the correctness and consistency of V8\u2019s parser and preparser. Bytecode flushing # 
Bytecode compiled from JavaScript source takes up a significant chunk of V8 heap space, typically around 15%, including related metadata. There are many functions which are only executed
during initialization, or rarely used after having been compiled. As a result, we added support for flushing compiled bytecode from functions during garbage collection if they 
haven\u2019t been executed recently. In order to do this, we keep track of the age of a function\u2019s bytecode, incrementing the age every major (mark-compact) garbage collection, and 
resetting it to zero when the function is executed. Any bytecode which crosses an aging threshold is eligible to be collected by the next garbage collection. If it is collected and then 
later executed again, it gets recompiled. There were technical challenges to ensure that bytecode is only ever flushed when it is no longer necessary. For instance, if function A calls 
another long-running function B , function A could be aged while it is still on the stack. We don\u2019t want to flush the bytecode for function A even if it reaches its aging threshold 
because we need to return to it when the long-running function B returns. As such, we treat bytecode as weakly held from a function when it reaches its aging threshold, but strongly held
by any references to it on the stack or elsewhere. We only flush the code when there are no strong links remaining. In addition to flushing bytecode, we also flush feedback vectors 
associated with these flushed functions. However we can\u2019t flush feedback vectors during the same GC cycle as the bytecode because they aren\u2019t retained by the same object - 
bytecode is held by a native-context independent SharedFunctionInfo , whereas the feedback vector is retained by the native-context dependent JSFunction . As a result we flush feedback 
vectors on the subsequent GC cycle. The object layout for an aged function after two GC cycles. Additional optimizations # In addition to these larger projects, we also uncovered and 
addressed a couple of inefficiencies. The first was to reduce the size of FunctionTemplateInfo objects. These objects store internal metadata about FunctionTemplate s , which are used to
enable embedders, such as Chrome, to provide C++ callback implementations of functions that can be called by JavaScript code. Chrome introduces a lot of FunctionTemplates in order to 
implement DOM Web APIs, and therefore FunctionTemplateInfo objects contributed to V8\u2019s heap size. After analysing the typical usage of FunctionTemplates, we found that of the eleven
fields on a FunctionTemplateInfo object, only three were typically set to a non-default value. We therefore split the FunctionTemplateInfo object such that the rare fields are stored in 
a side-table which is only allocated on demand if required. The second optimization is related to how we deoptimize from TurboFan optimized code. Since TurboFan performs speculative 
optimizations, it might need to fall back to the interpreter (deoptimize) if certain conditions no longer hold. Each deopt point has an id which enables the runtime to determine where in
the bytecode it should return execution to in the interpreter. Previously this id was calculated by having the optimized code jump to a particular offset within a large jump table, which
loaded the correct id into a register and then jumped into the runtime to perform the deoptimization. This had the advantage of requiring only a single jump instruction in the optimized 
code for each deopt point. However the deoptimize jump table was pre-allocated and had to be large enough to support the whole deoptimization id range. We instead modified TurboFan such 
that deopt points in optimized code load the deopt id directly before calling into the runtime. This enabled us to remove this large jump table entirely, at the expense of a slight 
increase in optimized code size. Results # We have released the optimizations described above over the last seven releases of V8. Typically they landed first in Lite mode , and then were
later brought to the default configuration of V8. Average V8 heap size for a set of typical web pages on an AndroidGo device. Per-page breakdown of memory savings of V8 v7.8 (Chrome 78) 
compared to v7.1 (Chrome 71). Over this time, we have reduced the V8 heap size by an average of 18% across a range of typical websites, which corresponds to an average decrease of 1.5 MB
for low-end AndroidGo mobile devices. This has been possible without any significant impact on JavaScript performance either on benchmarks or as measured on real world webpage 
interactions. Lite mode can provide further memory savings at some cost to JavaScript execution throughput by disabling function optimization. On average Lite mode provides 22% memory 
savings, with some pages seeing up to 32% reductions. This corresponds to a 1.8 MB reduction in V8 heap size on an AndroidGo device. Breakdown of memory savings of V8 v7.8 (Chrome 78) 
compared to v7.1 (Chrome 71). When split by the impact of each individual optimization, it is clear that different pages derive a different proportion of their benefit from each of these
optimizations. Going forward, we will continue to identify potential optimizations which can further reduce V8\u2019s memory usage while still remaining blazingly fast at JavaScript 
execution. Posted by Mythri Alle, Dan Elphick, and Ross McIlroy , V8 weight-watchers. Retweet this article! Branding Terms Privacy Twitter Edit this page on GitHub Except as otherwise 
noted, any code samples from the V8 project are licensed under V8\u2019s BSD-style license . Other content on this page is licensed under the Creative Commons Attribution 3.0 License . 
For details, see our site policies ."
  },
  {
    "topic": "V8 JavaScript Engine",
    "file": "v8/v8.dev/blog/leaving-the-sea-of-nodes.txt",
    "similarity": 0.44,
    "content_preview": "Topic: V8 JavaScript Engine\nFile: v8/v8.dev/blog/leaving-the-sea-of-nodes.txt\n\nLand ahoy: leaving the Sea of Nodes \u00b7 V8 V8 Show navigation Home Blog Docs 
Tools JS/Wasm features Research Land ahoy: leaving the Sea of Nodes Published 25 March 2025 \u00b7 Tagged with JavaScript internals V8\u2019s end-tier optimizing compiler, Turbofan, is 
famously one of the few large-scale production compilers to use Sea of Nodes (SoN). However, since almost 3 years ago, we\u2019ve started to get rid of Sea of Nodes and fall back to a 
more traditional Control-Flow Graph (CFG) Intermediate Representation (IR), which we named Turboshaft. By now, the whole JavaScript backend of Turbofan uses Turboshaft instead, and 
WebAssembly uses Turboshaft throughout its whole pipeline. Two parts of Turbofan still use some Sea of Nodes: the builtin pipeline, which we\u2019re slowly replacing by Turboshaft, and 
the frontend of the JavaScript pipeline, which we\u2019re replacing by Maglev, another CFG-based IR. This blog post explains the reasons that led us to move away from Sea of Nodes. The 
birth of Turbofan and Sea of Nodes # 12 years ago, in 2013, V8 had a single optimizing compiler: Crankshaft . It was using a Control-Flow Graph based Intermediate Representation. The 
initial version of Crankshaft provided significant performance improvements despite still being quite limited in what it supported. Over the next few years, the team kept improving it to
generate even faster code in ever more situations. However, technical debt was starting to stack up and a number of issues were arising with Crankshaft: It contained too much 
hand-written assembly code. Every time a new operator was added to the IR, its translation to assembly had to be manually written for the four architectures officially supported by V8 
(x64, ia32, arm, arm64). It struggled with optimizing asm.js , which was back then seen as an important step towards high-performance JavaScript. It didn\u2019t allow introducing control
flow in lowerings. Put otherwise, control flow was created at graph building time, and was then final. This was a major limitation, given that a common thing to do when writing compilers
is to start with high-level operations, and then lower them to low-level operations, often by introducing additional control flow. Consider for instance a high-level operation JSAdd(x,y)
, it could make sense to later lower it to something like if (x is String and y is String) { StringAdd(x, y) } else { \u2026 } . Well, that wasn\u2019t possible in Crankshaft. 
Try-catches were not supported, and supporting them was very challenging: multiple engineers had spent months trying to support them, without success. It suffered from many performance 
cliffs and bailouts. Using a specific feature or instruction, or running into a specific edge case of a feature, could cause performance to drop by a factor 100. This made it hard for 
JavaScript developers to write efficient code and to anticipate the performance of their applications. It contained many deoptimization loops : Crankshaft would optimize a function using
some speculative assumptions, then the function would get deoptimized when those assumptions didn\u2019t hold, but too often, Crankshaft would reoptimize the function with the same 
assumptions, leading to endless optimization-deoptimization loops. Individually, each of these issues could have probably been overcome. However, combined all together, they seemed like 
too much. So, the decision was made to replace Crankshaft with a new compiler written from scratch: Turbofan . And, rather than using a traditional CFG IR, Turbofan would use a 
supposedly more powerful IR: Sea of Nodes. At the time, this IR had already been used for more than 10 years in C2, the JIT compiler of the Java HotSpot Virtual Machine. But what is Sea 
of Nodes, really? # First, a small reminder about control-flow graph (CFG): a CFG is a representation of a program as a graph where nodes of the graph represent basic blocks of the 
program (that is, sequence of instructions without incoming or outgoing branches or jumps), and edges represent the control flow of the program. Here is a simple example: Simple CFG 
graph Instructions within a basic block are implicitly ordered: the first instruction should be executed before the second one, and the second one before the third, etc. In the small 
example above, it feels very natural: v1 == 0 can\u2019t be computed before x % 2 has been computed anyways. However, consider CFG graph with arithmetic operations that could be 
reordered Here, the CFG seemingly imposes that a * 2 be computed before b * 2 , even though we could very well compute them the other way around. That\u2019s where Sea of Nodes comes in:
Sea of Nodes does not represent basic blocks, but rather only true dependencies between the instructions. Nodes in Sea of Nodes are single instructions (rather than basic blocks), and 
edges represent value uses (meaning: an edge from a to b represents the fact that a uses b ). So, here is how this last example would be represented with Sea of Nodes: Simple Sea of 
Nodes graph with arithmetic operations Eventually, the compiler will need to generate assembly and thus will sequentially schedule these two multiplications, but until then, there is no 
more dependency between them. Now let\u2019s add control flow in the mix. Control nodes (e.g. branch , goto , return ) typically don\u2019t have value dependencies between each other 
that would force a particular schedule, even though they definitely have to be scheduled in a particular order. Thus, in order to represent control-flow, we need a new kind of edge, 
control edges , which impose some ordering on nodes that don\u2019t have value dependency: Sea of Nodes graph with control flow In this example, without control edges, nothing would 
prevent the return s from being executed before the branch , which would obviously be wrong. The crucial thing here is that the control edges only impose an order of the operations that 
have such incoming or outgoing edges, but not on other operations such as the arithmetic operations. This is the main difference between Sea of Nodes and Control flow graphs. Let\u2019s 
now add effectful operations (eg, loads and stores from and to memory) in the mix. Similarly to control nodes, effectful operations often have no value dependencies, but still cannot run
in a random order. For instance, a|0] += 42; x = a|0] and x = a|0]; a|0] += 42 are not equivalent. So, we need a way to impose an order (= a schedule) on effectful operations. We could 
reuse the control chain for this purpose, but this would be stricter than required. For instance, consider this small snippet: let v = a | 2 ] ; if ( c ) { return v ; } By putting a|2] 
(which reads memory) on the control chain, we would force it to happen before the branch on c , even though, in practice, this load could easily happen after the branch if its result is 
only used inside the body of the then-branch. Having lots of nodes in the program on the control chain would defeat the goal of Sea of Nodes, since we would basically end up with a 
CFG-like IR where only pure operations float around. So, to enjoy more freedom and actually benefit from Sea of Nodes, Turbofan has another kind of edge, effect edges , which impose some
ordering on nodes that have side effects. Let\u2019s ignore control flow for now and look at a small example: Sea of Nodes graph with effectful operations In this example, arr|0] = 42 
and let x = arr|a] have no value dependency (ie, the former is not an input of the latter, and vice versa) . However, because a could be 0 , arr|0] = 42 should be executed before x = 
arr|a] in order for the latter to always load the correct value from the array. Note that while Turbofan has a single effect chain (which splits on branches, and merges back when the 
control flow merges) which is used for all effectful operations, it\u2019s possible to have multiple effect chains, where operations that have no dependencies could be on different 
effect chains, thus relaxing how they can be scheduled (see Chapter 10 of SeaOfNodes/Simple for more details). However, as we\u2019ll explain later, maintaining a single effect chain is 
already very error prone, so we did not attempt in Turbofan to have multiple ones. And, of course, most real programs will contain both control flow and effectful operations. Sea of 
Nodes graph with control flow and effectful operations Note that store and load need control inputs, since they could be protected by various checks (such as type checks or bound 
checks). This example is a good showcase of the power of Sea of Nodes compared to CFG: y = x * c is only used in the else branch thus will freely float to after the branch rather than 
being computed before as was written in the original JavaScript code. This is similar for arr|0] , which is only used in the else branch, and could thus float after the branch (although,
in practice, Turbofan will not move down arr|0] , for reasons that I\u2019ll explain later). For comparison, here is what the corresponding CFG would look like: CFG graph with control 
flow and effectful operations Already, we start seeing the main issue with SoN: it\u2019s much further away from both the input (source code) and the output (assembly) of the compiler 
than CFG is, which makes it less intuitive to understand. Additionally, having effect and control dependencies always explicit makes it hard to quickly reason about the graph, and to 
write lowerings (since lowerings always have to explicitly maintain the control and effect chain, which are implicit in a CFG). And the troubles begin\u2026 # After more than a decade of
dealing with Sea of Nodes, we think that it has more downsides than upsides, at least as far as JavaScript and WebAssembly are concerned. We\u2019ll go into details in a few of the 
issues below. Manually/visually inspecting and understanding a Sea of Nodes graph is hard # We\u2019ve already seen that on small programs CFG is easier to read, as it is closer to the 
original source code, which is what developers (including Compiler Engineers!) are used to write. For the unconvinced readers, let me offer a slightly larger example, so that you 
understand the issue better. Consider the following JavaScript function, which concatenates an array of strings: function concat ( arr ) { let res = \"\" ; for ( let i = 0 ; i < arr . 
length ; i ++ ) { res += arr | i ] ; } return res ; } Here is the corresponding Sea of Node graph, in the middle of the Turbofan compilation pipeline (which means that some lowerings 
have already happened): Sea of Nodes graph for a simple array concatenation function Already, this starts looking like a messy soup of nodes. And, as a compiler engineer, a big part of 
my job is looking at Turbofan graphs to either understand bugs, or to find optimization opportunities. Well, it\u2019s not easy to do when the graph looks like this. After all, the input
of a compiler is the source code, which is CFG-like (instructions all have a fixed position in a given block), and the output of the compiler is assembly, which is also CFG-like 
(instructions also all have a fixed position in a given block). Having a CFG-like IR thus makes it easier for compiler engineers to match elements or the IR to either the source or the 
generated assembly. For comparison, here is the corresponding CFG graph (which we have available because we\u2019ve already started the process of replacing sea of nodes with CFG): CFG 
graph for the same simple array concatenation function Among other things, with the CFG, it\u2019s clear where the loop is, it\u2019s clear what the exit condition of the loop is, and 
it\u2019s easy to find some instructions in the CFG based on where we expect them to be: for instance arr.length can be found in the loop header (it\u2019s v22 = |v0 + 12] ), the string 
concatenation can be found towards the end of the loop ( v47 StringConcat(...) ). Arguably, value use-chains are harder to follow in the CFG version, but I would argue that more often 
than not, it\u2019s better to clearly see the control-flow structure of the graph rather than a soup of value nodes. Too many nodes are on the effect chain and/or have a control input # 
In order to benefit from Sea of Nodes, most nodes in the graph should float freely around, without control or effect chain. Unfortunately, that\u2019s not really the case in the typical 
JavaScript graph, because almost all generic JS operations can have arbitrary side effects. They should be rare in Turbofan though, since we have feedback that should allow to lower them
to more specific operations. Still, every memory operation needs both an effect input (since a Load should not float past Stores and vise-versa) and a control input (since there might be
a type-check or bound-check before the operation). And even some pure operations like division need control inputs because they might have special cases that are protected by checks. 
Let\u2019s have a look at a concrete example, and start from the following JavaScript function: function foo ( a , b ) { // assuming that `a.str` and `b.str` are strings return a . str +
b . str ; } Here is the corresponding Turbofan graph. To make things clearer, I\u2019ve highlighted part of the effect chain with dashed red lines, and annotated a few nodes with numbers
so that I can discuss them below. Sea of Nodes graph for a simple string concatenation function The first observation is that almost all nodes are on the effect chain. Let\u2019s go over
a few of them, and see if they really need to be: 1 ( CheckedTaggedToTaggedPointer ): this checks that the 1st input of the function is a pointer and not a \u201csmall integer\u201d (see
Pointer Compression in V8 ). On its own, it wouldn\u2019t really need an effect input, but in practice, it still needs to be on the effect chain, because it guards the following nodes. 2
( CheckMaps ): now that we know that the 1st input is a pointer, this node loads its \u201cmap\u201d (see Maps (Hidden Classes) in V8 ), and checks that it matches what the feedback 
recorded for this object. 3 ( LoadField ): now that we know that the 1st object is a pointer with the right map, we can load its .str field. 4 , 5 and 6 are a repeat for the second 
input. 7 ( CheckString ): now that we\u2019ve loaded a.str , this node checks that it\u2019s indeed a string. 8 : repeat for the second input. 9 : checks that the combined length of 
a.str and b.str is less than the maximum size of a String in V8. 10 ( StringConcat ): finally concatenates the 2 strings. This graph is very typical of Turbofan graphs for JavaScript 
programs: checking maps, loading values, checking the maps of the loaded values, and so on, and eventually doing a few calculations on those values. And like in this example, in a lot of
cases, most instructions end up being on the effect or control chain, which imposes a strict order on the operations, and completely defeats the purpose of Sea of Nodes. Memory 
operations do not float easily # Let\u2019s consider the following JavaScript program: let x = arr | 0 ] ; let y = arr | 1 ] ; if ( c ) { return x ; } else { return y ; } Given that x 
and y are each only used in a single side of the if - else , we may hope that SoN would allow them to freely float down to inside the \u201cthen\u201d and the \u201celse\u201d branches. 
However, in practice, making this happen in SoN would not be easier than in a CFG. Let\u2019s have a look at the SoN graph to understand why: Sea of Nodes graph where the effect chain 
mirrors the control chain, leading to effectful operations not floating as freely as one may hope When we build the SoN graph, we create the effect chain as we go along, and thus the 
second Load ends up being right after the first one, after which the effect chain has to split to reach both return s (if you\u2019re wondering why return s are even on the effect chain,
it\u2019s because there could be operations with side-effects before, such as Store s, which have to be executed before returning from the function). Given that the second Load is a 
predecessor to both return s, it has to be scheduled before the branch , and SoN thus doesn\u2019t allow any of the two Load s to float down freely. In order to move the Load s down the 
\u201cthen\u201d and \u201celse\u201d branches, we would have to compute that there are no side effects in between them, and that there are no side effects in between the second Load and
the return s, then we could split the effect chain at the beginning instead of after the second Load . Doing this analysis on a SoN graph or on a CFG is extremely similar. Now that 
we\u2019ve mentioned that a lot of nodes end up on the effect chain, and that effectful nodes often don\u2019t freely float very far, it\u2019s a good time to realize that in a way, SoN 
is just CFG where pure nodes are floating . Indeed, in practice, the control nodes and control chain always mirror the structure of the equivalent CFG. And, when both destinations of a 
branch have side effects (which is frequent in JavaScript), the effect chain splits and merges exactly where the control chain does (as is the case in the example above: the control 
chain splits on the branch , and the effect chain mirrors this by splitting on the Load ; and if the program would continue after the if - else , both chains would merge around the same 
place). Effectful nodes thus typically end up being constrained to be scheduled in between two control nodes, a.k.a., in a basic block. And within this basic block, the effect chain will
constrain effectful nodes to be in the same order as they were in the source code. In the end, only pure nodes actually float freely. One way to get more floating nodes is to use 
multiple effect chains, as mentioned earlier, but this comes at a price: first, managing a single effect chain is already hard; managing multiple ones will be much harder. Second, in a 
dynamic language like JavaScript, we end up with a lot of memory accesses that could alias, which means that the multiple effect chains would have to all merge very often, thus negating 
part of the advantages of having multiple effect chains. Managing the effect and control chains manually is hard # As mentioned in the previous section, while the effect and control 
chain are somewhat distinct, in practice, the effect chain typically has the same \u201cshape\u201d as the control chain: if the destinations of a branch contain effectful operations 
(and it\u2019s often the case), then the effect chain will split on the branch and merge back when the control flow merges back. Because we\u2019re dealing with JavaScript, a lot of 
nodes have side effects, and we have a lot of branches (typically branching on the type of some objects), which leads to having to keep track of both the effect and control chain in 
parallel, whereas with a CFG, we would only have to keep track of the control chain. History has shown that managing both the effect and control chains manually is error prone, hard to 
read and hard to maintain. Take this sample of code from the JSNativeContextSpecialization phase: JSNativeContextSpecialization :: ReduceNamedAccess ( . . . ) { Effect effect { . . . } ;
| . . . ] Node * receiverissmi_effect = effect ; | . . . ] Effect this_effect = effect ; | . . . ] this_effect = graph ( ) -> NewNode ( common ( ) -> EffectPhi ( 2 ) , this_effect , 
receiverissmi_effect , this_control ) ; receiverissmi_effect = receiverissmi_control = nullptr ; | . . . ] effect = graph ( ) -> NewNode ( common ( ) -> EffectPhi ( control_count ) , . .
. ) ; | . . . ] } Because of the various branches and cases that have to be handled here, we end up managing 3 different effect chains. It\u2019s easy to get it wrong and use one effect 
chain instead of the other. So easy that we indeed got it wrong initially , and only realized our mistake after a few months: For this issue, I would place the blame on both Turbofan and
Sea of Nodes, rather than only on the latter. Better helpers in Turbofan could have simplified managing the effect and control chains, but this would not have been an issue in a CFG. The
scheduler is too complex # Eventually, all instructions must be scheduled in order to generate assembly code. The theory to schedule instructions is simple enough: each instruction 
should be scheduled after its value, control and effect inputs (ignoring loops). Let\u2019s have a look at an interesting example: Sea of Nodes graph for a simple switch-case You\u2019ll
notice that while the source JavaScript program has two identical divisions, the Sea of Node graph only has one. In reality, Sea of Nodes would start with two divisions, but since this 
is a pure operation (assuming double inputs), redundancy elimination would easily deduplicate them into one. Then when reaching the scheduling phase, we would have to find a place to 
schedule this division. Clearly, it cannot go after case 1 or case 2 , since it\u2019s used in the other one. Instead, it would have to be scheduled before the switch . The downside is 
that, now, a / b will be computed even when c is 3 , where it doesn\u2019t really need to be computed. This is a real issue that can lead to many deduplicated instructions floating to 
the common dominator of their users, slowing down many paths that don\u2019t need them. There is a fix though: Turbofan\u2019s scheduler will try to identify these cases and duplicate 
the instructions so that they are only computed on the paths that need them. The downside is that this makes the scheduler more complex, requiring additional logic to figure out which 
nodes could and should be duplicated, and how to duplicate them. So, basically, we started with 2 divisions, then \u201coptimized\u201d to a single division, and then optimized further 
to 2 divisions again. And this doesn\u2019t happen just for division: a lot of other operations will go through similar cycles. Finding a good order to visit the graph is difficult # All
passes of a compiler need to visit the graph, be it to lower nodes, to apply local optimizations, or to run analysis over the whole graph. In a CFG, the order in which to visit nodes is 
usually straightforward: start from the first block (assuming a single-entry function), and iterate through each node of the block, and then move on to the successors and so on. In a 
peephole optimization phase (such as strength reduction ), a nice property of processing the graph in this order is that inputs are always optimized before a node is processed, and 
visiting each node exactly once is thus enough to apply most peephole optimizations. Consider for instance the following sequence of reductions: In total, it took three steps to optimize
the whole sequence, and each step did useful work. After which, dead code elimination would remove v1 and v2 , resulting in one less instruction than in the initial sequence. With Sea of
Nodes, it\u2019s not possible to process pure instructions from start to end, since they aren\u2019t on any control or effect chain, and thus there is no pointer to pure roots or 
anything like that. Instead, the usual way to process a Sea of Nodes graph for peephole optimizations is to start from the end (e.g., return instructions), and go up the value, effect 
and control inputs. This has the nice property that we won\u2019t visit any unused instruction, but the upsides stop about there, because for peephole optimization, this is about the 
worst visitation order you could get. On the example above, here are the steps we would take: Start by visiting v3 , but can\u2019t lower it at this point, then move on to its inputs 
Visit v1 , lower it to a << 3 , then move on to its uses, in case the lowering of v1 enables them to be optimized. Visit v3 again, but can\u2019t lower it yet (this time, we 
wouldn\u2019t visit its inputs again though) Visit v2 , lower it to b << 3 , then move on to its uses, in case this lowering enables them to be optimized. Visit v3 again, lower it to (a 
& b) << 3 . So, in total, v3 was visited 3 times but only lowered once. We measured this effect on typical JavaScript programs a while ago, and realized that, on average, nodes are 
changed only once every 20 visits! Another consequence of the difficulty to find a good visitation order of the graph is that state tracking is hard and expensive. A lot of optimizations
require tracking some state along the graph, like Load Elimination or Escape Analysis. However, this is hard to do with Sea of Nodes, because at a given point, it\u2019s hard to know if 
a given state needs to be kept alive or not, because it\u2019s hard to figure out if unprocessed nodes would need this state to be processed. As a consequence of this, Turbofan\u2019s 
Load Elimination phase has a bailout on large graphs to avoid taking too long to finish and consuming too much memory. By comparison, we wrote a new Load elimination phase for our new 
CFG compiler , which we\u2019ve benchmarked to be up to 190 times faster (it has better worst-case complexity, so this kind of speedup is easy to achieve on large graphs), while using 
way less memory. Cache unfriendliness # Almost all phases in Turbofan mutate the graph in-place. Given that nodes are fairly large in memory (mostly because each node has pointers to 
both its inputs and its uses), we try to reuse nodes as much as possible. However, inevitably, when we lower nodes to sequences of multiple nodes, we have to introduce new nodes, which 
will necessarily not be allocated close to the original node in memory. As a result, the deeper we go through the Turbofan pipeline and the more phases we run, the less cache friendly 
the graph is. Here is an illustration of this phenomenon: It\u2019s hard to estimate the exact impact of this cache unfriendliness on memory. Still, now that we have our new CFG 
compiler, we can compare the number of cache misses between the two: Sea of Nodes suffers on average from about 3 times more L1 dcache misses compared to our new CFG IR, and up to 7 
times more in some phases. We estimate that this costs up to 5% of compile time, although this number is a bit handwavy. Still, keep in mind that in a JIT compiler, compiling fast is 
essential. Control-flow dependent typing is limited # Let\u2019s consider the following JavaScript function: function foo ( x ) { if ( x < 42 ) { return x + 1 ; } return x ; } If so far 
we\u2019ve only seen small integers for x and for the result of x+1 (where \u201csmall integers\u201d are 31-bit integers, cf. Value tagging in V8 ), then we\u2019ll speculate that this 
will remain the case. If we ever see x being larger than a 31-bit integer, then we will deoptimize. Similarly, if x+1 produces a result that is larger than 31 bits, we will also 
deoptimize. This means that we need to check whether x+1 is less or more than the maximum value that fits in 31 bits. Let\u2019s have a look at corresponding the CFG and SoN graphs: 
(assuming a CheckedAdd operation that adds its inputs and deoptimizes if the result overflows 31-bits) With a CFG, it\u2019s easy to realize that when CheckedAdd(v1, 1) is executed, v1 
is guaranteed to be less than 42 , and that there is therefore no need to check for 31-bit overflow. We would thus easily replace the CheckedAdd by a regular Add , which would execute 
faster, and would not require a deoptimization state (which is otherwise required to know how to resume execution after deoptimizing). However, with a SoN graph, CheckedAdd , being a 
pure operation, will flow freely in the graph, and there is thus no way to remove the check until we\u2019ve computed a schedule and decided that we will compute it after the branch (and
at this point, we are back to a CFG, so this is not a SoN optimization anymore). Such checked operations are frequent in V8 due to this 31-bit small integer optimization, and the ability
to replace checked operations by unchecked operations can have a significant impact on quality of the code generated by Turbofan. So, Turbofan\u2019s SoN puts a control-input on 
CheckedAdd , which can enable this optimization, but also means introducing a scheduling constraint on a pure node, a.k.a., going back to a CFG. And many other issues\u2026 # Propagating
deadness is hard. Frequently, during some lowering, we realize that the current node is actually unreachable. In a CFG, we could just cut the current basic block here, and the following 
blocks would automatically become obviously unreachable since they would have no predecessors anymore. In Sea of Nodes, it\u2019s harder, because one has to patch both the control and 
effect chain. So, when a node on the effect chain is dead, we have to walk forward the effect chain until the next merge, killing everything along the way, and carefully handling nodes 
that are on the control chain. It\u2019s hard to introduce new control flow. Because control flow nodes have to be on the control chain, it\u2019s not possible to introduce new control 
flow during regular lowerings. So, if there is a pure node in the graph, such as Int32Max , which returns the maximum of 2 integers, and which we would eventually like to lower to if (x 
> y) { x } else { y } , this is not easily doable in Sea of Nodes, because we would need a way to figure out where on the control chain to plug this subgraph. One way to implement this 
would be to put Int32Max on the control chain from the beginning, but this feels wasteful: the node is pure and should be allowed to move around freely. So, the canonical Sea of Nodes 
way to solve this, used both in Turbofan, and also by Cliff Click (Sea of Nodes\u2019 inventor), as mentioned in this Coffee Compiler Club chat, is to delay this kind of lowerings until 
we have a schedule (and thus a CFG). As a result, we have a phase around the middle of the pipeline that computes a schedule and lowers the graph, where a lot of random optimizations are
packed together because they all require a schedule. By comparison, with a CFG, we would be free to do these optimizations earlier or later in the pipeline. Also, remember from the 
introduction that one of the issues of Crankshaft (Turbofan\u2019s predecessor) was that it was virtually impossible to introduce control flow after having built the graph. Turbofan is a
slight improvement over this, since lowering of nodes on the control chain can introduce new control flow, but this is still limited. It\u2019s hard to figure out what is inside of a 
loop. Because a lot of nodes are floating outside of the control chain, it\u2019s hard to figure out what is inside each loop. As a result, basic optimizations such as loop peeling and 
loop unrolling are hard to implement. Compiling is slow. This is a direct consequence of multiple issues that I\u2019ve already mentioned: it\u2019s hard to find a good visitation order 
for nodes, which leads to many useless revisitation, state tracking is expensive, memory usage is bad, cache locality is bad\u2026 This might not be a big deal for an ahead of time 
compiler, but in a JIT compiler, compiling slowly means that we keep executing slow unoptimized code until the optimized code is ready, while taking away resources from other tasks (eg, 
other compilation jobs, or the Garbage Collector). One consequence of this is that we are forced to think very carefully about the compile time - speedup tradeoff of new optimizations, 
often erring towards the side of optimizing less to keep optimizing fast. Sea of Nodes destroys any prior scheduling, by construction. JavaScript source code is typically not manually 
optimized with CPU microarchitecture in mind. However, WebAssembly code can be, either at the source level (C++ for instance), or by an ahead-of-time (AOT) compilation toolchain (like 
Binaryen/Emscripten ). As a result, a WebAssembly code could be scheduled in a way that should be good on most architectures (for instance, reducing the need for spilling , assuming 16 
registers). However, SoN always discards the initial schedule, and needs to rely on its own scheduler only, which, because of the time constraints of JIT compilation, can easily be worse
than what an AOT compiler (or a C++ developer carefully thinking about the scheduling of their code) could do. We have seen cases where WebAssembly was suffering from this. And, 
unfortunately, using a CFG compiler for WebAssembly and a SoN compiler for JavaScript in Turbofan was not an option either, since using the same compiler for both enables inlining across
both languages. Sea of Nodes: elegant but impractical for JavaScript # So, to recapitulate, here are the main problems we have with Sea of Nodes and Turbofan: It\u2019s too complex . 
Effect and control chains are hard to understand, leading to many subtle bugs. Graphs are hard to read and analyze, making new optimizations hard to implement and refine. It\u2019s too 
limited . Too many nodes are on the effect and control chain (because we\u2019re compiling JavaScript code), thus not providing many benefits over a traditional CFG. Additionally, 
because it\u2019s hard to introduce new control-flow in lowerings, even basic optimizations end up being hard to implement. Compiling is too slow . State-tracking is expensive, because 
it\u2019s hard to find a good order in which to visit graphs. Cache locality is bad. And reaching fixpoints during reduction phases takes too long. So, after ten years of dealing with 
Turbofan and battling Sea of Nodes, we\u2019ve finally decided to get rid of it, and instead go back to a more traditional CFG IR. Our experience with our new IR has been extremely 
positive so far, and we are very happy to have gone back to a CFG: compile time got divided by 2 compared to SoN, the code of the compiler is a lot simpler and shorter, investigating 
bugs is usually much easier, etc. Still, this post is already quite long, so I\u2019ll stop here. Stay tuned for an upcoming blog post that will explain the design of our new CFG IR, 
Turboshaft. Posted by Darius Mercadier. Branding Terms Privacy Twitter Edit this page on GitHub Except as otherwise noted, any code samples from the V8 project are licensed under 
V8\u2019s BSD-style license . Other content on this page is licensed under the Creative Commons Attribution 3.0 License . For details, see our site policies ."
  }
]
[Step 5: Duration 8.17 seconds| Input tokens: 37,585 | Output tokens: 1,207]
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ Step 6 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'get_knowledge_doc' with arguments: {'file_path': 'v8/v8.dev/blog/elements-kinds.txt'}                                                                                   │
╰────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
Observations: {
  "topic": "V8 JavaScript Engine",
  "file": "v8/v8.dev/blog/elements-kinds.txt",
  "content": "Topic: V8 JavaScript Engine\nFile: v8/v8.dev/blog/elements-kinds.txt\n\nElements kinds in V8 \u00b7 V8 V8 Show navigation Home Blog Docs Tools JS/Wasm features Research 
Elements kinds in V8 Published 12 September 2017 \u00b7 Tagged with internals presentations Note: If you prefer watching a presentation over reading articles, then enjoy the video below!
JavaScript objects can have arbitrary properties associated with them. The names of object properties can contain any character. One of the interesting cases that a JavaScript engine can
choose to optimize for are properties whose names are purely numeric, most specifically array indices . In V8, properties with integer names \u2014 the most common form of which are 
objects generated by the Array constructor \u2014 are handled specially. Although in many circumstances these numerically-indexed properties behave just like other properties, V8 chooses
to store them separately from non-numeric properties for optimization purposes. Internally, V8 even gives these properties a special name: elements . Objects have properties that map to 
values, whereas arrays have indices that map to elements. Although these internals are never directly exposed to JavaScript developers, they explain why certain code patterns are faster 
than others. Common elements kinds # While running JavaScript code, V8 keeps track of what kind of elements each array contains. This information allows V8 to optimize any operations on 
the array specifically for this type of element. For example, when you call reduce , map , or forEach on an array, V8 can optimize those operations based on what kind of elements the 
array contains. Take this array, for example: const array = | 1 , 2 , 3 ] ; What kinds of elements does it contain? If you\u2019d ask the typeof operator, it would tell you the array 
contains number s. At the language-level, that\u2019s all you get: JavaScript doesn\u2019t distinguish between integers, floats, and doubles \u2014 they\u2019re all just numbers. 
However, at the engine level, we can make more precise distinctions. The elements kind for this array is PACKED_SMI_ELEMENTS . In V8, the term Smi refers to the particular format used to
store small integers. (We\u2019ll get to the PACKED part in a minute.) Later adding a floating-point number to the same array transitions it to a more generic elements kind: const array 
= | 1 , 2 , 3 ] ; // elements kind: PACKED_SMI_ELEMENTS array . push ( 4.56 ) ; // elements kind: PACKED_DOUBLE_ELEMENTS Adding a string literal to the array changes its elements kind 
once again. const array = | 1 , 2 , 3 ] ; // elements kind: PACKED_SMI_ELEMENTS array . push ( 4.56 ) ; // elements kind: PACKED_DOUBLE_ELEMENTS array . push ( 'x' ) ; // elements kind: 
PACKED_ELEMENTS We\u2019ve seen three distinct elements kinds so far, with the following basic types: Sm all i ntegers, also known as Smi. Doubles, for floating-point numbers and 
integers that cannot be represented as a Smi. Regular elements, for values that cannot be represented as Smi or doubles. Note that doubles form a more general variant of Smi, and regular
elements are another generalization on top of doubles. The set of numbers that can be represented as a Smi is a subset of the numbers that can be represented as a double. What\u2019s 
important here is that elements kind transitions only go in one direction: from specific (e.g. PACKED_SMI_ELEMENTS ) to more general (e.g. PACKED_ELEMENTS ). Once an array is marked as 
PACKED_ELEMENTS , it cannot go back to PACKED_DOUBLE_ELEMENTS , for example. So far, we\u2019ve learned the following: V8 assigns an elements kind to each array. The elements kind of an 
array is not set in stone \u2014 it can change at runtime. In the earlier example, we transitioned from PACKED_SMI_ELEMENTS to PACKED_ELEMENTS . Elements kind transitions can only go 
from specific kinds to more general kinds. PACKED vs. HOLEY kinds # So far, we\u2019ve only been dealing with dense or packed arrays. Creating holes in the array (i.e. making the array 
sparse) downgrades the elements kind to its \u201choley\u201d variant: const array = | 1 , 2 , 3 , 4.56 , 'x' ] ; // elements kind: PACKED_ELEMENTS array . length ; // 5 array | 9 ] = 1 
; // array|5] until array|8] are now holes // elements kind: HOLEY_ELEMENTS V8 makes this distinction because operations on packed arrays can be optimized more aggressively than 
operations on holey arrays. For packed arrays, most operations can be performed efficiently. In comparison, operations on holey arrays require additional checks and expensive lookups on 
the prototype chain. Each of the basic elements kinds we\u2019ve seen so far (i.e. Smis, doubles, and regular elements) comes in two flavors: the packed and the holey version. Not only 
can we transition from, say, PACKED_SMI_ELEMENTS to PACKED_DOUBLE_ELEMENTS , we can also transition from any PACKED kind to its HOLEY counterpart. To recap: The most common elements 
kinds come in PACKED and HOLEY flavors. Operations on packed arrays are more efficient than operations on holey arrays. Elements kinds can transition from PACKED to HOLEY flavors. The 
elements kind lattice # V8 implements this tag transitioning system as a lattice . Here\u2019s a simplified visualization of that featuring only the most common elements kinds: It\u2019s
only possible to transition downwards through the lattice. Once a single floating-point number is added to an array of Smis, it is marked as DOUBLE, even if you later overwrite the float
with a Smi. Similarly, once a hole is created in an array, it\u2019s marked as holey forever, even when you fill it later. Update @ 2025-02-28: There is now an exception to this for 
Array.prototype.fill specifically . V8 currently distinguishes 21 different elements kinds , each of which comes with its own set of possible optimizations. In general, more specific 
elements kinds enable more fine-grained optimizations. The further down the elements kind is in the lattice, the slower manipulations of that object might be. For optimal performance, 
avoid needlessly transitioning to less specific types \u2014 stick to the most specific one that\u2019s applicable to your situation. Performance tips # In most cases, elements kind 
tracking works invisibly under the hood and you don\u2019t need to worry about it. But here are a few things you can do to get the greatest possible benefit from the system. Avoid 
reading beyond the length of the array # Somewhat unexpectedly (given the title of this post), our #1 performance tip is not directly related to elements kind tracking (although what 
happens under the hood is a bit similar). Reading beyond the length of an array can have a surprising performance impact, e.g. reading array|42] when array.length === 5 . In this case, 
the array index 42 is out of bounds, the property is not present on the array itself, and so the JavaScript engine has to perform expensive prototype chain lookups. Once a load has run 
into this situation, V8 remembers that \u201cthis load needs to deal with special cases\u201d, and it will never be as fast again as it was before reading out-of-bounds. Don\u2019t write
your loops like this: // Don\u2019t do this! for ( let i = 0 , item ; ( item = items | i ] ) != null ; i ++ ) { doSomething ( item ) ; } This code reads all the elements in the array, 
and then one more. It only ends once it finds an undefined or null element. (jQuery uses this pattern in a few places.) Instead, write your loops the old-fashioned way, and just keep 
iterating until you hit the last element. for ( let index = 0 ; index < items . length ; index ++ ) { const item = items | index ] ; doSomething ( item ) ; } When the collection 
you\u2019re looping over is iterable (as is the case for arrays and NodeList s), that\u2019s even better: just use for-of . for ( const item of items ) { doSomething ( item ) ; } For 
arrays specifically, you could use the forEach built-in: items . forEach ( ( item ) => { doSomething ( item ) ; } ) ; Nowadays, the performance of both for-of and forEach is on par with 
the old-fashioned for loop. Avoid reading beyond the array\u2019s length! In this case, V8\u2019s bounds check fails, the check to see if the property is present fails, and then V8 needs
to look up the prototype chain. The impact is even worse when you then accidentally use the value in computations, e.g.: function Maximum ( array ) { let max = 0 ; for ( let i = 0 ; i <=
array . length ; i ++ ) { // BAD COMPARISON! if ( array | i ] > max ) max = array | i ] ; } return max ; } Here, the last iteration reads beyond the array\u2019s length, which returns 
undefined , which taints not just the load but also the comparison: instead of comparing only numbers, it now has to deal with special cases. Fixing the termination condition to the 
proper i < array.length yields a 6\u00d7 performance improvement for this example (measured on arrays with 10,000 elements, so the number of iterations only drops by 0.01%). Avoid 
elements kind transitions # In general, if you need to perform lots of operations on an array, try sticking to an elements kind that\u2019s as specific as possible, so that V8 can 
optimize those operations as much as possible. This is harder than it seems. For example, just adding -0 to an array of small integers is enough to transition it to 
PACKED_DOUBLE_ELEMENTS . const array = | 3 , 2 , 1 , + 0 ] ; // PACKED_SMI_ELEMENTS array . push ( - 0 ) ; // PACKED_DOUBLE_ELEMENTS As a result, any future operations on this array are 
optimized in a completely different way than they would be for Smis. Avoid -0 , unless you explicitly need to differentiate -0 and +0 in your code. (You probably don\u2019t.) The same 
thing goes for NaN and Infinity . They are represented as doubles, so adding a single NaN or Infinity to an array of SMI_ELEMENTS transitions it to DOUBLE_ELEMENTS . const array = | 3 , 
2 , 1 ] ; // PACKED_SMI_ELEMENTS array . push ( NaN , Infinity ) ; // PACKED_DOUBLE_ELEMENTS If you\u2019re planning on performing lots of operations on an array of integers, consider 
normalizing -0 and blocking NaN and Infinity when initializing the values. That way, the array sticks to the PACKED_SMI_ELEMENTS kind. This one-time normalization cost can be worth the 
later optimizations. In fact, if you\u2019re doing mathematical operations on an array of numbers, consider using a TypedArray. We have specialized elements kinds for those, too. Prefer 
arrays over array-like objects # Some objects in JavaScript \u2014 especially in the DOM \u2014 look like arrays although they aren\u2019t proper arrays. It\u2019s possible to create 
array-like objects yourself: const arrayLike = { } ; arrayLike | 0 ] = 'a' ; arrayLike | 1 ] = 'b' ; arrayLike | 2 ] = 'c' ; arrayLike . length = 3 ; This object has a length and 
supports indexed element access (just like an array!) but it lacks array methods such as forEach on its prototype. It\u2019s still possible to call array generics on it, though: Array . 
prototype . forEach . call ( arrayLike , ( value , index ) => { console . log ( ` ${ index } : ${ value } ` ) ; } ) ; // This logs '0: a', then '1: b', and finally '2: c'. This code 
calls the Array.prototype.forEach built-in on the array-like object, and it works as expected. However, this is slower than calling forEach on a proper array, which is highly optimized 
in V8. If you plan on using array built-ins on this object more than once, consider turning it into an actual array beforehand: const actualArray = Array . prototype . slice . call ( 
arrayLike , 0 ) ; actualArray . forEach ( ( value , index ) => { console . log ( ` ${ index } : ${ value } ` ) ; } ) ; // This logs '0: a', then '1: b', and finally '2: c'. The one-time 
conversion cost can be worth the later optimizations, especially if you plan on performing lots of operations on the array. The arguments object, for example, is an array-like object. 
It\u2019s possible to call array builtins on it, but such operations won\u2019t be fully optimized the way they could be for a proper array. const logArgs = function ( ) { Array . 
prototype . forEach . call ( arguments , ( value , index ) => { console . log ( ` ${ index } : ${ value } ` ) ; } ) ; } ; logArgs ( 'a' , 'b' , 'c' ) ; // This logs '0: a', then '1: b', 
and finally '2: c'. ES2015 rest parameters can help here. They produce proper arrays that can be used instead of the array-like arguments objects in an elegant way. const logArgs = ( ...
args ) => { args . forEach ( ( value , index ) => { console . log ( ` ${ index } : ${ value } ` ) ; } ) ; } ; logArgs ( 'a' , 'b' , 'c' ) ; // This logs '0: a', then '1: b', and finally 
'2: c'. Nowadays, there\u2019s no good reason to use the arguments object directly. In general, avoid array-like objects whenever possible and use proper arrays instead. Avoid 
polymorphism # If you have code that handles arrays of many different elements kinds, it can lead to polymorphic operations that are slower than a version of the code that only operates 
on a single elements kind. Consider the following example, where a library function is called with various elements kinds. (Note that this is not the native Array.prototype.forEach , 
which has its own set of optimizations on top of the elements kinds-specific optimizations discussed in this article.) const each = ( array , callback ) => { for ( let index = 0 ; index 
< array . length ; ++ index ) { const item = array | index ] ; callback ( item ) ; } } ; const doSomething = ( item ) => console . log ( item ) ; each ( | ] , ( ) => { } ) ; each ( | 'a'
, 'b' , 'c' ] , doSomething ) ; // `each` is called with `PACKED_ELEMENTS`. V8 uses an inline cache // (or \u201cIC\u201d) to remember that `each` is called with this particular // 
elements kind. V8 is optimistic and assumes that the // `array.length` and `array|index]` accesses inside the `each` // function are monomorphic (i.e. only ever receive a single kind // 
of elements) until proven otherwise. For every future call to // `each`, V8 checks if the elements kind is `PACKED_ELEMENTS`. If // so, V8 can re-use the previously-generated code. If 
not, more work // is needed. each ( | 1.1 , 2.2 , 3.3 ] , doSomething ) ; // `each` is called with `PACKED_DOUBLE_ELEMENTS`. Because V8 has // now seen different elements kinds passed to
`each` in its IC, the // `array.length` and `array|index]` accesses inside the `each` // function get marked as polymorphic. V8 now needs an additional // check every time `each` gets 
called: one for `PACKED_ELEMENTS` // (like before), a new one for `PACKED_DOUBLE_ELEMENTS`, and one for // any other elements kinds (like before). This incurs a performance // hit. each 
( | 1 , 2 , 3 ] , doSomething ) ; // `each` is called with `PACKED_SMI_ELEMENTS`. This triggers another // degree of polymorphism. There are now three different elements // kinds in the 
IC for `each`. For every `each` call from now on, yet // another elements kind check is needed to re-use the generated code // for `PACKED_SMI_ELEMENTS`. This comes at a performance 
cost. Built-in methods (such as Array.prototype.forEach ) can deal with this kind of polymorphism much more efficiently, so consider using them instead of userland library functions in 
performance-sensitive situations. Another example of monomorphism vs. polymorphism in V8 involves object shapes, also known as the hidden class of an object. To learn about that case, 
check out Vyacheslav\u2019s article . Avoid creating holes # For real-world coding patterns, the performance difference between accessing holey or packed arrays is usually too small to 
matter or even be measurable. If (and that\u2019s a big \u201cif\u201d!) your performance measurements indicate that saving every last machine instruction in optimized code is worth it, 
then you can try to keep your arrays in packed-elements mode. Let\u2019s say we\u2019re trying to create an array, for example: const array = new Array ( 3 ) ; // The array is sparse at 
this point, so it gets marked as // `HOLEY_SMI_ELEMENTS`, i.e. the most specific possibility given // the current information. array | 0 ] = 'a' ; // Hold up, that\u2019s a string 
instead of a small integer\u2026 So the kind // transitions to `HOLEY_ELEMENTS`. array | 1 ] = 'b' ; array | 2 ] = 'c' ; // At this point, all three positions in the array are filled, so
// the array is packed (i.e. no longer sparse). However, we cannot // transition to a more specific kind such as `PACKED_ELEMENTS`. The // elements kind remains `HOLEY_ELEMENTS`. Once 
the array is marked as holey, it remains holey forever \u2014 even if all its elements are present later! A better way of creating an array is to use a literal instead: const array = | 
'a' , 'b' , 'c' ] ; // elements kind: PACKED_ELEMENTS If you don\u2019t know all the values ahead of time, create an empty array, and later push the values to it. const array = | ] ; // 
\u2026 array . push ( someValue ) ; // \u2026 array . push ( someOtherValue ) ; This approach ensures that the array never transitions to a holey elements kind. As a result, V8 can 
potentially generate ever so slightly faster optimized code for some operations on this array. Debugging elements kinds # To figure out a given object\u2019s \u201celements kind\u201d, 
get a debug build of d8 (either by building from source in debug mode or by grabbing a precompiled binary using jsvu ), and run: out/x64.debug/d8 --allow-natives-syntax This opens a d8 
REPL in which special functions such as %DebugPrint(object) are available. The \u201celements\u201d field in its output reveals the \u201celements kind\u201d of any object you pass to 
it. d8 > const array = | 1 , 2 , 3 ] ; % DebugPrint ( array ) ; DebugPrint : 0x1fbbad30fd71 : | JSArray ] - map = 0x10a6f8a038b1 | FastProperties ] - prototype = 0x1212bb687ec1 - 
elements = 0x1fbbad30fd19 < FixedArray | 3 ] > | PACKED_SMI_ELEMENTS ( COW ) ] - length = 3 - properties = 0x219eb0702241 < FixedArray | 0 ] > { #length : 0x219eb0764ac9 < AccessorInfo >
( const accessor descriptor ) } - elements = 0x1fbbad30fd19 < FixedArray | 3 ] > { 0 : 1 1 : 2 2 : 3 } | \u2026 ] Note that \u201cCOW\u201d stands for copy-on-write , which is yet 
another internal optimization. Don\u2019t worry about that for now \u2014 that\u2019s a topic for another blog post! Another useful flag that\u2019s available in debug builds is 
--trace-elements-transitions . Enable it to let V8 inform you whenever any elements kind transition takes place. $ cat my-script.js const array = | 1 , 2 , 3 ] ; array | 3 ] = 4.56 ; $ 
out/x64.debug/d8 --trace-elements-transitions my-script.js elements transition | PACKED_SMI_ELEMENTS - > PACKED_DOUBLE_ELEMENTS ] in ~+34 at x.js:2 for 0x1df87228c911 < JSArray | 3 ] > 
from 0x1df87228c889 < FixedArray | 3 ] > to 0x1df87228c941 < FixedDoubleArray | 22 ] > Posted by Mathias Bynens ( @mathias ). Retweet this article! Branding Terms Privacy Twitter Edit 
this page on GitHub Except as otherwise noted, any code samples from the V8 project are licensed under V8\u2019s BSD-style license . Other content on this page is licensed under the 
Creative Commons Attribution 3.0 License . For details, see our site policies ."
}
[Step 6: Duration 13.88 seconds| Input tokens: 71,810 | Output tokens: 1,627]
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ Step 7 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'final_answer' with arguments: {'answer': '{\n  "CODE REGION": "Keyed array element access & elements-kind transitions (KeyedStoreIC/KeyedLoadIC, ElementsTransition,    │
│ GrowElements/CopyElements, and Array builtin fast paths)",\n  "SUMMARY_OF_CODE_REGION": "This region covers the JS indexed load/store fast-paths and their slow-path transitions: the  │
│ inline cache machinery that dispatches keyed loads/stores (KeyedLoadIC, KeyedStoreIC / StoreIC/LoadIC), the runtime and object-level logic that implements elements kinds and          │
│ transitions (PACKED_SMI/DOUBLE/ELEMENTS <-> HOLEY variants), the grow/copy helpers (EnsureCapacity/GrowElementsCapacity/CopyElements/TransitionElementsKind), and the Array builtin    │
│ fast-path implementations that rely on these invariants (Array.prototype.push/pop/slice/splice/concat/Array.from/spread fast paths). On the JIT side this region is lowered and        │
│ reasoned about by AccessInfo/JSCreateLowering and by TurboFan reducers that turn JS keyed accesses and builtin calls into machine-friendly sequences. Key files touch both             │
│ runtime-side C++ (objects/elements, ICs, builtins) and compiler-side lowering/reducers. This area has historically been fragile because it mixes: fast-path optimistic assumptions     │
│ (monomorphic elements kind, in-bounds, unmodified prototype and iterator machinery) with runtime transitions (elements kind downgrades, hole creation, prototype or iterator override, │
│ length manipulations, species/construction overrides) and IC/feedback updates — all of which can cause stub replacement, deopts, or subtle type confusion if a lowering or IC stub     │
│ misses a case or races with a transition.",\n  "REASONING": "I selected this region because it satisfies the fuzzing evaluation criteria: (a) it\'s reachable from plain JS and FuzzIL │
│ through very common operations (indexed stores, Array builtins, length mutations, push/pop, spread, Array.from), (b) it\'s been historically prone to bugs around type/IC/elements     │
│ kind (transitions between Smi/Double/Object, packed vs holey, out-of-bounds growth, species/prototype edge cases, stale feedback vectors and deopts). It offers multiple               │
│ JS-controllable knobs (types inserted, holes, lengths, OOB indices, prototype changes, getters/setters, builtins being overridden) and has explicit both fast and slow paths in the VM │
│ and JIT, making it high-value for fuzzing that targets JIT correctness and type-confusion classes."\n}\n\n\n---\n\nPrimary pick (detailed, actionable for a fuzzing                    │
│ sub-agent):\n\nName/subsystem: Keyed array element access & elements-kind transitions (KeyedStoreIC / KeyedLoadIC and related builtin fast paths)\n\nRationale (why high value for     │
│ fuzzing):\n- Extremely reachable from plain JS via simple indexed assignment and common Array builtins (push/pop/slice/splice/concat/Array.from, spread literal).\n- Many subtle       │
│ transitions: PACKED_SMI -> PACKED_DOUBLE -> PACKED_ELEMENTS, PACKED -> HOLEY, typed arrays vs JS arrays, and length/capacity growth routines. These transitions update maps, elements  │
│ backing stores, feedback vectors and IC stubs — a rich surface for type confusion, stale IC state, OOB or incorrect hole handling, and deoptimization bugs.\n- JIT interaction: inline │
│ caches control the optimized fast path; TurboFan reductions and lowering expect certain AccessInfo (maps/elements kinds). Small mismatches between IC expectations, runtime            │
│ transitions, and lowering can be exploited by fuzzers.\n\nV8 loci (suggested file paths and key functions — entry points for CodeAnalyzer and fuzz harness assembly):\n-               │
│ src/objects/elements.cc / src/objects/elements.h\n  - TransitionElementsKind, EnsureCapacity, GrowElementsCapacity, CopyElements, Get/SetElement / SetLength implementation helpers\n- │
│ src/objects/js-array.cc / src/objects/js-array.h\n  - JSArray::SetLength and array element access helpers\n- src/ic/ic.cc, src/ic/ic.h, src/ic/keyed-store.cc, src/ic/keyed-load.cc    │
│ (or similarly-named IC files)\n  - KeyedStoreIC::Generate, KeyedLoadIC::Generate, StoreIC/LoadIC miss/fast-path generation, KeyedStoreGenericStub / KeyedLoadGenericStub\n-            │
│ src/ic/ic-compiler.cc / src/ic/stub-cache.cc\n  - IC assembly/stub creation and replacement code\n- src/builtins/array-push.cc, src/builtins/array-slice.cc,                           │
│ src/builtins/array-splice.cc, src/builtins/array-from.cc, src/builtins/array-concat.cc\n  - ArrayPrototypePush, ArrayPrototypeSlice, ArrayFromBuiltin — these contain fast-paths that  │
│ directly copy/backing-store-manipulate arrays\n- src/objects/elements-kind.h (or equivalent) — enumerations for ElementsKind (PACKED_SMI_ELEMENTS, PACKED_DOUBLE_ELEMENTS,             │
│ PACKED_ELEMENTS, HOLEY_* etc.)\n- src/compiler/* (TurboFan / lowering side):\n  - JSCreateLowering / ArrayBuiltinLowering reducers (files under src/compiler/ that lower JS array      │
│ builtin ops into lower-level nodes), AccessInfo computation paths, and the reducer/typer passes that affect element access (look for files implementing Load/Store lowering like       │
│ js-operator-reducer or builtins lowering; keywords: JSLoadIndexed, JSStoreIndexed, AccessInfo)\n  - Reducers that handle keyed loads/stores and effect on feedback vectors             │
│ (JSLoad/StoreLowering in compiler pipeline)\n- Hot runtime helpers in runtime/ or runtime/array.* (e.g., Runtime::TransitionElementsKind, Runtime::GrowElements) — these are called by │
│ slow paths and builtin slow-paths.\n\nTriggering JS patterns (concrete operations that expose fast vs slow paths):\n- Direct indexed stores: a[i] = value (with i being in-bounds,     │
│ then OOB to force grow, negative/huge indexes)\n- Array.prototype.push/pop and repeated push-driven growth\n- Setting length manually: a.length = smaller to truncate, a.length =      │
│ larger to create holes or reduce capacity\n- Hole creation: delete a[1], assign at far index (a[100] = x) to create holes and force HOLEY_* transitions\n- Mixing types: insert Smis,  │
│ then a double (e.g., -0 or NaN), then an object to force PACKED_SMI -> PACKED_DOUBLE -> PACKED_ELEMENTS transitions\n- Prototype mutation: this.__proto__ = Array.prototype or         │
│ override Array.prototype[n] or Symbol.iterator, or defineOwnProperty(Array.prototype, idx, getter) to affect iteration or hole semantics\n- Overriding builtins: Array.prototype.push  │
│ = function() { /* custom */ } to force builtin slow-path/IC changes\n- Species/prototype swaps during builtin operations (e.g., Array.prototype.slice with custom species) to get into │
│ alternate allocation paths\n- Using accessor properties (getters/setters) at element indexes or on prototype to trigger slow-paths\n- TypedArray interop: mixing operations that       │
│ expect TypedArray semantics vs JS array operations (Array.from/ spread into typed arrays vs arrays)\n\nPreconditions / shape constraints to exercise:\n- Start with a monomorphic      │
│ array shape: PACKED_SMI_ELEMENTS, length N, fast-elements backing store\n- Ensure maps are consistent (same hidden class across iterations) to hit the fast IC path first\n- Use write │
│ patterns to gradually convert elements kind (Smi -> Double -> Elements) or to make array holey\n- Control length writable/non-writable by Object.freeze / Object.preventExtensions /   │
│ Object.seal to exercise edge cases\n- Make prototype be Array.prototype or a mutated prototype to toggle fast-path guards\n\nJIT linkage (IC stubs, TurboFan reducers, lowering        │
│ passes):\n- Inline caches: KeyedStoreIC / KeyedLoadIC, StoreIC/LoadIC miss handlers and generated stubs (monomorphic / polymorphic / generic)\n- Feedback vectors: Feedback slots for  │
│ keyed loads/stores that record elements-kind or transition feedback\n- Runtime helpers called from IC slow paths: Runtime::SetElement, Runtime::TransitionElementsKind,                │
│ Runtime::EnsureCapacity/GrowElements\n- TurboFan lowering/reducers: reducers that take JSLoadIndexed / JSStoreIndexed nodes and lower to machine code assuming a particular            │
│ ElementsKind and bounds checks, and JS builtin lowering for push/slice that do block copies or element-kind conversions\n- AccessInfo computations: AccessInfo provides the compiler   │
│ with the representation and checks necessary to lower a property or element access; bugs here lead to incorrect assumptions in generated code\n- Deopt pathways: deopt points in       │
│ optimized code when speculative assumptions (e.g., elements kind, in-bounds) are violated; ensure test harness can trigger deopt paths and reopt again (stale feedback                 │
│ vulnerabilities)\n\nFuzz knobs (controllable in FuzzIL or JS harness):\n- Array initial type lattice: create arrays with PACKED_SMI / PACKED_DOUBLE / PACKED_ELEMENTS\n- Inserted      │
│ value types: Smi (small integers), HeapNumber (double), Object, undefined, null, Symbol, -0, NaN, Infinity\n- Index patterns: sequential small indices, repeated writes at same index, │
│ random indices, large OOB to force resize, negative indices, ToString-keyed numeric indexes\n- Holes: create holes via sparse assignment (a[1000]=x) or delete a[1]\n- length          │
│ manipulations: shrink length, grow length, set non-writable length (Object.defineProperty), repeated setting inside loops\n- Prototype mutation: change this.__proto__, modify         │
│ Array.prototype entries to introduce prototypes-provided elements\n- Accessors: define getters/setters on prototype or own properties at numeric indexes\n- Builtins override: shadow  │
│ Array.prototype.push/pop or Symbol.iterator\n- Species override: override constructor[Symbol.species] to switch allocation strategy\n- TypedArray vs JS array mixing: create typed     │
│ arrays and attempt operations that treat them as JS arrays\n- Deopt-triggering arithmetic: use -0, NaN, large numbers to force Smi->Double transitions and deopts\n- IC polymorphism:  │
│ call the same function on arrays with differing elements kind and maps to grow IC polymorphism\n\nBug classes to target:\n- Type confusion across ElementsKind boundaries (e.g.,       │
│ optimized load assuming Smi and reading a HeapNumber without proper tagging)\n- Out-of-bounds memory access during capacity growth or copy (GrowElements/CopyElements incorrect size   │
│ or missing checks)\n- Incorrect hole handling: assuming packed semantics when array is holey (missing prototype fallback)\n- Stale feedback / IC state: feedback vector indicates      │
│ monomorphic case but underlying objects/maps changed (leading to wrong fast path being reused)\n- Deopt mishandling: incorrect state after deopt or wrong frame reconstruction\n-      │
│ Species/prototype-based allocation mismatches (created objects with different maps expected by optimized code)\n- Missing or incorrect guards in TurboFan lowering leading to          │
│ optimized code that does not handle slow-path cases\n\nMinimal seed snippet (fast-path -> flip to slow-path):\n// Fast-path: monomorphic Smi-packed array, optimized expected\nlet a = │
│ [1,2,3,4,5];\nfunction store(i, v) { a[i] = v; }\nfor (let k = 0; k < 10000; k++) store(2, k); // call many times to populate                                                          │
│ feedback/opt\n%OptimizeFunctionOnNextCall(store);\nstore(2, 42);\n// Flip to slow path: insert double then object then create hole / change prototype\na[2] = 4.2;            // SMI   │
│ -> DOUBLE transition\na[3] = {x:1};          // DOUBLE -> OBJECT (PACKED_ELEMENTS) transition\ndelete a[1];           // make array HOLEY (hole introduced)\nObject.freeze(a);      // │
│ length/structure constraints -> slow/throw paths\nstore(2, -0);          // use -0/NaN to exercise double/edge-case\n\n(When run in d8 with --allow-natives-syntax the                 │
│ %OptimizeFunctionOnNextCall / %GetOptimizationStatus helpers can be used; in FuzzIL you would loop to reach warm-up counts instead.)\n\nNotes for harnessing: start with the simple    │
│ seed above and then systematically vary the fuzz knobs to toggle transitions; instrument for crashes, assertions, incorrect results, and deopt traces.\n\n\nTwo alternates             │
│ (brief):\n\nAlternate A: Array builtin fast-paths & species/prototype edge cases\n- Key files: src/builtins/array-from.cc, src/builtins/spread.cc, src/builtins/array-slice.cc,        │
│ src/builtins/array-concat.cc\n- Rationale: builtins implement specialized fast paths that copy/backing-store-manipulate arrays. Overriding Symbol.iterator, Array.prototype methods,   │
│ or species can force switching to slow-paths. Knobs: iterator override, species override, accessor elements on prototype, interleaved mutation during copy (e.g. mutate source array   │
│ during spread). These trigger subtle bugs in copying logic and elements-kind transitions.\n\nAlternate B: TypedArray vs JS array element access and fast-paths\n- Key files:           │
│ src/objects/typed-array-*.cc (src/objects/typed-array.cc), src/builtins/typed-array.* and compiler lowering for typed array loads/stores\n- Rationale: Typed arrays have distinct      │
│ fast-path lowering and bounds semantics; mixing typed array operations, buffer detachment, or converting between typed arrays and JS arrays (Array.from, set) can cause incorrect      │
│ lowering assumptions in JIT and IC stubs. Knobs: detachArrayBuffer at specific points, pass different typed array types, induce OOB writes via conversions, mix with normal arrays to  │
│ grow IC polymorphism.\n\n\n---\n\nRequired outputs for your manager (three parts):\n\n### 1. Task outcome (short version):\nPrimary pick: Keyed array element access & elements-kind   │
│ transitions (KeyedStoreIC/KeyedLoadIC + TransitionElementsKind + Grow/Copy helpers + Array builtin fast paths). This region is reachable from simple JS (a[i]=v, push, slice, spread)  │
│ and historically prone to type/IC/elements transitions, providing many fuzzing knobs (types, holes, lengths, prototype changes, getters, species).\n\n### 2. Task outcome (extremely   │
│ detailed version):\n(See the long detailed section above titled "Primary pick (detailed, actionable for a fuzzing sub-agent)". It contains rationale, concrete files & functions to    │
│ inspect, triggering JS patterns, preconditions and shapes, JIT linkage, fuzz knobs, target bug classes, and a minimal seed snippet to exercise fast->slow transitions.)\n\n### 3.      │
│ Additional context (if relevant):\n- Use the minimal seed to warm up ICs (many repeated calls) before attempting the transitions — that maximizes the chance of hitting optimized code │
│ paths and stale IC/feedback bugs.\n- Combine prototype/iterator/builtin overrides with in-loop element mutations or length changes to create racy/odd states for the JIT               │
│ assumptions.\n- Instrument with flags: --trace-elements-transitions, --trace-ic, --trace-deopt, and debug builds of d8 to get richer diagnostics while fuzzing.\n- Start fuzzing with  │
│ JS-level variations (FuzzIL knobs above). If a crash or misbehavior is found, capture feedback-vector states / map pointers via debug helpers (%DebugPrint, --trace-maps) to triage    │
│ the IC and map transitions involved.\n\n\nJSON summary required by earlier stage (copied at top):\n{\n  CODE REGION: "Keyed array element access & elements-kind transitions           │
│ (KeyedStoreIC/KeyedLoadIC, ElementsTransition, GrowElements/CopyElements, and Array builtin fast paths)",\n  SUMMARY_OF_CODE_REGION: "This region covers the JS indexed load/store     │
│ fast-paths and their slow-path transitions: the inline cache machinery that dispatches keyed loads/stores (KeyedLoadIC, KeyedStoreIC / StoreIC/LoadIC), the runtime and object-level   │
│ logic that implements elements kinds and transitions (PACKED_SMI/DOUBLE/ELEMENTS <-> HOLEY variants), the grow/copy helpers                                                            │
│ (EnsureCapacity/GrowElementsCapacity/CopyElements/TransitionElementsKind), and the Array builtin fast-path implementations that rely on these invariants                               │
│ (Array.prototype.push/pop/slice/splice/concat/Array.from/spread fast paths). On the JIT side this region is lowered and reasoned about by AccessInfo/JSCreateLowering and by TurboFan  │
│ reducers that turn JS keyed accesses and builtin calls into machine-friendly sequences. Key files touch both runtime-side C++ (objects/elements, ICs, builtins) and compiler-side      │
│ lowering/reducers. This area has historically been fragile because it mixes: fast-path optimistic assumptions (monomorphic elements kind, in-bounds, unmodified prototype and iterator │
│ machinery) with runtime transitions (elements kind downgrades, hole creation, prototype or iterator override, length manipulations, species/construction overrides) and IC/feedback    │
│ updates — all of which can cause stub replacement, deopts, or subtle type confusion if a lowering or IC stub misses a case or races with a transition.",\n  REASONING: "I selected     │
│ this region because it satisfies the fuzzing evaluation criteria: (a) it\'s reachable from plain JS and FuzzIL through very common operations (indexed stores, Array builtins, length  │
│ mutations, push/pop, spread, Array.from), (b) it\'s been historically prone to bugs around type/IC/elements kind (transitions between Smi/Double/Object, packed vs holey,              │
│ out-of-bounds growth, species/prototype edge cases, stale feedback vectors and deopts). It offers multiple JS-controllable knobs (types inserted, holes, lengths, OOB indices,         │
│ prototype changes, getters/setters, builtins being overridden) and has explicit both fast and slow paths in the VM and JIT, making it high-value for fuzzing that targets JIT          │
│ correctness and type-confusion classes."\n}\n\n\nIf you want, I can immediately produce an initial FuzzIL template using the seed and knobs above (example FuzzIL program and a guided │
│ mutational plan to toggle elements-kinds and IC polymorphism).'}                                                                                                                       │
╰────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
Observations: {
  "CODE REGION": "Keyed array element access & elements-kind transitions (KeyedStoreIC/KeyedLoadIC, ElementsTransition, GrowElements/CopyElements, and Array builtin fast paths)",
  "SUMMARY_OF_CODE_REGION": "This region covers the JS indexed load/store fast-paths and their slow-path transitions: the inline cache machinery that dispatches keyed loads/stores 
(KeyedLoadIC, KeyedStoreIC / StoreIC/LoadIC), the runtime and object-level logic that implements elements kinds and transitions (PACKED_SMI/DOUBLE/ELEMENTS <-> HOLEY variants), the 
grow/copy helpers (EnsureCapacity/GrowElementsCapacity/CopyElements/TransitionElementsKind), and the Array builtin fast-path implementations that rely on these invariants 
(Array.prototype.push/pop/slice/splice/concat/Array.from/spread fast paths). On the JIT side this region is lowered and reasoned about by AccessInfo/JSCreateLowering and by TurboFan 
reducers that turn JS keyed accesses and builtin calls into machine-friendly sequences. Key files touch both runtime-side C++ (objects/elements, ICs, builtins) and compiler-side 
lowering/reducers. This area has historically been fragile because it mixes: fast-path optimistic assumptions (monomorphic elements kind, in-bounds, unmodified prototype and iterator 
machinery) with runtime transitions (elements kind downgrades, hole creation, prototype or iterator override, length manipulations, species/construction overrides) and IC/feedback 
updates — all of which can cause stub replacement, deopts, or subtle type confusion if a lowering or IC stub misses a case or races with a transition.",
  "REASONING": "I selected this region because it satisfies the fuzzing evaluation criteria: (a) it's reachable from plain JS and FuzzIL through very common operations (indexed stores, 
Array builtins, length mutations, push/pop, spread, Array.from), (b) it's been historically prone to bugs around type/IC/elements kind (transitions between Smi/Double/Object, packed vs 
holey, out-of-bounds growth, species/prototype edge cases, stale feedback vectors and deopts). It offers multiple JS-controllable knobs (types inserted, holes, lengths, OOB indices, 
prototype changes, getters/setters, builtins being overridden) and has explicit both fast and slow paths in the VM and JIT, making it high-value for fuzzing that targets JIT correctness 
and type-confusion classes."
}


---

Primary pick (detailed, actionable for a fuzzing sub-agent):

Name/subsystem: Keyed array element access & elements-kind transitions (KeyedStoreIC / KeyedLoadIC and related builtin fast paths)

Rationale (why high value for fuzzing):
- Extremely reachable from plain JS via simple indexed assignment and common Array builtins (push/pop/slice/splice/concat/Array.from, spread literal).
- Many subtle transitions: PACKED_SMI -> PACKED_DOUBLE -> PACKED_ELEMENTS, PACKED -> HOLEY, typed arrays vs JS arrays, and length/capacity growth routines. These transitions update maps,
elements backing stores, feedback vectors and IC stubs — a rich surface for type confusion, stale IC state, OOB or incorrect hole handling, and deoptimization bugs.
- JIT interaction: inline caches control the optimized fast path; TurboFan reductions and lowering expect certain AccessInfo (maps/elements kinds). Small mismatches between IC 
expectations, runtime transitions, and lowering can be exploited by fuzzers.

V8 loci (suggested file paths and key functions — entry points for CodeAnalyzer and fuzz harness assembly):
- src/objects/elements.cc / src/objects/elements.h
  - TransitionElementsKind, EnsureCapacity, GrowElementsCapacity, CopyElements, Get/SetElement / SetLength implementation helpers
- src/objects/js-array.cc / src/objects/js-array.h
  - JSArray::SetLength and array element access helpers
- src/ic/ic.cc, src/ic/ic.h, src/ic/keyed-store.cc, src/ic/keyed-load.cc (or similarly-named IC files)
  - KeyedStoreIC::Generate, KeyedLoadIC::Generate, StoreIC/LoadIC miss/fast-path generation, KeyedStoreGenericStub / KeyedLoadGenericStub
- src/ic/ic-compiler.cc / src/ic/stub-cache.cc
  - IC assembly/stub creation and replacement code
- src/builtins/array-push.cc, src/builtins/array-slice.cc, src/builtins/array-splice.cc, src/builtins/array-from.cc, src/builtins/array-concat.cc
  - ArrayPrototypePush, ArrayPrototypeSlice, ArrayFromBuiltin — these contain fast-paths that directly copy/backing-store-manipulate arrays
- src/objects/elements-kind.h (or equivalent) — enumerations for ElementsKind (PACKED_SMI_ELEMENTS, PACKED_DOUBLE_ELEMENTS, PACKED_ELEMENTS, HOLEY_* etc.)
- src/compiler/* (TurboFan / lowering side):
  - JSCreateLowering / ArrayBuiltinLowering reducers (files under src/compiler/ that lower JS array builtin ops into lower-level nodes), AccessInfo computation paths, and the 
reducer/typer passes that affect element access (look for files implementing Load/Store lowering like js-operator-reducer or builtins lowering; keywords: JSLoadIndexed, JSStoreIndexed, 
AccessInfo)
  - Reducers that handle keyed loads/stores and effect on feedback vectors (JSLoad/StoreLowering in compiler pipeline)
- Hot runtime helpers in runtime/ or runtime/array.* (e.g., Runtime::TransitionElementsKind, Runtime::GrowElements) — these are called by slow paths and builtin slow-paths.

Triggering JS patterns (concrete operations that expose fast vs slow paths):
- Direct indexed stores: a|i] = value (with i being in-bounds, then OOB to force grow, negative/huge indexes)
- Array.prototype.push/pop and repeated push-driven growth
- Setting length manually: a.length = smaller to truncate, a.length = larger to create holes or reduce capacity
- Hole creation: delete a|1], assign at far index (a|100] = x) to create holes and force HOLEY_* transitions
- Mixing types: insert Smis, then a double (e.g., -0 or NaN), then an object to force PACKED_SMI -> PACKED_DOUBLE -> PACKED_ELEMENTS transitions
- Prototype mutation: this.__proto__ = Array.prototype or override Array.prototype|n] or Symbol.iterator, or defineOwnProperty(Array.prototype, idx, getter) to affect iteration or hole 
semantics
- Overriding builtins: Array.prototype.push = function() { /* custom */ } to force builtin slow-path/IC changes
- Species/prototype swaps during builtin operations (e.g., Array.prototype.slice with custom species) to get into alternate allocation paths
- Using accessor properties (getters/setters) at element indexes or on prototype to trigger slow-paths
- TypedArray interop: mixing operations that expect TypedArray semantics vs JS array operations (Array.from/ spread into typed arrays vs arrays)

Preconditions / shape constraints to exercise:
- Start with a monomorphic array shape: PACKED_SMI_ELEMENTS, length N, fast-elements backing store
- Ensure maps are consistent (same hidden class across iterations) to hit the fast IC path first
- Use write patterns to gradually convert elements kind (Smi -> Double -> Elements) or to make array holey
- Control length writable/non-writable by Object.freeze / Object.preventExtensions / Object.seal to exercise edge cases
- Make prototype be Array.prototype or a mutated prototype to toggle fast-path guards

JIT linkage (IC stubs, TurboFan reducers, lowering passes):
- Inline caches: KeyedStoreIC / KeyedLoadIC, StoreIC/LoadIC miss handlers and generated stubs (monomorphic / polymorphic / generic)
- Feedback vectors: Feedback slots for keyed loads/stores that record elements-kind or transition feedback
- Runtime helpers called from IC slow paths: Runtime::SetElement, Runtime::TransitionElementsKind, Runtime::EnsureCapacity/GrowElements
- TurboFan lowering/reducers: reducers that take JSLoadIndexed / JSStoreIndexed nodes and lower to machine code assuming a particular ElementsKind and bounds checks, and JS builtin 
lowering for push/slice that do block copies or element-kind conversions
- AccessInfo computations: AccessInfo provides the compiler with the representation and checks necessary to lower a property or element access; bugs here lead to incorrect assumptions in
generated code
- Deopt pathways: deopt points in optimized code when speculative assumptions (e.g., elements kind, in-bounds) are violated; ensure test harness can trigger deopt paths and reopt again 
(stale feedback vulnerabilities)

Fuzz knobs (controllable in FuzzIL or JS harness):
- Array initial type lattice: create arrays with PACKED_SMI / PACKED_DOUBLE / PACKED_ELEMENTS
- Inserted value types: Smi (small integers), HeapNumber (double), Object, undefined, null, Symbol, -0, NaN, Infinity
- Index patterns: sequential small indices, repeated writes at same index, random indices, large OOB to force resize, negative indices, ToString-keyed numeric indexes
- Holes: create holes via sparse assignment (a|1000]=x) or delete a|1]
- length manipulations: shrink length, grow length, set non-writable length (Object.defineProperty), repeated setting inside loops
- Prototype mutation: change this.__proto__, modify Array.prototype entries to introduce prototypes-provided elements
- Accessors: define getters/setters on prototype or own properties at numeric indexes
- Builtins override: shadow Array.prototype.push/pop or Symbol.iterator
- Species override: override constructor|Symbol.species] to switch allocation strategy
- TypedArray vs JS array mixing: create typed arrays and attempt operations that treat them as JS arrays
- Deopt-triggering arithmetic: use -0, NaN, large numbers to force Smi->Double transitions and deopts
- IC polymorphism: call the same function on arrays with differing elements kind and maps to grow IC polymorphism

Bug classes to target:
- Type confusion across ElementsKind boundaries (e.g., optimized load assuming Smi and reading a HeapNumber without proper tagging)
- Out-of-bounds memory access during capacity growth or copy (GrowElements/CopyElements incorrect size or missing checks)
- Incorrect hole handling: assuming packed semantics when array is holey (missing prototype fallback)
- Stale feedback / IC state: feedback vector indicates monomorphic case but underlying objects/maps changed (leading to wrong fast path being reused)
- Deopt mishandling: incorrect state after deopt or wrong frame reconstruction
- Species/prototype-based allocation mismatches (created objects with different maps expected by optimized code)
- Missing or incorrect guards in TurboFan lowering leading to optimized code that does not handle slow-path cases

Minimal seed snippet (fast-path -> flip to slow-path):
// Fast-path: monomorphic Smi-packed array, optimized expected
let a = |1,2,3,4,5];
function store(i, v) { a|i] = v; }
for (let k = 0; k < 10000; k++) store(2, k); // call many times to populate feedback/opt
%OptimizeFunctionOnNextCall(store);
store(2, 42);
// Flip to slow path: insert double then object then create hole / change prototype
a|2] = 4.2;            // SMI -> DOUBLE transition
a|3] = {x:1};          // DOUBLE -> OBJECT (PACKED_ELEMENTS) transition
delete a|1];           // make array HOLEY (hole introduced)
Object.freeze(a);      // length/structure constraints -> slow/throw paths
store(2, -0);          // use -0/NaN to exercise double/edge-case

(When run in d8 with --allow-natives-syntax the %OptimizeFunctionOnNextCall / %GetOptimizationStatus helpers can be used; in FuzzIL you would loop to reach warm-up counts instead.)

Notes for harnessing: start with the simple seed above and then systematically vary the fuzz knobs to toggle transitions; instrument for crashes, assertions, incorrect results, and deopt
traces.


Two alternates (brief):

Alternate A: Array builtin fast-paths & species/prototype edge cases
- Key files: src/builtins/array-from.cc, src/builtins/spread.cc, src/builtins/array-slice.cc, src/builtins/array-concat.cc
- Rationale: builtins implement specialized fast paths that copy/backing-store-manipulate arrays. Overriding Symbol.iterator, Array.prototype methods, or species can force switching to 
slow-paths. Knobs: iterator override, species override, accessor elements on prototype, interleaved mutation during copy (e.g. mutate source array during spread). These trigger subtle 
bugs in copying logic and elements-kind transitions.

Alternate B: TypedArray vs JS array element access and fast-paths
- Key files: src/objects/typed-array-*.cc (src/objects/typed-array.cc), src/builtins/typed-array.* and compiler lowering for typed array loads/stores
- Rationale: Typed arrays have distinct fast-path lowering and bounds semantics; mixing typed array operations, buffer detachment, or converting between typed arrays and JS arrays 
(Array.from, set) can cause incorrect lowering assumptions in JIT and IC stubs. Knobs: detachArrayBuffer at specific points, pass different typed array types, induce OOB writes via 
conversions, mix with normal arrays to grow IC polymorphism.


---

Required outputs for your manager (three parts):

### 1. Task outcome (short version):
Primary pick: Keyed array element access & elements-kind transitions (KeyedStoreIC/KeyedLoadIC + TransitionElementsKind + Grow/Copy helpers + Array builtin fast paths). This region is 
reachable from simple JS (a|i]=v, push, slice, spread) and historically prone to type/IC/elements transitions, providing many fuzzing knobs (types, holes, lengths, prototype changes, 
getters, species).

### 2. Task outcome (extremely detailed version):
(See the long detailed section above titled "Primary pick (detailed, actionable for a fuzzing sub-agent)". It contains rationale, concrete files & functions to inspect, triggering JS 
patterns, preconditions and shapes, JIT linkage, fuzz knobs, target bug classes, and a minimal seed snippet to exercise fast->slow transitions.)

### 3. Additional context (if relevant):
- Use the minimal seed to warm up ICs (many repeated calls) before attempting the transitions — that maximizes the chance of hitting optimized code paths and stale IC/feedback bugs.
- Combine prototype/iterator/builtin overrides with in-loop element mutations or length changes to create racy/odd states for the JIT assumptions.
- Instrument with flags: --trace-elements-transitions, --trace-ic, --trace-deopt, and debug builds of d8 to get richer diagnostics while fuzzing.
- Start fuzzing with JS-level variations (FuzzIL knobs above). If a crash or misbehavior is found, capture feedback-vector states / map pointers via debug helpers (%DebugPrint, 
--trace-maps) to triage the IC and map transitions involved.


JSON summary required by earlier stage (copied at top):
{
  CODE REGION: "Keyed array element access & elements-kind transitions (KeyedStoreIC/KeyedLoadIC, ElementsTransition, GrowElements/CopyElements, and Array builtin fast paths)",
  SUMMARY_OF_CODE_REGION: "This region covers the JS indexed load/store fast-paths and their slow-path transitions: the inline cache machinery that dispatches keyed loads/stores 
(KeyedLoadIC, KeyedStoreIC / StoreIC/LoadIC), the runtime and object-level logic that implements elements kinds and transitions (PACKED_SMI/DOUBLE/ELEMENTS <-> HOLEY variants), the 
grow/copy helpers (EnsureCapacity/GrowElementsCapacity/CopyElements/TransitionElementsKind), and the Array builtin fast-path implementations that rely on these invariants 
(Array.prototype.push/pop/slice/splice/concat/Array.from/spread fast paths). On the JIT side this region is lowered and reasoned about by AccessInfo/JSCreateLowering and by TurboFan 
reducers that turn JS keyed accesses and builtin calls into machine-friendly sequences. Key files touch both runtime-side C++ (objects/elements, ICs, builtins) and compiler-side 
lowering/reducers. This area has historically been fragile because it mixes: fast-path optimistic assumptions (monomorphic elements kind, in-bounds, unmodified prototype and iterator 
machinery) with runtime transitions (elements kind downgrades, hole creation, prototype or iterator override, length manipulations, species/construction overrides) and IC/feedback 
updates — all of which can cause stub replacement, deopts, or subtle type confusion if a lowering or IC stub misses a case or races with a transition.",
  REASONING: "I selected this region because it satisfies the fuzzing evaluation criteria: (a) it's reachable from plain JS and FuzzIL through very common operations (indexed stores, 
Array builtins, length mutations, push/pop, spread, Array.from), (b) it's been historically prone to bugs around type/IC/elements kind (transitions between Smi/Double/Object, packed vs 
holey, out-of-bounds growth, species/prototype edge cases, stale feedback vectors and deopts). It offers multiple JS-controllable knobs (types inserted, holes, lengths, OOB indices, 
prototype changes, getters/setters, builtins being overridden) and has explicit both fast and slow paths in the VM and JIT, making it high-value for fuzzing that targets JIT correctness 
and type-confusion classes."
}


If you want, I can immediately produce an initial FuzzIL template using the seed and knobs above (example FuzzIL program and a guided mutational plan to toggle elements-kinds and IC 
polymorphism).
Final answer: {
  "CODE REGION": "Keyed array element access & elements-kind transitions (KeyedStoreIC/KeyedLoadIC, ElementsTransition, GrowElements/CopyElements, and Array builtin fast paths)",
  "SUMMARY_OF_CODE_REGION": "This region covers the JS indexed load/store fast-paths and their slow-path transitions: the inline cache machinery that dispatches keyed loads/stores 
(KeyedLoadIC, KeyedStoreIC / StoreIC/LoadIC), the runtime and object-level logic that implements elements kinds and transitions (PACKED_SMI/DOUBLE/ELEMENTS <-> HOLEY variants), the 
grow/copy helpers (EnsureCapacity/GrowElementsCapacity/CopyElements/TransitionElementsKind), and the Array builtin fast-path implementations that rely on these invariants 
(Array.prototype.push/pop/slice/splice/concat/Array.from/spread fast paths). On the JIT side this region is lowered and reasoned about by AccessInfo/JSCreateLowering and by TurboFan 
reducers that turn JS keyed accesses and builtin calls into machine-friendly sequences. Key files touch both runtime-side C++ (objects/elements, ICs, builtins) and compiler-side 
lowering/reducers. This area has historically been fragile because it mixes: fast-path optimistic assumptions (monomorphic elements kind, in-bounds, unmodified prototype and iterator 
machinery) with runtime transitions (elements kind downgrades, hole creation, prototype or iterator override, length manipulations, species/construction overrides) and IC/feedback 
updates — all of which can cause stub replacement, deopts, or subtle type confusion if a lowering or IC stub misses a case or races with a transition.",
  "REASONING": "I selected this region because it satisfies the fuzzing evaluation criteria: (a) it's reachable from plain JS and FuzzIL through very common operations (indexed stores, 
Array builtins, length mutations, push/pop, spread, Array.from), (b) it's been historically prone to bugs around type/IC/elements kind (transitions between Smi/Double/Object, packed vs 
holey, out-of-bounds growth, species/prototype edge cases, stale feedback vectors and deopts). It offers multiple JS-controllable knobs (types inserted, holes, lengths, OOB indices, 
prototype changes, getters/setters, builtins being overridden) and has explicit both fast and slow paths in the VM and JIT, making it high-value for fuzzing that targets JIT correctness 
and type-confusion classes."
}


---

Primary pick (detailed, actionable for a fuzzing sub-agent):

Name/subsystem: Keyed array element access & elements-kind transitions (KeyedStoreIC / KeyedLoadIC and related builtin fast paths)

Rationale (why high value for fuzzing):
- Extremely reachable from plain JS via simple indexed assignment and common Array builtins (push/pop/slice/splice/concat/Array.from, spread literal).
- Many subtle transitions: PACKED_SMI -> PACKED_DOUBLE -> PACKED_ELEMENTS, PACKED -> HOLEY, typed arrays vs JS arrays, and length/capacity growth routines. These transitions update maps,
elements backing stores, feedback vectors and IC stubs — a rich surface for type confusion, stale IC state, OOB or incorrect hole handling, and deoptimization bugs.
- JIT interaction: inline caches control the optimized fast path; TurboFan reductions and lowering expect certain AccessInfo (maps/elements kinds). Small mismatches between IC 
expectations, runtime transitions, and lowering can be exploited by fuzzers.

V8 loci (suggested file paths and key functions — entry points for CodeAnalyzer and fuzz harness assembly):
- src/objects/elements.cc / src/objects/elements.h
  - TransitionElementsKind, EnsureCapacity, GrowElementsCapacity, CopyElements, Get/SetElement / SetLength implementation helpers
- src/objects/js-array.cc / src/objects/js-array.h
  - JSArray::SetLength and array element access helpers
- src/ic/ic.cc, src/ic/ic.h, src/ic/keyed-store.cc, src/ic/keyed-load.cc (or similarly-named IC files)
  - KeyedStoreIC::Generate, KeyedLoadIC::Generate, StoreIC/LoadIC miss/fast-path generation, KeyedStoreGenericStub / KeyedLoadGenericStub
- src/ic/ic-compiler.cc / src/ic/stub-cache.cc
  - IC assembly/stub creation and replacement code
- src/builtins/array-push.cc, src/builtins/array-slice.cc, src/builtins/array-splice.cc, src/builtins/array-from.cc, src/builtins/array-concat.cc
  - ArrayPrototypePush, ArrayPrototypeSlice, ArrayFromBuiltin — these contain fast-paths that directly copy/backing-store-manipulate arrays
- src/objects/elements-kind.h (or equivalent) — enumerations for ElementsKind (PACKED_SMI_ELEMENTS, PACKED_DOUBLE_ELEMENTS, PACKED_ELEMENTS, HOLEY_* etc.)
- src/compiler/* (TurboFan / lowering side):
  - JSCreateLowering / ArrayBuiltinLowering reducers (files under src/compiler/ that lower JS array builtin ops into lower-level nodes), AccessInfo computation paths, and the 
reducer/typer passes that affect element access (look for files implementing Load/Store lowering like js-operator-reducer or builtins lowering; keywords: JSLoadIndexed, JSStoreIndexed, 
AccessInfo)
  - Reducers that handle keyed loads/stores and effect on feedback vectors (JSLoad/StoreLowering in compiler pipeline)
- Hot runtime helpers in runtime/ or runtime/array.* (e.g., Runtime::TransitionElementsKind, Runtime::GrowElements) — these are called by slow paths and builtin slow-paths.

Triggering JS patterns (concrete operations that expose fast vs slow paths):
- Direct indexed stores: a[i] = value (with i being in-bounds, then OOB to force grow, negative/huge indexes)
- Array.prototype.push/pop and repeated push-driven growth
- Setting length manually: a.length = smaller to truncate, a.length = larger to create holes or reduce capacity
- Hole creation: delete a[1], assign at far index (a[100] = x) to create holes and force HOLEY_* transitions
- Mixing types: insert Smis, then a double (e.g., -0 or NaN), then an object to force PACKED_SMI -> PACKED_DOUBLE -> PACKED_ELEMENTS transitions
- Prototype mutation: this.__proto__ = Array.prototype or override Array.prototype[n] or Symbol.iterator, or defineOwnProperty(Array.prototype, idx, getter) to affect iteration or hole 
semantics
- Overriding builtins: Array.prototype.push = function() { /* custom */ } to force builtin slow-path/IC changes
- Species/prototype swaps during builtin operations (e.g., Array.prototype.slice with custom species) to get into alternate allocation paths
- Using accessor properties (getters/setters) at element indexes or on prototype to trigger slow-paths
- TypedArray interop: mixing operations that expect TypedArray semantics vs JS array operations (Array.from/ spread into typed arrays vs arrays)

Preconditions / shape constraints to exercise:
- Start with a monomorphic array shape: PACKED_SMI_ELEMENTS, length N, fast-elements backing store
- Ensure maps are consistent (same hidden class across iterations) to hit the fast IC path first
- Use write patterns to gradually convert elements kind (Smi -> Double -> Elements) or to make array holey
- Control length writable/non-writable by Object.freeze / Object.preventExtensions / Object.seal to exercise edge cases
- Make prototype be Array.prototype or a mutated prototype to toggle fast-path guards

JIT linkage (IC stubs, TurboFan reducers, lowering passes):
- Inline caches: KeyedStoreIC / KeyedLoadIC, StoreIC/LoadIC miss handlers and generated stubs (monomorphic / polymorphic / generic)
- Feedback vectors: Feedback slots for keyed loads/stores that record elements-kind or transition feedback
- Runtime helpers called from IC slow paths: Runtime::SetElement, Runtime::TransitionElementsKind, Runtime::EnsureCapacity/GrowElements
- TurboFan lowering/reducers: reducers that take JSLoadIndexed / JSStoreIndexed nodes and lower to machine code assuming a particular ElementsKind and bounds checks, and JS builtin 
lowering for push/slice that do block copies or element-kind conversions
- AccessInfo computations: AccessInfo provides the compiler with the representation and checks necessary to lower a property or element access; bugs here lead to incorrect assumptions in
generated code
- Deopt pathways: deopt points in optimized code when speculative assumptions (e.g., elements kind, in-bounds) are violated; ensure test harness can trigger deopt paths and reopt again 
(stale feedback vulnerabilities)

Fuzz knobs (controllable in FuzzIL or JS harness):
- Array initial type lattice: create arrays with PACKED_SMI / PACKED_DOUBLE / PACKED_ELEMENTS
- Inserted value types: Smi (small integers), HeapNumber (double), Object, undefined, null, Symbol, -0, NaN, Infinity
- Index patterns: sequential small indices, repeated writes at same index, random indices, large OOB to force resize, negative indices, ToString-keyed numeric indexes
- Holes: create holes via sparse assignment (a[1000]=x) or delete a[1]
- length manipulations: shrink length, grow length, set non-writable length (Object.defineProperty), repeated setting inside loops
- Prototype mutation: change this.__proto__, modify Array.prototype entries to introduce prototypes-provided elements
- Accessors: define getters/setters on prototype or own properties at numeric indexes
- Builtins override: shadow Array.prototype.push/pop or Symbol.iterator
- Species override: override constructor[Symbol.species] to switch allocation strategy
- TypedArray vs JS array mixing: create typed arrays and attempt operations that treat them as JS arrays
- Deopt-triggering arithmetic: use -0, NaN, large numbers to force Smi->Double transitions and deopts
- IC polymorphism: call the same function on arrays with differing elements kind and maps to grow IC polymorphism

Bug classes to target:
- Type confusion across ElementsKind boundaries (e.g., optimized load assuming Smi and reading a HeapNumber without proper tagging)
- Out-of-bounds memory access during capacity growth or copy (GrowElements/CopyElements incorrect size or missing checks)
- Incorrect hole handling: assuming packed semantics when array is holey (missing prototype fallback)
- Stale feedback / IC state: feedback vector indicates monomorphic case but underlying objects/maps changed (leading to wrong fast path being reused)
- Deopt mishandling: incorrect state after deopt or wrong frame reconstruction
- Species/prototype-based allocation mismatches (created objects with different maps expected by optimized code)
- Missing or incorrect guards in TurboFan lowering leading to optimized code that does not handle slow-path cases

Minimal seed snippet (fast-path -> flip to slow-path):
// Fast-path: monomorphic Smi-packed array, optimized expected
let a = [1,2,3,4,5];
function store(i, v) { a[i] = v; }
for (let k = 0; k < 10000; k++) store(2, k); // call many times to populate feedback/opt
%OptimizeFunctionOnNextCall(store);
store(2, 42);
// Flip to slow path: insert double then object then create hole / change prototype
a[2] = 4.2;            // SMI -> DOUBLE transition
a[3] = {x:1};          // DOUBLE -> OBJECT (PACKED_ELEMENTS) transition
delete a[1];           // make array HOLEY (hole introduced)
Object.freeze(a);      // length/structure constraints -> slow/throw paths
store(2, -0);          // use -0/NaN to exercise double/edge-case

(When run in d8 with --allow-natives-syntax the %OptimizeFunctionOnNextCall / %GetOptimizationStatus helpers can be used; in FuzzIL you would loop to reach warm-up counts instead.)

Notes for harnessing: start with the simple seed above and then systematically vary the fuzz knobs to toggle transitions; instrument for crashes, assertions, incorrect results, and deopt
traces.


Two alternates (brief):

Alternate A: Array builtin fast-paths & species/prototype edge cases
- Key files: src/builtins/array-from.cc, src/builtins/spread.cc, src/builtins/array-slice.cc, src/builtins/array-concat.cc
- Rationale: builtins implement specialized fast paths that copy/backing-store-manipulate arrays. Overriding Symbol.iterator, Array.prototype methods, or species can force switching to 
slow-paths. Knobs: iterator override, species override, accessor elements on prototype, interleaved mutation during copy (e.g. mutate source array during spread). These trigger subtle 
bugs in copying logic and elements-kind transitions.

Alternate B: TypedArray vs JS array element access and fast-paths
- Key files: src/objects/typed-array-*.cc (src/objects/typed-array.cc), src/builtins/typed-array.* and compiler lowering for typed array loads/stores
- Rationale: Typed arrays have distinct fast-path lowering and bounds semantics; mixing typed array operations, buffer detachment, or converting between typed arrays and JS arrays 
(Array.from, set) can cause incorrect lowering assumptions in JIT and IC stubs. Knobs: detachArrayBuffer at specific points, pass different typed array types, induce OOB writes via 
conversions, mix with normal arrays to grow IC polymorphism.


---

Required outputs for your manager (three parts):

### 1. Task outcome (short version):
Primary pick: Keyed array element access & elements-kind transitions (KeyedStoreIC/KeyedLoadIC + TransitionElementsKind + Grow/Copy helpers + Array builtin fast paths). This region is 
reachable from simple JS (a[i]=v, push, slice, spread) and historically prone to type/IC/elements transitions, providing many fuzzing knobs (types, holes, lengths, prototype changes, 
getters, species).

### 2. Task outcome (extremely detailed version):
(See the long detailed section above titled "Primary pick (detailed, actionable for a fuzzing sub-agent)". It contains rationale, concrete files & functions to inspect, triggering JS 
patterns, preconditions and shapes, JIT linkage, fuzz knobs, target bug classes, and a minimal seed snippet to exercise fast->slow transitions.)

### 3. Additional context (if relevant):
- Use the minimal seed to warm up ICs (many repeated calls) before attempting the transitions — that maximizes the chance of hitting optimized code paths and stale IC/feedback bugs.
- Combine prototype/iterator/builtin overrides with in-loop element mutations or length changes to create racy/odd states for the JIT assumptions.
- Instrument with flags: --trace-elements-transitions, --trace-ic, --trace-deopt, and debug builds of d8 to get richer diagnostics while fuzzing.
- Start fuzzing with JS-level variations (FuzzIL knobs above). If a crash or misbehavior is found, capture feedback-vector states / map pointers via debug helpers (%DebugPrint, 
--trace-maps) to triage the IC and map transitions involved.


JSON summary required by earlier stage (copied at top):
{
  CODE REGION: "Keyed array element access & elements-kind transitions (KeyedStoreIC/KeyedLoadIC, ElementsTransition, GrowElements/CopyElements, and Array builtin fast paths)",
  SUMMARY_OF_CODE_REGION: "This region covers the JS indexed load/store fast-paths and their slow-path transitions: the inline cache machinery that dispatches keyed loads/stores 
(KeyedLoadIC, KeyedStoreIC / StoreIC/LoadIC), the runtime and object-level logic that implements elements kinds and transitions (PACKED_SMI/DOUBLE/ELEMENTS <-> HOLEY variants), the 
grow/copy helpers (EnsureCapacity/GrowElementsCapacity/CopyElements/TransitionElementsKind), and the Array builtin fast-path implementations that rely on these invariants 
(Array.prototype.push/pop/slice/splice/concat/Array.from/spread fast paths). On the JIT side this region is lowered and reasoned about by AccessInfo/JSCreateLowering and by TurboFan 
reducers that turn JS keyed accesses and builtin calls into machine-friendly sequences. Key files touch both runtime-side C++ (objects/elements, ICs, builtins) and compiler-side 
lowering/reducers. This area has historically been fragile because it mixes: fast-path optimistic assumptions (monomorphic elements kind, in-bounds, unmodified prototype and iterator 
machinery) with runtime transitions (elements kind downgrades, hole creation, prototype or iterator override, length manipulations, species/construction overrides) and IC/feedback 
updates — all of which can cause stub replacement, deopts, or subtle type confusion if a lowering or IC stub misses a case or races with a transition.",
  REASONING: "I selected this region because it satisfies the fuzzing evaluation criteria: (a) it's reachable from plain JS and FuzzIL through very common operations (indexed stores, 
Array builtins, length mutations, push/pop, spread, Array.from), (b) it's been historically prone to bugs around type/IC/elements kind (transitions between Smi/Double/Object, packed vs 
holey, out-of-bounds growth, species/prototype edge cases, stale feedback vectors and deopts). It offers multiple JS-controllable knobs (types inserted, holes, lengths, OOB indices, 
prototype changes, getters/setters, builtins being overridden) and has explicit both fast and slow paths in the VM and JIT, making it high-value for fuzzing that targets JIT correctness 
and type-confusion classes."
}


If you want, I can immediately produce an initial FuzzIL template using the seed and knobs above (example FuzzIL program and a guided mutational plan to toggle elements-kinds and IC 
polymorphism).
[Step 7: Duration 79.37 seconds| Input tokens: 110,826 | Output tokens: 7,102]
Observations: Here is the final answer from your managed agent 'PickSection':
{
  "CODE REGION": "Keyed array element access & elements-kind transitions (KeyedStoreIC/KeyedLoadIC, ElementsTransition, GrowElements/CopyElements, and Array builtin fast paths)",
  "SUMMARY_OF_CODE_REGION": "This region covers the JS indexed load/store fast-paths and their slow-path transitions: the inline cache machinery that dispatches keyed loads/stores 
(KeyedLoadIC, KeyedStoreIC / StoreIC/LoadIC), the runtime and object-level logic that implements elements kinds and transitions (PACKED_SMI/DOUBLE/ELEMENTS <-> HOLEY variants), the 
grow/copy helpers (EnsureCapacity/GrowElementsCapacity/CopyElements/TransitionElementsKind), and the Array builtin fast-path implementations that rely on these invariants 
(Array.prototype.push/pop/slice/splice/concat/Array.from/spread fast paths). On the JIT side this region is lowered and reasoned about by AccessInfo/JSCreateLowering and by TurboFan 
reducers that turn JS keyed accesses and builtin calls into machine-friendly sequences. Key files touch both runtime-side C++ (objects/elements, ICs, builtins) and compiler-side 
lowering/reducers. This area has historically been fragile because it mixes: fast-path optimistic assumptions (monomorphic elements kind, in-bounds, unmodified prototype and iterator 
machinery) with runtime transitions (elements kind downgrades, hole creation, prototype or iterator override, length manipulations, species/construction overrides) and IC/feedback 
updates — all of which can cause stub replacement, deopts, or subtle type confusion if a lowering or IC stub misses a case or races with a transition.",
  "REASONING": "I selected this region because it satisfies the fuzzing evaluation criteria: (a) it's reachable from plain JS and FuzzIL through very common operations (indexed stores, 
Array builtins, length mutations, push/pop, spread, Array.from), (b) it's been historically prone to bugs around type/IC/elements kind (transitions between Smi/Double/Object, packed vs 
holey, out-of-bounds growth, species/prototype edge cases, stale feedback vectors and deopts). It offers multiple JS-controllable knobs (types inserted, holes, lengths, OOB indices, 
prototype changes, getters/setters, builtins being overridden) and has explicit both fast and slow paths in the VM and JIT, making it high-value for fuzzing that targets JIT correctness 
and type-confusion classes."
}


---

Primary pick (detailed, actionable for a fuzzing sub-agent):

Name/subsystem: Keyed array element access & elements-kind transitions (KeyedStoreIC / KeyedLoadIC and related builtin fast paths)

Rationale (why high value for fuzzing):
- Extremely reachable from plain JS via simple indexed assignment and common Array builtins (push/pop/slice/splice/concat/Array.from, spread literal).
- Many subtle transitions: PACKED_SMI -> PACKED_DOUBLE -> PACKED_ELEMENTS, PACKED -> HOLEY, typed arrays vs JS arrays, and length/capacity growth routines. These transitions update maps,
elements backing stores, feedback vectors and IC stubs — a rich surface for type confusion, stale IC state, OOB or incorrect hole handling, and deoptimization bugs.
- JIT interaction: inline caches control the optimized fast path; TurboFan reductions and lowering expect certain AccessInfo (maps/elements kinds). Small mismatches between IC 
expectations, runtime transitions, and lowering can be exploited by fuzzers.

V8 loci (suggested file paths and key functions — entry points for CodeAnalyzer and fuzz harness assembly):
- src/objects/elements.cc / src/objects/elements.h
  - TransitionElementsKind, EnsureCapacity, GrowElementsCapacity, CopyElements, Get/SetElement / SetLength implementation helpers
- src/objects/js-array.cc / src/objects/js-array.h
  - JSArray::SetLength and array element access helpers
- src/ic/ic.cc, src/ic/ic.h, src/ic/keyed-store.cc, src/ic/keyed-load.cc (or similarly-named IC files)
  - KeyedStoreIC::Generate, KeyedLoadIC::Generate, StoreIC/LoadIC miss/fast-path generation, KeyedStoreGenericStub / KeyedLoadGenericStub
- src/ic/ic-compiler.cc / src/ic/stub-cache.cc
  - IC assembly/stub creation and replacement code
- src/builtins/array-push.cc, src/builtins/array-slice.cc, src/builtins/array-splice.cc, src/builtins/array-from.cc, src/builtins/array-concat.cc
  - ArrayPrototypePush, ArrayPrototypeSlice, ArrayFromBuiltin — these contain fast-paths that directly copy/backing-store-manipulate arrays
- src/objects/elements-kind.h (or equivalent) — enumerations for ElementsKind (PACKED_SMI_ELEMENTS, PACKED_DOUBLE_ELEMENTS, PACKED_ELEMENTS, HOLEY_* etc.)
- src/compiler/* (TurboFan / lowering side):
  - JSCreateLowering / ArrayBuiltinLowering reducers (files under src/compiler/ that lower JS array builtin ops into lower-level nodes), AccessInfo computation paths, and the 
reducer/typer passes that affect element access (look for files implementing Load/Store lowering like js-operator-reducer or builtins lowering; keywords: JSLoadIndexed, JSStoreIndexed, 
AccessInfo)
  - Reducers that handle keyed loads/stores and effect on feedback vectors (JSLoad/StoreLowering in compiler pipeline)
- Hot runtime helpers in runtime/ or runtime/array.* (e.g., Runtime::TransitionElementsKind, Runtime::GrowElements) — these are called by slow paths and builtin slow-paths.

Triggering JS patterns (concrete operations that expose fast vs slow paths):
- Direct indexed stores: a|i] = value (with i being in-bounds, then OOB to force grow, negative/huge indexes)
- Array.prototype.push/pop and repeated push-driven growth
- Setting length manually: a.length = smaller to truncate, a.length = larger to create holes or reduce capacity
- Hole creation: delete a|1], assign at far index (a|100] = x) to create holes and force HOLEY_* transitions
- Mixing types: insert Smis, then a double (e.g., -0 or NaN), then an object to force PACKED_SMI -> PACKED_DOUBLE -> PACKED_ELEMENTS transitions
- Prototype mutation: this.__proto__ = Array.prototype or override Array.prototype|n] or Symbol.iterator, or defineOwnProperty(Array.prototype, idx, getter) to affect iteration or hole 
semantics
- Overriding builtins: Array.prototype.push = function() { /* custom */ } to force builtin slow-path/IC changes
- Species/prototype swaps during builtin operations (e.g., Array.prototype.slice with custom species) to get into alternate allocation paths
- Using accessor properties (getters/setters) at element indexes or on prototype to trigger slow-paths
- TypedArray interop: mixing operations that expect TypedArray semantics vs JS array operations (Array.from/ spread into typed arrays vs arrays)

Preconditions / shape constraints to exercise:
- Start with a monomorphic array shape: PACKED_SMI_ELEMENTS, length N, fast-elements backing store
- Ensure maps are consistent (same hidden class across iterations) to hit the fast IC path first
- Use write patterns to gradually convert elements kind (Smi -> Double -> Elements) or to make array holey
- Control length writable/non-writable by Object.freeze / Object.preventExtensions / Object.seal to exercise edge cases
- Make prototype be Array.prototype or a mutated prototype to toggle fast-path guards

JIT linkage (IC stubs, TurboFan reducers, lowering passes):
- Inline caches: KeyedStoreIC / KeyedLoadIC, StoreIC/LoadIC miss handlers and generated stubs (monomorphic / polymorphic / generic)
- Feedback vectors: Feedback slots for keyed loads/stores that record elements-kind or transition feedback
- Runtime helpers called from IC slow paths: Runtime::SetElement, Runtime::TransitionElementsKind, Runtime::EnsureCapacity/GrowElements
- TurboFan lowering/reducers: reducers that take JSLoadIndexed / JSStoreIndexed nodes and lower to machine code assuming a particular ElementsKind and bounds checks, and JS builtin 
lowering for push/slice that do block copies or element-kind conversions
- AccessInfo computations: AccessInfo provides the compiler with the representation and checks necessary to lower a property or element access; bugs here lead to incorrect assumptions in
generated code
- Deopt pathways: deopt points in optimized code when speculative assumptions (e.g., elements kind, in-bounds) are violated; ensure test harness can trigger deopt paths and reopt again 
(stale feedback vulnerabilities)

Fuzz knobs (controllable in FuzzIL or JS harness):
- Array initial type lattice: create arrays with PACKED_SMI / PACKED_DOUBLE / PACKED_ELEMENTS
- Inserted value types: Smi (small integers), HeapNumber (double), Object, undefined, null, Symbol, -0, NaN, Infinity
- Index patterns: sequential small indices, repeated writes at same index, random indices, large OOB to force resize, negative indices, ToString-keyed numeric indexes
- Holes: create holes via sparse assignment (a|1000]=x) or delete a|1]
- length manipulations: shrink length, grow length, set non-writable length (Object.defineProperty), repeated setting inside loops
- Prototype mutation: change this.__proto__, modify Array.prototype entries to introduce prototypes-provided elements
- Accessors: define getters/setters on prototype or own properties at numeric indexes
- Builtins override: shadow Array.prototype.push/pop or Symbol.iterator
- Species override: override constructor|Symbol.species] to switch allocation strategy
- TypedArray vs JS array mixing: create typed arrays and attempt operations that treat them as JS arrays
- Deopt-triggering arithmetic: use -0, NaN, large numbers to force Smi->Double transitions and deopts
- IC polymorphism: call the same function on arrays with differing elements kind and maps to grow IC polymorphism

Bug classes to target:
- Type confusion across ElementsKind boundaries (e.g., optimized load assuming Smi and reading a HeapNumber without proper tagging)
- Out-of-bounds memory access during capacity growth or copy (GrowElements/CopyElements incorrect size or missing checks)
- Incorrect hole handling: assuming packed semantics when array is holey (missing prototype fallback)
- Stale feedback / IC state: feedback vector indicates monomorphic case but underlying objects/maps changed (leading to wrong fast path being reused)
- Deopt mishandling: incorrect state after deopt or wrong frame reconstruction
- Species/prototype-based allocation mismatches (created objects with different maps expected by optimized code)
- Missing or incorrect guards in TurboFan lowering leading to optimized code that does not handle slow-path cases

Minimal seed snippet (fast-path -> flip to slow-path):
// Fast-path: monomorphic Smi-packed array, optimized expected
let a = |1,2,3,4,5];
function store(i, v) { a|i] = v; }
for (let k = 0; k < 10000; k++) store(2, k); // call many times to populate feedback/opt
%OptimizeFunctionOnNextCall(store);
store(2, 42);
// Flip to slow path: insert double then object then create hole / change prototype
a|2] = 4.2;            // SMI -> DOUBLE transition
a|3] = {x:1};          // DOUBLE -> OBJECT (PACKED_ELEMENTS) transition
delete a|1];           // make array HOLEY (hole introduced)
Object.freeze(a);      // length/structure constraints -> slow/throw paths
store(2, -0);          // use -0/NaN to exercise double/edge-case

(When run in d8 with --allow-natives-syntax the %OptimizeFunctionOnNextCall / %GetOptimizationStatus helpers can be used; in FuzzIL you would loop to reach warm-up counts instead.)

Notes for harnessing: start with the simple seed above and then systematically vary the fuzz knobs to toggle transitions; instrument for crashes, assertions, incorrect results, and deopt
traces.


Two alternates (brief):

Alternate A: Array builtin fast-paths & species/prototype edge cases
- Key files: src/builtins/array-from.cc, src/builtins/spread.cc, src/builtins/array-slice.cc, src/builtins/array-concat.cc
- Rationale: builtins implement specialized fast paths that copy/backing-store-manipulate arrays. Overriding Symbol.iterator, Array.prototype methods, or species can force switching to 
slow-paths. Knobs: iterator override, species override, accessor elements on prototype, interleaved mutation during copy (e.g. mutate source array during spread). These trigger subtle 
bugs in copying logic and elements-kind transitions.

Alternate B: TypedArray vs JS array element access and fast-paths
- Key files: src/objects/typed-array-*.cc (src/objects/typed-array.cc), src/builtins/typed-array.* and compiler lowering for typed array loads/stores
- Rationale: Typed arrays have distinct fast-path lowering and bounds semantics; mixing typed array operations, buffer detachment, or converting between typed arrays and JS arrays 
(Array.from, set) can cause incorrect lowering assumptions in JIT and IC stubs. Knobs: detachArrayBuffer at specific points, pass different typed array types, induce OOB writes via 
conversions, mix with normal arrays to grow IC polymorphism.


---

Required outputs for your manager (three parts):

### 1. Task outcome (short version):
Primary pick: Keyed array element access & elements-kind transitions (KeyedStoreIC/KeyedLoadIC + TransitionElementsKind + Grow/Copy helpers + Array builtin fast paths). This region is 
reachable from simple JS (a|i]=v, push, slice, spread) and historically prone to type/IC/elements transitions, providing many fuzzing knobs (types, holes, lengths, prototype changes, 
getters, species).

### 2. Task outcome (extremely detailed version):
(See the long detailed section above titled "Primary pick (detailed, actionable for a fuzzing sub-agent)". It contains rationale, concrete files & functions to inspect, triggering JS 
patterns, preconditions and shapes, JIT linkage, fuzz knobs, target bug classes, and a minimal seed snippet to exercise fast->slow transitions.)

### 3. Additional context (if relevant):
- Use the minimal seed to warm up ICs (many repeated calls) before attempting the transitions — that maximizes the chance of hitting optimized code paths and stale IC/feedback bugs.
- Combine prototype/iterator/builtin overrides with in-loop element mutations or length changes to create racy/odd states for the JIT assumptions.
- Instrument with flags: --trace-elements-transitions, --trace-ic, --trace-deopt, and debug builds of d8 to get richer diagnostics while fuzzing.
- Start fuzzing with JS-level variations (FuzzIL knobs above). If a crash or misbehavior is found, capture feedback-vector states / map pointers via debug helpers (%DebugPrint, 
--trace-maps) to triage the IC and map transitions involved.


JSON summary required by earlier stage (copied at top):
{
  CODE REGION: "Keyed array element access & elements-kind transitions (KeyedStoreIC/KeyedLoadIC, ElementsTransition, GrowElements/CopyElements, and Array builtin fast paths)",
  SUMMARY_OF_CODE_REGION: "This region covers the JS indexed load/store fast-paths and their slow-path transitions: the inline cache machinery that dispatches keyed loads/stores 
(KeyedLoadIC, KeyedStoreIC / StoreIC/LoadIC), the runtime and object-level logic that implements elements kinds and transitions (PACKED_SMI/DOUBLE/ELEMENTS <-> HOLEY variants), the 
grow/copy helpers (EnsureCapacity/GrowElementsCapacity/CopyElements/TransitionElementsKind), and the Array builtin fast-path implementations that rely on these invariants 
(Array.prototype.push/pop/slice/splice/concat/Array.from/spread fast paths). On the JIT side this region is lowered and reasoned about by AccessInfo/JSCreateLowering and by TurboFan 
reducers that turn JS keyed accesses and builtin calls into machine-friendly sequences. Key files touch both runtime-side C++ (objects/elements, ICs, builtins) and compiler-side 
lowering/reducers. This area has historically been fragile because it mixes: fast-path optimistic assumptions (monomorphic elements kind, in-bounds, unmodified prototype and iterator 
machinery) with runtime transitions (elements kind downgrades, hole creation, prototype or iterator override, length manipulations, species/construction overrides) and IC/feedback 
updates — all of which can cause stub replacement, deopts, or subtle type confusion if a lowering or IC stub misses a case or races with a transition.",
  REASONING: "I selected this region because it satisfies the fuzzing evaluation criteria: (a) it's reachable from plain JS and FuzzIL through very common operations (indexed stores, 
Array builtins, length mutations, push/pop, spread, Array.from), (b) it's been historically prone to bugs around type/IC/elements kind (transitions between Smi/Double/Object, packed vs 
holey, out-of-bounds growth, species/prototype edge cases, stale feedback vectors and deopts). It offers multiple JS-controllable knobs (types inserted, holes, lengths, OOB indices, 
prototype changes, getters/setters, builtins being overridden) and has explicit both fast and slow paths in the VM and JIT, making it high-value for fuzzing that targets JIT correctness 
and type-confusion classes."
}


If you want, I can immediately produce an initial FuzzIL template using the seed and knobs above (example FuzzIL program and a guided mutational plan to toggle elements-kinds and IC 
polymorphism).
[Step 1: Duration 163.53 seconds| Input tokens: 2,948 | Output tokens: 1,791]
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ Step 2 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'search_knowledge_base' with arguments: {'query': 'V8 KeyedStoreIC KeyedLoadIC file paths and implementations', 'top_k': 5, 'topic_filter': 'v8'}                        │
╰────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
Observations: |
  {
    "topic": "V8 JavaScript Engine",
    "file": "v8/v8.dev/blog/hash-code.txt",
    "similarity": 0.461,
    "content_preview": "Topic: V8 JavaScript Engine\nFile: v8/v8.dev/blog/hash-code.txt\n\nOptimizing hash tables: hiding the hash code \u00b7 V8 V8 Show navigation Home Blog Docs Tools 
JS/Wasm features Research Optimizing hash tables: hiding the hash code Published 29 January 2018 \u00b7 Tagged with internals ECMAScript 2015 introduced several new data structures such 
as Map, Set, WeakSet, and WeakMap, all of which use hash tables under the hood. This post details the recent improvements in how V8 v6.3+ stores the keys in hash tables. Hash code # A 
hash function is used to map a given key to a location in the hash table. A hash code is the result of running this hash function over a given key. In V8, the hash code is just a random 
number, independent of the object value. Therefore, we can\u2019t recompute it, meaning we must store it. For JavaScript objects that were used as keys, previously, the hash code was 
stored as a private symbol on the object. A private symbol in V8 is similar to a Symbol , except that it\u2019s not enumerable and doesn\u2019t leak to userspace JavaScript. function 
GetObjectHash ( key ) { let hash = key | hashCodeSymbol ] ; if ( IS_UNDEFINED ( hash ) ) { hash = ( MathRandom ( ) * 0x40000000 ) | 0 ; if ( hash === 0 ) hash = 1 ; key | hashCodeSymbol 
] = hash ; } return hash ; } This worked well because we didn\u2019t have to reserve memory for a hash code field until the object was added to a hash table, at which point a new private
symbol was stored on the object. V8 could also optimize the hash code symbol lookup just like any other property lookup using the IC system, providing very fast lookups for the hash 
code. This works well for monomorphic IC lookups , when the keys have the same hidden class . However, most real-world code doesn\u2019t follow this pattern, and often keys have 
different hidden classes, leading to slow megamorphic IC lookups of the hash code. Another problem with the private symbol approach was that it triggered a hidden class transition in the
key on storing the hash code. This resulted in poor polymorphic code not just for the hash code lookup but also for other property lookups on the key and deoptimization from optimized 
code. JavaScript object backing stores # A JavaScript object ( JSObject ) in V8 uses two words (apart from its header): one word for storing a pointer to the elements backing store, and 
another word for storing a pointer to the properties backing store. The elements backing store is used for storing properties that look like array indices , whereas the properties 
backing store is used for storing properties whose keys are strings or symbols. See this V8 blog post by Camillo Bruni for more information about these backing stores. const x = { } ; x 
| 1 ] = 'bar' ; // \u2190 stored in elements x | 'foo' ] = 'bar' ; // \u2190 stored in properties Hiding the hash code # The easiest solution to storing the hash code would be to extend 
the size of a JavaScript object by one word and store the hash code directly on the object. However, this would waste memory for objects that aren\u2019t added to a hash table. Instead, 
we could try to store the hash code in the elements store or properties store. The elements backing store is an array containing its length and all the elements. There\u2019s not much to
be done here, as storing the hashcode in a reserved slot (like the 0th index) would still waste memory when we don\u2019t use the object as a key in a hash table. Let\u2019s look at the 
properties backing store. There are two kinds of data structures used as a properties backing store: arrays and dictionaries. Unlike the array used in the elements backing store which 
does not have an upper limit, the array used in the properties backing store has an upper limit of 1022 values. V8 transitions to using a dictionary on exceeding this limit for 
performance reasons. (I\u2019m slightly simplifying this \u2014 V8 can also use a dictionary in other cases, but there is a fixed upper limit on the number of values that can be stored 
in the array.) So, there are three possible states for the properties backing store: empty (no properties) array (can store up to 1022 values) dictionary Let\u2019s discuss each of 
these. The properties backing store is empty # For the empty case, we can directly store the hash code in this offset on the JSObject . The properties backing store is an array # V8 
represents integers less than 2 31 (on 32-bit systems) unboxed, as Smi s. In a Smi, the least significant bit is a tag used to distinguish it from pointers, while the remaining 31 bits 
hold the actual integer value. Normally, arrays store their length as a Smi. Since we know that the maximum capacity of this array is only 1022, we only need 10 bits to store the length.
We can use the remaining 21 bits to store the hash code! The properties backing store is a dictionary # For the dictionary case, we increase the dictionary size by 1 word to store the 
hashcode in a dedicated slot at the beginning of the dictionary. We get away with potentially wasting a word of memory in this case, because the proportional increase in size isn\u2019t 
as big as in the array case. With these changes, the hash code lookup no longer has to go through the complex JavaScript property lookup machinery. Performance improvements # The 
SixSpeed benchmark tracks the performance of Map and Set, and these changes resulted in a ~500% improvement. This change caused a 5% improvement on the Basic benchmark in ARES6 as well. 
This also resulted in an 18% improvement in one of the benchmarks in the Emberperf benchmark suite that tests Ember.js. Posted by Sathya Gunasekaran , keeper of hash codes. Retweet this 
article! Branding Terms Privacy Twitter Edit this page on GitHub Except as otherwise noted, any code samples from the V8 project are licensed under V8\u2019s BSD-style license . Other 
content on this page is licensed under the Creative Commons Attribution 3.0 License . For details, see our site policies ."
  },
  {
    "topic": "V8 JavaScript Engine",
    "file": "v8/v8.dev/docs/ignition.txt",
    "similarity": 0.437,
    "content_preview": "Topic: V8 JavaScript Engine\nFile: v8/v8.dev/docs/ignition.txt\n\nIgnition \u00b7 V8 V8 Show navigation Home Blog Docs Tools JS/Wasm features Research Ignition V8
features an interpreter called Ignition. Ignition is a fast low-level register-based interpreter written using the backend of TurboFan . The V8 blog post presents a high-level overview 
of the Ignition interpreter. More details can be found in the following resources: Talks # V8: Hooking up the Ignition to the Turbofan Ignition: jump-starting an interpreter for V8 
Ignition: an interpreter for V8 ( video ) Articles # Understanding V8\u2019s bytecode Design Docs # Ignition design document Register equivalence optimization Branding Terms Privacy 
Twitter Edit this page on GitHub Except as otherwise noted, any code samples from the V8 project are licensed under V8\u2019s BSD-style license . Other content on this page is licensed 
under the Creative Commons Attribution 3.0 License . For details, see our site policies ."
  },
  {
    "topic": "V8 JavaScript Engine",
    "file": "v8/v8.dev/features/simd.txt",
    "similarity": 0.437,
    "content_preview": "Topic: V8 JavaScript Engine\nFile: v8/v8.dev/features/simd.txt\n\nFast, parallel applications with WebAssembly SIMD \u00b7 V8 V8 Show navigation Home Blog Docs 
Tools JS/Wasm features Research Fast, parallel applications with WebAssembly SIMD Published 30 January 2020 \u00b7 Updated 06 November 2022 \u00b7 Tagged with WebAssembly SIMD stands for
Single Instruction, Multiple Data . SIMD instructions are a special class of instructions that exploit data parallelism in applications by simultaneously performing the same operation on
multiple data elements. Compute intensive applications like audio/video codecs, image processors, are all examples of applications that take advantage of SIMD instructions to accelerate 
performance. Most modern architectures support some variants of SIMD instructions. The WebAssembly SIMD proposal defines a portable, performant subset of SIMD operations that are 
available across most modern architectures. This proposal derived many elements from the SIMD.js proposal , which in turn was originally derived from the Dart SIMD specification. The 
SIMD.js proposal was an API proposed at TC39 with new types and functions for performing SIMD computations, but this was archived in favor of supporting SIMD operations more 
transparently in WebAssembly. The WebAssembly SIMD proposal was introduced as a way for browsers to take advantage of the data level parallelism using the underlying hardware. 
WebAssembly SIMD proposal # The high-level goal of the WebAssembly SIMD proposal is to introduce vector operations to the WebAssembly Specification, in a way that guarantees portable 
performance. The set of SIMD instructions is large, and varied across architectures. The set of operations included in the WebAssembly SIMD proposal consist of operations that are well 
supported on a wide variety of platforms, and are proven to be performant. To this end, the current proposal is limited to standardizing Fixed-Width 128-bit SIMD operations. The current 
proposal introduces a new v128 value type, and a number of new operations that operate on this type. The criteria used to determine these operations are: The operations should be well 
supported across multiple modern architectures. Performance wins should be positive across multiple relevant architectures within an instruction group. The chosen set of operations 
should minimize performance cliffs if any. The proposal is now in finalized state (phase 4) , both V8 and the toolchain have working implementations. Enabling SIMD support # Feature 
detection # First of all, note that SIMD is a new feature and isn't yet available in all browsers with WebAssembly support. You can find which browsers support new WebAssembly features 
on the webassembly.org website. To ensure that all users can load your application, you'll need to build two different versions - one with SIMD enabled and one without it - and load the 
corresponding version depending on feature detection results. To detect SIMD at runtime, you can use wasm-feature-detect library and load the corresponding module like this: import { 
simd } from 'wasm-feature-detect' ; ( async ( ) => { const hasSIMD = await simd ( ) ; const module = await ( hasSIMD ? import ( './module-with-simd.js' ) : import ( 
'./module-without-simd.js' ) ) ; // \u2026now use `module` as you normally would } ) ( ) ; To learn about building code with SIMD support, check the section below . SIMD support in 
browsers # WebAssembly SIMD support is available by default from Chrome 91. Make sure to use the latest version of the toolchain as detailed below, as well as latest wasm-feature-detect 
to detect engines that support the final version of the spec. If something doesn\u2019t look right, please file a bug . WebAssembly SIMD is also supported in Firefox 89 and above. 
Building with SIMD support # Building C / C++ to target SIMD # WebAssembly\u2019s SIMD support depends on using a recent build of clang with the WebAssembly LLVM backend enabled. 
Emscripten has support for the WebAssembly SIMD proposal as well. Install and activate the latest distribution of emscripten using emsdk to use the SIMD features. ./emsdk install latest 
./emsdk activate latest There are a couple of different ways to enable generating SIMD code when porting your application to use SIMD. Once the latest upstream emscripten version has 
been installed, compile using emscripten, and pass the -msimd128 flag to enable SIMD. emcc -msimd128 -O3 foo.c -o foo.js Applications that have already been ported to use WebAssembly may
benefit from SIMD with no source modifications thanks to LLVM\u2019s autovectorization optimizations. These optimizations can automatically transform loops that perform arithmetic 
operations on each iteration into equivalent loops that perform the same arithmetic operations on multiple inputs at a time using SIMD instructions. LLVM\u2019s autovectorizers are 
enabled by default at optimization levels -O2 and -O3 when the -msimd128 flag is supplied. For example, consider the following function that multiplies the elements of two input arrays 
together and stores the results in an output array. void multiply_arrays ( int * out , int * in_a , int * in_b , int size ) { for ( int i = 0 ; i < size ; i ++ ) { out | i ] = in_a | i ]
* in_b | i ] ; } } Without passing the -msimd128 flag, the compiler emits this WebAssembly loop: ( loop ( i32 . store \u2026 get address in `out` \u2026 ( i32 . mul ( i32 . load \u2026 
get address in `in_a` \u2026 ) ( i32 . load \u2026 get address in `in_b` \u2026 ) \u2026 ) But when the -msimd128 flag is used, the autovectorizer turns this into code that includes the 
following loop: ( loop ( v128.store align = 4 \u2026 get address in `out` \u2026 ( i32x4.mul ( v128.load align = 4 \u2026 get address in `in_a` \u2026 ) ( v128.load align = 4 \u2026 get 
address in `in_b` \u2026 ) \u2026 ) ) The loop body has the same structure but SIMD instructions are being used to load, multiply, and store four elements at a time inside the loop body.
For finer grained control over the SIMD instructions generated by the compiler, include the wasm_simd128.h header file , which defines a set of intrinsics. Intrinsics are special 
functions that, when called, will be turned by the compiler into the corresponding WebAssembly SIMD instructions, unless it can make further optimizations. As an example, here is the 
same function from before manually rewritten to use the SIMD intrinsics. # include <wasm_simd128.h> void multiply_arrays ( int * out , int * in_a , int * in_b , int size ) { for ( int i 
= 0 ; i < size ; i += 4 ) { v128_t a = wasm_v128_load ( & in_a | i ] ) ; v128_t b = wasm_v128_load ( & in_b | i ] ) ; v128_t prod = wasm_i32x4_mul ( a , b ) ; wasm_v128_store ( & out | i
] , prod ) ; } } This manually rewritten code assumes that the input and output arrays are aligned and do not alias and that size is a multiple of four. The autovectorizer cannot make 
these assumptions and has to generate extra code to handle the cases where they are not true, so hand-written SIMD code often ends up being smaller than autovectorized SIMD code. 
Cross-compiling existing C / C++ projects # Many existing projects already support SIMD when targeting other platforms, in particular SSE and AVX instructions on x86 / x86-64 platforms 
and NEON instructions on ARM platforms. There are two ways those are usually implemented. First one is via assembly files that take care of SIMD operations and are linked together with C
/ C++ during the build process. The assembly syntax and instructions are highly platform-dependant and not portable, so, to make use of SIMD, such projects need to add WebAssembly as an 
additional supported target and reimplement corresponding functions using either WebAssembly text format or intrinsics described above . Another common approach is to use SSE / SSE2 / 
AVX / NEON intrinsics directly from C / C++ code and here Emscripten can help. Emscripten provides compatible headers and an emulation layer for all those instruction sets, and an 
emulation layer that compiles them directly to Wasm intrinsics where possible, or scalarized code otherwise. To cross-compile such projects, first enable SIMD via project-specific 
configuration flags, e.g. ./configure --enable-simd so that it passes -msse , -msse2 , -mavx or -mfpu=neon to the compiler and calls corresponding intrinsics. Then, additionally pass 
-msimd128 to enable WebAssembly SIMD too either by using CFLAGS=-msimd128 make \u2026 / CXXFLAGS=\"-msimd128 make \u2026 or by modifying the build config directly when targeting Wasm. 
Building Rust to target SIMD # When compiling Rust code to target WebAssembly SIMD, you'll need to enable the same simd128 LLVM feature as in Emscripten above. If you can control rustc 
flags directly or via environment variable RUSTFLAGS , pass -C target-feature=+simd128 : rustc \u2026 -C target-feature = +simd128 -o out.wasm or RUSTFLAGS = \"-C 
target-feature=+simd128\" cargo build Like in Clang / Emscripten, LLVM\u2019s autovectorizers are enabled by default for optimized code when simd128 feature is enabled. For example, Rust
equivalent of the multiply_arrays example above pub fn multiply_arrays ( out : & mut | i32 ] , in_a : & | i32 ] , in_b : & | i32 ] ) { in_a . iter ( ) . zip ( in_b ) . zip ( out ) . 
for_each ( | ( ( a , b ) , dst ) | { * dst = a * b ; } ) ; } would produce similar autovectorized code for the aligned part of the inputs. In order to have manual control over the SIMD 
operations, you can use the nightly toolchain, enable Rust feature wasm_simd and invoke the intrinsics from the std::arch::wasm32 namespace directly: #!|feature(wasm_simd)] use std :: 
arch :: wasm32 :: * ; pub unsafe fn multiply_arrays ( out : & mut | i32 ] , in_a : & | i32 ] , in_b : & | i32 ] ) { in_a . chunks ( 4 ) . zip ( in_b . chunks ( 4 ) ) . zip ( out . 
chunks_mut ( 4 ) ) . for_each ( | ( ( a , b ) , dst ) | { let a = v128_load ( a . as_ptr ( ) as * const v128 ) ; let b = v128_load ( b . as_ptr ( ) as * const v128 ) ; let prod = 
i32x4_mul ( a , b ) ; v128_store ( dst . as_mut_ptr ( ) as * mut v128 , prod ) ; } ) ; } Alternatively, use a helper crate like packed_simd that abstracts over SIMD implementations on 
various platforms. Compelling use cases # The WebAssembly SIMD proposal seeks to accelerate high compute applications like audio/video codecs, image processing applications, 
cryptographic applications, etc. Currently WebAssembly SIMD is experimentally supported in widely used open source projects like Halide , OpenCV.js , and XNNPACK . Some interesting demos
come from the MediaPipe project by the Google Research team. As per their description, MediaPipe is a framework for building multimodal (eg. video, audio, any time series data) applied 
ML pipelines. And they have a Web version , too! One of the most visually appealing demos where it\u2019s easy to observe the difference in performance SIMD makes, is a CPU-only 
(non-GPU) build of a hand-tracking system. Without SIMD , you can get only around 14-15 FPS (frames per second) on a modern laptop, while with SIMD enabled in Chrome Canary you get a 
much smoother experience at 38-40 FPS. Another interesting set of demos that makes use of SIMD for smooth experience, come from OpenCV - a popular computer vision library that can also 
be compiled to WebAssembly. They\u2019re available by link , or you can check out the pre-recorded versions below: Card reading Invisibility cloak Emoji replacement Future work # The 
current fixed-width SIMD proposal is in Phase 4 , so it's considered complete. Some explorations of future SIMD extensions have started in Relaxed SIMD and Flexible Vectors proposals, 
which, at the moment of writing, are in Phase 1. Posted by Deepti Gandluri ( @dptig ), Thomas Lively ( @tlively52 ), Ingvar Stepanyan ( @RReverser ). Retweet this article! Branding Terms
Privacy Twitter Edit this page on GitHub Except as otherwise noted, any code samples from the V8 project are licensed under V8\u2019s BSD-style license . Other content on this page is 
licensed under the Creative Commons Attribution 3.0 License . For details, see our site policies ."
  },
  {
    "topic": "V8 JavaScript Engine",
    "file": "v8/v8.dev/blog/lazy-deserialization.txt",
    "similarity": 0.435,
    "content_preview": "Topic: V8 JavaScript Engine\nFile: v8/v8.dev/blog/lazy-deserialization.txt\n\nLazy deserialization \u00b7 V8 V8 Show navigation Home Blog Docs Tools JS/Wasm 
features Research Lazy deserialization Published 12 February 2018 \u00b7 Tagged with internals TL;DR: Lazy deserialization was recently enabled by default in V8 v6.4 , reducing V8\u2019s
memory consumption by over 500 KB per browser tab on average. Read on to find out more! Introducing V8 snapshots # But first, let\u2019s take a step back and have a look at how V8 uses 
heap snapshots to speed up creation of new Isolates (which roughly correspond to a browser tab in Chrome). My colleague Yang Guo gave a good introduction on that front in his article on 
custom startup snapshots : The JavaScript specification includes a lot of built-in functionality, from math functions to a full-featured regular expression engine. Every newly-created V8
context has these functions available from the start. For this to work, the global object (for example, the window object in a browser) and all the built-in functionality must be set up 
and initialized into V8\u2019s heap at the time the context is created. It takes quite some time to do this from scratch. Fortunately, V8 uses a shortcut to speed things up: just like 
thawing a frozen pizza for a quick dinner, we deserialize a previously-prepared snapshot directly into the heap to get an initialized context. On a regular desktop computer, this can 
bring the time to create a context from 40 ms down to less than 2 ms. On an average mobile phone, this could mean a difference between 270 ms and 10 ms. To recap: snapshots are critical 
for startup performance, and they are deserialized to create the initial state of V8\u2019s heap for each Isolate. The size of the snapshot thus determines the minimum size of the V8 
heap, and larger snapshots translate directly into higher memory consumption for each Isolate. A snapshot contains everything needed to fully initialize a new Isolate, including language
constants (e.g., the undefined value), internal bytecode handlers used by the interpreter, built-in objects (e.g., String ), and the functions installed on built-in objects (e.g., 
String.prototype.replace ) together with their executable Code objects. Startup snapshot size in bytes from 2016-01 to 2017-09. The x-axis shows V8 revision numbers. Over the past two 
years, the snapshot has nearly tripled in size, going from roughly 600 KB in early 2016 to over 1500 KB today. The vast majority of this increase comes from serialized Code objects, 
which have both increased in count (e.g., through recent additions to the JavaScript language as the language specification evolves and grows); and in size (built-ins generated by the 
new CodeStubAssembler pipeline ship as native code vs. the more compact bytecode or minimized JS formats). This is bad news, since we\u2019d like to keep memory consumption as low as 
possible. Lazy deserialization # One of the major pain points was that we used to copy the entire content of the snapshot into each Isolate. Doing so was especially wasteful for built-in
functions, which were all loaded unconditionally but may never have ended up being used. This is where lazy deserialization comes in. The concept is quite simple: what if we were to only
deserialize built-in functions just before they were called? A quick investigation of some of the most popular websites showed this approach to be quite attractive: on average, only 30% 
of all built-in functions were used, with some sites only using 16%. This looked remarkably promising, given that most of these sites are heavy JS users and these numbers can thus be 
seen as a (fuzzy) lower bound of potential memory savings for the web in general. As we began working on this direction, it turned out that lazy deserialization integrated very well with
V8\u2019s architecture and there were only a few, mostly non-invasive design changes necessary to get up and running: Well-known positions within the snapshot. Prior to lazy 
deserialization, the order of objects within the serialized snapshot was irrelevant since we\u2019d only ever deserialize the entire heap at once. Lazy deserialization must be able to 
deserialize any given built-in function on its own, and therefore has to know where it is located within the snapshot. Deserialization of single objects. V8\u2019s snapshots were 
initially designed for full heap deserialization, and bolting on support for single-object deserialization required dealing with a few quirks such as non-contiguous snapshot layout 
(serialized data for one object could be interspersed with data for other objects) and so-called backreferences (which can directly reference objects previously deserialized within the 
current run). The lazy deserialization mechanism itself. At runtime, the lazy deserialization handler must be able to a) determine which code object to deserialize, b) perform the actual
deserialization, and c) attach the serialized code object to all relevant functions. Our solution to the first two points was to add a new dedicated built-ins area to the snapshot, which
may only contain serialized code objects. Serialization occurs in a well-defined order and the starting offset of each Code object is kept in a dedicated section within the built-ins 
snapshot area. Both back-references and interspersed object data are disallowed. Lazy built-in deserialization is handled by the aptly named DeserializeLazy built-in , which is installed
on all lazy built-in functions at deserialization time. When called at runtime, it deserializes the relevant Code object and finally installs it on both the JSFunction (representing the 
function object) and the SharedFunctionInfo (shared between functions created from the same function literal). Each built-in function is deserialized at most once. In addition to 
built-in functions, we have also implemented lazy deserialization for bytecode handlers . Bytecode handlers are code objects that contain the logic to execute each bytecode within 
V8\u2019s Ignition interpreter. Unlike built-ins, they neither have an attached JSFunction nor a SharedFunctionInfo . Instead, their code objects are stored directly in the dispatch 
table into which the interpreter indexes when dispatching to the next bytecode handler. Lazy deserialization is similar as to built-ins: the DeserializeLazy handler determines which 
handler to deserialize by inspecting the bytecode array, deserializes the code object, and finally stores the deserialized handler in the dispatch table. Again, each handler is 
deserialized at most once. Results # We evaluated memory savings by loading the top 1000 most popular websites using Chrome 65 on an Android device, with and without lazy 
deserialization. On average, V8\u2019s heap size decreased by 540 KB, with 25% of the tested sites saving more than 620 KB, 50% saving more than 540 KB, and 75% saving more than 420 KB. 
Runtime performance (measured on standard JS benchmarks such as Speedometer, as well as a wide selection of popular websites) has remained unaffected by lazy deserialization. Next steps 
# Lazy deserialization ensures that each Isolate only loads the built-in code objects that are actually used. That is already a big win, but we believe it is possible to go one step 
further and reduce the (built-in-related) cost of each Isolate to effectively zero. We hope to bring you updates on this front later this year. Stay tuned! Posted by Jakob Gruber ( 
@schuay ). Retweet this article! Branding Terms Privacy Twitter Edit this page on GitHub Except as otherwise noted, any code samples from the V8 project are licensed under V8\u2019s 
BSD-style license . Other content on this page is licensed under the Creative Commons Attribution 3.0 License . For details, see our site policies ."
  },
  {
    "topic": "V8 JavaScript Engine",
    "file": "v8/v8.dev/blog/tags/security.txt",
    "similarity": 0.435,
    "content_preview": "Topic: V8 JavaScript Engine\nFile: v8/v8.dev/blog/tags/security.txt\n\nBlog posts tagged \u201csecurity\u201d \u00b7 V8 V8 Show navigation Home Blog Docs Tools 
JS/Wasm features Research Blog posts tagged \u201csecurity\u201d The V8 Sandbox 04 April 2024 security V8 is Faster and Safer than Ever! 14 December 2023 JavaScript WebAssembly security 
benchmarks Control-flow Integrity in V8 09 October 2023 security Retrofitting temporal memory safety on C++ 14 June 2022 internals memory security A year with Spectre: a V8 perspective 
23 April 2019 security Temporarily disabling escape analysis 22 September 2017 security About that hash flooding vulnerability in Node.js\u2026 11 August 2017 security Branding Terms 
Privacy Twitter Edit this page on GitHub Except as otherwise noted, any code samples from the V8 project are licensed under V8\u2019s BSD-style license . Other content on this page is 
licensed under the Creative Commons Attribution 3.0 License . For details, see our site policies ."
  }
]
[Step 2: Duration 43.31 seconds| Input tokens: 10,285 | Output tokens: 3,956]
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ Step 3 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'CodeAnalyzer' with arguments: {'task': 'Stage 1 request. Analyze the following primary code region to guide ProgramBuilder template design.\n\nPrimary region: Keyed    │
│ array element access & elements-kind transitions\n- Focus: Indexed loads/stores on JS arrays, elements-kind transitions (PACKED_SMI/DOUBLE/ELEMENTS <-> HOLEY_*), capacity             │
│ growth/copy, and Array builtin fast paths (push/pop/slice/splice/concat/from/spread) as they interact with ICs and TurboFan lowering.\n\nDeliverables:\n1) Concrete loci inventory\n   │
│ - List exact files and functions/classes to anchor analysis. Prefer current V8 paths; include Torque/CSA origins where applicable.\n   - Subsections:\n     a) Elements operations:    │
│ TransitionElementsKind, EnsureCapacity/GrowElementsCapacity, CopyElements, SetLength.\n     b) Arrays core: JSArray::SetLength and helpers, elements accessors.\n     c) Inline        │
│ caches: KeyedStoreIC/KeyedLoadIC (and StoreIC/LoadIC where relevant), stub state transitions (mono/poly/mega), generic stubs, feedback collection for keyed accesses including         │
│ elements-kind and KeyedStoreMode.\n     d) Builtins fast paths: ArrayPrototypePush/Pop/Slice/Splice/Concat/From/Spread (Torque/CSA + C++ entry points), including guards for fast      │
│ paths and switches to slow-paths (species/prototype/iterator/accessors/holes).\n     e) Compiler lowering: AccessInfo computation (AccessInfoFactory),                                 │
│ JSCreateLowering/JSNativeContextSpecialization/JSCallReducer for array builtins, JS(Load|Store)Indexed lowering, SimplifiedLowering checks on ElementsKind, bounds/hole checks.\n      │
│ f) Deopt/feedback: locations of deopt guards for elements kind and bounds; feedback vector slot kinds for keyed loads/stores; transitions that update or invalidate IC state.\n\n2)    │
│ Call graphs and invariants\n   - For each builtin (push, slice, splice, concat, from), sketch fast-path call graph and the exact conditions (maps, elements kind, holey/packed,        │
│ prototype unchanged, species default, iterator = ArrayIterator, no accessors on indices) that keep us on fast-path vs. trigger slow-path. Note the observable mutations (length, map,  │
│ elements backing store) and the expected IC feedback.\n   - For KeyedLoad/Store: enumerate handler selection based on receiver map/elements kind/index type; when do we enter elements │
│ transition/grow paths; what runtime calls occur; what map writes happen.\n\n3) Fuzzable guard catalog\n   - Produce a checklist of guards/assumptions we can toggle from JS to flip    │
│ paths: elements kind checks, in-bounds, hole checks, prototype chain cleanliness, species/constructor checks, iterator checks, length writability, extensibility, accessors on numeric │
│ indices, -0/NaN, smi->double->object transitions, large index growth.\n\n4) Risky mismatches\n   - Highlight known or plausible mismatches between IC feedback and TurboFan lowering   │
│ assumptions (e.g., stale elements kind, missing hole-mode guard, map migration while optimized code assumes stable map) and between builtin fast-path expectations and real shapes     │
│ (e.g., species/prototype swaps mid-invocation).\n\n5) Output format\n   - Provide a concise, structured summary suitable for program template planning: JSON-like blocks per component │
│ with: name, key files, key functions, fast-path guards, slow-path triggers, observable effects, fuzz knobs, and notes on deopt/feedback.\n\nSeed references from prior selection       │
│ (validate/refresh paths against current V8):\n- src/objects/elements.(cc|h) — TransitionElementsKind, EnsureCapacity/GrowElementsCapacity, CopyElements; element access helpers.\n-    │
│ src/objects/js-array.(cc|h) — JSArray::SetLength.\n- src/ic/* — ic.(cc|h), keyed-(store|load).cc, ic-compiler.cc, stub-cache.\n- src/builtins/array-*.cc or Torque/CSA sources:        │
│ src/builtins/array.tq and generated builtins.\n- src/compiler/* — AccessInfo, JSCreateLowering, JSNativeContextSpecialization, JSCallReducer, SimplifiedLowering;                      │
│ JS(Load|Store)Indexed.\n- runtime/array-*.cc or Runtime::TransitionElementsKind/GrowElements (if still present).\n\nGoal: Prepare immediately actionable, file/function-grounded       │
│ guidance for constructing FuzzIL templates targeting elements-kind transitions and keyed access ICs.'}                                                                                 │
╰────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭──────────────────────────────────────────────────────────────────────────────── New run - CodeAnalyzer ────────────────────────────────────────────────────────────────────────────────╮
│                                                                                                                                                                                        │
│ You're a helpful agent named 'CodeAnalyzer'.                                                                                                                                           │
│ You have been submitted this task by your manager.                                                                                                                                     │
│ ---                                                                                                                                                                                    │
│ Task:                                                                                                                                                                                  │
│ Stage 1 request. Analyze the following primary code region to guide ProgramBuilder template design.                                                                                    │
│                                                                                                                                                                                        │
│ Primary region: Keyed array element access & elements-kind transitions                                                                                                                 │
│ - Focus: Indexed loads/stores on JS arrays, elements-kind transitions (PACKED_SMI/DOUBLE/ELEMENTS <-> HOLEY_*), capacity growth/copy, and Array builtin fast paths                     │
│ (push/pop/slice/splice/concat/from/spread) as they interact with ICs and TurboFan lowering.                                                                                            │
│                                                                                                                                                                                        │
│ Deliverables:                                                                                                                                                                          │
│ 1) Concrete loci inventory                                                                                                                                                             │
│    - List exact files and functions/classes to anchor analysis. Prefer current V8 paths; include Torque/CSA origins where applicable.                                                  │
│    - Subsections:                                                                                                                                                                      │
│      a) Elements operations: TransitionElementsKind, EnsureCapacity/GrowElementsCapacity, CopyElements, SetLength.                                                                     │
│      b) Arrays core: JSArray::SetLength and helpers, elements accessors.                                                                                                               │
│      c) Inline caches: KeyedStoreIC/KeyedLoadIC (and StoreIC/LoadIC where relevant), stub state transitions (mono/poly/mega), generic stubs, feedback collection for keyed accesses    │
│ including elements-kind and KeyedStoreMode.                                                                                                                                            │
│      d) Builtins fast paths: ArrayPrototypePush/Pop/Slice/Splice/Concat/From/Spread (Torque/CSA + C++ entry points), including guards for fast paths and switches to slow-paths        │
│ (species/prototype/iterator/accessors/holes).                                                                                                                                          │
│      e) Compiler lowering: AccessInfo computation (AccessInfoFactory), JSCreateLowering/JSNativeContextSpecialization/JSCallReducer for array builtins, JS(Load|Store)Indexed          │
│ lowering, SimplifiedLowering checks on ElementsKind, bounds/hole checks.                                                                                                               │
│      f) Deopt/feedback: locations of deopt guards for elements kind and bounds; feedback vector slot kinds for keyed loads/stores; transitions that update or invalidate IC state.     │
│                                                                                                                                                                                        │
│ 2) Call graphs and invariants                                                                                                                                                          │
│    - For each builtin (push, slice, splice, concat, from), sketch fast-path call graph and the exact conditions (maps, elements kind, holey/packed, prototype unchanged, species       │
│ default, iterator = ArrayIterator, no accessors on indices) that keep us on fast-path vs. trigger slow-path. Note the observable mutations (length, map, elements backing store) and   │
│ the expected IC feedback.                                                                                                                                                              │
│    - For KeyedLoad/Store: enumerate handler selection based on receiver map/elements kind/index type; when do we enter elements transition/grow paths; what runtime calls occur; what  │
│ map writes happen.                                                                                                                                                                     │
│                                                                                                                                                                                        │
│ 3) Fuzzable guard catalog                                                                                                                                                              │
│    - Produce a checklist of guards/assumptions we can toggle from JS to flip paths: elements kind checks, in-bounds, hole checks, prototype chain cleanliness, species/constructor     │
│ checks, iterator checks, length writability, extensibility, accessors on numeric indices, -0/NaN, smi->double->object transitions, large index growth.                                 │
│                                                                                                                                                                                        │
│ 4) Risky mismatches                                                                                                                                                                    │
│    - Highlight known or plausible mismatches between IC feedback and TurboFan lowering assumptions (e.g., stale elements kind, missing hole-mode guard, map migration while optimized  │
│ code assumes stable map) and between builtin fast-path expectations and real shapes (e.g., species/prototype swaps mid-invocation).                                                    │
│                                                                                                                                                                                        │
│ 5) Output format                                                                                                                                                                       │
│    - Provide a concise, structured summary suitable for program template planning: JSON-like blocks per component with: name, key files, key functions, fast-path guards, slow-path    │
│ triggers, observable effects, fuzz knobs, and notes on deopt/feedback.                                                                                                                 │
│                                                                                                                                                                                        │
│ Seed references from prior selection (validate/refresh paths against current V8):                                                                                                      │
│ - src/objects/elements.(cc|h) — TransitionElementsKind, EnsureCapacity/GrowElementsCapacity, CopyElements; element access helpers.                                                     │
│ - src/objects/js-array.(cc|h) — JSArray::SetLength.                                                                                                                                    │
│ - src/ic/* — ic.(cc|h), keyed-(store|load).cc, ic-compiler.cc, stub-cache.                                                                                                             │
│ - src/builtins/array-*.cc or Torque/CSA sources: src/builtins/array.tq and generated builtins.                                                                                         │
│ - src/compiler/* — AccessInfo, JSCreateLowering, JSNativeContextSpecialization, JSCallReducer, SimplifiedLowering; JS(Load|Store)Indexed.                                              │
│ - runtime/array-*.cc or Runtime::TransitionElementsKind/GrowElements (if still present).                                                                                               │
│                                                                                                                                                                                        │
│ Goal: Prepare immediately actionable, file/function-grounded guidance for constructing FuzzIL templates targeting elements-kind transitions and keyed access ICs.                      │
│ ---                                                                                                                                                                                    │
│ You're helping your manager solve a wider task: so make sure to not provide a one-line answer, but give as much information as possible to give them a clear understanding of the      │
│ answer.                                                                                                                                                                                │
│                                                                                                                                                                                        │
│ Your final_answer WILL HAVE to contain these parts:                                                                                                                                    │
│ ### 1. Task outcome (short version):                                                                                                                                                   │
│ ### 2. Task outcome (extremely detailed version):                                                                                                                                      │
│ ### 3. Additional context (if relevant):                                                                                                                                               │
│                                                                                                                                                                                        │
│ Put all these in your final_answer tool, everything that you do not pass as an argument to final_answer will be lost.                                                                  │
│ And even if your task resolution is not successful, please return as much context as possible, so that your manager can act upon this feedback.                                        │
│                                                                                                                                                                                        │
╰─ LiteLLMModel - gpt-5 ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ Step 1 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'V8Search' with arguments: {'task': 'Stage 1 reconnaissance. Please scan current V8 main branch for the primary region: Keyed array element access & elements-kind       │
│ transitions. Goal: produce an up-to-date loci inventory with exact file paths and key functions/classes. Cover these subsections and return IDs for each relevant item so we can dive  │
│ deeper later:\n\n(a) Elements operations: TransitionElementsKind, EnsureCapacity/GrowElementsCapacity, CopyElements, SetLength, and general elements helper utilities. Include both    │
│ CSA/Torque and C++ if applicable.\n\n(b) Arrays core: JSArray::SetLength and helpers; elements accessors for JSArray/JSObject touching elements backing store, length updates, and     │
│ capacity growth.\n\n(c) Inline caches: KeyedStoreIC/KeyedLoadIC (plus StoreIC/LoadIC if they participate), IC stub state transitions (mono/poly/mega), generic stubs, feedback         │
│ collection for keyed accesses including elements-kind and KeyedStoreMode, and any Runtime/TF handlers involved.\n\n(d) Builtins fast paths:                                            │
│ ArrayPrototypePush/Pop/Slice/Splice/Concat/From/Spread – point to Torque/CSA definitions (array.tq/array-helpers.tq etc.) and generated C++ entry points or dispatch wrappers. Include │
│ fast-path guards and where they branch to slow-path.\n\n(e) Compiler lowering: AccessInfo/AccessInfoFactory, JSCreateLowering, JSNativeContextSpecialization, JSCallReducer for array  │
│ builtins, JS(Load|Store)Indexed lowering, SimplifiedLowering logic related to ElementsKind, index bounds/hole checks, and any graph builder helpers for keyed accesses.\n\n(f)         │
│ Deopt/feedback: locations of deopt guards for elements kind and bounds; feedback vector slot kinds for keyed loads/stores; transitions that update or invalidate IC state; places      │
│ where map stability is assumed/checked.\n\nPlease return a structured list of candidates with: [id, file path, symbol/function name, brief note], grouped per subsection, and prefer   │
│ most-current paths (Torque sources under src/builtins/*.tq, ICs under src/ic, elements under src/objects, compiler under src/compiler). Where names were renamed recently (e.g.,       │
│ EnsureCapacity vs GrowElementsCapacity), include both old/new. If multiple overloads exist, include the main entry and helpers.'}                                                      │
╰────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────── New run - V8Search ──────────────────────────────────────────────────────────────────────────────────╮
│                                                                                                                                                                                        │
│ You're a helpful agent named 'V8Search'.                                                                                                                                               │
│ You have been submitted this task by your manager.                                                                                                                                     │
│ ---                                                                                                                                                                                    │
│ Task:                                                                                                                                                                                  │
│ Stage 1 reconnaissance. Please scan current V8 main branch for the primary region: Keyed array element access & elements-kind transitions. Goal: produce an up-to-date loci inventory  │
│ with exact file paths and key functions/classes. Cover these subsections and return IDs for each relevant item so we can dive deeper later:                                            │
│                                                                                                                                                                                        │
│ (a) Elements operations: TransitionElementsKind, EnsureCapacity/GrowElementsCapacity, CopyElements, SetLength, and general elements helper utilities. Include both CSA/Torque and C++  │
│ if applicable.                                                                                                                                                                         │
│                                                                                                                                                                                        │
│ (b) Arrays core: JSArray::SetLength and helpers; elements accessors for JSArray/JSObject touching elements backing store, length updates, and capacity growth.                         │
│                                                                                                                                                                                        │
│ (c) Inline caches: KeyedStoreIC/KeyedLoadIC (plus StoreIC/LoadIC if they participate), IC stub state transitions (mono/poly/mega), generic stubs, feedback collection for keyed        │
│ accesses including elements-kind and KeyedStoreMode, and any Runtime/TF handlers involved.                                                                                             │
│                                                                                                                                                                                        │
│ (d) Builtins fast paths: ArrayPrototypePush/Pop/Slice/Splice/Concat/From/Spread – point to Torque/CSA definitions (array.tq/array-helpers.tq etc.) and generated C++ entry points or   │
│ dispatch wrappers. Include fast-path guards and where they branch to slow-path.                                                                                                        │
│                                                                                                                                                                                        │
│ (e) Compiler lowering: AccessInfo/AccessInfoFactory, JSCreateLowering, JSNativeContextSpecialization, JSCallReducer for array builtins, JS(Load|Store)Indexed lowering,                │
│ SimplifiedLowering logic related to ElementsKind, index bounds/hole checks, and any graph builder helpers for keyed accesses.                                                          │
│                                                                                                                                                                                        │
│ (f) Deopt/feedback: locations of deopt guards for elements kind and bounds; feedback vector slot kinds for keyed loads/stores; transitions that update or invalidate IC state; places  │
│ where map stability is assumed/checked.                                                                                                                                                │
│                                                                                                                                                                                        │
│ Please return a structured list of candidates with: [id, file path, symbol/function name, brief note\], grouped per subsection, and prefer most-current paths (Torque sources under    │
│ src/builtins/*.tq, ICs under src/ic, elements under src/objects, compiler under src/compiler). Where names were renamed recently (e.g., EnsureCapacity vs GrowElementsCapacity),       │
│ include both old/new. If multiple overloads exist, include the main entry and helpers.                                                                                                 │
│ ---                                                                                                                                                                                    │
│ You're helping your manager solve a wider task: so make sure to not provide a one-line answer, but give as much information as possible to give them a clear understanding of the      │
│ answer.                                                                                                                                                                                │
│                                                                                                                                                                                        │
│ Your final_answer WILL HAVE to contain these parts:                                                                                                                                    │
│ ### 1. Task outcome (short version):                                                                                                                                                   │
│ ### 2. Task outcome (extremely detailed version):                                                                                                                                      │
│ ### 3. Additional context (if relevant):                                                                                                                                               │
│                                                                                                                                                                                        │
│ Put all these in your final_answer tool, everything that you do not pass as an argument to final_answer will be lost.                                                                  │
│ And even if your task resolution is not successful, please return as much context as possible, so that your manager can act upon this feedback.                                        │
│                                                                                                                                                                                        │
╰─ LiteLLMModel - gpt-5-mini ────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ Step 1 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'tree' with arguments: {'options': '-L 2 src -f'}                                                                                                                        │
╰────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
Command: cd /Users/tarun/v8/v8/src && tree -L 2 src -f | head -n 1000
Observations: src  |error opening dir]

0 directories, 0 files
[Step 1: Duration 4.50 seconds| Input tokens: 2,265 | Output tokens: 92]
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ Step 2 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'fuzzy_finder' with arguments: {'pattern': 'ElementsKind', 'options': '--filter'}                                                                                        │
╰────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
Command: cd /Users/tarun/v8/v8/src && rg --hidden --no-follow --no-ignore-vcs --files 2>/dev/null | fzf --filter 'ElementsKind' | head -n 1000
Observations: None
[Step 2: Duration 3.01 seconds| Input tokens: 4,575 | Output tokens: 187]
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ Step 3 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'fuzzy_finder' with arguments: {'pattern': 'elements', 'options': '--filter'}                                                                                            │
╰────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
Command: cd /Users/tarun/v8/v8/src && rg --hidden --no-follow --no-ignore-vcs --files 2>/dev/null | fzf --filter 'elements' | head -n 1000
Observations: objects/elements.h
objects/elements.cc
objects/elements-inl.h
objects/elements-kind.h
objects/elements-kind.cc
builtins/promise-all-element-closure.tq
torque/implementation-visitor.h
torque/implementation-visitor.cc
[Step 3: Duration 2.77 seconds| Input tokens: 6,924 | Output tokens: 281]
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ Step 4 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'ripgrep' with arguments: {'pattern':                                                                                                                                    │
│ 'TransitionElementsKind|EnsureCapacity|GrowElementsCapacity|CopyElements|SetLength|JSArray::SetLength|KeyedStoreIC|KeyedLoadIC|StoreIC|LoadIC|ArrayPrototypePush|ArrayPrototypePop|Arr │
│ ayPrototypeSlice|ArrayPrototypeSplice|ArrayPrototypeConcat|ArrayPrototypeFrom|ArrayPrototypeSpread|AccessInfoFactory|JSCreateLowering|JSNativeContextSpecialization|JSCallReducer|Load │
│ Indexed|StoreIndexed|ElementsKind', 'options': ''}                                                                                                                                     │
╰────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
Command: cd /Users/tarun/v8/v8/src && rg 'TransitionElementsKind|EnsureCapacity|GrowElementsCapacity|CopyElements|SetLength|JSArray::SetLength|KeyedStoreIC|KeyedLoadIC|StoreIC|LoadIC|ArrayPrototypePush|ArrayPrototypePop|ArrayPrototypeSlice|ArrayPrototypeSplice|ArrayPrototypeConcat|ArrayPrototypeFrom|ArrayPrototypeSpread|AccessInfoFactory|JSCreateLowering|JSNativeContextSpecialization|JSCallReducer|LoadIndexed|StoreIndexed|ElementsKind' | head -n 1000
Observations: debug/debug-evaluate.cc:  V(TransitionElementsKind)              \
debug/debug-evaluate.cc:    case Builtin::kArrayPrototypeConcat:
debug/debug-evaluate.cc:    case Builtin::kArrayPrototypeSlice:
debug/debug-evaluate.cc:    case Builtin::kTypedArrayPrototypeSlice:
debug/debug-evaluate.cc:    case Builtin::kArrayPrototypePop:
debug/debug-evaluate.cc:    case Builtin::kArrayPrototypePush:
debug/debug-evaluate.cc:    case Builtin::kArrayPrototypeSplice:
debug/debug-evaluate.cc:        case Builtin::kArrayPrototypeSlice:
debug/debug-evaluate.cc:        case Builtin::kArrayPrototypeSlice:
zone/zone-containers.h:    EnsureCapacity(ilist.size());
zone/zone-containers.h:    EnsureCapacity(new_size);
zone/zone-containers.h:    EnsureCapacity(new_size);
zone/zone-containers.h:      EnsureCapacity(new_size);
zone/zone-containers.h:  void reserve(size_t new_cap) { EnsureCapacity(new_cap); }
zone/zone-containers.h:  V8_INLINE void EnsureCapacity(size_t minimum) {
debug/debug.cc:  RegExpMatchInfo::CopyElements(isolate_, *regexp_match_info_, 0,
interpreter/bytecode-generator.cc:              feedback_index(feedback_spec()->AddLoadICSlot()));
interpreter/bytecode-generator.cc:                  feedback_index(feedback_spec()->AddLoadICSlot()));
interpreter/bytecode-generator.cc:    FeedbackSlot slot = feedback_spec()->AddStoreICSlot(language_mode());
interpreter/bytecode-generator.cc:      feedback_index(feedback_spec()->AddKeyedLoadICSlot()));
interpreter/bytecode-generator.cc:  FeedbackSlot slot = feedback_spec()->AddKeyedStoreICSlot(language_mode());
interpreter/bytecode-generator.cc:  FeedbackSlot slot = feedback_spec()->AddLoadICSlot();
interpreter/bytecode-generator.cc:      feedback_index(feedback_spec()->AddLoadICSlot()));
interpreter/bytecode-generator.cc:      int length_load_slot = feedback_index(feedback_spec()->AddLoadICSlot());
interpreter/bytecode-generator.cc:      feedback_spec(), feedback_spec()->GetStoreICSlot(LanguageMode::kStrict));
interpreter/bytecode-generator.cc:      FeedbackSlot next_value_load_slot = feedback_spec()->AddLoadICSlot();
interpreter/bytecode-generator.cc:      FeedbackSlot next_done_load_slot = feedback_spec()->AddLoadICSlot();
interpreter/bytecode-generator.cc:  FeedbackSlot slot = GetCachedLoadICSlot(object_expr, name);
interpreter/bytecode-generator.cc:  FeedbackSlot slot = GetCachedStoreICSlot(object_expr, name);
interpreter/bytecode-generator.cc:                  feedback_index(feedback_spec()->AddLoadICSlot()))
interpreter/bytecode-generator.cc:        FeedbackSlot next_value_load_slot = feedback_spec()->AddLoadICSlot();
interpreter/bytecode-generator.cc:        FeedbackSlot next_done_load_slot = feedback_spec()->AddLoadICSlot();
interpreter/bytecode-generator.cc:          value, value_name, feedback_index(feedback_spec()->AddLoadICSlot()));
interpreter/bytecode-generator.cc:          value, feedback_index(feedback_spec()->AddKeyedLoadICSlot()));
interpreter/bytecode-generator.cc:      FeedbackSlot slot = feedback_spec()->AddKeyedStoreICSlot(language_mode());
interpreter/bytecode-generator.cc:      FeedbackSlot slot = feedback_spec()->AddKeyedLoadICSlot();
interpreter/bytecode-generator.cc:          feedback_index(feedback_spec()->AddLoadICSlot()));
interpreter/bytecode-generator.cc:            feedback_index(feedback_spec()->AddLoadICSlot()));
interpreter/bytecode-generator.cc:                          feedback_index(feedback_spec()->AddLoadICSlot()))
interpreter/bytecode-generator.cc:      BuildLoadKeyedProperty(obj, feedback_spec()->AddKeyedLoadICSlot());
interpreter/bytecode-generator.cc:        object, feedback_index(feedback_spec()->AddKeyedLoadICSlot()));
interpreter/bytecode-generator.cc:          feedback_index(feedback_spec()->AddKeyedLoadICSlot());
interpreter/bytecode-generator.cc:          feedback_index(GetCachedLoadICSlot(property->obj(), name)));
interpreter/bytecode-generator.cc:          object, feedback_index(feedback_spec()->AddKeyedLoadICSlot()));
interpreter/bytecode-generator.cc:      FeedbackSlot slot = GetCachedStoreICSlot(property->obj(), name);
interpreter/bytecode-generator.cc:      FeedbackSlot slot = feedback_spec()->AddKeyedStoreICSlot(language_mode());
interpreter/bytecode-generator.cc:        obj, feedback_index(feedback_spec()->AddLoadICSlot()));
interpreter/bytecode-generator.cc:                               feedback_index(feedback_spec()->AddLoadICSlot()))
interpreter/bytecode-generator.cc:          feedback_index(feedback_spec()->AddLoadICSlot());
interpreter/bytecode-generator.cc:                         feedback_index(feedback_spec()->AddLoadICSlot()))
interpreter/bytecode-generator.cc:  FeedbackSlot slot = feedback_spec()->AddLoadICSlot();
interpreter/bytecode-generator.cc:FeedbackSlot BytecodeGenerator::GetCachedLoadICSlot(const Expression* expr,
interpreter/bytecode-generator.cc:    return feedback_spec()->AddLoadICSlot();
interpreter/bytecode-generator.cc:    return feedback_spec()->AddLoadICSlot();
interpreter/bytecode-generator.cc:  slot = feedback_spec()->AddLoadICSlot();
interpreter/bytecode-generator.cc:    return feedback_spec()->AddLoadICSlot();
interpreter/bytecode-generator.cc:  slot = feedback_spec()->AddLoadICSlot();
interpreter/bytecode-generator.cc:FeedbackSlot BytecodeGenerator::GetCachedStoreICSlot(const Expression* expr,
interpreter/bytecode-generator.cc:    return feedback_spec()->AddStoreICSlot(language_mode());
interpreter/bytecode-generator.cc:    return feedback_spec()->AddStoreICSlot(language_mode());
interpreter/bytecode-generator.cc:  slot = feedback_spec()->AddStoreICSlot(language_mode());
interpreter/bytecodes.h:  /* Property loads (LoadIC) operations */                                     \
interpreter/bytecodes.h:  /* Propery stores (StoreIC) operations */                                    \
interpreter/interpreter-generator.cc:// Calls the LoadIC at FeedBackVector slot <slot> for <object> and the name at
interpreter/interpreter-generator.cc:  AccessorAssembler::LazyLoadICParameters params(lazy_context, recv, lazy_name,
interpreter/interpreter-generator.cc:  accessor_asm.LoadIC_BytecodeHandler(&params, &exit_point);
interpreter/interpreter-generator.cc:// Calls the KeyedLoadIC at FeedBackVector slot <slot> for <object> and the key
interpreter/interpreter-generator.cc:  var_result = CallBuiltin(Builtin::kKeyedLoadIC, context, object, name, slot,
interpreter/interpreter-generator.cc:// Calls the EnumeratedKeyedLoadIC at FeedBackVector slot <slot> for <object>
interpreter/interpreter-generator.cc:  var_result = CallBuiltin(Builtin::kEnumeratedKeyedLoadIC, context, object,
interpreter/interpreter-generator.cc:// Calls the StoreIC at FeedBackVector slot <slot> for <object> and
interpreter/interpreter-generator.cc:  // StoreIC is currently a base class for multiple property store operations
interpreter/interpreter-generator.cc:  // TODO(v8:12548): refactor SetNamedIC as a subclass of StoreIC, which can be
interpreter/interpreter-generator.cc:  SetNamedProperty(Builtin::kStoreIC, NamedPropertyType::kNotOwn);
interpreter/interpreter-generator.cc:// Calls the KeyedStoreIC at FeedbackVector slot <slot> for <object> and
interpreter/interpreter-generator.cc:  // KeyedStoreIC is currently a base class for multiple keyed property store
interpreter/interpreter-generator.cc:  // TODO(v8:12548): refactor SetKeyedIC as a subclass of KeyedStoreIC, which
interpreter/interpreter-generator.cc:  TNode<Object> result = CallBuiltin(Builtin::kKeyedStoreIC, context, object,
interpreter/interpreter-generator.cc:    TNode<Map> array_map = LoadJSArrayElementsMap(GetInitialFastElementsKind(),
interpreter/interpreter-generator.cc:    result = AllocateJSArray(GetInitialFastElementsKind(), array_map, capacity,
regexp/regexp-macro-assembler.cc:  Address new_stack_base = regexp_stack->EnsureCapacity(old_size * 2);
roots/roots.h:enum ElementsKind : uint8_t;
regexp/regexp-stack.h:  Address EnsureCapacity(size_t size);
regexp/regexp-stack.cc:    EnsureCapacity(thread_local_.memory_size_ + 1);
regexp/regexp-stack.cc:Address RegExpStack::EnsureCapacity(size_t size) {
interpreter/bytecode-generator.h:  FeedbackSlot GetCachedLoadICSlot(const Expression* expr,
interpreter/bytecode-generator.h:  FeedbackSlot GetCachedStoreICSlot(const Expression* expr,
init/bootstrapper.cc:  FixedArray::CopyElements(isolate, *new_array, 0, cache_, 0, cache_->length());
init/bootstrapper.cc:                                       ElementsKind elements_kind,
init/bootstrapper.cc:  ElementsKind elements_kind;
init/bootstrapper.cc:  ElementsKind kind = current_map->elements_kind();
init/bootstrapper.cc:  DCHECK_EQ(GetInitialFastElementsKind(), kind);
init/bootstrapper.cc:  for (int i = GetSequenceIndexFromFastElementsKind(kind) + 1;
init/bootstrapper.cc:       i < kFastElementsKindCount; ++i) {
init/bootstrapper.cc:    ElementsKind next_kind = GetFastElementsKindFromSequenceIndex(i);
init/bootstrapper.cc:      new_map = Map::CopyAsElementsKind(isolate, current_map, next_kind,
init/bootstrapper.cc:  DCHECK_EQ(global_object_from_snapshot->GetElementsKind(),
init/bootstrapper.cc:            global_object->GetElementsKind());
init/bootstrapper.cc:    DCHECK(initial_map->elements_kind() == GetInitialFastElementsKind());
init/bootstrapper.cc:                          Builtin::kArrayPrototypeConcat, 1, kDontAdapt);
init/bootstrapper.cc:    SimpleInstallFunction(isolate_, proto, "pop", Builtin::kArrayPrototypePop,
init/bootstrapper.cc:    SimpleInstallFunction(isolate_, proto, "push", Builtin::kArrayPrototypePush,
init/bootstrapper.cc:                          Builtin::kArrayPrototypeSlice, 2, kDontAdapt);
init/bootstrapper.cc:                          Builtin::kArrayPrototypeSplice, 2, kDontAdapt);
init/bootstrapper.cc:                          Builtin::kTypedArrayPrototypeSlice, 2, kDontAdapt);
init/bootstrapper.cc:    DCHECK(IsObjectElementsKind(map->elements_kind()));
init/bootstrapper.cc:    DCHECK(IsObjectElementsKind(map->elements_kind()));
init/bootstrapper.cc:                                              ElementsKind elements_kind,
init/bootstrapper.cc:      Smi::FromInt(1 << ElementsKindToShiftSize(elements_kind)), isolate());
init/bootstrapper.cc:          GetCorrespondingRabGsabElementsKind(elements_kind), 0);
init/bootstrapper.cc:    template_map = Map::CopyAsElementsKind(isolate_, template_map,
strings/string-builder-inl.h:  EnsureCapacity(2);  // Subject slices are encoded with up to two smis.
strings/string-builder.cc:void FixedArrayBuilder::EnsureCapacity(Isolate* isolate, int elements) {
strings/string-builder.cc:    FixedArray::CopyElements(isolate, *extended_array, 0, *array_, 0, length_);
strings/string-builder.cc:void ReplacementStringBuilder::EnsureCapacity(int elements) {
strings/string-builder.cc:  array_builder_.EnsureCapacity(Isolate::FromHeap(heap_), elements);
strings/string-builder.cc:  EnsureCapacity(1);
strings/string-builder.h:  // EnsureCapacity is called.
strings/string-builder.h:  void EnsureCapacity(Isolate* isolate, int elements);
strings/string-builder.h:  void EnsureCapacity(int elements);
runtime/runtime-object.cc:      ElementsKind elements_kind = lookup_start_object->GetElementsKind();
runtime/runtime-object.cc:      if (IsDoubleElementsKind(elements_kind)) {
runtime/runtime-object.cc:          elements_kind = IsHoleyElementsKind(elements_kind) ? HOLEY_ELEMENTS
runtime/runtime-object.cc:          JSObject::TransitionElementsKind(lookup_start_object, elements_kind);
runtime/runtime-object.cc:        DCHECK(IsSmiOrObjectElementsKind(elements_kind) ||
runtime/runtime-object.cc:               !IsFastElementsKind(elements_kind));
runtime/runtime-object.cc:      IsFastPackedElementsKind(obj->map()->elements_kind()));
runtime/runtime-literals.cc:  switch (copy->GetElementsKind(isolate)) {
runtime/runtime-literals.cc:  ElementsKind constant_elements_kind =
runtime/runtime-literals.cc:  if (IsDoubleElementsKind(constant_elements_kind)) {
runtime/runtime-literals.cc:    DCHECK(IsSmiOrObjectElementsKind(constant_elements_kind));
codegen/external-reference.h:    "TypedArrayAndRabGsabTypedArrayElementsKindShifts")                        \
codegen/external-reference.h:    "TypedArrayAndRabGsabTypedArrayElementsKindSizes")                         \
codegen/external-reference.h:  // The following version is used by JSCallReducer in the compiler
objects/fixed-array.cc:int FixedArrayBase::GetMaxLengthForNewSpaceAllocation(ElementsKind kind) {
objects/fixed-array.cc:          ElementsKindToShiftSize(kind));
objects/fixed-array.cc:  CopyElements(isolate, *new_array, 0, *array, 0, old_length, mode);
codegen/arm64/macro-assembler-arm64.h:  void LoadElementsKindFromMap(Register result, Register map);
diagnostics/objects-debug.cc:        IsTransitionableFastElementsKind(map()->elements_kind());
diagnostics/objects-debug.cc:      IsJSObjectMap(*this) && !CanHaveFastTransitionableElementsKind(),
diagnostics/objects-debug.cc:      IsDictionaryElementsKind(elements_kind()) ||
diagnostics/objects-debug.cc:          IsTerminalElementsKind(elements_kind()) ||
diagnostics/objects-debug.cc:          IsAnyHoleyNonextensibleElementsKind(elements_kind()) ||
diagnostics/objects-debug.cc:          IsSharedArrayElementsKind(elements_kind()));
diagnostics/objects-debug.cc:  ElementsKind kind = holder->GetElementsKind();
diagnostics/objects-debug.cc:  if (IsSloppyArgumentsElementsKind(GetElementsKind())) {
diagnostics/objects-debug.cc:  switch (GetElementsKind()) {
snapshot/context-deserializer.cc:  void EnsureCapacity(size_t new_capacity) {
snapshot/context-deserializer.cc:    buffer.EnsureCapacity(size);
snapshot/context-deserializer.cc:    buffer.EnsureCapacity(size);
runtime/runtime-regexp.cc:    builder.EnsureCapacity(isolate, kMaxBuilderEntriesPerRegExpMatch);
logging/runtime-call-stats.h:  V(KeyedLoadIC_KeyedLoadSloppyArgumentsStub)     \
logging/runtime-call-stats.h:  V(KeyedLoadIC_LoadElementDH)                    \
logging/runtime-call-stats.h:  V(KeyedLoadIC_LoadIndexedInterceptorStub)       \
logging/runtime-call-stats.h:  V(KeyedLoadIC_LoadIndexedStringDH)              \
logging/runtime-call-stats.h:  V(KeyedLoadIC_SlowStub)                         \
logging/runtime-call-stats.h:  V(KeyedStoreIC_ElementsTransitionAndStoreStub)  \
logging/runtime-call-stats.h:  V(KeyedStoreIC_KeyedStoreSloppyArgumentsStub)   \
logging/runtime-call-stats.h:  V(KeyedStoreIC_SlowStub)                        \
logging/runtime-call-stats.h:  V(KeyedStoreIC_StoreElementStub)                \
logging/runtime-call-stats.h:  V(KeyedStoreIC_StoreFastElementStub)            \
logging/runtime-call-stats.h:  V(LoadIC_FunctionPrototypeStub)                 \
logging/runtime-call-stats.h:  V(LoadIC_HandlerCacheHit_Accessor)              \
logging/runtime-call-stats.h:  V(LoadIC_LoadAccessorDH)                        \
logging/runtime-call-stats.h:  V(LoadIC_LoadAccessorFromPrototypeDH)           \
logging/runtime-call-stats.h:  V(LoadIC_LoadApiGetterFromPrototypeDH)          \
logging/runtime-call-stats.h:  V(LoadIC_LoadCallback)                          \
logging/runtime-call-stats.h:  V(LoadIC_LoadConstantDH)                        \
logging/runtime-call-stats.h:  V(LoadIC_LoadConstantFromPrototypeDH)           \
logging/runtime-call-stats.h:  V(LoadIC_LoadFieldDH)                           \
logging/runtime-call-stats.h:  V(LoadIC_LoadFieldFromPrototypeDH)              \
logging/runtime-call-stats.h:  V(LoadIC_LoadGlobalDH)                          \
logging/runtime-call-stats.h:  V(LoadIC_LoadGlobalFromPrototypeDH)             \
logging/runtime-call-stats.h:  V(LoadIC_LoadIntegerIndexedExoticDH)            \
logging/runtime-call-stats.h:  V(LoadIC_LoadInterceptorDH)                     \
logging/runtime-call-stats.h:  V(LoadIC_LoadInterceptorFromPrototypeDH)        \
logging/runtime-call-stats.h:  V(LoadIC_LoadNativeDataPropertyDH)              \
logging/runtime-call-stats.h:  V(LoadIC_LoadNativeDataPropertyFromPrototypeDH) \
logging/runtime-call-stats.h:  V(LoadIC_LoadNonexistentDH)                     \
logging/runtime-call-stats.h:  V(LoadIC_LoadNonMaskingInterceptorDH)           \
logging/runtime-call-stats.h:  V(LoadIC_LoadNormalDH)                          \
logging/runtime-call-stats.h:  V(LoadIC_LoadNormalFromPrototypeDH)             \
logging/runtime-call-stats.h:  V(LoadIC_NonReceiver)                           \
logging/runtime-call-stats.h:  V(LoadIC_SlowStub)                              \
logging/runtime-call-stats.h:  V(LoadIC_StringLength)                          \
logging/runtime-call-stats.h:  V(LoadIC_StringWrapperLength)                   \
logging/runtime-call-stats.h:  V(StoreIC_HandlerCacheHit_Accessor)             \
logging/runtime-call-stats.h:  V(StoreIC_NonReceiver)                          \
logging/runtime-call-stats.h:  V(StoreIC_SlowStub)                             \
logging/runtime-call-stats.h:  V(StoreIC_StoreAccessorDH)                      \
logging/runtime-call-stats.h:  V(StoreIC_StoreAccessorOnPrototypeDH)           \
logging/runtime-call-stats.h:  V(StoreIC_StoreApiSetterOnPrototypeDH)          \
logging/runtime-call-stats.h:  V(StoreIC_StoreFieldDH)                         \
logging/runtime-call-stats.h:  V(StoreIC_StoreGlobalDH)                        \
logging/runtime-call-stats.h:  V(StoreIC_StoreGlobalTransitionDH)              \
logging/runtime-call-stats.h:  V(StoreIC_StoreInterceptorStub)                 \
logging/runtime-call-stats.h:  V(StoreIC_StoreNativeDataPropertyDH)            \
logging/runtime-call-stats.h:  V(StoreIC_StoreNativeDataPropertyOnPrototypeDH) \
logging/runtime-call-stats.h:  V(StoreIC_StoreNormalDH)                        \
logging/runtime-call-stats.h:  V(StoreIC_StoreTransitionDH)                    \
diagnostics/objects-printer.cc:void PrintSloppyArgumentElements(std::ostream& os, ElementsKind kind,
diagnostics/objects-printer.cc:     << ElementsKindToString(arguments_store->map()->elements_kind()) << " {";
diagnostics/objects-printer.cc:  // Don't call GetElementsKind, its validation code can cause the printer to
diagnostics/objects-printer.cc:  // Don't call GetElementsKind, its validation code can cause the printer to
diagnostics/objects-printer.cc:     << ElementsKindToString(obj->map()->elements_kind());
diagnostics/objects-printer.cc:  os << "\n - elements kind: " << ElementsKindToString(elements_kind());
diagnostics/objects-printer.cc:    ElementsKind kind = GetElementsKind();
diagnostics/objects-printer.cc:    os << "Array allocation with ElementsKind " << ElementsKindToString(kind);
diagnostics/objects-printer.cc:          os << ElementsKindToString(map->elements_kind());
diagnostics/objects-printer.cc:  os << "\n - elements kind: " << ElementsKindToString(elements_kind());
diagnostics/objects-printer.cc:    os << "(transition to " << ElementsKindToString(target->elements_kind())
diagnostics/objects-printer.cc:          os << "to " << ElementsKindToString(target->elements_kind());
runtime/runtime-array.cc:RUNTIME_FUNCTION(Runtime_TransitionElementsKind) {
runtime/runtime-array.cc:  ElementsKind to_kind = to_map->elements_kind();
runtime/runtime-array.cc:          ->TransitionElementsKind(object, to_map)
runtime/runtime-array.cc:    // TODO(victorgomes): EffectControlLinearizer::LowerTransitionElementsKind
runtime/runtime-array.cc:RUNTIME_FUNCTION(Runtime_TransitionElementsKindWithKind) {
runtime/runtime-array.cc:  ElementsKind to_kind = static_cast<ElementsKind>(args.smi_value_at(1));
runtime/runtime-array.cc:  JSObject::TransitionElementsKind(object, to_kind);
runtime/runtime-array.cc:          JSArray::SetLengthWouldNormalize(isolate->heap(), value)) {
runtime/runtime-array.cc:  ElementsKind to_kind = can_use_type_feedback ? site->GetElementsKind()
runtime/runtime-array.cc:  if (holey && !IsHoleyElementsKind(to_kind)) {
runtime/runtime-array.cc:    to_kind = GetHoleyElementsKind(to_kind);
runtime/runtime-array.cc:    if (!site.is_null()) site->SetElementsKind(to_kind);
runtime/runtime-array.cc:  initial_map = Map::AsElementsKind(isolate, initial_map, to_kind);
runtime/runtime-array.cc:  // If we don't care to track arrays of to_kind ElementsKind, then
runtime/runtime-array.cc:  ElementsKind old_kind = array->GetElementsKind();
runtime/runtime-array.cc:    if ((old_kind != array->GetElementsKind() || !can_use_type_feedback ||
runtime/runtime-array.cc:    if (old_kind != array->GetElementsKind() || !can_inline_array_constructor) {
runtime/runtime-array.cc:  ElementsKind kind = object->GetElementsKind();
runtime/runtime-array.cc:  CHECK(IsFastElementsKind(kind));
runtime/runtime-array.cc:  // element index, perform fast operation tailored to specific ElementsKinds.
runtime/runtime-array.cc:  // uint32_t, perform fast operation tailored to specific ElementsKinds.
runtime/runtime.h:  F(TransitionElementsKind, 2, 1)      \
runtime/runtime.h:  F(TransitionElementsKindWithKind, 2, 1)
runtime/runtime.h:  F(TypedArrayCopyElements, 3, 1)              \
runtime/runtime.h:  F(ElementsTransitionAndStoreIC_Miss, 6, 1) \
runtime/runtime.h:  F(KeyedLoadIC_Miss, 4, 1)                  \
runtime/runtime.h:  F(KeyedStoreIC_Miss, 5, 1)                 \
runtime/runtime.h:  F(KeyedStoreIC_Slow, 3, 1)                 \
runtime/runtime.h:  F(LoadIC_Miss, 4, 1)                       \
runtime/runtime.h:  F(StoreIC_Miss, 5, 1)                      \
runtime/runtime-internal.cc:const char* ElementsKindToType(ElementsKind fixed_elements_kind) {
runtime/runtime-internal.cc:  ElementsKind kind = map->elements_kind();
runtime/runtime-internal.cc:      isolate->factory()->NewStringFromAsciiChecked(ElementsKindToType(kind));
runtime/runtime-internal.cc:  Factory::TypeAndSizeForElementsKind(kind, &external_type, &size);
objects/string-table.h:  Data* EnsureCapacity(PtrComprCageBase cage_base, int additional_elements);
runtime/runtime-collections.cc:      OrderedHashSet::EnsureCapacityForAdding(isolate, table);
runtime/runtime-collections.cc:      OrderedHashSet::EnsureCapacityForAdding(isolate, table);
runtime/runtime-collections.cc:      OrderedHashMap::EnsureCapacityForAdding(isolate, table);
runtime/runtime-collections.cc:      OrderedHashMap::EnsureCapacityForAdding(isolate, table);
runtime/runtime-typedarray.cc:RUNTIME_FUNCTION(Runtime_TypedArrayCopyElements) {
runtime/runtime-typedarray.cc:  return accessor->CopyElements(source, target, length, 0);
runtime/runtime-typedarray.cc:  return accessor->CopyElements(source, target, length, offset);
objects/scope-info.cc:void ScopeInfo::CopyElements(Isolate* isolate, int dst_index,
objects/allocation-site-inl.h:  SetElementsKind(GetInitialFastElementsKind());
objects/allocation-site-inl.h:ElementsKind AllocationSite::GetElementsKind() const {
objects/allocation-site-inl.h:  return ElementsKindBits::decode(transition_info());
objects/allocation-site-inl.h:void AllocationSite::SetElementsKind(ElementsKind kind) {
objects/allocation-site-inl.h:  set_transition_info(ElementsKindBits::update(transition_info(), kind));
objects/allocation-site-inl.h:bool AllocationSite::ShouldTrack(ElementsKind boilerplate_elements_kind) {
objects/allocation-site-inl.h:  return IsSmiElementsKind(boilerplate_elements_kind);
objects/allocation-site-inl.h:                                              ElementsKind to_kind) {
objects/allocation-site-inl.h:    ElementsKind kind = boilerplate->GetElementsKind();
objects/allocation-site-inl.h:    if (IsHoleyElementsKind(kind)) {
objects/allocation-site-inl.h:      to_kind = GetHoleyElementsKind(to_kind);
objects/allocation-site-inl.h:    if (IsMoreGeneralElementsKindTransition(kind, to_kind)) {
objects/allocation-site-inl.h:                 is_nested ? "(nested)" : " ", ElementsKindToString(kind),
objects/allocation-site-inl.h:                 ElementsKindToString(to_kind));
objects/allocation-site-inl.h:        JSObject::TransitionElementsKind(boilerplate, to_kind);
objects/allocation-site-inl.h:    ElementsKind kind = site->GetElementsKind();
objects/allocation-site-inl.h:    if (IsHoleyElementsKind(kind)) {
objects/allocation-site-inl.h:      to_kind = GetHoleyElementsKind(to_kind);
objects/allocation-site-inl.h:    if (IsMoreGeneralElementsKindTransition(kind, to_kind)) {
objects/allocation-site-inl.h:               reinterpret_cast<void*>(site->ptr()), ElementsKindToString(kind),
objects/allocation-site-inl.h:               ElementsKindToString(to_kind));
objects/allocation-site-inl.h:      site->SetElementsKind(to_kind);
objects/js-objects-inl.h:  ElementsKind elements_kind = object->map()->elements_kind();
objects/js-objects-inl.h:  if (!IsObjectElementsKind(elements_kind)) {
objects/js-objects-inl.h:    if (IsHoleyElementsKind(elements_kind)) {
objects/js-objects-inl.h:      TransitionElementsKind(object, HOLEY_ELEMENTS);
objects/js-objects-inl.h:      TransitionElementsKind(object, PACKED_ELEMENTS);
objects/js-objects-inl.h:  ElementsKind current_kind = object->GetElementsKind();
objects/js-objects-inl.h:  ElementsKind target_kind = current_kind;
objects/js-objects-inl.h:    bool is_holey = IsHoleyElementsKind(current_kind);
objects/js-objects-inl.h:        target_kind = GetHoleyElementsKind(target_kind);
objects/js-objects-inl.h:          if (IsSmiElementsKind(target_kind)) {
objects/js-objects-inl.h:    TransitionElementsKind(object, target_kind);
objects/js-objects-inl.h:  if (object->GetElementsKind() == HOLEY_SMI_ELEMENTS) {
objects/js-objects-inl.h:    TransitionElementsKind(object, HOLEY_DOUBLE_ELEMENTS);
objects/js-objects-inl.h:  } else if (object->GetElementsKind() == PACKED_SMI_ELEMENTS) {
objects/js-objects-inl.h:        TransitionElementsKind(object, HOLEY_DOUBLE_ELEMENTS);
objects/js-objects-inl.h:    TransitionElementsKind(object, PACKED_DOUBLE_ELEMENTS);
objects/js-objects-inl.h:DEF_GETTER(JSObject, GetElementsKind, ElementsKind) {
objects/js-objects-inl.h:  ElementsKind kind = map(cage_base)->elements_kind();
objects/js-objects-inl.h:    if (IsSmiOrObjectElementsKind(kind)) {
objects/js-objects-inl.h:    } else if (IsDoubleElementsKind(kind)) {
objects/js-objects-inl.h:      CHECK(kind > DICTIONARY_ELEMENTS || IsAnyNonextensibleElementsKind(kind));
objects/js-objects-inl.h:    CHECK_IMPLIES(IsSloppyArgumentsElementsKind(kind),
objects/js-objects-inl.h:  return ElementsAccessor::ForKind(GetElementsKind(cage_base));
objects/js-objects-inl.h:  return IsObjectElementsKind(GetElementsKind(cage_base));
objects/js-objects-inl.h:  return IsSmiElementsKind(GetElementsKind(cage_base));
objects/js-objects-inl.h:  return IsSmiOrObjectElementsKind(GetElementsKind(cage_base));
objects/js-objects-inl.h:  return IsDoubleElementsKind(GetElementsKind(cage_base));
objects/js-objects-inl.h:  return IsHoleyElementsKind(GetElementsKind(cage_base));
objects/js-objects-inl.h:  return IsFastElementsKind(GetElementsKind(cage_base));
objects/js-objects-inl.h:  return IsFastPackedElementsKind(GetElementsKind(cage_base));
objects/js-objects-inl.h:  return IsDictionaryElementsKind(GetElementsKind(cage_base));
objects/js-objects-inl.h:  return GetElementsKind(cage_base) == PACKED_ELEMENTS;
objects/js-objects-inl.h:  return IsAnyNonextensibleElementsKind(GetElementsKind(cage_base));
objects/js-objects-inl.h:  return IsSealedElementsKind(GetElementsKind(cage_base));
objects/js-objects-inl.h:  return GetElementsKind(cage_base) == SHARED_ARRAY_ELEMENTS;
objects/js-objects-inl.h:  return IsNonextensibleElementsKind(GetElementsKind(cage_base));
objects/js-objects-inl.h:  return IsFastArgumentsElementsKind(GetElementsKind(cage_base));
objects/js-objects-inl.h:  return IsSlowArgumentsElementsKind(GetElementsKind(cage_base));
objects/js-objects-inl.h:  return IsSloppyArgumentsElementsKind(GetElementsKind(cage_base));
objects/js-objects-inl.h:  return IsStringWrapperElementsKind(GetElementsKind(cage_base));
objects/js-objects-inl.h:  return GetElementsKind(cage_base) == FAST_STRING_WRAPPER_ELEMENTS;
objects/js-objects-inl.h:  return GetElementsKind(cage_base) == SLOW_STRING_WRAPPER_ELEMENTS;
objects/literal-objects-inl.h:ElementsKind ArrayBoilerplateDescription::elements_kind() const {
objects/literal-objects-inl.h:  return static_cast<ElementsKind>(flags());
objects/literal-objects-inl.h:void ArrayBoilerplateDescription::set_elements_kind(ElementsKind kind) {
codegen/code-stub-assembler.cc:TNode<Word32T> CodeStubAssembler::IsStringWrapperElementsKind(TNode<Map> map) {
codegen/code-stub-assembler.cc:  TNode<Int32T> kind = LoadMapElementsKind(map);
codegen/code-stub-assembler.cc:  GotoIf(IsStringWrapperElementsKind(map), if_slow);
codegen/code-stub-assembler.cc:  CSA_DCHECK(this, Word32Or(IsFastElementsKind(LoadElementsKind(array)),
codegen/code-stub-assembler.cc:                            IsElementsKindInRange(
codegen/code-stub-assembler.cc:                                LoadElementsKind(array),
codegen/code-stub-assembler.cc:TNode<Int32T> CodeStubAssembler::LoadMapElementsKind(TNode<Map> map) {
codegen/code-stub-assembler.cc:  return Signed(DecodeWord32<Map::Bits2::ElementsKindBits>(bit_field2));
codegen/code-stub-assembler.cc:TNode<Int32T> CodeStubAssembler::LoadElementsKind(TNode<HeapObject> object) {
codegen/code-stub-assembler.cc:  return LoadMapElementsKind(LoadMap(object));
codegen/code-stub-assembler.cc:    ElementsKind elements_kind) {
codegen/code-stub-assembler.cc:    CSA_DCHECK(this, IsDictionaryElementsKind(elements_kind));
codegen/code-stub-assembler.cc:  CSA_DCHECK(this, IsFastElementsKind(kind));
codegen/code-stub-assembler.cc:    ElementsKind kind, TNode<NativeContext> native_context) {
codegen/code-stub-assembler.cc:      DecodeWord32<Map::Bits2::ElementsKindBits>(LoadMapBitField2(map));
codegen/code-stub-assembler.cc:void CodeStubAssembler::PossiblyGrowElementsCapacity(
codegen/code-stub-assembler.cc:    ElementsKind kind, TNode<HeapObject> array, TNode<BInt> length,
codegen/code-stub-assembler.cc:  *var_elements = GrowElementsCapacity(array, var_elements->value(), kind, kind,
codegen/code-stub-assembler.cc:TNode<Smi> CodeStubAssembler::BuildAppendJSArray(ElementsKind kind,
codegen/code-stub-assembler.cc:  Comment("BuildAppendJSArray: ", ElementsKindToString(kind));
codegen/code-stub-assembler.cc:  // FixedArray. In that case, PossiblyGrowElementsCapacity can fail even if no
codegen/code-stub-assembler.cc:  PossiblyGrowElementsCapacity(kind, array, var_length.value(), &var_elements,
codegen/code-stub-assembler.cc:void CodeStubAssembler::TryStoreArrayElement(ElementsKind kind, Label* bailout,
codegen/code-stub-assembler.cc:  if (IsSmiElementsKind(kind)) {
codegen/code-stub-assembler.cc:  } else if (IsDoubleElementsKind(kind)) {
codegen/code-stub-assembler.cc:  if (IsDoubleElementsKind(kind)) {
codegen/code-stub-assembler.cc:void CodeStubAssembler::BuildAppendJSArray(ElementsKind kind,
codegen/code-stub-assembler.cc:  Comment("BuildAppendJSArray: ", ElementsKindToString(kind));
codegen/code-stub-assembler.cc:  PossiblyGrowElementsCapacity(kind, array, var_length.value(), &var_elements,
codegen/code-stub-assembler.cc:  const ElementsKind elements_kind = HOLEY_ELEMENTS;
codegen/code-stub-assembler.cc:    ElementsKind kind, TNode<Map> array_map, TNode<Smi> length,
codegen/code-stub-assembler.cc:    if (IsDoubleElementsKind(kind)) {
codegen/code-stub-assembler.cc:    RootIndex elements_map_index = IsDoubleElementsKind(kind)
codegen/code-stub-assembler.cc:    ElementsKind kind, TNode<Map> array_map, TNode<IntPtrT> capacity,
codegen/code-stub-assembler.cc:  TNode<Int32T> elements_kind = LoadMapElementsKind(original_array_map);
codegen/code-stub-assembler.cc:  // Use the canonical map for the Array's ElementsKind
codegen/code-stub-assembler.cc:  TVARIABLE(Int32T, var_elements_kind, LoadMapElementsKind(LoadMap(array)));
codegen/code-stub-assembler.cc:    GotoIf(IsHoleyFastElementsKindForRead(var_elements_kind.value()),
codegen/code-stub-assembler.cc:  CSA_DCHECK(this, IsElementsKindLessThanOrEqual(
codegen/code-stub-assembler.cc:  GotoIf(IsElementsKindLessThanOrEqual(var_elements_kind.value(),
codegen/code-stub-assembler.cc:    ElementsKind kind, TNode<TIndex> capacity, AllocationFlags flags,
codegen/code-stub-assembler.cc:  const intptr_t kMaxLength = IsDoubleElementsKind(kind)
codegen/code-stub-assembler.cc:  if (IsDoubleElementsKind(kind)) flags |= AllocationFlag::kDoubleAlignment;
codegen/code-stub-assembler.cc:    RootIndex map_index = IsDoubleElementsKind(kind)
codegen/code-stub-assembler.cc:    CodeStubAssembler::AllocateFixedArray<IntPtrT>(ElementsKind, TNode<IntPtrT>,
codegen/code-stub-assembler.cc:    TNode<TIndex> capacity, TNode<Map> source_map, ElementsKind from_kind,
codegen/code-stub-assembler.cc:  if (IsDoubleElementsKind(from_kind)) {
codegen/code-stub-assembler.cc:    const ElementsKind to_kind = PACKED_ELEMENTS;
codegen/code-stub-assembler.cc:        !IsDoubleElementsKind(from_kind)) {
codegen/code-stub-assembler.cc:      // We can use CopyElements (memcpy) because we don't need to replace or
codegen/code-stub-assembler.cc:      // convert any values. Since {to_elements} is in new-space, CopyElements
codegen/code-stub-assembler.cc:      CopyElements(to_kind, to_elements, IntPtrConstant(0), source,
codegen/code-stub-assembler.cc:  const ElementsKind kind = PACKED_DOUBLE_ELEMENTS;
codegen/code-stub-assembler.cc:      ElementsKind kind = PACKED_DOUBLE_ELEMENTS;
codegen/code-stub-assembler.cc:      CopyElements(kind, to_elements, IntPtrConstant(0), source,
codegen/code-stub-assembler.cc:  ElementsKind kind = PACKED_ELEMENTS;
codegen/code-stub-assembler.cc:void CodeStubAssembler::FillFixedArrayWithValue(ElementsKind kind,
codegen/code-stub-assembler.cc:  if (IsDoubleElementsKind(kind)) {
codegen/code-stub-assembler.cc:        if (IsDoubleElementsKind(kind)) {
codegen/code-stub-assembler.cc:    CodeStubAssembler::FillFixedArrayWithValue<IntPtrT>(ElementsKind,
codegen/code-stub-assembler.cc:    ElementsKind, TNode<FixedArrayBase>, TNode<Smi>, TNode<Smi>, RootIndex);
codegen/code-stub-assembler.cc:void CodeStubAssembler::FillFixedArrayWithSmiZero(ElementsKind kind,
codegen/code-stub-assembler.cc:  DCHECK(IsSmiOrObjectElementsKind(kind));
codegen/code-stub-assembler.cc:void CodeStubAssembler::MoveElements(ElementsKind kind,
codegen/code-stub-assembler.cc:  const bool needs_barrier_check = !IsDoubleElementsKind(kind);
codegen/code-stub-assembler.cc:  DCHECK(IsFastElementsKind(kind));
codegen/code-stub-assembler.cc:      IntPtrMul(length, IntPtrConstant(ElementsKindToByteSize(kind)));
codegen/code-stub-assembler.cc:                    IntPtrConstant(ElementsKindToByteSize(kind)));
codegen/code-stub-assembler.cc:void CodeStubAssembler::CopyElements(ElementsKind kind,
codegen/code-stub-assembler.cc:  const bool needs_barrier_check = !IsDoubleElementsKind(kind);
codegen/code-stub-assembler.cc:  DCHECK(IsFastElementsKind(kind));
codegen/code-stub-assembler.cc:      IntPtrMul(length, IntPtrConstant(ElementsKindToByteSize(kind)));
codegen/code-stub-assembler.cc:                    IntPtrConstant(ElementsKindToByteSize(kind)));
codegen/code-stub-assembler.cc:    ElementsKind from_kind, TNode<FixedArrayBase> from_array,
codegen/code-stub-assembler.cc:    ElementsKind to_kind, TNode<FixedArrayBase> to_array,
codegen/code-stub-assembler.cc:  DCHECK(!IsTypedArrayElementsKind(from_kind));
codegen/code-stub-assembler.cc:  DCHECK(!IsTypedArrayElementsKind(to_kind));
codegen/code-stub-assembler.cc:  bool from_double_elements = IsDoubleElementsKind(from_kind);
codegen/code-stub-assembler.cc:  bool to_double_elements = IsDoubleElementsKind(to_kind);
codegen/code-stub-assembler.cc:      IsDoubleElementsKind(from_kind) && IsObjectElementsKind(to_kind);
codegen/code-stub-assembler.cc:      (barrier_mode == UPDATE_WRITE_BARRIER && IsObjectElementsKind(to_kind));
codegen/code-stub-assembler.cc:       IsDoubleElementsKind(from_kind) == IsDoubleElementsKind(to_kind));
codegen/code-stub-assembler.cc:    DCHECK(IsObjectElementsKind(to_kind));
codegen/code-stub-assembler.cc:    } else if (IsDoubleElementsKind(to_kind)) {
codegen/code-stub-assembler.cc:      // This case happens only when IsObjectElementsKind(to_kind).
codegen/code-stub-assembler.cc:  ElementsKind kind = PACKED_ELEMENTS;
codegen/code-stub-assembler.cc:    TNode<FixedArrayBase> array, TNode<IntPtrT> offset, ElementsKind from_kind,
codegen/code-stub-assembler.cc:    ElementsKind to_kind, Label* if_hole) {
codegen/code-stub-assembler.cc:  DCHECK(!IsDoubleElementsKind(to_kind));
codegen/code-stub-assembler.cc:  if (IsDoubleElementsKind(from_kind)) {
codegen/code-stub-assembler.cc:    TNode<FixedArrayBase> array, TNode<IntPtrT> offset, ElementsKind from_kind,
codegen/code-stub-assembler.cc:    ElementsKind to_kind, Label* if_hole) {
codegen/code-stub-assembler.cc:  DCHECK(IsDoubleElementsKind(to_kind));
codegen/code-stub-assembler.cc:  if (IsDoubleElementsKind(from_kind)) {
codegen/code-stub-assembler.cc:    if (IsSmiElementsKind(from_kind)) {
codegen/code-stub-assembler.cc:  Comment("TryGrowElementsCapacity");
codegen/code-stub-assembler.cc:TNode<FixedArrayBase> CodeStubAssembler::TryGrowElementsCapacity(
codegen/code-stub-assembler.cc:    TNode<HeapObject> object, TNode<FixedArrayBase> elements, ElementsKind kind,
codegen/code-stub-assembler.cc:  return TryGrowElementsCapacity(object, elements, kind,
codegen/code-stub-assembler.cc:TNode<FixedArrayBase> CodeStubAssembler::TryGrowElementsCapacity(
codegen/code-stub-assembler.cc:    TNode<HeapObject> object, TNode<FixedArrayBase> elements, ElementsKind kind,
codegen/code-stub-assembler.cc:  Comment("TryGrowElementsCapacity");
codegen/code-stub-assembler.cc:  return GrowElementsCapacity(object, elements, kind, kind, capacity,
codegen/code-stub-assembler.cc:TNode<FixedArrayBase> CodeStubAssembler::GrowElementsCapacity(
codegen/code-stub-assembler.cc:    ElementsKind from_kind, ElementsKind to_kind, TNode<TIndex> capacity,
codegen/code-stub-assembler.cc:  Comment("| GrowElementsCapacity");
codegen/code-stub-assembler.cc:  Comment("] GrowElementsCapacity");
codegen/code-stub-assembler.cc:template TNode<FixedArrayBase> CodeStubAssembler::GrowElementsCapacity<IntPtrT>(
codegen/code-stub-assembler.cc:    TNode<HeapObject>, TNode<FixedArrayBase>, ElementsKind, ElementsKind,
codegen/code-stub-assembler.cc:    TNode<FixedArrayBase> object, ElementsKind kind) {
codegen/code-stub-assembler.cc:                                                     ElementsKind kind) {
codegen/code-stub-assembler.cc:  if (IsDoubleElementsKind(kind)) {
codegen/code-stub-assembler.cc:    DCHECK(IsSmiOrObjectElementsKind(kind) || IsSealedElementsKind(kind) ||
codegen/code-stub-assembler.cc:           IsNonextensibleElementsKind(kind));
codegen/code-stub-assembler.cc:  return IsStringWrapperElementsKind(LoadMap(object));
codegen/code-stub-assembler.cc:  TNode<Int32T> elements_kind = LoadMapElementsKind(map);
codegen/code-stub-assembler.cc:    TNode<TIndex> index_node, ElementsKind kind, int base_size) {
codegen/code-stub-assembler.cc:  int element_size_shift = ElementsKindToShiftSize(kind);
codegen/code-stub-assembler.cc:                                               ElementsKind kind,
codegen/code-stub-assembler.cc:    TNode<TaggedIndex> index_node, ElementsKind kind, int base_size);
codegen/code-stub-assembler.cc:                                                   ElementsKind kind,
codegen/code-stub-assembler.cc:                                                 ElementsKind kind) {
codegen/code-stub-assembler.cc:  int element_size = 1 << ElementsKindToShiftSize(kind);
codegen/code-stub-assembler.cc:MachineRepresentation ElementsKindToMachineRepresentation(ElementsKind kind) {
codegen/code-stub-assembler.cc:                                                     ElementsKind kind,
codegen/code-stub-assembler.cc:                                               ElementsKind kind,
codegen/code-stub-assembler.cc:                                               ElementsKind kind,
codegen/code-stub-assembler.cc:                                                     ElementsKind kind,
codegen/code-stub-assembler.cc:  DCHECK(IsTypedArrayElementsKind(kind));
codegen/code-stub-assembler.cc:  MachineRepresentation rep = ElementsKindToMachineRepresentation(kind);
codegen/code-stub-assembler.cc:                                               ElementsKind kind,
codegen/code-stub-assembler.cc:                                               ElementsKind kind,
codegen/code-stub-assembler.cc:                                               ElementsKind kind,
codegen/code-stub-assembler.cc:  DCHECK(IsTypedArrayElementsKind(kind));
codegen/code-stub-assembler.cc:  MachineRepresentation rep = ElementsKindToMachineRepresentation(kind);
codegen/code-stub-assembler.cc:                                     ElementsKind kind, TNode<TIndex> index,
codegen/code-stub-assembler.cc:  DCHECK(!IsDoubleElementsKind(kind));
codegen/code-stub-assembler.cc:  if (IsTypedArrayElementsKind(kind)) {
codegen/code-stub-assembler.cc:  } else if (IsSmiElementsKind(kind)) {
codegen/code-stub-assembler.cc:                                     ElementsKind kind, TNode<TIndex> index,
codegen/code-stub-assembler.cc:  DCHECK(IsDoubleElementsKind(kind));
codegen/code-stub-assembler.cc:void CodeStubAssembler::StoreElement(TNode<RawPtrT> elements, ElementsKind kind,
codegen/code-stub-assembler.cc:  DCHECK(IsTypedArrayElementsKind(kind));
codegen/code-stub-assembler.cc:                                                                ElementsKind,
codegen/code-stub-assembler.cc:                                                                ElementsKind,
codegen/code-stub-assembler.cc:    TNode<RawPtrT>, ElementsKind, TNode<UintPtrT>, TNode<Float32T>);
codegen/code-stub-assembler.cc:    TNode<RawPtrT>, ElementsKind, TNode<UintPtrT>, TNode<Float64T>);
codegen/code-stub-assembler.cc:                                                                ElementsKind,
codegen/code-stub-assembler.cc:    TNode<RawPtrT>, ElementsKind, TNode<UintPtrT>, TNode<Float16RawBitsT>);
codegen/code-stub-assembler.cc:    TNode<Object> input, ElementsKind elements_kind, TNode<Context> context) {
codegen/code-stub-assembler.cc:  DCHECK(IsTypedArrayElementsKind(elements_kind));
codegen/code-stub-assembler.cc:    TNode<Object> input, ElementsKind elements_kind, TNode<Context> context) {
codegen/code-stub-assembler.cc:  DCHECK(IsTypedArrayElementsKind(elements_kind));
codegen/code-stub-assembler.cc:    TNode<Object> input, ElementsKind elements_kind, TNode<Context> context) {
codegen/code-stub-assembler.cc:  DCHECK(IsTypedArrayElementsKind(elements_kind));
codegen/code-stub-assembler.cc:    TNode<Object> input, ElementsKind elements_kind, TNode<Context> context) {
codegen/code-stub-assembler.cc:  DCHECK(IsTypedArrayElementsKind(elements_kind));
codegen/code-stub-assembler.cc:    TNode<Object> input, ElementsKind elements_kind, TNode<Context> context) {
codegen/code-stub-assembler.cc:    TNode<Object> value, ElementsKind elements_kind,
codegen/code-stub-assembler.cc:    TNode<Object> value, ElementsKind elements_kind,
codegen/code-stub-assembler.cc:    TNode<Object> value, ElementsKind elements_kind,
codegen/code-stub-assembler.cc:    TNode<Object> value, ElementsKind elements_kind,
codegen/code-stub-assembler.cc:    TNode<Object> value, ElementsKind elements_kind,
codegen/code-stub-assembler.cc:    ElementsKind elements_kind, KeyedAccessStoreMode store_mode, Label* bailout,
codegen/code-stub-assembler.cc:  if (IsRabGsabTypedArrayElementsKind(elements_kind)) {
codegen/code-stub-assembler.cc:    // ElementsKind.
codegen/code-stub-assembler.cc:    elements_kind = GetCorrespondingNonRabGsabElementsKind(elements_kind);
codegen/code-stub-assembler.cc:    ElementsKind elements_kind, KeyedAccessStoreMode store_mode, Label* bailout,
codegen/code-stub-assembler.cc:  if (!(IsSmiOrObjectElementsKind(elements_kind) ||
codegen/code-stub-assembler.cc:        IsSealedElementsKind(elements_kind) ||
codegen/code-stub-assembler.cc:        IsNonextensibleElementsKind(elements_kind))) {
codegen/code-stub-assembler.cc:  if (IsTypedArrayOrRabGsabTypedArrayElementsKind(elements_kind)) {
codegen/code-stub-assembler.cc:  DCHECK(IsFastElementsKind(elements_kind) ||
codegen/code-stub-assembler.cc:         IsSealedElementsKind(elements_kind) ||
codegen/code-stub-assembler.cc:         IsNonextensibleElementsKind(elements_kind));
codegen/code-stub-assembler.cc:  if (IsSmiElementsKind(elements_kind)) {
codegen/code-stub-assembler.cc:  } else if (IsDoubleElementsKind(elements_kind)) {
codegen/code-stub-assembler.cc:      !(IsSealedElementsKind(elements_kind) ||
codegen/code-stub-assembler.cc:        IsNonextensibleElementsKind(elements_kind))) {
codegen/code-stub-assembler.cc:  if (!(IsSmiOrObjectElementsKind(elements_kind) ||
codegen/code-stub-assembler.cc:        IsSealedElementsKind(elements_kind) ||
codegen/code-stub-assembler.cc:        IsNonextensibleElementsKind(elements_kind))) {
codegen/code-stub-assembler.cc:    elements = CopyElementsOnWrite(object, elements, elements_kind,
codegen/code-stub-assembler.cc:    TNode<JSObject> object, TNode<FixedArrayBase> elements, ElementsKind kind,
codegen/code-stub-assembler.cc:  DCHECK(IsFastElementsKind(kind));
codegen/code-stub-assembler.cc:  if (IsHoleyElementsKind(kind)) {
codegen/code-stub-assembler.cc:      TNode<FixedArrayBase> new_elements = TryGrowElementsCapacity(
codegen/code-stub-assembler.cc:TNode<FixedArrayBase> CodeStubAssembler::CopyElementsOnWrite(
codegen/code-stub-assembler.cc:    TNode<HeapObject> object, TNode<FixedArrayBase> elements, ElementsKind kind,
codegen/code-stub-assembler.cc:    TNode<FixedArrayBase> new_elements = GrowElementsCapacity(
codegen/code-stub-assembler.cc:void CodeStubAssembler::TransitionElementsKind(TNode<JSObject> object,
codegen/code-stub-assembler.cc:                                               ElementsKind from_kind,
codegen/code-stub-assembler.cc:                                               ElementsKind to_kind,
codegen/code-stub-assembler.cc:  DCHECK(!IsHoleyElementsKind(from_kind) || IsHoleyElementsKind(to_kind));
codegen/code-stub-assembler.cc:          CSA_DCHECK(this, IsFastElementsKind(LoadElementsKind(object)));
codegen/code-stub-assembler.cc:    GrowElementsCapacity(object, elements, from_kind, to_kind, array_length,
codegen/code-stub-assembler.cc:  TNode<WordT> field = UpdateWord<AllocationSite::ElementsKindBits>(
codegen/code-stub-assembler.cc:      IntPtrConstant(0), UintPtrConstant(GetInitialFastElementsKind()));
codegen/code-stub-assembler.cc:TNode<Int32T> CodeStubAssembler::LoadElementsKind(
codegen/code-stub-assembler.cc:      Signed(DecodeWord32<AllocationSite::ElementsKindBits>(
codegen/code-stub-assembler.cc:  CSA_DCHECK(this, IsFastElementsKind(elements_kind));
codegen/code-stub-assembler.cc:    ElementsKind kind, TNode<TIndex> first_element_inclusive,
codegen/code-stub-assembler.cc:  int increment = IsDoubleElementsKind(kind) ? kDoubleSize : kTaggedSize;
codegen/code-stub-assembler.cc:      ElementsKindToElementByteSize(LoadElementsKind(typed_array));
codegen/code-stub-assembler.cc:      ElementsKindToElementByteSize(LoadElementsKind(array));
codegen/code-stub-assembler.cc:      ElementsKindToElementByteSize(LoadElementsKind(array));
codegen/code-stub-assembler.cc:TNode<IntPtrT> CodeStubAssembler::ElementsKindToElementByteSize(
codegen/code-stub-assembler.cc:  const size_t kTypedElementsKindCount =
codegen/code-stub-assembler.cc:  DCHECK_EQ(kTypedElementsKindCount, arraysize(elements_kinds));
codegen/code-stub-assembler.cc:  DCHECK_EQ(kTypedElementsKindCount, arraysize(elements_kind_labels));
codegen/code-stub-assembler.cc:         kTypedElementsKindCount);
codegen/code-stub-assembler.cc:TNode<BoolT> CodeStubAssembler::IsFastElementsKind(
codegen/code-stub-assembler.cc:TNode<BoolT> CodeStubAssembler::IsFastPackedElementsKind(
codegen/code-stub-assembler.cc:  // ElementsKind values that are even are packed. See
codegen/code-stub-assembler.cc:  // internal::IsFastPackedElementsKind.
codegen/code-stub-assembler.cc:                   IsFastElementsKind(elements_kind));
codegen/code-stub-assembler.cc:TNode<BoolT> CodeStubAssembler::IsFastOrNonExtensibleOrSealedElementsKind(
codegen/code-stub-assembler.cc:TNode<BoolT> CodeStubAssembler::IsDoubleElementsKind(
codegen/code-stub-assembler.cc:TNode<BoolT> CodeStubAssembler::IsFastSmiOrTaggedElementsKind(
codegen/code-stub-assembler.cc:TNode<BoolT> CodeStubAssembler::IsFastSmiElementsKind(
codegen/code-stub-assembler.cc:TNode<BoolT> CodeStubAssembler::IsHoleyFastElementsKind(
codegen/code-stub-assembler.cc:  CSA_DCHECK(this, IsFastElementsKind(elements_kind));
codegen/code-stub-assembler.cc:TNode<BoolT> CodeStubAssembler::IsHoleyFastElementsKindForRead(
codegen/code-stub-assembler.cc:TNode<BoolT> CodeStubAssembler::IsElementsKindGreaterThan(
codegen/code-stub-assembler.cc:    TNode<Int32T> target_kind, ElementsKind reference_kind) {
codegen/code-stub-assembler.cc:TNode<BoolT> CodeStubAssembler::IsElementsKindGreaterThanOrEqual(
codegen/code-stub-assembler.cc:    TNode<Int32T> target_kind, ElementsKind reference_kind) {
codegen/code-stub-assembler.cc:TNode<BoolT> CodeStubAssembler::IsElementsKindLessThanOrEqual(
codegen/code-stub-assembler.cc:    TNode<Int32T> target_kind, ElementsKind reference_kind) {
codegen/code-stub-assembler.cc:TNode<Int32T> CodeStubAssembler::GetNonRabGsabElementsKind(
codegen/code-stub-assembler.cc:  ArrayListSetLength(array_with_space, new_length);
codegen/code-stub-assembler.cc:void CodeStubAssembler::ArrayListSetLength(TNode<ArrayList> array,
codegen/code-stub-assembler.cc:  static constexpr ElementsKind kind = ElementsKind::PACKED_ELEMENTS;
codegen/arm64/macro-assembler-arm64.cc:void MacroAssembler::LoadElementsKindFromMap(Register result, Register map) {
codegen/arm64/macro-assembler-arm64.cc:  DecodeField<Map::Bits2::ElementsKindBits>(result);
objects/objects.cc:  ElementsKind array_kind = array->GetElementsKind();
objects/objects.cc:  if (IsFastPackedElementsKind(array_kind)) return false;
objects/objects.cc:  if (IsHoleyElementsKind(array_kind) &&
objects/objects.cc:    ElementsKind elements_kind = Cast<JSObject>(*receiver)->GetElementsKind();
objects/objects.cc:    if (IsBigIntTypedArrayElementsKind(elements_kind)) {
objects/objects.cc:    // 2a. Return ArraySetLength(A, Desc).
objects/objects.cc:    return ArraySetLength(isolate, o, desc, should_throw);
objects/objects.cc:// Part of ES6 9.4.2.4 ArraySetLength.
objects/objects.cc:  // Slow path: follow steps in ES6 9.4.2.4 "ArraySetLength".
objects/objects.cc:Maybe<bool> JSArray::ArraySetLength(Isolate* isolate, DirectHandle<JSArray> a,
objects/objects.cc:      // since we later use JSArray::SetLength instead of
objects/objects.cc:  // Most of steps 16 through 19 is implemented by JSArray::SetLength.
objects/objects.cc:  MAYBE_RETURN(JSArray::SetLength(a, new_len), Nothing<bool>());
objects/objects.cc:Maybe<bool> JSArray::SetLength(DirectHandle<JSArray> array,
objects/objects.cc:  if (array->SetLengthWouldNormalize(new_length)) {
objects/objects.cc:  return array->GetElementsAccessor()->SetLength(array, new_length);
objects/objects.cc:bool JSArray::SetLengthWouldNormalize(uint32_t new_length) {
objects/objects.cc:  return JSArray::SetLengthWouldNormalize(GetHeap(), new_length) &&
objects/objects.cc:bool AllocationSite::ShouldTrack(ElementsKind from, ElementsKind to) {
objects/objects.cc:  return IsMoreGeneralElementsKindTransition(from, to);
objects/objects.cc:HandleType<Derived> HashTable<Derived, Shape>::EnsureCapacity(
objects/objects.cc:  // EnsureCapacity will guarantee the hash table is never full.
objects/objects.cc:  // EnsureCapacity will guarantee the hash table is never full.
objects/objects.cc:    stringset = EnsureCapacity(isolate, stringset);
objects/objects.cc:  table = EnsureCapacity(isolate, table);
objects/objects.cc:  dictionary = Derived::EnsureCapacity(isolate, dictionary);
objects/objects.cc:  table = Derived::EnsureCapacity(isolate, table);
objects/objects.cc:  table = Derived::EnsureCapacity(isolate, table);
objects/objects.cc:    set = EnsureCapacity(isolate, set);
objects/objects.cc:  HashTable<DERIVED, SHAPE>::EnsureCapacity(Isolate*, Handle<DERIVED>, int,  \
objects/objects.cc:  HashTable<DERIVED, SHAPE>::EnsureCapacity(LocalIsolate*, Handle<DERIVED>,  \
objects/objects.cc:  HashTable<DERIVED, SHAPE>::EnsureCapacity(Isolate*, DirectHandle<DERIVED>, \
objects/objects.cc:  HashTable<DERIVED, SHAPE>::EnsureCapacity(                                 \
objects/js-array-buffer.h:                                        ElementsKind* element_kind);
objects/map-updater.h:  Handle<Map> ReconfigureElementsKind(ElementsKind elements_kind);
objects/map-updater.h:  ElementsKind new_elements_kind_;
objects/js-array-buffer.cc:  DCHECK(IsTypedArrayOrRabGsabTypedArrayElementsKind(self->GetElementsKind()));
objects/js-array-buffer.cc:  auto element_byte_size = ElementsKindToByteSize(array->GetElementsKind());
objects/feedback-vector.h:inline bool IsLoadICKind(FeedbackSlotKind kind) {
objects/feedback-vector.h:inline bool IsKeyedLoadICKind(FeedbackSlotKind kind) {
objects/feedback-vector.h:inline bool IsKeyedStoreICKind(FeedbackSlotKind kind) {
objects/feedback-vector.h:         IsStoreGlobalICKind(kind) || IsKeyedStoreICKind(kind) ||
objects/feedback-vector.h:  DEFINE_SLOT_KIND_PREDICATE(IsLoadIC)
objects/feedback-vector.h:  DEFINE_SLOT_KIND_PREDICATE(IsKeyedLoadIC)
objects/feedback-vector.h:  DEFINE_SLOT_KIND_PREDICATE(IsKeyedStoreIC)
objects/feedback-vector.h:  FeedbackSlot AddLoadICSlot() {
objects/feedback-vector.h:  FeedbackSlot AddKeyedLoadICSlot() {
objects/feedback-vector.h:  FeedbackSlotKind GetStoreICSlot(LanguageMode language_mode) {
objects/feedback-vector.h:  FeedbackSlot AddStoreICSlot(LanguageMode language_mode) {
objects/feedback-vector.h:    return AddSlot(GetStoreICSlot(language_mode));
objects/feedback-vector.h:  FeedbackSlotKind GetKeyedStoreICSlotKind(LanguageMode language_mode) {
objects/feedback-vector.h:  FeedbackSlot AddKeyedStoreICSlot(LanguageMode language_mode) {
objects/feedback-vector.h:    return AddSlot(GetKeyedStoreICSlotKind(language_mode));
objects/property-array-inl.h:void PropertyArray::CopyElements(Isolate* isolate, Tagged<PropertyArray> dst,
compiler/heap-refs.cc:         IsFastElementsKind(map->elements_kind()) &&
compiler/heap-refs.cc:// Only used in JSNativeContextSpecialization.
compiler/heap-refs.cc:  ElementsKind kind = elements_kind();
compiler/heap-refs.cc:  if (IsFastElementsKind(kind)) return true;
compiler/heap-refs.cc:  if (IsTypedArrayElementsKind(kind) &&
compiler/heap-refs.cc:  if (IsRabGsabTypedArrayElementsKind(kind) &&
compiler/heap-refs.cc:OptionalMapRef MapRef::AsElementsKind(JSHeapBroker* broker,
compiler/heap-refs.cc:                                      ElementsKind kind) const {
compiler/heap-refs.cc:  const ElementsKind current_kind = elements_kind();
compiler/heap-refs.cc:  // If starting from an initial JSArray map, TryAsElementsKind must succeed
compiler/heap-refs.cc:        Map::TryAsElementsKind(broker->isolate(), object(), kind,
compiler/heap-refs.cc:  std::optional<Tagged<Map>> maybe_result = Map::TryAsElementsKind(
compiler/heap-refs.cc:    TRACE_BROKER_MISSING(broker, "MapRef::AsElementsKind " << *this);
compiler/heap-refs.cc:        !IsFastOrNonextensibleOrSealedElementsKind(
compiler/heap-refs.cc:HEAP_ACCESSOR_C(AllocationSite, ElementsKind, GetElementsKind)
compiler/heap-refs.cc:BIMODAL_ACCESSOR_B(Map, bit_field2, elements_kind, Map::Bits2::ElementsKindBits)
compiler/heap-refs.cc:                                              ElementsKind kind) const {
compiler/heap-refs.cc:    ElementsKind elements_kind, uint32_t index) const {
compiler/heap-refs.cc:  ElementsKind elements_kind = map(broker).elements_kind();
compiler/heap-refs.cc:  if (!IsSmiOrObjectElementsKind(elements_kind)) return {};
compiler/heap-refs.cc:  DCHECK(IsFastElementsKind(elements_kind));
objects/embedder-data-array.cc:DirectHandle<EmbedderDataArray> EmbedderDataArray::EnsureCapacity(
objects/transitions.h:// transition target, or a StoreIC handler for a transitioning store (which in
objects/transitions.h:// and/or handlers as well as prototype and ElementsKind transitions.  Property
codegen/bailout-reason.h:  V(kUnexpectedElementsKindInArrayConstructor,                                 \
codegen/bailout-reason.h:    "Unexpected ElementsKind in array constructor")                            \
compiler/js-call-reducer.cc:class JSCallReducerAssembler : public JSGraphAssembler {
compiler/js-call-reducer.cc:  JSCallReducerAssembler(JSCallReducer* reducer, Node* node,
compiler/js-call-reducer.cc:  TNode<JSArray> AllocateEmptyJSArray(ElementsKind kind,
compiler/js-call-reducer.cc:  TNode<Number> LoadMapElementsKind(TNode<Map> map);
compiler/js-call-reducer.cc:  TNode<Object> ConvertHoleToUndefined(TNode<Object> value, ElementsKind kind) {
compiler/js-call-reducer.cc:    DCHECK(IsHoleyElementsKind(kind));
compiler/js-call-reducer.cc:    TryCatchBuilder0(JSCallReducerAssembler* gasm, const TryFunction& try_body)
compiler/js-call-reducer.cc:    JSCallReducerAssembler* const gasm_;
compiler/js-call-reducer.cc:class IteratingArrayBuiltinReducerAssembler : public JSCallReducerAssembler {
compiler/js-call-reducer.cc:  IteratingArrayBuiltinReducerAssembler(JSCallReducer* reducer, Node* node)
compiler/js-call-reducer.cc:      : JSCallReducerAssembler(reducer, node) {
compiler/js-call-reducer.cc:                                            ElementsKind kind,
compiler/js-call-reducer.cc:                                           ElementsKind kind,
compiler/js-call-reducer.cc:                                         ElementsKind kind,
compiler/js-call-reducer.cc:                                            ElementsKind kind,
compiler/js-call-reducer.cc:                                         ElementsKind kind,
compiler/js-call-reducer.cc:      ElementsKind kind, SharedFunctionInfoRef shared,
compiler/js-call-reducer.cc:      ElementsKind kind, ArrayIndexOfIncludesVariant variant);
compiler/js-call-reducer.cc:  TNode<Number> ReduceArrayPrototypePush(MapInference* inference);
compiler/js-call-reducer.cc:  std::pair<TNode<Number>, TNode<Object>> SafeLoadElement(ElementsKind kind,
compiler/js-call-reducer.cc:      TNode<Object> o, ElementsKind kind,
compiler/js-call-reducer.cc:    if (!IsHoleyElementsKind(kind)) return o;
compiler/js-call-reducer.cc:  TNode<Smi> LoadJSArrayLength(TNode<JSArray> array, ElementsKind kind) {
compiler/js-call-reducer.cc:                          ElementsKind kind) {
compiler/js-call-reducer.cc:                                  TNode<Object> v, ElementsKind kind) {
compiler/js-call-reducer.cc:  TNode<Boolean> HoleCheck(ElementsKind kind, TNode<Object> v) {
compiler/js-call-reducer.cc:    return IsDoubleElementsKind(kind)
compiler/js-call-reducer.cc:class PromiseBuiltinReducerAssembler : public JSCallReducerAssembler {
compiler/js-call-reducer.cc:  PromiseBuiltinReducerAssembler(JSCallReducer* reducer, Node* node)
compiler/js-call-reducer.cc:      : JSCallReducerAssembler(reducer, node) {
compiler/js-call-reducer.cc:class FastApiCallReducerAssembler : public JSCallReducerAssembler {
compiler/js-call-reducer.cc:      JSCallReducer* reducer, Node* node,
compiler/js-call-reducer.cc:      : JSCallReducerAssembler(reducer, node),
compiler/js-call-reducer.cc:TNode<Number> JSCallReducerAssembler::SpeculativeToNumber(
compiler/js-call-reducer.cc:TNode<Smi> JSCallReducerAssembler::CheckSmi(TNode<Object> value) {
compiler/js-call-reducer.cc:TNode<Number> JSCallReducerAssembler::CheckNumber(TNode<Object> value) {
compiler/js-call-reducer.cc:TNode<String> JSCallReducerAssembler::CheckString(TNode<Object> value) {
compiler/js-call-reducer.cc:TNode<Number> JSCallReducerAssembler::CheckBounds(TNode<Number> value,
compiler/js-call-reducer.cc:TNode<Smi> JSCallReducerAssembler::TypeGuardUnsignedSmall(TNode<Object> value) {
compiler/js-call-reducer.cc:TNode<Object> JSCallReducerAssembler::TypeGuardNonInternal(
compiler/js-call-reducer.cc:TNode<Number> JSCallReducerAssembler::TypeGuardFixedArrayLength(
compiler/js-call-reducer.cc:TNode<Object> JSCallReducerAssembler::Call4(
compiler/js-call-reducer.cc:TNode<Object> JSCallReducerAssembler::JSCall3(
compiler/js-call-reducer.cc:TNode<Object> JSCallReducerAssembler::JSCall4(
compiler/js-call-reducer.cc:TNode<Object> JSCallReducerAssembler::CopyNode() {
compiler/js-call-reducer.cc:TNode<JSArray> JSCallReducerAssembler::CreateArrayNoThrow(
compiler/js-call-reducer.cc:TNode<JSArray> JSCallReducerAssembler::AllocateEmptyJSArray(
compiler/js-call-reducer.cc:    ElementsKind kind, NativeContextRef native_context) {
compiler/js-call-reducer.cc:TNode<Number> JSCallReducerAssembler::LoadMapElementsKind(TNode<Map> map) {
compiler/js-call-reducer.cc:                       NumberConstant(Map::Bits2::ElementsKindBits::kMask)),
compiler/js-call-reducer.cc:      NumberConstant(Map::Bits2::ElementsKindBits::kShift));
compiler/js-call-reducer.cc:TNode<Object> JSCallReducerAssembler::ReduceMathUnary(const Operator* op) {
compiler/js-call-reducer.cc:TNode<Object> JSCallReducerAssembler::ReduceMathBinary(const Operator* op) {
compiler/js-call-reducer.cc:TNode<String> JSCallReducerAssembler::ReduceStringPrototypeSubstring() {
compiler/js-call-reducer.cc:TNode<Boolean> JSCallReducerAssembler::ReduceStringPrototypeStartsWith(
compiler/js-call-reducer.cc:  DCHECK(search_string_length <= JSCallReducer::kMaxInlineMatchSequence);
compiler/js-call-reducer.cc:TNode<Boolean> JSCallReducerAssembler::ReduceStringPrototypeStartsWith() {
compiler/js-call-reducer.cc:TNode<Boolean> JSCallReducerAssembler::ReduceStringPrototypeEndsWith(
compiler/js-call-reducer.cc:  DCHECK_LE(search_string_length, JSCallReducer::kMaxInlineMatchSequence);
compiler/js-call-reducer.cc:TNode<Boolean> JSCallReducerAssembler::ReduceStringPrototypeEndsWith() {
compiler/js-call-reducer.cc:TNode<String> JSCallReducerAssembler::ReduceStringPrototypeCharAt(
compiler/js-call-reducer.cc:TNode<String> JSCallReducerAssembler::ReduceStringPrototypeCharAt() {
compiler/js-call-reducer.cc:TNode<String> JSCallReducerAssembler::ReduceStringPrototypeSlice() {
compiler/js-call-reducer.cc:TNode<Object> JSCallReducerAssembler::ReduceJSCallMathMinMaxWithArrayLike(
compiler/js-call-reducer.cc:      LoadMapElementsKind(arguments_list_map);
compiler/js-call-reducer.cc:    if (IsHoleyElementsKind(map.elements_kind())) {
compiler/js-call-reducer.cc:TNode<Number> IteratingArrayBuiltinReducerAssembler::ReduceArrayPrototypePush(
compiler/js-call-reducer.cc:    ElementsKind kind = map.elements_kind();
compiler/js-call-reducer.cc:      if (IsDoubleElementsKind(kind)) {
compiler/js-call-reducer.cc:      } else if (IsSmiElementsKind(kind)) {
compiler/js-call-reducer.cc:      if (IsDoubleElementsKind(kind)) {
compiler/js-call-reducer.cc:      } else if (IsSmiElementsKind(kind)) {
compiler/js-call-reducer.cc:  auto build_array_push = |&](ElementsKind kind,
compiler/js-call-reducer.cc:    ElementsKind kind, SharedFunctionInfoRef shared) {
compiler/js-call-reducer.cc:    ElementsKind kind, ArrayReduceDirection direction,
compiler/js-call-reducer.cc:    ElementsKind kind, SharedFunctionInfoRef shared,
compiler/js-call-reducer.cc:    ElementsKind kind, SharedFunctionInfoRef shared,
compiler/js-call-reducer.cc:  const ElementsKind packed_kind = GetPackedElementsKind(kind);
compiler/js-call-reducer.cc:    ElementsKind kind, SharedFunctionInfoRef shared,
compiler/js-call-reducer.cc:    if (IsHoleyElementsKind(kind)) {
compiler/js-call-reducer.cc:    ElementsKind kind, SharedFunctionInfoRef shared,
compiler/js-call-reducer.cc:                                            ElementsKind elements_kind,
compiler/js-call-reducer.cc:    ElementsKind kind, ArrayIndexOfIncludesVariant variant) {
compiler/js-call-reducer.cc:// Remnant of old-style JSCallReducer code. Could be ported to graph assembler,
compiler/js-call-reducer.cc:std::pair<Node*, Node*> JSCallReducer::ReleaseEffectAndControlFromAssembler(
compiler/js-call-reducer.cc:    JSCallReducerAssembler* gasm) {
compiler/js-call-reducer.cc:Reduction JSCallReducer::ReplaceWithSubgraph(JSCallReducerAssembler* gasm,
compiler/js-call-reducer.cc:Reduction JSCallReducer::ReduceMathUnary(Node* node, const Operator* op) {
compiler/js-call-reducer.cc:  JSCallReducerAssembler a(this, node);
compiler/js-call-reducer.cc:Reduction JSCallReducer::ReduceMathBinary(Node* node, const Operator* op) {
compiler/js-call-reducer.cc:  JSCallReducerAssembler a(this, node);
compiler/js-call-reducer.cc:Reduction JSCallReducer::ReduceMathImul(Node* node) {
compiler/js-call-reducer.cc:Reduction JSCallReducer::ReduceMathClz32(Node* node) {
compiler/js-call-reducer.cc:Reduction JSCallReducer::ReduceMathMinMax(Node* node, const Operator* op,
compiler/js-call-reducer.cc:Reduction JSCallReducer::Reduce(Node* node) {
compiler/js-call-reducer.cc:void JSCallReducer::Finalize() {
compiler/js-call-reducer.cc:Reduction JSCallReducer::ReduceArrayConstructor(Node* node) {
compiler/js-call-reducer.cc:Reduction JSCallReducer::ReduceBooleanConstructor(Node* node) {
compiler/js-call-reducer.cc:Reduction JSCallReducer::ReduceObjectConstructor(Node* node) {
compiler/js-call-reducer.cc:Reduction JSCallReducer::ReduceFunctionPrototypeApply(Node* node) {
compiler/js-call-reducer.cc:Reduction JSCallReducer::ReduceFunctionPrototypeBind(Node* node) {
compiler/js-call-reducer.cc:Reduction JSCallReducer::ReduceFunctionPrototypeCall(Node* node) {
compiler/js-call-reducer.cc:Reduction JSCallReducer::ReduceFunctionPrototypeHasInstance(Node* node) {
compiler/js-call-reducer.cc:Reduction JSCallReducer::ReduceObjectGetPrototype(Node* node, Node* object) {
compiler/js-call-reducer.cc:Reduction JSCallReducer::ReduceObjectGetPrototypeOf(Node* node) {
compiler/js-call-reducer.cc:Reduction JSCallReducer::ReduceObjectIs(Node* node) {
compiler/js-call-reducer.cc:Reduction JSCallReducer::ReduceObjectPrototypeGetProto(Node* node) {
compiler/js-call-reducer.cc:Reduction JSCallReducer::ReduceObjectPrototypeHasOwnProperty(Node* node) {
compiler/js-call-reducer.cc:Reduction JSCallReducer::ReduceObjectPrototypeIsPrototypeOf(Node* node) {
compiler/js-call-reducer.cc:Reduction JSCallReducer::ReduceReflectApply(Node* node) {
compiler/js-call-reducer.cc:Reduction JSCallReducer::ReduceReflectConstruct(Node* node) {
compiler/js-call-reducer.cc:Reduction JSCallReducer::ReduceReflectGetPrototypeOf(Node* node) {
compiler/js-call-reducer.cc:Reduction JSCallReducer::ReduceObjectCreate(Node* node) {
compiler/js-call-reducer.cc:Reduction JSCallReducer::ReduceReflectGet(Node* node) {
compiler/js-call-reducer.cc:Reduction JSCallReducer::ReduceReflectHas(Node* node) {
compiler/js-call-reducer.cc:                                    ElementsKind* kind_return) {
compiler/js-call-reducer.cc:        !UnionElementsKindUptoSize(kind_return, map.elements_kind())) {
compiler/js-call-reducer.cc:                                   std::vector<ElementsKind>* kinds,
compiler/js-call-reducer.cc:    ElementsKind current_kind = map.elements_kind();
compiler/js-call-reducer.cc:      if (UnionElementsKindUptoPackedness(kind_ptr, current_kind)) {
compiler/js-call-reducer.cc:  ElementsKind elements_kind() const { return elements_kind_; }
compiler/js-call-reducer.cc:  ElementsKind elements_kind_;
compiler/js-call-reducer.cc:Reduction JSCallReducer::ReduceArrayForEach(Node* node,
compiler/js-call-reducer.cc:Reduction JSCallReducer::ReduceArrayReduce(Node* node,
compiler/js-call-reducer.cc:Reduction JSCallReducer::ReduceArrayReduceRight(Node* node,
compiler/js-call-reducer.cc:Reduction JSCallReducer::ReduceArrayMap(Node* node,
compiler/js-call-reducer.cc:Reduction JSCallReducer::ReduceArrayFilter(Node* node,
compiler/js-call-reducer.cc:Reduction JSCallReducer::ReduceArrayFind(Node* node,
compiler/js-call-reducer.cc:Reduction JSCallReducer::ReduceArrayFindIndex(Node* node,
compiler/js-call-reducer.cc:Reduction JSCallReducer::ReduceArrayEvery(Node* node,
compiler/js-call-reducer.cc:Reduction JSCallReducer::ReduceArrayIncludes(Node* node) {
compiler/js-call-reducer.cc:Reduction JSCallReducer::ReduceArrayIndexOf(Node* node) {
compiler/js-call-reducer.cc:Reduction JSCallReducer::ReduceArraySome(Node* node,
compiler/js-call-reducer.cc:Reduction JSCallReducer::ReduceCallWasmFunction(Node* node,
compiler/js-call-reducer.cc:Reduction JSCallReducer::ReduceCallApiFunction(Node* node,
compiler/js-call-reducer.cc:  // JSNativeContextSpecialization::InlineApiCall method a bit.
compiler/js-call-reducer.cc:Node* JSCallReducer::ConvertHoleToUndefined(Node* value, ElementsKind kind) {
compiler/js-call-reducer.cc:  DCHECK(IsHoleyElementsKind(kind));
compiler/js-call-reducer.cc:void JSCallReducer::CheckIfConstructor(Node* construct) {
compiler/js-call-reducer.cc:Node* JSCallReducer::CheckArrayLength(Node* array, ElementsKind elements_kind,
compiler/js-call-reducer.cc:JSCallReducer::ReduceCallOrConstructWithArrayLikeOrSpreadOfCreateArguments(
compiler/js-call-reducer.cc:Reduction JSCallReducer::ReduceCallOrConstructWithArrayLikeOrSpread(
compiler/js-call-reducer.cc:    JSCallReducerAssembler a(this, node);
compiler/js-call-reducer.cc:  ElementsKind elements_kind = array_map.elements_kind();
compiler/js-call-reducer.cc:    if (IsHoleyElementsKind(elements_kind)) {
compiler/js-call-reducer.cc:bool JSCallReducer::IsBuiltinOrApiFunction(JSFunctionRef function) const {
compiler/js-call-reducer.cc:Reduction JSCallReducer::ReduceJSCall(Node* node) {
compiler/js-call-reducer.cc:Reduction JSCallReducer::ReduceJSCall(Node* node,
compiler/js-call-reducer.cc:    case Builtin::kArrayPrototypePush:
compiler/js-call-reducer.cc:      return ReduceArrayPrototypePush(node);
compiler/js-call-reducer.cc:    case Builtin::kArrayPrototypePop:
compiler/js-call-reducer.cc:      return ReduceArrayPrototypePop(node);
compiler/js-call-reducer.cc:    // counter-productive at least for Object ElementsKinds. Disable it until
compiler/js-call-reducer.cc:    case Builtin::kArrayPrototypeSlice:
compiler/js-call-reducer.cc:      return ReduceArrayPrototypeSlice(node);
compiler/js-call-reducer.cc:TNode<Object> JSCallReducerAssembler::ReduceJSCallWithArrayLikeOrSpreadOfEmpty(
compiler/js-call-reducer.cc:Reduction JSCallReducer::ReduceJSCallWithArrayLike(Node* node) {
compiler/js-call-reducer.cc:Reduction JSCallReducer::ReduceJSCallWithSpread(Node* node) {
compiler/js-call-reducer.cc:Reduction JSCallReducer::ReduceJSConstruct(Node* node) {
compiler/js-call-reducer.cc:Reduction JSCallReducer::ReduceStringPrototypeIndexOfIncludes(
compiler/js-call-reducer.cc:Reduction JSCallReducer::ReduceStringPrototypeSubstring(Node* node) {
compiler/js-call-reducer.cc:  JSCallReducerAssembler a(this, node);
compiler/js-call-reducer.cc:Reduction JSCallReducer::ReduceStringPrototypeSlice(Node* node) {
compiler/js-call-reducer.cc:  JSCallReducerAssembler a(this, node);
compiler/js-call-reducer.cc:Reduction JSCallReducer::ReduceStringPrototypeSubstr(Node* node) {
compiler/js-call-reducer.cc:Reduction JSCallReducer::ReduceJSConstructWithArrayLike(Node* node) {
compiler/js-call-reducer.cc:Reduction JSCallReducer::ReduceJSConstructWithSpread(Node* node) {
compiler/js-call-reducer.cc:Reduction JSCallReducer::ReduceJSConstructForwardAllArgs(Node* node) {
compiler/js-call-reducer.cc:Reduction JSCallReducer::ReduceReturnReceiver(Node* node) {
compiler/js-call-reducer.cc:Reduction JSCallReducer::ReduceForInsufficientFeedback(
compiler/js-call-reducer.cc:Node* JSCallReducer::LoadReceiverElementsKind(Node* receiver, Effect* effect,
compiler/js-call-reducer.cc:          jsgraph()->ConstantNoHole(Map::Bits2::ElementsKindBits::kMask)),
compiler/js-call-reducer.cc:      jsgraph()->ConstantNoHole(Map::Bits2::ElementsKindBits::kShift));
compiler/js-call-reducer.cc:void JSCallReducer::CheckIfElementsKind(Node* receiver_elements_kind,
compiler/js-call-reducer.cc:                                        ElementsKind kind, Node* control,
compiler/js-call-reducer.cc:                       jsgraph()->ConstantNoHole(GetPackedElementsKind(kind)));
compiler/js-call-reducer.cc:  if (IsHoleyElementsKind(kind)) {
compiler/js-call-reducer.cc:                         jsgraph()->ConstantNoHole(GetHoleyElementsKind(kind)));
compiler/js-call-reducer.cc:Reduction JSCallReducer::ReduceArrayPrototypeAt(Node* node) {
compiler/js-call-reducer.cc:Reduction JSCallReducer::ReduceArrayPrototypePush(Node* node) {
compiler/js-call-reducer.cc:  std::vector<ElementsKind> kinds;
compiler/js-call-reducer.cc:  TNode<Object> subgraph = a.ReduceArrayPrototypePush(&inference);
compiler/js-call-reducer.cc:Reduction JSCallReducer::ReduceArrayPrototypePop(Node* node) {
compiler/js-call-reducer.cc:  std::vector<ElementsKind> kinds;
compiler/js-call-reducer.cc:      LoadReceiverElementsKind(receiver, &effect, control);
compiler/js-call-reducer.cc:    ElementsKind kind = kinds|i];
compiler/js-call-reducer.cc:      CheckIfElementsKind(receiver_elements_kind, kind, control_node,
compiler/js-call-reducer.cc:      // big, as implemented in elements.cc:ElementsAccessorBase::SetLengthImpl.
compiler/js-call-reducer.cc:      if (IsSmiOrObjectElementsKind(kind)) {
compiler/js-call-reducer.cc:              AccessBuilder::ForFixedArrayElement(GetHoleyElementsKind(kind))),
compiler/js-call-reducer.cc:    if (IsHoleyElementsKind(kind)) {
compiler/js-call-reducer.cc:Reduction JSCallReducer::ReduceArrayPrototypeShift(Node* node) {
compiler/js-call-reducer.cc:  std::vector<ElementsKind> kinds;
compiler/js-call-reducer.cc:      LoadReceiverElementsKind(receiver, &effect, control);
compiler/js-call-reducer.cc:    ElementsKind kind = kinds|i];
compiler/js-call-reducer.cc:      CheckIfElementsKind(receiver_elements_kind, kind, control_node,
compiler/js-call-reducer.cc:          jsgraph()->ConstantNoHole(JSArray::kMaxCopyElements));
compiler/js-call-reducer.cc:        if (IsSmiOrObjectElementsKind(kind)) {
compiler/js-call-reducer.cc:            jsgraph()->ConstantNoHole(JSArray::kMaxCopyElements - 1), loop);
compiler/js-call-reducer.cc:          // is in |1, kMaxCopyElements-1], and will break in representing
compiler/js-call-reducer.cc:          static_assert(JSArray::kMaxCopyElements < kSmiMaxValue);
compiler/js-call-reducer.cc:                GetHoleyElementsKind(kind))),
compiler/js-call-reducer.cc:    if (IsHoleyElementsKind(kind)) {
compiler/js-call-reducer.cc:Reduction JSCallReducer::ReduceArrayPrototypeSlice(Node* node) {
compiler/js-call-reducer.cc:  // ReduceArrayPrototypeSlice (to a reasonable degree). This is because
compiler/js-call-reducer.cc:    if (IsHoleyElementsKind(receiver_map.elements_kind())) {
compiler/js-call-reducer.cc:Reduction JSCallReducer::ReduceArrayIsArray(Node* node) {
compiler/js-call-reducer.cc:Reduction JSCallReducer::ReduceArrayIterator(Node* node,
compiler/js-call-reducer.cc:      std::set<ElementsKind> elements_kinds;
compiler/js-call-reducer.cc:      JSCallReducerAssembler a(this, node);
compiler/js-call-reducer.cc:Reduction JSCallReducer::ReduceArrayIteratorPrototypeNext(Node* node) {
compiler/js-call-reducer.cc:  ElementsKind elements_kind = iterated_object_maps|0].elements_kind();
compiler/js-call-reducer.cc:  if (IsTypedArrayElementsKind(elements_kind)) {
compiler/js-call-reducer.cc:  if (IsHoleyElementsKind(elements_kind) &&
compiler/js-call-reducer.cc:  if (IsFloat16TypedArrayElementsKind(elements_kind)) {
compiler/js-call-reducer.cc:  if (IsTypedArrayElementsKind(elements_kind)) {
compiler/js-call-reducer.cc:  if (IsTypedArrayElementsKind(elements_kind)) {
compiler/js-call-reducer.cc:  if (IsTypedArrayElementsKind(elements_kind)) {
compiler/js-call-reducer.cc:        jsgraph()->UintPtrConstant(ElementsKindToShiftSize(elements_kind)));
compiler/js-call-reducer.cc:      if (IsTypedArrayElementsKind(elements_kind)) {
compiler/js-call-reducer.cc:        if (IsHoleyElementsKind(elements_kind)) {
compiler/js-call-reducer.cc:    if (!IsTypedArrayElementsKind(elements_kind)) {
compiler/js-call-reducer.cc:Reduction JSCallReducer::ReduceStringPrototypeStringAt(
compiler/js-call-reducer.cc:Reduction JSCallReducer::ReduceStringPrototypeStartsWith(Node* node) {
compiler/js-call-reducer.cc:      JSCallReducerAssembler a(this, node);
compiler/js-call-reducer.cc:  JSCallReducerAssembler a(this, node);
compiler/js-call-reducer.cc:Reduction JSCallReducer::ReduceStringPrototypeEndsWith(Node* node) {
compiler/js-call-reducer.cc:      JSCallReducerAssembler a(this, node);
compiler/js-call-reducer.cc:  JSCallReducerAssembler a(this, node);
compiler/js-call-reducer.cc:Reduction JSCallReducer::ReduceStringPrototypeCharAt(Node* node) {
compiler/js-call-reducer.cc:      JSCallReducerAssembler a(this, node);
compiler/js-call-reducer.cc:  JSCallReducerAssembler a(this, node);
compiler/js-call-reducer.cc:Reduction JSCallReducer::ReduceStringPrototypeToLowerCaseIntl(Node* node) {
compiler/js-call-reducer.cc:Reduction JSCallReducer::ReduceStringPrototypeToUpperCaseIntl(Node* node) {
compiler/js-call-reducer.cc:Reduction JSCallReducer::ReduceStringFromCharCode(Node* node) {
compiler/js-call-reducer.cc:Reduction JSCallReducer::ReduceStringFromCodePoint(Node* node) {
compiler/js-call-reducer.cc:Reduction JSCallReducer::ReduceStringPrototypeIterator(Node* node) {
compiler/js-call-reducer.cc:Reduction JSCallReducer::ReduceStringPrototypeLocaleCompareIntl(Node* node) {
compiler/js-call-reducer.cc:Reduction JSCallReducer::ReduceStringIteratorPrototypeNext(Node* node) {
compiler/js-call-reducer.cc:Reduction JSCallReducer::ReduceStringPrototypeConcat(Node* node) {
compiler/js-call-reducer.cc:Reduction JSCallReducer::ReduceStringConstructor(Node* node,
compiler/js-call-reducer.cc:Reduction JSCallReducer::ReducePromiseConstructor(Node* node) {
compiler/js-call-reducer.cc:bool JSCallReducer::DoPromiseChecks(MapInference* inference) {
compiler/js-call-reducer.cc:Reduction JSCallReducer::ReducePromisePrototypeCatch(Node* node) {
compiler/js-call-reducer.cc:Node* JSCallReducer::CreateClosureFromBuiltinSharedFunctionInfo(
compiler/js-call-reducer.cc:Reduction JSCallReducer::ReducePromisePrototypeFinally(Node* node) {
compiler/js-call-reducer.cc:Reduction JSCallReducer::ReducePromisePrototypeThen(Node* node) {
compiler/js-call-reducer.cc:Reduction JSCallReducer::ReducePromiseResolveTrampoline(Node* node) {
compiler/js-call-reducer.cc:Reduction JSCallReducer::ReduceTypedArrayConstructor(
compiler/js-call-reducer.cc:Reduction JSCallReducer::ReduceTypedArrayPrototypeToStringTag(Node* node) {
compiler/js-call-reducer.cc:          jsgraph()->ConstantNoHole(Map::Bits2::ElementsKindBits::kMask)),
compiler/js-call-reducer.cc:      jsgraph()->ConstantNoHole(Map::Bits2::ElementsKindBits::kShift));
compiler/js-call-reducer.cc:Reduction JSCallReducer::ReduceArrayBufferViewByteLengthAccessor(
compiler/js-call-reducer.cc:  std::set<ElementsKind> elements_kinds;
compiler/js-call-reducer.cc:      ElementsKind kind = map.elements_kind();
compiler/js-call-reducer.cc:      if (IsRabGsabTypedArrayElementsKind(kind)) maybe_rab_gsab = true;
compiler/js-call-reducer.cc:  JSCallReducerAssembler a(this, node);
compiler/js-call-reducer.cc:Reduction JSCallReducer::ReduceArrayBufferViewByteOffsetAccessor(
compiler/js-call-reducer.cc:  std::set<ElementsKind> elements_kinds;
compiler/js-call-reducer.cc:      ElementsKind kind = map.elements_kind();
compiler/js-call-reducer.cc:      if (IsRabGsabTypedArrayElementsKind(kind)) maybe_rab_gsab = true;
compiler/js-call-reducer.cc:Reduction JSCallReducer::ReduceTypedArrayPrototypeLength(Node* node) {
compiler/js-call-reducer.cc:  std::set<ElementsKind> elements_kinds;
compiler/js-call-reducer.cc:    ElementsKind kind = map.elements_kind();
compiler/js-call-reducer.cc:    if (IsRabGsabTypedArrayElementsKind(kind)) maybe_rab_gsab = true;
compiler/js-call-reducer.cc:  JSCallReducerAssembler a(this, node);
compiler/js-call-reducer.cc:Reduction JSCallReducer::ReduceNumberIsFinite(Node* node) {
compiler/js-call-reducer.cc:Reduction JSCallReducer::ReduceNumberIsInteger(Node* node) {
compiler/js-call-reducer.cc:Reduction JSCallReducer::ReduceNumberIsSafeInteger(Node* node) {
compiler/js-call-reducer.cc:Reduction JSCallReducer::ReduceNumberIsNaN(Node* node) {
compiler/js-call-reducer.cc:Reduction JSCallReducer::ReduceMapPrototypeGet(Node* node) {
compiler/js-call-reducer.cc:Reduction JSCallReducer::ReduceCollectionPrototypeHas(
compiler/js-call-reducer.cc:Reduction JSCallReducer::ReduceMapPrototypeHas(Node* node) {
compiler/js-call-reducer.cc:Reduction JSCallReducer::ReduceSetPrototypeHas(Node* node) {
compiler/js-call-reducer.cc:Reduction JSCallReducer::ReduceCollectionIteration(
compiler/js-call-reducer.cc:Reduction JSCallReducer::ReduceCollectionPrototypeSize(
compiler/js-call-reducer.cc:Reduction JSCallReducer::ReduceCollectionIteratorPrototypeNext(
compiler/js-call-reducer.cc:Reduction JSCallReducer::ReduceArrayBufferIsView(Node* node) {
compiler/js-call-reducer.cc:Reduction JSCallReducer::ReduceArrayBufferViewAccessor(
compiler/js-call-reducer.cc:                   return IsRabGsabTypedArrayElementsKind(map.elements_kind());
compiler/js-call-reducer.cc:  JSCallReducerAssembler a(this, node, effect);
compiler/js-call-reducer.cc:    TNode<Uint32T> elements_kind = a.LoadElementsKind(map);
compiler/js-call-reducer.cc:    TNode<Uint32T> shift = a.LookupByteShiftForElementsKind(elements_kind);
compiler/js-call-reducer.cc:Reduction JSCallReducer::ReduceDataViewAccess(Node* node, DataViewAccess access,
compiler/js-call-reducer.cc:Reduction JSCallReducer::ReduceGlobalIsFinite(Node* node) {
compiler/js-call-reducer.cc:Reduction JSCallReducer::ReduceGlobalIsNaN(Node* node) {
compiler/js-call-reducer.cc:Reduction JSCallReducer::ReduceDatePrototypeGetTime(Node* node) {
compiler/js-call-reducer.cc:Reduction JSCallReducer::ReduceDateNow(Node* node) {
compiler/js-call-reducer.cc:Reduction JSCallReducer::ReduceNumberParseInt(Node* node) {
compiler/js-call-reducer.cc:Reduction JSCallReducer::ReduceRegExpPrototypeTest(Node* node) {
compiler/js-call-reducer.cc:  AccessInfoFactory access_info_factory(broker(), graph()->zone());
compiler/js-call-reducer.cc:Reduction JSCallReducer::ReduceNumberConstructor(Node* node) {
compiler/js-call-reducer.cc:Reduction JSCallReducer::ReduceBigIntConstructor(Node* node) {
compiler/js-call-reducer.cc:Reduction JSCallReducer::ReduceBigIntAsN(Node* node, Builtin builtin) {
compiler/js-call-reducer.cc:std::optional<Reduction> JSCallReducer::TryReduceJSCallMathMinMaxWithArrayLike(
compiler/js-call-reducer.cc:Reduction JSCallReducer::ReduceJSCallMathMinMaxWithArrayLike(Node* node,
compiler/js-call-reducer.cc:  JSCallReducerAssembler a(this, node);
compiler/js-call-reducer.cc:Reduction JSCallReducer::ReduceGetContinuationPreservedEmbedderData(
compiler/js-call-reducer.cc:Reduction JSCallReducer::ReduceSetContinuationPreservedEmbedderData(
compiler/js-call-reducer.cc:CompilationDependencies* JSCallReducer::dependencies() const {
compiler/js-call-reducer.cc:Graph* JSCallReducer::graph() const { return jsgraph()->graph(); }
compiler/js-call-reducer.cc:Isolate* JSCallReducer::isolate() const { return jsgraph()->isolate(); }
compiler/js-call-reducer.cc:Factory* JSCallReducer::factory() const { return isolate()->factory(); }
compiler/js-call-reducer.cc:NativeContextRef JSCallReducer::native_context() const {
compiler/js-call-reducer.cc:CommonOperatorBuilder* JSCallReducer::common() const {
compiler/js-call-reducer.cc:JSOperatorBuilder* JSCallReducer::javascript() const {
compiler/js-call-reducer.cc:SimplifiedOperatorBuilder* JSCallReducer::simplified() const {
objects/ordered-hash-table.cc:OrderedHashTable<Derived, entrysize>::EnsureCapacityForAdding(
objects/ordered-hash-table.cc:      OrderedHashSet::EnsureCapacityForAdding(isolate, table);
objects/ordered-hash-table.cc:      OrderedHashMap::EnsureCapacityForAdding(isolate, table);
objects/ordered-hash-table.cc:      OrderedNameDictionary::EnsureCapacityForAdding(isolate, table);
objects/ordered-hash-table.cc:OrderedHashTable<OrderedHashSet, 1>::EnsureCapacityForAdding(
objects/ordered-hash-table.cc:OrderedHashTable<OrderedHashMap, 2>::EnsureCapacityForAdding(
objects/ordered-hash-table.cc:OrderedHashTable<OrderedNameDictionary, 3>::EnsureCapacityForAdding(
objects/hash-table.h:  V8_WARN_UNUSED_RESULT static HandleType<Derived> EnsureCapacity(
objects/hash-table.h:  HashTable<DERIVED, SHAPE>::EnsureCapacity(Isolate*, Handle<DERIVED>, int,  \
objects/hash-table.h:  HashTable<DERIVED, SHAPE>::EnsureCapacity(LocalIsolate*, Handle<DERIVED>,  \
objects/hash-table.h:      HashTable<DERIVED, SHAPE>::EnsureCapacity(                             \
objects/hash-table.h:      HashTable<DERIVED, SHAPE>::EnsureCapacity(                             \
objects/shared-function-info-inl.h:  // Built-in functions are handled by the JSCallReducer.
objects/contexts.cc:  names_table = names_table->EnsureCapacity(isolate, names_table, local_count);
objects/contexts.cc:    CopyElements(isolate, *new_table, 0, *table, 0, old_length);
objects/regexp-match-info.cc:    RegExpMatchInfo::CopyElements(isolate, *new_info, 0, *match_info, 0,
objects/objects-inl.h:ElementsKind Object::OptimalElementsKind(Tagged<Object> obj,
objects/embedder-data-array.h:  static DirectHandle<EmbedderDataArray> EnsureCapacity(
objects/fixed-array.h:  inline static void CopyElements(Isolate* isolate, Tagged<Derived> dst,
objects/fixed-array.h:  using Super::CopyElements;
objects/fixed-array.h:  inline void CopyElements(Isolate* isolate, int dst_index,
objects/fixed-array.h:  static int GetMaxLengthForNewSpaceAllocation(ElementsKind kind);
objects/fixed-array.h:  inline void CopyElements(Isolate* isolate, int dst_index,
objects/elements-kind.cc:constexpr uint8_t kTypedArrayAndRabGsabTypedArrayElementsKindShifts|] = {
objects/elements-kind.cc:constexpr uint8_t kTypedArrayAndRabGsabTypedArrayElementsKindSizes|] = {
objects/elements-kind.cc:      kTypedArrayAndRabGsabTypedArrayElementsKindShifts                \
objects/elements-kind.cc:              |ElementsKind::TYPE##_ELEMENTS -                         \
objects/elements-kind.cc:               ElementsKind::FIRST_FIXED_TYPED_ARRAY_ELEMENTS_KIND] == \
objects/elements-kind.cc:          ElementsKindToShiftSize(ElementsKind::TYPE##_ELEMENTS),      \
objects/elements-kind.cc:      "Shift of ElementsKind::" #TYPE                                  \
objects/elements-kind.cc:      kTypedArrayAndRabGsabTypedArrayElementsKindSizes                 \
objects/elements-kind.cc:              |ElementsKind::TYPE##_ELEMENTS -                         \
objects/elements-kind.cc:               ElementsKind::FIRST_FIXED_TYPED_ARRAY_ELEMENTS_KIND] == \
objects/elements-kind.cc:          ElementsKindToByteSize(ElementsKind::TYPE##_ELEMENTS),       \
objects/elements-kind.cc:      "Size of ElementsKind::" #TYPE                                   \
objects/elements-kind.cc:const uint8_t* TypedArrayAndRabGsabTypedArrayElementsKindShifts() {
objects/elements-kind.cc:  return &kTypedArrayAndRabGsabTypedArrayElementsKindShifts|0];
objects/elements-kind.cc:const uint8_t* TypedArrayAndRabGsabTypedArrayElementsKindSizes() {
objects/elements-kind.cc:  return &kTypedArrayAndRabGsabTypedArrayElementsKindSizes|0];
objects/elements-kind.cc:int GetDefaultHeaderSizeForElementsKind(ElementsKind elements_kind) {
objects/elements-kind.cc:  if (IsTypedArrayOrRabGsabTypedArrayElementsKind(elements_kind)) {
objects/elements-kind.cc:const char* ElementsKindToString(ElementsKind kind) {
objects/elements-kind.cc:const ElementsKind kFastElementsKindSequence|kFastElementsKindCount] = {
objects/elements-kind.cc:// Verify that kFastElementsKindPackedToHoley is correct.
objects/elements-kind.cc:static_assert(PACKED_SMI_ELEMENTS + kFastElementsKindPackedToHoley ==
objects/elements-kind.cc:static_assert(PACKED_DOUBLE_ELEMENTS + kFastElementsKindPackedToHoley ==
objects/elements-kind.cc:static_assert(PACKED_ELEMENTS + kFastElementsKindPackedToHoley ==
objects/elements-kind.cc:ElementsKind GetFastElementsKindFromSequenceIndex(int sequence_number) {
objects/elements-kind.cc:  DCHECK(sequence_number >= 0 && sequence_number < kFastElementsKindCount);
objects/elements-kind.cc:  return kFastElementsKindSequence|sequence_number];
objects/elements-kind.cc:int GetSequenceIndexFromFastElementsKind(ElementsKind elements_kind) {
objects/elements-kind.cc:  for (int i = 0; i < kFastElementsKindCount; ++i) {
objects/elements-kind.cc:    if (kFastElementsKindSequence|i] == elements_kind) {
objects/elements-kind.cc:ElementsKind GetNextTransitionElementsKind(ElementsKind kind) {
objects/elements-kind.cc:  int index = GetSequenceIndexFromFastElementsKind(kind);
objects/elements-kind.cc:  return GetFastElementsKindFromSequenceIndex(index + 1);
[Step 4: Duration 5.21 seconds| Input tokens: 9,365 | Output tokens: 467]
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ Step 5 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'fuzzy_finder' with arguments: {'pattern': 'objects/elements', 'options': '--filter'}                                                                                    │
╰────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
Command: cd /Users/tarun/v8/v8/src && rg --hidden --no-follow --no-ignore-vcs --files 2>/dev/null | fzf --filter 'objects/elements' | head -n 1000
Observations: objects/elements.h
objects/elements.cc
objects/elements-inl.h
objects/elements-kind.h
objects/elements-kind.cc
[Step 5: Duration 4.81 seconds| Input tokens: 32,993 | Output tokens: 627]
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ Step 6 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'read_file' with arguments: {'file_path': 'src/objects/elements.cc'}                                                                                                     │
╰────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
Command: cd /Users/tarun/v8/v8/src && wc -l '/Users/tarun/v8/v8/src/src/objects/elements.cc'
Observations: Could not determine number of lines in file. wc -l output: wc: /Users/tarun/v8/v8/src/src/objects/elements.cc: open: No such file or directory
[Step 6: Duration 5.32 seconds| Input tokens: 56,688 | Output tokens: 912]
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ Step 7 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'read_file' with arguments: {'file_path': 'objects/elements.cc'}                                                                                                         │
╰────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
Command: cd /Users/tarun/v8/v8/src && wc -l '/Users/tarun/v8/v8/src/objects/elements.cc'
Observations: File 'objects/elements.cc' has 5779 lines and is divided into 2 sections (each section is 3000 lines).
To read this file, please specify a section number between 1 and 2 using the 'section' argument.
[Step 7: Duration 5.80 seconds| Input tokens: 80,457 | Output tokens: 1,195]
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ Step 8 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'fuzzy_finder' with arguments: {'pattern': 'ic/Keyed', 'options': '--filter'}                                                                                            │
╰────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
Command: cd /Users/tarun/v8/v8/src && rg --hidden --no-follow --no-ignore-vcs --files 2>/dev/null | fzf --filter 'ic/Keyed' | head -n 1000
Observations: None
[Step 8: Duration 5.22 seconds| Input tokens: 104,309 | Output tokens: 1,420]
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ Step 9 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'ripgrep' with arguments: {'pattern': 'KeyedLoadIC|KeyedStoreIC|LoadIC|StoreIC', 'options': '--hidden'}                                                                  │
╰────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
Command: cd /Users/tarun/v8/v8/src && rg --hidden 'KeyedLoadIC|KeyedStoreIC|LoadIC|StoreIC' | head -n 1000
Observations: interpreter/interpreter-generator.cc:// Calls the LoadIC at FeedBackVector slot <slot> for <object> and the name at
interpreter/interpreter-generator.cc:  AccessorAssembler::LazyLoadICParameters params(lazy_context, recv, lazy_name,
interpreter/interpreter-generator.cc:  accessor_asm.LoadIC_BytecodeHandler(&params, &exit_point);
interpreter/interpreter-generator.cc:// Calls the KeyedLoadIC at FeedBackVector slot <slot> for <object> and the key
interpreter/interpreter-generator.cc:  var_result = CallBuiltin(Builtin::kKeyedLoadIC, context, object, name, slot,
interpreter/interpreter-generator.cc:// Calls the EnumeratedKeyedLoadIC at FeedBackVector slot <slot> for <object>
interpreter/interpreter-generator.cc:  var_result = CallBuiltin(Builtin::kEnumeratedKeyedLoadIC, context, object,
interpreter/interpreter-generator.cc:// Calls the StoreIC at FeedBackVector slot <slot> for <object> and
interpreter/interpreter-generator.cc:  // StoreIC is currently a base class for multiple property store operations
interpreter/interpreter-generator.cc:  // TODO(v8:12548): refactor SetNamedIC as a subclass of StoreIC, which can be
interpreter/interpreter-generator.cc:  SetNamedProperty(Builtin::kStoreIC, NamedPropertyType::kNotOwn);
interpreter/interpreter-generator.cc:// Calls the KeyedStoreIC at FeedbackVector slot <slot> for <object> and
interpreter/interpreter-generator.cc:  // KeyedStoreIC is currently a base class for multiple keyed property store
interpreter/interpreter-generator.cc:  // TODO(v8:12548): refactor SetKeyedIC as a subclass of KeyedStoreIC, which
interpreter/interpreter-generator.cc:  TNode<Object> result = CallBuiltin(Builtin::kKeyedStoreIC, context, object,
interpreter/bytecodes.h:  /* Property loads (LoadIC) operations */                                     \
interpreter/bytecodes.h:  /* Propery stores (StoreIC) operations */                                    \
interpreter/bytecode-generator.h:  FeedbackSlot GetCachedLoadICSlot(const Expression* expr,
interpreter/bytecode-generator.h:  FeedbackSlot GetCachedStoreICSlot(const Expression* expr,
interpreter/bytecode-generator.cc:              feedback_index(feedback_spec()->AddLoadICSlot()));
interpreter/bytecode-generator.cc:                  feedback_index(feedback_spec()->AddLoadICSlot()));
interpreter/bytecode-generator.cc:    FeedbackSlot slot = feedback_spec()->AddStoreICSlot(language_mode());
interpreter/bytecode-generator.cc:      feedback_index(feedback_spec()->AddKeyedLoadICSlot()));
interpreter/bytecode-generator.cc:  FeedbackSlot slot = feedback_spec()->AddKeyedStoreICSlot(language_mode());
interpreter/bytecode-generator.cc:  FeedbackSlot slot = feedback_spec()->AddLoadICSlot();
interpreter/bytecode-generator.cc:      feedback_index(feedback_spec()->AddLoadICSlot()));
interpreter/bytecode-generator.cc:      int length_load_slot = feedback_index(feedback_spec()->AddLoadICSlot());
interpreter/bytecode-generator.cc:      feedback_spec(), feedback_spec()->GetStoreICSlot(LanguageMode::kStrict));
interpreter/bytecode-generator.cc:      FeedbackSlot next_value_load_slot = feedback_spec()->AddLoadICSlot();
interpreter/bytecode-generator.cc:      FeedbackSlot next_done_load_slot = feedback_spec()->AddLoadICSlot();
interpreter/bytecode-generator.cc:  FeedbackSlot slot = GetCachedLoadICSlot(object_expr, name);
interpreter/bytecode-generator.cc:  FeedbackSlot slot = GetCachedStoreICSlot(object_expr, name);
interpreter/bytecode-generator.cc:                  feedback_index(feedback_spec()->AddLoadICSlot()))
interpreter/bytecode-generator.cc:        FeedbackSlot next_value_load_slot = feedback_spec()->AddLoadICSlot();
interpreter/bytecode-generator.cc:        FeedbackSlot next_done_load_slot = feedback_spec()->AddLoadICSlot();
interpreter/bytecode-generator.cc:          value, value_name, feedback_index(feedback_spec()->AddLoadICSlot()));
interpreter/bytecode-generator.cc:          value, feedback_index(feedback_spec()->AddKeyedLoadICSlot()));
interpreter/bytecode-generator.cc:      FeedbackSlot slot = feedback_spec()->AddKeyedStoreICSlot(language_mode());
interpreter/bytecode-generator.cc:      FeedbackSlot slot = feedback_spec()->AddKeyedLoadICSlot();
interpreter/bytecode-generator.cc:          feedback_index(feedback_spec()->AddLoadICSlot()));
interpreter/bytecode-generator.cc:            feedback_index(feedback_spec()->AddLoadICSlot()));
interpreter/bytecode-generator.cc:                          feedback_index(feedback_spec()->AddLoadICSlot()))
interpreter/bytecode-generator.cc:      BuildLoadKeyedProperty(obj, feedback_spec()->AddKeyedLoadICSlot());
interpreter/bytecode-generator.cc:        object, feedback_index(feedback_spec()->AddKeyedLoadICSlot()));
interpreter/bytecode-generator.cc:          feedback_index(feedback_spec()->AddKeyedLoadICSlot());
interpreter/bytecode-generator.cc:          feedback_index(GetCachedLoadICSlot(property->obj(), name)));
interpreter/bytecode-generator.cc:          object, feedback_index(feedback_spec()->AddKeyedLoadICSlot()));
interpreter/bytecode-generator.cc:      FeedbackSlot slot = GetCachedStoreICSlot(property->obj(), name);
interpreter/bytecode-generator.cc:      FeedbackSlot slot = feedback_spec()->AddKeyedStoreICSlot(language_mode());
interpreter/bytecode-generator.cc:        obj, feedback_index(feedback_spec()->AddLoadICSlot()));
interpreter/bytecode-generator.cc:                               feedback_index(feedback_spec()->AddLoadICSlot()))
interpreter/bytecode-generator.cc:          feedback_index(feedback_spec()->AddLoadICSlot());
interpreter/bytecode-generator.cc:                         feedback_index(feedback_spec()->AddLoadICSlot()))
interpreter/bytecode-generator.cc:  FeedbackSlot slot = feedback_spec()->AddLoadICSlot();
interpreter/bytecode-generator.cc:FeedbackSlot BytecodeGenerator::GetCachedLoadICSlot(const Expression* expr,
interpreter/bytecode-generator.cc:    return feedback_spec()->AddLoadICSlot();
interpreter/bytecode-generator.cc:    return feedback_spec()->AddLoadICSlot();
interpreter/bytecode-generator.cc:  slot = feedback_spec()->AddLoadICSlot();
interpreter/bytecode-generator.cc:    return feedback_spec()->AddLoadICSlot();
interpreter/bytecode-generator.cc:  slot = feedback_spec()->AddLoadICSlot();
interpreter/bytecode-generator.cc:FeedbackSlot BytecodeGenerator::GetCachedStoreICSlot(const Expression* expr,
interpreter/bytecode-generator.cc:    return feedback_spec()->AddStoreICSlot(language_mode());
interpreter/bytecode-generator.cc:    return feedback_spec()->AddStoreICSlot(language_mode());
interpreter/bytecode-generator.cc:  slot = feedback_spec()->AddStoreICSlot(language_mode());
maglev/maglev-ir.cc:  __ CallBuiltin<Builtin::kLoadIC>(
maglev/maglev-ir.cc:  using D = CallInterfaceDescriptorFor<Builtin::kStoreIC>::type;
maglev/maglev-ir.cc:  using D = CallInterfaceDescriptorFor<Builtin::kStoreIC>::type;
maglev/maglev-ir.cc:  __ CallBuiltin<Builtin::kStoreIC>(
maglev/maglev-ir.cc:  using D = CallInterfaceDescriptorFor<Builtin::kKeyedStoreIC>::type;
maglev/maglev-ir.cc:  using D = CallInterfaceDescriptorFor<Builtin::kKeyedStoreIC>::type;
maglev/maglev-ir.cc:  __ CallBuiltin<Builtin::kKeyedStoreIC>(
maglev/maglev-ir.cc:  using D = CallInterfaceDescriptorFor<Builtin::kKeyedLoadIC>::type;
maglev/maglev-ir.cc:  using D = CallInterfaceDescriptorFor<Builtin::kKeyedLoadIC>::type;
maglev/maglev-ir.cc:  __ CallBuiltin<Builtin::kKeyedLoadIC>(
baseline/baseline-compiler.cc:  CallBuiltin<Builtin::kLoadICBaseline>(RegisterOperand(0),  // object
baseline/baseline-compiler.cc:  CallBuiltin<Builtin::kKeyedLoadICBaseline>(
baseline/baseline-compiler.cc:  CallBuiltin<Builtin::kEnumeratedKeyedLoadICBaseline>(
baseline/baseline-compiler.cc:  // StoreIC is currently a base class for multiple property store operations
baseline/baseline-compiler.cc:  // TODO(v8:12548): refactor SetNamedIC as a subclass of StoreIC, which can be
baseline/baseline-compiler.cc:  CallBuiltin<Builtin::kStoreICBaseline>(
baseline/baseline-compiler.cc:  // KeyedStoreIC is currently a base class for multiple keyed property store
baseline/baseline-compiler.cc:  // TODO(v8:12548): refactor SetKeyedIC as a subclass of KeyedStoreIC, which
baseline/baseline-compiler.cc:  CallBuiltin<Builtin::kKeyedStoreICBaseline>(
maglev/maglev-graph-builder.cc:          return BuildCallBuiltin<Builtin::kLoadIC_Megamorphic>(
maglev/maglev-graph-builder.cc:          return BuildCallBuiltin<Builtin::kStoreIC_Megamorphic>(
maglev/maglev-graph-builder.cc:      return BuildCallBuiltin<Builtin::kKeyedLoadIC_Megamorphic>(
maglev/maglev-graph-builder.cc:      return BuildCallBuiltin<Builtin::kKeyedStoreIC_Megamorphic>(
runtime/runtime.h:  F(ElementsTransitionAndStoreIC_Miss, 6, 1) \
runtime/runtime.h:  F(KeyedLoadIC_Miss, 4, 1)                  \
runtime/runtime.h:  F(KeyedStoreIC_Miss, 5, 1)                 \
runtime/runtime.h:  F(KeyedStoreIC_Slow, 3, 1)                 \
runtime/runtime.h:  F(LoadIC_Miss, 4, 1)                       \
runtime/runtime.h:  F(StoreIC_Miss, 5, 1)                      \
objects/transitions.h:// transition target, or a StoreIC handler for a transitioning store (which in
objects/feedback-vector.h:inline bool IsLoadICKind(FeedbackSlotKind kind) {
objects/feedback-vector.h:inline bool IsKeyedLoadICKind(FeedbackSlotKind kind) {
objects/feedback-vector.h:inline bool IsKeyedStoreICKind(FeedbackSlotKind kind) {
objects/feedback-vector.h:         IsStoreGlobalICKind(kind) || IsKeyedStoreICKind(kind) ||
objects/feedback-vector.h:  DEFINE_SLOT_KIND_PREDICATE(IsLoadIC)
objects/feedback-vector.h:  DEFINE_SLOT_KIND_PREDICATE(IsKeyedLoadIC)
objects/feedback-vector.h:  DEFINE_SLOT_KIND_PREDICATE(IsKeyedStoreIC)
objects/feedback-vector.h:  FeedbackSlot AddLoadICSlot() {
objects/feedback-vector.h:  FeedbackSlot AddKeyedLoadICSlot() {
objects/feedback-vector.h:  FeedbackSlotKind GetStoreICSlot(LanguageMode language_mode) {
objects/feedback-vector.h:  FeedbackSlot AddStoreICSlot(LanguageMode language_mode) {
objects/feedback-vector.h:    return AddSlot(GetStoreICSlot(language_mode));
objects/feedback-vector.h:  FeedbackSlotKind GetKeyedStoreICSlotKind(LanguageMode language_mode) {
objects/feedback-vector.h:  FeedbackSlot AddKeyedStoreICSlot(LanguageMode language_mode) {
objects/feedback-vector.h:    return AddSlot(GetKeyedStoreICSlotKind(language_mode));
builtins/iterator.tq:      iteratorMethod = LoadIC(
builtins/iterator.tq:      LoadIC(context, receiver, IteratorSymbolConstant(), loadSlot, feedback);
builtins/builtins-ic-gen.cc:void Builtins::Generate_LoadIC(compiler::CodeAssemblerState* state) {
builtins/builtins-ic-gen.cc:  assembler.GenerateLoadIC();
builtins/builtins-ic-gen.cc:void Builtins::Generate_LoadIC_Megamorphic(
builtins/builtins-ic-gen.cc:  assembler.GenerateLoadIC_Megamorphic();
builtins/builtins-ic-gen.cc:void Builtins::Generate_LoadIC_Noninlined(compiler::CodeAssemblerState* state) {
builtins/builtins-ic-gen.cc:  assembler.GenerateLoadIC_Noninlined();
builtins/builtins-ic-gen.cc:void Builtins::Generate_LoadIC_NoFeedback(compiler::CodeAssemblerState* state) {
builtins/builtins-ic-gen.cc:  assembler.GenerateLoadIC_NoFeedback();
builtins/builtins-ic-gen.cc:void Builtins::Generate_LoadICTrampoline(compiler::CodeAssemblerState* state) {
builtins/builtins-ic-gen.cc:  assembler.GenerateLoadICTrampoline();
builtins/builtins-ic-gen.cc:void Builtins::Generate_LoadICBaseline(compiler::CodeAssemblerState* state) {
builtins/builtins-ic-gen.cc:  assembler.GenerateLoadICBaseline();
builtins/builtins-ic-gen.cc:void Builtins::Generate_LoadICTrampoline_Megamorphic(
builtins/builtins-ic-gen.cc:  assembler.GenerateLoadICTrampoline_Megamorphic();
builtins/builtins-ic-gen.cc:void Builtins::Generate_KeyedLoadIC(compiler::CodeAssemblerState* state) {
builtins/builtins-ic-gen.cc:  assembler.GenerateKeyedLoadIC();
builtins/builtins-ic-gen.cc:void Builtins::Generate_EnumeratedKeyedLoadIC(
builtins/builtins-ic-gen.cc:  assembler.GenerateEnumeratedKeyedLoadIC();
builtins/builtins-ic-gen.cc:void Builtins::Generate_EnumeratedKeyedLoadICBaseline(
builtins/builtins-ic-gen.cc:  assembler.GenerateEnumeratedKeyedLoadICBaseline();
builtins/builtins-ic-gen.cc:void Builtins::Generate_KeyedLoadIC_Megamorphic(
builtins/builtins-ic-gen.cc:  assembler.GenerateKeyedLoadIC_Megamorphic();
builtins/builtins-ic-gen.cc:void Builtins::Generate_KeyedLoadIC_PolymorphicName(
builtins/builtins-ic-gen.cc:  assembler.GenerateKeyedLoadIC_PolymorphicName();
builtins/builtins-ic-gen.cc:void Builtins::Generate_KeyedLoadICTrampoline(
builtins/builtins-ic-gen.cc:  assembler.GenerateKeyedLoadICTrampoline();
builtins/builtins-ic-gen.cc:void Builtins::Generate_KeyedLoadICBaseline(
builtins/builtins-ic-gen.cc:  assembler.GenerateKeyedLoadICBaseline();
builtins/builtins-ic-gen.cc:void Builtins::Generate_KeyedLoadICTrampoline_Megamorphic(
builtins/builtins-ic-gen.cc:  assembler.GenerateKeyedLoadICTrampoline_Megamorphic();
builtins/builtins-ic-gen.cc:void Builtins::Generate_StoreIC(compiler::CodeAssemblerState* state) {
builtins/builtins-ic-gen.cc:  assembler.GenerateStoreIC();
builtins/builtins-ic-gen.cc:void Builtins::Generate_StoreIC_Megamorphic(
builtins/builtins-ic-gen.cc:  assembler.GenerateStoreIC_Megamorphic();
builtins/builtins-ic-gen.cc:void Builtins::Generate_StoreICTrampoline(compiler::CodeAssemblerState* state) {
builtins/builtins-ic-gen.cc:  assembler.GenerateStoreICTrampoline();
builtins/builtins-ic-gen.cc:void Builtins::Generate_StoreICTrampoline_Megamorphic(
builtins/builtins-ic-gen.cc:  assembler.GenerateStoreICTrampoline_Megamorphic();
builtins/builtins-ic-gen.cc:void Builtins::Generate_StoreICBaseline(compiler::CodeAssemblerState* state) {
builtins/builtins-ic-gen.cc:  assembler.GenerateStoreICBaseline();
builtins/builtins-ic-gen.cc:void Builtins::Generate_KeyedStoreIC(compiler::CodeAssemblerState* state) {
builtins/builtins-ic-gen.cc:  assembler.GenerateKeyedStoreIC();
builtins/builtins-ic-gen.cc:void Builtins::Generate_KeyedStoreICTrampoline(
builtins/builtins-ic-gen.cc:  assembler.GenerateKeyedStoreICTrampoline();
builtins/builtins-ic-gen.cc:void Builtins::Generate_KeyedStoreICTrampoline_Megamorphic(
builtins/builtins-ic-gen.cc:  assembler.GenerateKeyedStoreICTrampoline_Megamorphic();
builtins/builtins-ic-gen.cc:void Builtins::Generate_KeyedStoreICBaseline(
builtins/builtins-ic-gen.cc:  assembler.GenerateKeyedStoreICBaseline();
logging/runtime-call-stats.h:  V(KeyedLoadIC_KeyedLoadSloppyArgumentsStub)     \
logging/runtime-call-stats.h:  V(KeyedLoadIC_LoadElementDH)                    \
logging/runtime-call-stats.h:  V(KeyedLoadIC_LoadIndexedInterceptorStub)       \
logging/runtime-call-stats.h:  V(KeyedLoadIC_LoadIndexedStringDH)              \
logging/runtime-call-stats.h:  V(KeyedLoadIC_SlowStub)                         \
logging/runtime-call-stats.h:  V(KeyedStoreIC_ElementsTransitionAndStoreStub)  \
logging/runtime-call-stats.h:  V(KeyedStoreIC_KeyedStoreSloppyArgumentsStub)   \
logging/runtime-call-stats.h:  V(KeyedStoreIC_SlowStub)                        \
logging/runtime-call-stats.h:  V(KeyedStoreIC_StoreElementStub)                \
logging/runtime-call-stats.h:  V(KeyedStoreIC_StoreFastElementStub)            \
logging/runtime-call-stats.h:  V(LoadIC_FunctionPrototypeStub)                 \
logging/runtime-call-stats.h:  V(LoadIC_HandlerCacheHit_Accessor)              \
logging/runtime-call-stats.h:  V(LoadIC_LoadAccessorDH)                        \
logging/runtime-call-stats.h:  V(LoadIC_LoadAccessorFromPrototypeDH)           \
logging/runtime-call-stats.h:  V(LoadIC_LoadApiGetterFromPrototypeDH)          \
logging/runtime-call-stats.h:  V(LoadIC_LoadCallback)                          \
logging/runtime-call-stats.h:  V(LoadIC_LoadConstantDH)                        \
logging/runtime-call-stats.h:  V(LoadIC_LoadConstantFromPrototypeDH)           \
logging/runtime-call-stats.h:  V(LoadIC_LoadFieldDH)                           \
logging/runtime-call-stats.h:  V(LoadIC_LoadFieldFromPrototypeDH)              \
logging/runtime-call-stats.h:  V(LoadIC_LoadGlobalDH)                          \
logging/runtime-call-stats.h:  V(LoadIC_LoadGlobalFromPrototypeDH)             \
logging/runtime-call-stats.h:  V(LoadIC_LoadIntegerIndexedExoticDH)            \
logging/runtime-call-stats.h:  V(LoadIC_LoadInterceptorDH)                     \
logging/runtime-call-stats.h:  V(LoadIC_LoadInterceptorFromPrototypeDH)        \
logging/runtime-call-stats.h:  V(LoadIC_LoadNativeDataPropertyDH)              \
logging/runtime-call-stats.h:  V(LoadIC_LoadNativeDataPropertyFromPrototypeDH) \
logging/runtime-call-stats.h:  V(LoadIC_LoadNonexistentDH)                     \
logging/runtime-call-stats.h:  V(LoadIC_LoadNonMaskingInterceptorDH)           \
logging/runtime-call-stats.h:  V(LoadIC_LoadNormalDH)                          \
logging/runtime-call-stats.h:  V(LoadIC_LoadNormalFromPrototypeDH)             \
logging/runtime-call-stats.h:  V(LoadIC_NonReceiver)                           \
logging/runtime-call-stats.h:  V(LoadIC_SlowStub)                              \
logging/runtime-call-stats.h:  V(LoadIC_StringLength)                          \
logging/runtime-call-stats.h:  V(LoadIC_StringWrapperLength)                   \
logging/runtime-call-stats.h:  V(StoreIC_HandlerCacheHit_Accessor)             \
logging/runtime-call-stats.h:  V(StoreIC_NonReceiver)                          \
logging/runtime-call-stats.h:  V(StoreIC_SlowStub)                             \
logging/runtime-call-stats.h:  V(StoreIC_StoreAccessorDH)                      \
logging/runtime-call-stats.h:  V(StoreIC_StoreAccessorOnPrototypeDH)           \
logging/runtime-call-stats.h:  V(StoreIC_StoreApiSetterOnPrototypeDH)          \
logging/runtime-call-stats.h:  V(StoreIC_StoreFieldDH)                         \
logging/runtime-call-stats.h:  V(StoreIC_StoreGlobalDH)                        \
logging/runtime-call-stats.h:  V(StoreIC_StoreGlobalTransitionDH)              \
logging/runtime-call-stats.h:  V(StoreIC_StoreInterceptorStub)                 \
logging/runtime-call-stats.h:  V(StoreIC_StoreNativeDataPropertyDH)            \
logging/runtime-call-stats.h:  V(StoreIC_StoreNativeDataPropertyOnPrototypeDH) \
logging/runtime-call-stats.h:  V(StoreIC_StoreNormalDH)                        \
logging/runtime-call-stats.h:  V(StoreIC_StoreTransitionDH)                    \
compiler/js-heap-broker.cc:  if (IsKeyedLoadICKind(kind)) {
compiler/js-heap-broker.cc:  if (IsKeyedStoreICKind(kind)) {
compiler/js-heap-broker.cc:  DCHECK(IsKeyedLoadICKind(slot_kind) || IsKeyedHasICKind(slot_kind) ||
compiler/js-heap-broker.cc:         IsKeyedStoreICKind(slot_kind) ||
compiler/js-heap-broker.cc:  DCHECK(IsLoadICKind(slot_kind));
compiler/js-heap-broker.cc:  DCHECK(IsLoadICKind(slot_kind) || IsSetNamedICKind(slot_kind) ||
compiler/js-heap-broker.cc:         IsDefineNamedOwnICKind(slot_kind) || IsKeyedLoadICKind(slot_kind) ||
compiler/js-heap-broker.cc:         IsKeyedHasICKind(slot_kind) || IsKeyedStoreICKind(slot_kind) ||
objects/js-objects.cc:// Note, that the normal Load/StoreICs that load/store through the global object
builtins/builtins-definitions.h:  TFH(KeyedLoadIC_PolymorphicName, LoadWithVector)                             \
builtins/builtins-definitions.h:  TFH(KeyedStoreIC_Megamorphic, StoreWithVector)                               \
builtins/builtins-definitions.h:  TFH(LoadIC_FunctionPrototype, LoadWithVector)                                \
builtins/builtins-definitions.h:  TFH(LoadIC_StringLength, LoadWithVector)                                     \
builtins/builtins-definitions.h:  TFH(LoadIC_StringWrapperLength, LoadWithVector)                              \
builtins/builtins-definitions.h:  TFH(LoadIC_NoFeedback, LoadNoFeedback)                                       \
builtins/builtins-definitions.h:  TFH(StoreIC_NoFeedback, StoreNoFeedback)                                     \
builtins/builtins-definitions.h:  TFH(KeyedLoadIC_SloppyArguments, LoadWithVector)                             \
builtins/builtins-definitions.h:  TFH(KeyedStoreIC_SloppyArguments_InBounds, StoreWithVector)                  \
builtins/builtins-definitions.h:  TFH(KeyedStoreIC_SloppyArguments_NoTransitionGrowAndHandleCOW,               \
builtins/builtins-definitions.h:  TFH(KeyedStoreIC_SloppyArguments_NoTransitionIgnoreTypedArrayOOB,            \
builtins/builtins-definitions.h:  TFH(KeyedStoreIC_SloppyArguments_NoTransitionHandleCOW, StoreWithVector)     \
builtins/builtins-definitions.h:  TFH(LoadIC, LoadWithVector)                                                  \
builtins/builtins-definitions.h:  TFH(LoadIC_Megamorphic, LoadWithVector)                                      \
builtins/builtins-definitions.h:  TFH(LoadIC_Noninlined, LoadWithVector)                                       \
builtins/builtins-definitions.h:  TFH(LoadICTrampoline, Load)                                                  \
builtins/builtins-definitions.h:  TFH(LoadICBaseline, LoadBaseline)                                            \
builtins/builtins-definitions.h:  TFH(LoadICTrampoline_Megamorphic, Load)                                      \
builtins/builtins-definitions.h:  TFH(KeyedLoadIC, KeyedLoadWithVector)                                        \
builtins/builtins-definitions.h:  TFH(EnumeratedKeyedLoadIC, EnumeratedKeyedLoad)                              \
builtins/builtins-definitions.h:  TFH(KeyedLoadIC_Megamorphic, KeyedLoadWithVector)                            \
builtins/builtins-definitions.h:  TFH(KeyedLoadICTrampoline, KeyedLoad)                                        \
builtins/builtins-definitions.h:  TFH(KeyedLoadICBaseline, KeyedLoadBaseline)                                  \
builtins/builtins-definitions.h:  TFH(EnumeratedKeyedLoadICBaseline, EnumeratedKeyedLoadBaseline)              \
builtins/builtins-definitions.h:  TFH(KeyedLoadICTrampoline_Megamorphic, KeyedLoad)                            \
builtins/builtins-definitions.h:  TFH(StoreIC, StoreWithVector)                                                \
builtins/builtins-definitions.h:  TFH(StoreIC_Megamorphic, StoreWithVector)                                    \
builtins/builtins-definitions.h:  TFH(StoreICTrampoline, Store)                                                \
builtins/builtins-definitions.h:  TFH(StoreICTrampoline_Megamorphic, Store)                                    \
builtins/builtins-definitions.h:  TFH(StoreICBaseline, StoreBaseline)                                          \
builtins/builtins-definitions.h:  TFH(KeyedStoreIC, StoreWithVector)                                           \
builtins/builtins-definitions.h:  TFH(KeyedStoreICTrampoline, Store)                                           \
builtins/builtins-definitions.h:  TFH(KeyedStoreICTrampoline_Megamorphic, Store)                               \
builtins/builtins-definitions.h:  TFH(KeyedStoreICBaseline, StoreBaseline)                                     \
builtins/builtins-handler-gen.cc:  void Generate_KeyedStoreIC_SloppyArguments();
builtins/builtins-handler-gen.cc:TF_BUILTIN(LoadIC_StringLength, CodeStubAssembler) {
builtins/builtins-handler-gen.cc:TF_BUILTIN(LoadIC_StringWrapperLength, CodeStubAssembler) {
builtins/builtins-handler-gen.cc:void Builtins::Generate_KeyedStoreIC_Megamorphic(
builtins/builtins-handler-gen.cc:void Builtins::Generate_StoreIC_NoFeedback(
builtins/builtins-handler-gen.cc:  StoreICNoFeedbackGenerator::Generate(state);
builtins/builtins-handler-gen.cc:  TailCallRuntime(Runtime::kElementsTransitionAndStoreIC_Miss, context,
builtins/builtins-handler-gen.cc:  TailCallRuntime(Runtime::kKeyedStoreIC_Miss, context,
builtins/builtins-handler-gen.cc:TF_BUILTIN(LoadIC_FunctionPrototype, CodeStubAssembler) {
builtins/builtins-handler-gen.cc:  TailCallRuntime(Runtime::kLoadIC_Miss, context, receiver, name, slot, vector);
builtins/builtins-handler-gen.cc:TF_BUILTIN(KeyedLoadIC_SloppyArguments, HandlerBuiltinsAssembler) {
builtins/builtins-handler-gen.cc:    TailCallRuntime(Runtime::kKeyedLoadIC_Miss, context, receiver, key, slot,
builtins/builtins-handler-gen.cc:void HandlerBuiltinsAssembler::Generate_KeyedStoreIC_SloppyArguments() {
builtins/builtins-handler-gen.cc:  TailCallRuntime(Runtime::kKeyedStoreIC_Miss, context, value, slot, vector,
builtins/builtins-handler-gen.cc:TF_BUILTIN(KeyedStoreIC_SloppyArguments_InBounds, HandlerBuiltinsAssembler) {
builtins/builtins-handler-gen.cc:  Generate_KeyedStoreIC_SloppyArguments();
builtins/builtins-handler-gen.cc:TF_BUILTIN(KeyedStoreIC_SloppyArguments_NoTransitionGrowAndHandleCOW,
builtins/builtins-handler-gen.cc:  Generate_KeyedStoreIC_SloppyArguments();
builtins/builtins-handler-gen.cc:TF_BUILTIN(KeyedStoreIC_SloppyArguments_NoTransitionIgnoreTypedArrayOOB,
builtins/builtins-handler-gen.cc:  Generate_KeyedStoreIC_SloppyArguments();
builtins/builtins-handler-gen.cc:TF_BUILTIN(KeyedStoreIC_SloppyArguments_NoTransitionHandleCOW,
builtins/builtins-handler-gen.cc:  Generate_KeyedStoreIC_SloppyArguments();
builtins/builtins-handler-gen.cc:  TailCallRuntime(Runtime::kKeyedLoadIC_Miss, context, receiver, key, slot,
objects/feedback-vector.cc:        DCHECK(IsLoadICKind(kind()));
objects/feedback-vector.cc:          DCHECK(IsKeyedLoadICKind(kind()) || IsKeyedStoreICKind(kind()) ||
objects/feedback-vector.cc:  if (IsKeyedStoreICKind(kind()) || IsKeyedLoadICKind(kind()) ||
objects/feedback-vector.cc:  DCHECK(IsKeyedLoadICKind(kind()) || IsKeyedHasICKind(kind()));
objects/feedback-vector.cc:    case Builtin::kKeyedStoreIC_SloppyArguments_InBounds:
objects/feedback-vector.cc:    case Builtin::kKeyedStoreIC_SloppyArguments_NoTransitionGrowAndHandleCOW:
objects/feedback-vector.cc:    case Builtin::kKeyedStoreIC_SloppyArguments_NoTransitionIgnoreTypedArrayOOB:
objects/feedback-vector.cc:    case Builtin::kKeyedStoreIC_SloppyArguments_NoTransitionHandleCOW:
objects/feedback-vector.cc:    case Builtin::kKeyedStoreIC_SloppyArguments_InBounds:
objects/feedback-vector.cc:    case Builtin::kKeyedStoreIC_SloppyArguments_NoTransitionGrowAndHandleCOW:
objects/feedback-vector.cc:    case Builtin::kKeyedStoreIC_SloppyArguments_NoTransitionIgnoreTypedArrayOOB:
objects/feedback-vector.cc:    case Builtin::kKeyedStoreIC_SloppyArguments_NoTransitionHandleCOW:
objects/feedback-vector.cc:  DCHECK(IsKeyedStoreICKind(kind()) || IsStoreInArrayLiteralICKind(kind()) ||
objects/feedback-vector.cc:  DCHECK(IsKeyedStoreICKind(kind()) || IsKeyedLoadICKind(kind()) ||
objects/feedback-vector.cc:      IsLoadICKind(nexus->kind()) || IsSetNamedICKind(nexus->kind()) ||
objects/feedback-vector.cc:      IsKeyedLoadICKind(nexus->kind()) || IsKeyedStoreICKind(nexus->kind()) ||
builtins/base.tq:extern builtin LoadIC(
compiler/js-generic-lowering.cc:                  ? Builtin::kKeyedLoadICTrampoline_Megamorphic
compiler/js-generic-lowering.cc:                  : Builtin::kKeyedLoadICTrampoline);
compiler/js-generic-lowering.cc:                  ? Builtin::kKeyedLoadIC_Megamorphic
compiler/js-generic-lowering.cc:                  : Builtin::kKeyedLoadIC);
compiler/js-generic-lowering.cc:                  ? Builtin::kLoadICTrampoline_Megamorphic
compiler/js-generic-lowering.cc:                  : Builtin::kLoadICTrampoline);
compiler/js-generic-lowering.cc:                  ? Builtin::kLoadIC_Megamorphic
compiler/js-generic-lowering.cc:                  : Builtin::kLoadIC);
compiler/js-generic-lowering.cc:    // KeyedStoreIC is currently a base class for multiple keyed property store
compiler/js-generic-lowering.cc:    // TODO(v8:12548): refactor SetKeyedIC as a subclass of KeyedStoreIC, which
compiler/js-generic-lowering.cc:                  ? Builtin::kKeyedStoreICTrampoline_Megamorphic
compiler/js-generic-lowering.cc:                  : Builtin::kKeyedStoreICTrampoline);
compiler/js-generic-lowering.cc:                  ? Builtin::kKeyedStoreIC_Megamorphic
compiler/js-generic-lowering.cc:                  : Builtin::kKeyedStoreIC);
compiler/js-generic-lowering.cc:    // StoreIC is currently a base class for multiple property store operations
compiler/js-generic-lowering.cc:    // TODO(v8:12548): refactor SetNamedIC as a subclass of StoreIC, which can
compiler/js-generic-lowering.cc:                  ? Builtin::kStoreICTrampoline_Megamorphic
compiler/js-generic-lowering.cc:                  : Builtin::kStoreICTrampoline);
compiler/js-generic-lowering.cc:                  ? Builtin::kStoreIC_Megamorphic
compiler/js-generic-lowering.cc:                  : Builtin::kStoreIC);
ic/keyed-store-generic.cc:  // chain to invoke setters. it's used by KeyedStoreIC and StoreIC to
ic/keyed-store-generic.cc:  void StoreIC_NoFeedback();
ic/keyed-store-generic.cc:                                const StoreICParameters* p,
ic/keyed-store-generic.cc:                                const StoreICParameters* p, Label* slow) {
ic/keyed-store-generic.cc:  TNode<Map> FindCandidateStoreICTransitionMapHandler(TNode<Map> map,
ic/keyed-store-generic.cc:void StoreICNoFeedbackGenerator::Generate(compiler::CodeAssemblerState* state) {
ic/keyed-store-generic.cc:  assembler.StoreIC_NoFeedback();
ic/keyed-store-generic.cc:  assembler.StoreIC_NoFeedback();
ic/keyed-store-generic.cc:TNode<Map> KeyedStoreGenericAssembler::FindCandidateStoreICTransitionMapHandler(
ic/keyed-store-generic.cc:    TNode<Uint16T> instance_type, const StoreICParameters* p,
ic/keyed-store-generic.cc:      TNode<Map> transition_map = FindCandidateStoreICTransitionMapHandler(
ic/keyed-store-generic.cc:      HandleStoreICTransitionMapHandlerCase(p, transition_map, slow, flags);
ic/keyed-store-generic.cc:      HandleStoreICHandlerCase(p, var_handler.value(), &stub_cache_miss,
ic/keyed-store-generic.cc:      TailCallRuntime(Runtime::kKeyedStoreIC_Miss, p->context(), p->value(),
ic/keyed-store-generic.cc:    StoreICParameters p(context, receiver, var_unique.value(), value,
ic/keyed-store-generic.cc:                        StoreICMode::kDefault);
ic/keyed-store-generic.cc:void KeyedStoreGenericAssembler::StoreIC_NoFeedback() {
ic/keyed-store-generic.cc:      StoreICParameters p(context, receiver, name, value, std::nullopt, {},
ic/keyed-store-generic.cc:                          IsDefineNamedOwn() ? StoreICMode::kDefineNamedOwn
ic/keyed-store-generic.cc:                                             : StoreICMode::kDefault);
ic/keyed-store-generic.cc:                                      : Runtime::kStoreIC_Miss;
ic/keyed-store-generic.cc:  StoreICParameters p(context, receiver, unique_name, value, std::nullopt, {},
ic/keyed-store-generic.cc:                      UndefinedConstant(), StoreICMode::kDefault);
ic/ic.h:// IC is the base class for LoadIC, StoreIC, KeyedLoadIC, and KeyedStoreIC.
ic/ic.h:    return IsLoadIC() || IsLoadGlobalIC() || IsKeyedLoadIC();
ic/ic.h:           IsKeyedStoreIC() || IsStoreInArrayLiteralICKind(kind()) ||
ic/ic.h:  bool IsLoadIC() const { return IsLoadICKind(kind_); }
ic/ic.h:  bool IsKeyedLoadIC() const { return IsKeyedLoadICKind(kind_); }
ic/ic.h:  bool IsKeyedStoreIC() const { return IsKeyedStoreICKind(kind_); }
ic/ic.h:    return IsKeyedLoadIC() || IsKeyedStoreIC() || IsStoreInArrayLiteralIC() ||
ic/ic.h:class LoadIC : public IC {
ic/ic.h:  LoadIC(Isolate* isolate, Handle<FeedbackVector> vector, FeedbackSlot slot,
ic/ic.h:class LoadGlobalIC : public LoadIC {
ic/ic.h:      : LoadIC(isolate, vector, slot, kind) {}
ic/ic.h:class KeyedLoadIC : public LoadIC {
ic/ic.h:  KeyedLoadIC(Isolate* isolate, Handle<FeedbackVector> vector,
ic/ic.h:      : LoadIC(isolate, vector, slot, kind) {}
ic/ic.h:class StoreIC : public IC {
ic/ic.h:  StoreIC(Isolate* isolate, Handle<FeedbackVector> vector, FeedbackSlot slot,
ic/ic.h:class StoreGlobalIC : public StoreIC {
ic/ic.h:      : StoreIC(isolate, vector, slot, kind) {}
ic/ic.h:class KeyedStoreIC : public StoreIC {
ic/ic.h:  KeyedStoreIC(Isolate* isolate, Handle<FeedbackVector> vector,
ic/ic.h:      : StoreIC(isolate, vector, slot, kind) {}
ic/ic.h:class StoreInArrayLiteralIC : public KeyedStoreIC {
ic/ic.h:      : KeyedStoreIC(isolate, vector, slot,
ic/keyed-store-generic.h:class StoreICNoFeedbackGenerator {
ic/accessor-assembler.cc:    const LoadICParameters* p, TNode<Map> lookup_start_object_map,
ic/accessor-assembler.cc:void AccessorAssembler::HandleLoadICHandlerCase(
ic/accessor-assembler.cc:    const LazyLoadICParameters* p, TNode<MaybeObject> handler, Label* miss,
ic/accessor-assembler.cc:    HandleLoadICProtoHandler(p, CAST(handler), &var_holder, &var_smi_handler,
ic/accessor-assembler.cc:    HandleLoadICSmiHandlerCase(
ic/accessor-assembler.cc:              // LoadIC case: the receiver is definitely not null or undefined.
ic/accessor-assembler.cc:    const LazyLoadICParameters* p, TNode<JSObject> holder,
ic/accessor-assembler.cc:    const LazyLoadICParameters* p,
ic/accessor-assembler.cc:void AccessorAssembler::HandleLoadICSmiHandlerCase(
ic/accessor-assembler.cc:    const LazyLoadICParameters* p, TNode<Object> holder, TNode<Smi> smi_handler,
ic/accessor-assembler.cc:    HandleLoadICSmiHandlerHasNamedCase(p, holder, handler_kind, miss,
ic/accessor-assembler.cc:    HandleLoadICSmiHandlerLoadNamedCase(
ic/accessor-assembler.cc:void AccessorAssembler::HandleLoadICSmiHandlerLoadNamedCase(
ic/accessor-assembler.cc:    const LazyLoadICParameters* p, TNode<Object> holder,
ic/accessor-assembler.cc:void AccessorAssembler::HandleLoadICSmiHandlerHasNamedCase(
ic/accessor-assembler.cc:    const LazyLoadICParameters* p, TNode<Object> holder,
ic/accessor-assembler.cc:void AccessorAssembler::HandleLoadICProtoHandler(
ic/accessor-assembler.cc:    const LazyLoadICParameters* p, TNode<DataHandler> handler,
ic/accessor-assembler.cc:      // Code sub-handlers are not expected in LoadICs, so no |on_code_handler|.
ic/accessor-assembler.cc:void AccessorAssembler::HandleStoreICNativeDataProperty(
ic/accessor-assembler.cc:    const StoreICParameters* p, TNode<HeapObject> holder,
ic/accessor-assembler.cc:void AccessorAssembler::HandleStoreICSmiHandlerJSSharedStructFieldCase(
ic/accessor-assembler.cc:void AccessorAssembler::HandleStoreICHandlerCase(
ic/accessor-assembler.cc:    const StoreICParameters* p, TNode<MaybeObject> handler, Label* miss,
ic/accessor-assembler.cc:      HandleStoreICNativeDataProperty(p, CAST(holder), handler_word);
ic/accessor-assembler.cc:      HandleStoreICSmiHandlerJSSharedStructFieldCase(p->context(), handler_word,
ic/accessor-assembler.cc:      HandleStoreICSmiHandlerCase(handler_word, CAST(holder), p->value(), miss);
ic/accessor-assembler.cc:          id = Runtime::kKeyedStoreIC_Slow;
ic/accessor-assembler.cc:      HandleStoreICProtoHandler(p, CAST(strong_handler), &if_slow, miss,
ic/accessor-assembler.cc:      HandleStoreICTransitionMapHandlerCase(p, map, miss,
ic/accessor-assembler.cc:void AccessorAssembler::HandleStoreICTransitionMapHandlerCase(
ic/accessor-assembler.cc:    const StoreICParameters* p, TNode<Map> transition_map, Label* miss,
ic/accessor-assembler.cc:void AccessorAssembler::HandleStoreICProtoHandler(
ic/accessor-assembler.cc:    const StoreICParameters* p, TNode<StoreHandler> handler, Label* slow,
ic/accessor-assembler.cc:  Comment("HandleStoreICProtoHandler");
ic/accessor-assembler.cc:    // Code sub-handlers are expected only in KeyedStoreICs.
ic/accessor-assembler.cc:    HandleStoreICNativeDataProperty(p, holder, handler_word);
ic/accessor-assembler.cc:void AccessorAssembler::HandleStoreToProxy(const StoreICParameters* p,
ic/accessor-assembler.cc:void AccessorAssembler::HandleStoreICSmiHandlerCase(TNode<Word32T> handler_word,
ic/accessor-assembler.cc:    TNode<Int32T> lookup_start_object_instance_type, const LoadICParameters* p,
ic/accessor-assembler.cc:        LazyLoadICParameters lazy_p(p);
ic/accessor-assembler.cc:        HandleLoadICHandlerCase(&lazy_p, var_handler.value(), &stub_cache_miss,
ic/accessor-assembler.cc:        TailCallRuntime(Runtime::kKeyedLoadIC_Miss, p->context(),
ic/accessor-assembler.cc:void AccessorAssembler::LoadIC_BytecodeHandler(const LazyLoadICParameters* p,
ic/accessor-assembler.cc:  // Must be kept in sync with LoadIC.
ic/accessor-assembler.cc:    Comment("LoadIC_BytecodeHandler_fast");
ic/accessor-assembler.cc:    HandleLoadICHandlerCase(p, var_handler.value(), &miss, exit_point);
ic/accessor-assembler.cc:    Comment("LoadIC_BytecodeHandler_noninlined");
ic/accessor-assembler.cc:    // Call into the stub that implements the non-inlined parts of LoadIC.
ic/accessor-assembler.cc:    exit_point->ReturnCallBuiltin(Builtin::kLoadIC_Noninlined, p->context(),
ic/accessor-assembler.cc:    Comment("LoadIC_BytecodeHandler_nofeedback");
ic/accessor-assembler.cc:    // Call into the stub that implements the non-inlined parts of LoadIC.
ic/accessor-assembler.cc:    exit_point->ReturnCallBuiltin(Builtin::kLoadIC_NoFeedback, p->context(),
ic/accessor-assembler.cc:    Comment("LoadIC_BytecodeHandler_miss");
ic/accessor-assembler.cc:    exit_point->ReturnCallRuntime(Runtime::kLoadIC_Miss, p->context(),
ic/accessor-assembler.cc:void AccessorAssembler::LoadIC(const LoadICParameters* p) {
ic/accessor-assembler.cc:  // Must be kept in sync with LoadIC_BytecodeHandler.
ic/accessor-assembler.cc:    LazyLoadICParameters lazy_p(p);
ic/accessor-assembler.cc:    HandleLoadICHandlerCase(&lazy_p, var_handler.value(), &miss, &direct_exit);
ic/accessor-assembler.cc:    Comment("LoadIC_try_polymorphic");
ic/accessor-assembler.cc:    LoadIC_Noninlined(p, lookup_start_object_map, strong_feedback, &var_handler,
ic/accessor-assembler.cc:    Comment("LoadIC_nofeedback");
ic/accessor-assembler.cc:    // Call into the stub that implements the non-inlined parts of LoadIC.
ic/accessor-assembler.cc:    direct_exit.ReturnCallBuiltin(Builtin::kLoadIC_NoFeedback, p->context(),
ic/accessor-assembler.cc:  direct_exit.ReturnCallRuntime(Runtime::kLoadIC_Miss, p->context(),
ic/accessor-assembler.cc:void AccessorAssembler::LoadSuperIC(const LoadICParameters* p) {
ic/accessor-assembler.cc:    LazyLoadICParameters lazy_p(p);
ic/accessor-assembler.cc:    HandleLoadICHandlerCase(&lazy_p, var_handler.value(), &miss, &direct_exit);
ic/accessor-assembler.cc:    // LoadIC_Noninlined can be used here, since it handles the
ic/accessor-assembler.cc:    LoadIC_Noninlined(p, lookup_start_object_map, strong_feedback, &var_handler,
ic/accessor-assembler.cc:void AccessorAssembler::LoadIC_Noninlined(const LoadICParameters* p,
ic/accessor-assembler.cc:void AccessorAssembler::LoadIC_NoFeedback(const LoadICParameters* p,
ic/accessor-assembler.cc:void AccessorAssembler::LoadSuperIC_NoFeedback(const LoadICParameters* p) {
ic/accessor-assembler.cc:  LazyLoadICParameters p(|=] { return context; }, receiver, lazy_name,
ic/accessor-assembler.cc:  HandleLoadICHandlerCase(&p, handler, miss, exit_point, ICMode::kGlobalIC,
ic/accessor-assembler.cc:  TailCallBuiltin(Builtin::kLoadIC_NoFeedback, context, global_object, name,
ic/accessor-assembler.cc:void AccessorAssembler::KeyedLoadIC(const LoadICParameters* p,
ic/accessor-assembler.cc:    LazyLoadICParameters lazy_p(p);
ic/accessor-assembler.cc:    HandleLoadICHandlerCase(
ic/accessor-assembler.cc:    Comment("KeyedLoadIC_try_polymorphic");
ic/accessor-assembler.cc:    Comment("KeyedLoadIC_try_megamorphic");
ic/accessor-assembler.cc:        access_mode == LoadAccessMode::kLoad ? Builtin::kKeyedLoadIC_Megamorphic
ic/accessor-assembler.cc:    Comment("KeyedLoadIC_try_uninitialized");
ic/accessor-assembler.cc:    Comment("KeyedLoadIC_try_polymorphic_name");
ic/accessor-assembler.cc:                          ? Builtin::kKeyedLoadIC_PolymorphicName
ic/accessor-assembler.cc:    Comment("KeyedLoadIC_miss");
ic/accessor-assembler.cc:        access_mode == LoadAccessMode::kLoad ? Runtime::kKeyedLoadIC_Miss
ic/accessor-assembler.cc:void AccessorAssembler::KeyedLoadICGeneric(const LoadICParameters* p) {
ic/accessor-assembler.cc:      LoadICParameters pp(p, var_unique.value());
ic/accessor-assembler.cc:          LoadICParameters pp(p, var_unique.value());
ic/accessor-assembler.cc:void AccessorAssembler::KeyedLoadICPolymorphicName(const LoadICParameters* p,
ic/accessor-assembler.cc:  // LoadIC handler logic below.
ic/accessor-assembler.cc:    LazyLoadICParameters lazy_p(p);
ic/accessor-assembler.cc:    HandleLoadICHandlerCase(
ic/accessor-assembler.cc:    Comment("KeyedLoadIC_miss");
ic/accessor-assembler.cc:        access_mode == LoadAccessMode::kLoad ? Runtime::kKeyedLoadIC_Miss
ic/accessor-assembler.cc:void AccessorAssembler::StoreIC(const StoreICParameters* p) {
ic/accessor-assembler.cc:    Comment("StoreIC_if_handler");
ic/accessor-assembler.cc:    HandleStoreICHandlerCase(p, var_handler.value(), &miss,
ic/accessor-assembler.cc:    Comment("StoreIC_try_polymorphic");
ic/accessor-assembler.cc:    // TODO(v8:12548): refactor SetNamedIC as a subclass of StoreIC, which can
ic/accessor-assembler.cc:                                         : Builtin::kStoreIC_NoFeedback;
ic/accessor-assembler.cc:                                         : Runtime::kStoreIC_Miss;
ic/accessor-assembler.cc:void AccessorAssembler::StoreGlobalIC(const StoreICParameters* pp) {
ic/accessor-assembler.cc:      StoreICParameters p(
ic/accessor-assembler.cc:          StoreICMode::kDefault);
ic/accessor-assembler.cc:      HandleStoreICHandlerCase(&p, handler, &miss, ICMode::kGlobalIC);
ic/accessor-assembler.cc:void AccessorAssembler::KeyedStoreIC(const StoreICParameters* p) {
ic/accessor-assembler.cc:      Comment("KeyedStoreIC_if_handler");
ic/accessor-assembler.cc:      HandleStoreICHandlerCase(p, var_handler.value(), &miss,
ic/accessor-assembler.cc:      Comment("KeyedStoreIC_try_polymorphic");
ic/accessor-assembler.cc:      Comment("KeyedStoreIC_try_megamorphic");
ic/accessor-assembler.cc:      TailCallBuiltin(Builtin::kKeyedStoreIC_Megamorphic, p->context(),
ic/accessor-assembler.cc:      Comment("KeyedStoreIC_try_polymorphic_name");
ic/accessor-assembler.cc:    Comment("KeyedStoreIC_miss");
ic/accessor-assembler.cc:    TailCallRuntime(Runtime::kKeyedStoreIC_Miss, p->context(), p->value(),
ic/accessor-assembler.cc:void AccessorAssembler::DefineKeyedOwnIC(const StoreICParameters* p) {
ic/accessor-assembler.cc:      // StoreICParameters flags and have builtins:kDefineKeyedOwnIC reusing
ic/accessor-assembler.cc:      HandleStoreICHandlerCase(p, var_handler.value(), &miss,
ic/accessor-assembler.cc:void AccessorAssembler::StoreInArrayLiteralIC(const StoreICParameters* p) {
ic/accessor-assembler.cc:      // This is a stripped-down version of HandleStoreICHandlerCase.
ic/accessor-assembler.cc:void AccessorAssembler::GenerateLoadIC() {
ic/accessor-assembler.cc:  LoadICParameters p(context, receiver, name, slot, vector);
ic/accessor-assembler.cc:  LoadIC(&p);
ic/accessor-assembler.cc:void AccessorAssembler::GenerateLoadIC_Megamorphic() {
ic/accessor-assembler.cc:  LazyLoadICParameters p(
ic/accessor-assembler.cc:  HandleLoadICHandlerCase(&p, var_handler.value(), &miss, &direct_exit);
ic/accessor-assembler.cc:  direct_exit.ReturnCallRuntime(Runtime::kLoadIC_Miss, context, receiver, name,
ic/accessor-assembler.cc:void AccessorAssembler::GenerateLoadIC_Noninlined() {
ic/accessor-assembler.cc:  LoadICParameters p(context, receiver, name, slot, vector);
ic/accessor-assembler.cc:  LoadIC_Noninlined(&p, lookup_start_object_map, feedback, &var_handler,
ic/accessor-assembler.cc:    LazyLoadICParameters lazy_p(&p);
ic/accessor-assembler.cc:    HandleLoadICHandlerCase(&lazy_p, var_handler.value(), &miss, &direct_exit);
ic/accessor-assembler.cc:  direct_exit.ReturnCallRuntime(Runtime::kLoadIC_Miss, context, receiver, name,
ic/accessor-assembler.cc:void AccessorAssembler::GenerateLoadIC_NoFeedback() {
ic/accessor-assembler.cc:  LoadICParameters p(context, receiver, name,
ic/accessor-assembler.cc:  LoadIC_NoFeedback(&p, ic_kind);
ic/accessor-assembler.cc:void AccessorAssembler::GenerateLoadICTrampoline() {
ic/accessor-assembler.cc:  TailCallBuiltin(Builtin::kLoadIC, context, receiver, name, slot, vector);
ic/accessor-assembler.cc:void AccessorAssembler::GenerateLoadICBaseline() {
ic/accessor-assembler.cc:  TailCallBuiltin(Builtin::kLoadIC, context, receiver, name, slot, vector);
ic/accessor-assembler.cc:void AccessorAssembler::GenerateLoadICTrampoline_Megamorphic() {
ic/accessor-assembler.cc:  TailCallBuiltin(Builtin::kLoadIC_Megamorphic, context, receiver, name, slot,
ic/accessor-assembler.cc:  LoadICParameters p(context, receiver, name, slot, vector,
ic/accessor-assembler.cc:void AccessorAssembler::GenerateKeyedLoadIC() {
ic/accessor-assembler.cc:  LoadICParameters p(context, receiver, name, slot, vector);
ic/accessor-assembler.cc:  KeyedLoadIC(&p, LoadAccessMode::kLoad);
ic/accessor-assembler.cc:void AccessorAssembler::GenerateEnumeratedKeyedLoadIC() {
ic/accessor-assembler.cc:  LoadICParameters p(context, receiver, name, slot, vector, lookup_start_object,
ic/accessor-assembler.cc:  KeyedLoadIC(&p, LoadAccessMode::kLoad);
ic/accessor-assembler.cc:void AccessorAssembler::GenerateKeyedLoadIC_Megamorphic() {
ic/accessor-assembler.cc:  LoadICParameters p(context, receiver, name, slot, vector);
ic/accessor-assembler.cc:  KeyedLoadICGeneric(&p);
ic/accessor-assembler.cc:void AccessorAssembler::GenerateKeyedLoadICTrampoline() {
ic/accessor-assembler.cc:  TailCallBuiltin(Builtin::kKeyedLoadIC, context, receiver, name, slot, vector);
ic/accessor-assembler.cc:void AccessorAssembler::GenerateKeyedLoadICBaseline() {
ic/accessor-assembler.cc:  TailCallBuiltin(Builtin::kKeyedLoadIC, context, receiver, name, slot, vector);
ic/accessor-assembler.cc:void AccessorAssembler::GenerateEnumeratedKeyedLoadICBaseline() {
ic/accessor-assembler.cc:  TailCallBuiltin(Builtin::kEnumeratedKeyedLoadIC, context, receiver, name,
ic/accessor-assembler.cc:void AccessorAssembler::GenerateKeyedLoadICTrampoline_Megamorphic() {
ic/accessor-assembler.cc:  TailCallBuiltin(Builtin::kKeyedLoadIC_Megamorphic, context, receiver, name,
ic/accessor-assembler.cc:void AccessorAssembler::GenerateKeyedLoadIC_PolymorphicName() {
ic/accessor-assembler.cc:  LoadICParameters p(context, receiver, name, slot, vector);
ic/accessor-assembler.cc:  KeyedLoadICPolymorphicName(&p, LoadAccessMode::kLoad);
ic/accessor-assembler.cc:  StoreICParameters p(context, std::nullopt, name, value, flags, slot, vector,
ic/accessor-assembler.cc:                      StoreICMode::kDefault);
ic/accessor-assembler.cc:void AccessorAssembler::GenerateStoreIC() {
ic/accessor-assembler.cc:  StoreICParameters p(context, receiver, name, value, flags, slot, vector,
ic/accessor-assembler.cc:                      StoreICMode::kDefault);
ic/accessor-assembler.cc:  StoreIC(&p);
ic/accessor-assembler.cc:void AccessorAssembler::GenerateStoreIC_Megamorphic() {
ic/accessor-assembler.cc:    StoreICParameters p(context, receiver, name, value, flags, slot, vector,
ic/accessor-assembler.cc:                        StoreICMode::kDefault);
ic/accessor-assembler.cc:    HandleStoreICHandlerCase(&p, var_handler.value(), &miss,
ic/accessor-assembler.cc:    direct_exit.ReturnCallRuntime(Runtime::kStoreIC_Miss, context, value, slot,
ic/accessor-assembler.cc:void AccessorAssembler::GenerateStoreICTrampoline() {
ic/accessor-assembler.cc:  TailCallBuiltin(Builtin::kStoreIC, context, receiver, name, value, slot,
ic/accessor-assembler.cc:void AccessorAssembler::GenerateStoreICTrampoline_Megamorphic() {
ic/accessor-assembler.cc:  TailCallBuiltin(Builtin::kStoreIC_Megamorphic, context, receiver, name, value,
ic/accessor-assembler.cc:void AccessorAssembler::GenerateStoreICBaseline() {
ic/accessor-assembler.cc:  TailCallBuiltin(Builtin::kStoreIC, context, receiver, name, value, slot,
ic/accessor-assembler.cc:  StoreICParameters p(context, receiver, name, value, flags, slot, vector,
ic/accessor-assembler.cc:                      StoreICMode::kDefineNamedOwn);
ic/accessor-assembler.cc:  // StoreIC is a generic helper than handle both set and define own
ic/accessor-assembler.cc:  StoreIC(&p);
ic/accessor-assembler.cc:void AccessorAssembler::GenerateKeyedStoreIC() {
ic/accessor-assembler.cc:  StoreICParameters p(context, receiver, name, value, flags, slot, vector,
ic/accessor-assembler.cc:                      StoreICMode::kDefault);
ic/accessor-assembler.cc:  KeyedStoreIC(&p);
ic/accessor-assembler.cc:void AccessorAssembler::GenerateKeyedStoreICTrampoline() {
ic/accessor-assembler.cc:  TailCallBuiltin(Builtin::kKeyedStoreIC, context, receiver, name, value, slot,
ic/accessor-assembler.cc:void AccessorAssembler::GenerateKeyedStoreICTrampoline_Megamorphic() {
ic/accessor-assembler.cc:  TailCallBuiltin(Builtin::kKeyedStoreIC_Megamorphic, context, receiver, name,
ic/accessor-assembler.cc:void AccessorAssembler::GenerateKeyedStoreICBaseline() {
ic/accessor-assembler.cc:  TailCallBuiltin(Builtin::kKeyedStoreIC, context, receiver, name, value, slot,
ic/accessor-assembler.cc:  StoreICParameters p(context, receiver, name, value, flags, slot, vector,
ic/accessor-assembler.cc:                      StoreICMode::kDefineKeyedOwn);
ic/accessor-assembler.cc:  StoreICParameters p(context, array, index, value, flags, slot, vector,
ic/accessor-assembler.cc:                      StoreICMode::kDefault);
ic/accessor-assembler.cc:  LoadICParameters p(context, receiver, name, slot, vector);
ic/accessor-assembler.cc:  KeyedLoadIC(&p, LoadAccessMode::kHas);
ic/accessor-assembler.cc:  // TODO(magardn): implement HasProperty handling in KeyedLoadICGeneric
ic/accessor-assembler.cc:  LoadICParameters p(context, receiver, name, slot, vector);
ic/accessor-assembler.cc:  KeyedLoadICPolymorphicName(&p, LoadAccessMode::kHas);
ic/handler-configuration-inl.h:      return BUILTIN_CODE(isolate, KeyedStoreIC_SloppyArguments_InBounds);
ic/handler-configuration-inl.h:          isolate, KeyedStoreIC_SloppyArguments_NoTransitionGrowAndHandleCOW);
ic/handler-configuration-inl.h:          KeyedStoreIC_SloppyArguments_NoTransitionIgnoreTypedArrayOOB);
ic/handler-configuration-inl.h:                          KeyedStoreIC_SloppyArguments_NoTransitionHandleCOW);
ic/accessor-assembler.h:  void GenerateLoadIC();
ic/accessor-assembler.h:  void GenerateLoadIC_Megamorphic();
ic/accessor-assembler.h:  void GenerateLoadIC_Noninlined();
ic/accessor-assembler.h:  void GenerateLoadIC_NoFeedback();
ic/accessor-assembler.h:  void GenerateLoadICTrampoline();
ic/accessor-assembler.h:  void GenerateLoadICBaseline();
ic/accessor-assembler.h:  void GenerateLoadICTrampoline_Megamorphic();
ic/accessor-assembler.h:  void GenerateKeyedLoadIC();
ic/accessor-assembler.h:  void GenerateEnumeratedKeyedLoadIC();
ic/accessor-assembler.h:  void GenerateKeyedLoadIC_Megamorphic();
ic/accessor-assembler.h:  void GenerateKeyedLoadIC_PolymorphicName();
ic/accessor-assembler.h:  void GenerateKeyedLoadICTrampoline();
ic/accessor-assembler.h:  void GenerateKeyedLoadICBaseline();
ic/accessor-assembler.h:  void GenerateEnumeratedKeyedLoadICBaseline();
ic/accessor-assembler.h:  void GenerateKeyedLoadICTrampoline_Megamorphic();
ic/accessor-assembler.h:  void GenerateStoreIC();
ic/accessor-assembler.h:  void GenerateStoreIC_Megamorphic();
ic/accessor-assembler.h:  void GenerateStoreICTrampoline();
ic/accessor-assembler.h:  void GenerateStoreICTrampoline_Megamorphic();
ic/accessor-assembler.h:  void GenerateStoreICBaseline();
ic/accessor-assembler.h:  void GenerateKeyedStoreIC();
ic/accessor-assembler.h:  void GenerateKeyedStoreICTrampoline();
ic/accessor-assembler.h:  void GenerateKeyedStoreICTrampoline_Megamorphic();
ic/accessor-assembler.h:  void GenerateKeyedStoreICBaseline();
ic/accessor-assembler.h:  struct LoadICParameters {
ic/accessor-assembler.h:    LoadICParameters(
ic/accessor-assembler.h:    LoadICParameters(const LoadICParameters* p, TNode<Object> unique_name)
ic/accessor-assembler.h:  struct LazyLoadICParameters {
ic/accessor-assembler.h:    LazyLoadICParameters(
ic/accessor-assembler.h:    explicit LazyLoadICParameters(const LoadICParameters* p)
ic/accessor-assembler.h:  // Specialized LoadIC for inlined bytecode handler, hand-tuned to omit frame
ic/accessor-assembler.h:  void LoadIC_BytecodeHandler(const LazyLoadICParameters* p,
ic/accessor-assembler.h:  enum class StoreICMode {
ic/accessor-assembler.h:  struct StoreICParameters {
ic/accessor-assembler.h:    StoreICParameters(TNode<Context> context,
ic/accessor-assembler.h:                      StoreICMode mode)
ic/accessor-assembler.h:      return mode_ == StoreICMode::kDefineNamedOwn;
ic/accessor-assembler.h:      return mode_ == StoreICMode::kDefineKeyedOwn;
ic/accessor-assembler.h:    StoreICMode mode_;
ic/accessor-assembler.h:  void HandleStoreICHandlerCase(
ic/accessor-assembler.h:      const StoreICParameters* p, TNode<MaybeObject> handler, Label* miss,
ic/accessor-assembler.h:  void HandleStoreICTransitionMapHandlerCase(const StoreICParameters* p,
ic/accessor-assembler.h:  // LoadIC contains the full LoadIC logic, while LoadIC_Noninlined contains
ic/accessor-assembler.h:  void LoadIC(const LoadICParameters* p);
ic/accessor-assembler.h:  void LoadIC_Noninlined(const LoadICParameters* p,
ic/accessor-assembler.h:  void LoadSuperIC(const LoadICParameters* p);
ic/accessor-assembler.h:  void LoadIC_NoFeedback(const LoadICParameters* p, TNode<Smi> smi_typeof_mode);
ic/accessor-assembler.h:  void LoadSuperIC_NoFeedback(const LoadICParameters* p);
ic/accessor-assembler.h:  void KeyedLoadIC(const LoadICParameters* p, LoadAccessMode access_mode);
ic/accessor-assembler.h:  void KeyedLoadICGeneric(const LoadICParameters* p);
ic/accessor-assembler.h:  void KeyedLoadICPolymorphicName(const LoadICParameters* p,
ic/accessor-assembler.h:  void StoreIC(const StoreICParameters* p);
ic/accessor-assembler.h:  void StoreGlobalIC(const StoreICParameters* p);
ic/accessor-assembler.h:  void KeyedStoreIC(const StoreICParameters* p);
ic/accessor-assembler.h:  void DefineKeyedOwnIC(const StoreICParameters* p);
ic/accessor-assembler.h:  void StoreInArrayLiteralIC(const StoreICParameters* p);
ic/accessor-assembler.h:  void TryEnumeratedKeyedLoad(const LoadICParameters* p,
ic/accessor-assembler.h:  // LoadIC implementation.
ic/accessor-assembler.h:  void HandleLoadICHandlerCase(
ic/accessor-assembler.h:      const LazyLoadICParameters* p, TNode<MaybeObject> handler, Label* miss,
ic/accessor-assembler.h:  void HandleLoadICSmiHandlerCase(const LazyLoadICParameters* p,
ic/accessor-assembler.h:  void HandleLoadICProtoHandler(const LazyLoadICParameters* p,
ic/accessor-assembler.h:  void HandleLoadCallbackProperty(const LazyLoadICParameters* p,
ic/accessor-assembler.h:  void HandleLoadAccessor(const LazyLoadICParameters* p,
ic/accessor-assembler.h:  void HandleLoadICSmiHandlerLoadNamedCase(
ic/accessor-assembler.h:      const LazyLoadICParameters* p, TNode<Object> holder,
ic/accessor-assembler.h:  void HandleLoadICSmiHandlerHasNamedCase(const LazyLoadICParameters* p,
ic/accessor-assembler.h:  // StoreIC implementation.
ic/accessor-assembler.h:  void HandleStoreICProtoHandler(const StoreICParameters* p,
ic/accessor-assembler.h:  void HandleStoreICSmiHandlerCase(TNode<Word32T> handler_word,
ic/accessor-assembler.h:  void HandleStoreICSmiHandlerJSSharedStructFieldCase(
ic/accessor-assembler.h:  void HandleStoreICNativeDataProperty(const StoreICParameters* p,
ic/accessor-assembler.h:  void HandleStoreToProxy(const StoreICParameters* p, TNode<JSProxy> proxy,
ic/accessor-assembler.h:  // KeyedLoadIC_Generic implementation.
ic/accessor-assembler.h:                           const LoadICParameters* p, Label* slow,
ic/ic.cc:  } else if (IsKeyedLoadIC()) {
ic/ic.cc:  } else if (IsKeyedStoreIC() || IsStoreInArrayLiteralIC() ||
ic/ic.cc:MaybeHandle<Object> LoadIC::Load(Handle<JSAny> object, Handle<Name> name,
ic/ic.cc:      TRACE_HANDLER_STATS(isolate(), LoadIC_NonReceiver);
ic/ic.cc:      TraceIC("LoadIC", name);
ic/ic.cc:                       : TraceIC("LoadIC", name);
ic/ic.cc:  return LoadIC::Load(global, name, update_feedback);
ic/ic.cc:  // TODO(gsathya): Support KeyedLoadIC, StoreIC and KeyedStoreIC.
ic/ic.cc:  if (!IsLoadIC()) return false;
ic/ic.cc:void LoadIC::UpdateCaches(LookupIterator* lookup) {
ic/ic.cc:      TRACE_HANDLER_STATS(isolate(), LoadIC_LoadNonexistentDH);
ic/ic.cc:  TraceIC("LoadIC", lookup->GetName());
ic/ic.cc:MaybeObjectHandle LoadIC::ComputeHandler(LookupIterator* lookup) {
ic/ic.cc:      TRACE_HANDLER_STATS(isolate(), LoadIC_StringLength);
ic/ic.cc:      return MaybeObjectHandle(BUILTIN_CODE(isolate(), LoadIC_StringLength));
ic/ic.cc:      TRACE_HANDLER_STATS(isolate(), LoadIC_StringWrapperLength);
ic/ic.cc:          BUILTIN_CODE(isolate(), LoadIC_StringWrapperLength));
ic/ic.cc:      TRACE_HANDLER_STATS(isolate(), LoadIC_FunctionPrototypeStub);
ic/ic.cc:          BUILTIN_CODE(isolate(), LoadIC_FunctionPrototype));
ic/ic.cc:        TRACE_HANDLER_STATS(isolate(), LoadIC_LoadNonMaskingInterceptorDH);
ic/ic.cc:        TRACE_HANDLER_STATS(isolate(), LoadIC_LoadInterceptorDH);
ic/ic.cc:      TRACE_HANDLER_STATS(isolate(), LoadIC_LoadInterceptorFromPrototypeDH);
ic/ic.cc:        TRACE_HANDLER_STATS(isolate(), LoadIC_LoadFieldDH);
ic/ic.cc:          TRACE_HANDLER_STATS(isolate(), LoadIC_SlowStub);
ic/ic.cc:          TRACE_HANDLER_STATS(isolate(), LoadIC_SlowStub);
ic/ic.cc:            TRACE_HANDLER_STATS(isolate(), LoadIC_SlowStub);
ic/ic.cc:          TRACE_HANDLER_STATS(isolate(), LoadIC_LoadApiGetterFromPrototypeDH);
ic/ic.cc:            TRACE_HANDLER_STATS(isolate(), LoadIC_LoadAccessorDH);
ic/ic.cc:          TRACE_HANDLER_STATS(isolate(), LoadIC_LoadAccessorFromPrototypeDH);
ic/ic.cc:          TRACE_HANDLER_STATS(isolate(), LoadIC_LoadGlobalFromPrototypeDH);
ic/ic.cc:          TRACE_HANDLER_STATS(isolate(), LoadIC_LoadNormalDH);
ic/ic.cc:          TRACE_HANDLER_STATS(isolate(), LoadIC_LoadNormalFromPrototypeDH);
ic/ic.cc:        TRACE_HANDLER_STATS(isolate(), LoadIC_SlowStub);
ic/ic.cc:        TRACE_HANDLER_STATS(isolate(), LoadIC_SlowStub);
ic/ic.cc:      TRACE_HANDLER_STATS(isolate(), LoadIC_LoadNativeDataPropertyDH);
ic/ic.cc:                          LoadIC_LoadNativeDataPropertyFromPrototypeDH);
ic/ic.cc:          TRACE_HANDLER_STATS(isolate(), LoadIC_LoadGlobalDH);
ic/ic.cc:        TRACE_HANDLER_STATS(isolate(), LoadIC_LoadNormalDH);
ic/ic.cc:        TRACE_HANDLER_STATS(isolate(), LoadIC_LoadNormalFromPrototypeDH);
ic/ic.cc:        TRACE_HANDLER_STATS(isolate(), LoadIC_SlowStub);
ic/ic.cc:        TRACE_HANDLER_STATS(isolate(), LoadIC_LoadFieldDH);
ic/ic.cc:        TRACE_HANDLER_STATS(isolate(), LoadIC_LoadFieldFromPrototypeDH);
ic/ic.cc:          TRACE_HANDLER_STATS(isolate(), LoadIC_LoadConstantFromPrototypeDH);
ic/ic.cc:      TRACE_HANDLER_STATS(isolate(), LoadIC_LoadIntegerIndexedExoticDH);
ic/ic.cc:KeyedAccessLoadMode KeyedLoadIC::GetKeyedAccessLoadModeFor(
ic/ic.cc:void KeyedLoadIC::UpdateLoadElement(DirectHandle<HeapObject> receiver,
ic/ic.cc:Handle<Object> KeyedLoadIC::LoadElementHandler(
ic/ic.cc:    TRACE_HANDLER_STATS(isolate(), KeyedLoadIC_LoadIndexedInterceptorStub);
ic/ic.cc:    TRACE_HANDLER_STATS(isolate(), KeyedLoadIC_LoadIndexedStringDH);
ic/ic.cc:    TRACE_HANDLER_STATS(isolate(), KeyedLoadIC_SlowStub);
ic/ic.cc:    TRACE_HANDLER_STATS(isolate(), KeyedLoadIC_SlowStub);
ic/ic.cc:    TRACE_HANDLER_STATS(isolate(), KeyedLoadIC_KeyedLoadSloppyArgumentsStub);
ic/ic.cc:                      : BUILTIN_CODE(isolate(), KeyedLoadIC_SloppyArguments);
ic/ic.cc:    TRACE_HANDLER_STATS(isolate(), KeyedLoadIC_LoadElementDH);
ic/ic.cc:  TRACE_HANDLER_STATS(isolate(), KeyedLoadIC_LoadElementDH);
ic/ic.cc:void KeyedLoadIC::LoadElementPolymorphicHandlers(
ic/ic.cc:MaybeHandle<Object> KeyedLoadIC::RuntimeLoad(DirectHandle<JSAny> object,
ic/ic.cc:  if (IsKeyedLoadIC()) {
ic/ic.cc:MaybeHandle<Object> KeyedLoadIC::LoadName(Handle<JSAny> object,
ic/ic.cc:                             LoadIC::Load(object, name));
ic/ic.cc:    TraceIC("LoadIC", key);
ic/ic.cc:MaybeHandle<Object> KeyedLoadIC::Load(Handle<JSAny> object,
ic/ic.cc:      TraceIC("LoadIC", key);
ic/ic.cc:    TraceIC("LoadIC", key);
ic/ic.cc:bool StoreIC::LookupForWrite(LookupIterator* it, DirectHandle<Object> value,
ic/ic.cc:  return StoreIC::Store(global, name, value);
ic/ic.cc:MaybeHandle<Object> StoreIC::Store(Handle<JSAny> object, Handle<Name> name,
ic/ic.cc:    // KeyedStoreIC should handle DefineKeyedOwnIC with deprecated maps directly
ic/ic.cc:      TRACE_HANDLER_STATS(isolate(), StoreIC_NonReceiver);
ic/ic.cc:      TraceIC("StoreIC", name);
ic/ic.cc:                      : TraceIC("StoreIC", name);
ic/ic.cc:  // of StoreIC so their logic doesn't get mixed here.
ic/ic.cc:  // IsAnyDefineOwn() can be true when this method is reused by KeyedStoreIC.
ic/ic.cc:void StoreIC::UpdateCaches(LookupIterator* lookup, DirectHandle<Object> value,
ic/ic.cc:  TraceIC("StoreIC", lookup->GetName());
ic/ic.cc:MaybeObjectHandle StoreIC::ComputeHandler(LookupIterator* lookup) {
ic/ic.cc:        TRACE_HANDLER_STATS(isolate(), StoreIC_StoreGlobalTransitionDH);
ic/ic.cc:          TRACE_HANDLER_STATS(isolate(), StoreIC_SlowStub);
ic/ic.cc:      // This is currently guaranteed by checks in StoreIC::Store.
ic/ic.cc:        TRACE_HANDLER_STATS(isolate(), StoreIC_SlowStub);
ic/ic.cc:        TRACE_HANDLER_STATS(isolate(), StoreIC_SlowStub);
ic/ic.cc:          TRACE_HANDLER_STATS(isolate(), StoreIC_SlowStub);
ic/ic.cc:          TRACE_HANDLER_STATS(isolate(), StoreIC_SlowStub);
ic/ic.cc:        TRACE_HANDLER_STATS(isolate(), StoreIC_StoreNativeDataPropertyDH);
ic/ic.cc:                            StoreIC_StoreNativeDataPropertyOnPrototypeDH);
ic/ic.cc:          TRACE_HANDLER_STATS(isolate(), StoreIC_SlowStub);
ic/ic.cc:          TRACE_HANDLER_STATS(isolate(), StoreIC_SlowStub);
ic/ic.cc:            TRACE_HANDLER_STATS(isolate(), StoreIC_StoreApiSetterOnPrototypeDH);
ic/ic.cc:          TRACE_HANDLER_STATS(isolate(), StoreIC_SlowStub);
ic/ic.cc:          TRACE_HANDLER_STATS(isolate(), StoreIC_SlowStub);
ic/ic.cc:          TRACE_HANDLER_STATS(isolate(), StoreIC_StoreAccessorDH);
ic/ic.cc:        TRACE_HANDLER_STATS(isolate(), StoreIC_StoreAccessorOnPrototypeDH);
ic/ic.cc:      TRACE_HANDLER_STATS(isolate(), StoreIC_SlowStub);
ic/ic.cc:      // This is currently guaranteed by checks in StoreIC::Store.
ic/ic.cc:          TRACE_HANDLER_STATS(isolate(), StoreIC_StoreGlobalDH);
ic/ic.cc:        TRACE_HANDLER_STATS(isolate(), StoreIC_StoreNormalDH);
ic/ic.cc:        TRACE_HANDLER_STATS(isolate(), StoreIC_SlowStub);
ic/ic.cc:        TRACE_HANDLER_STATS(isolate(), StoreIC_StoreFieldDH);
ic/ic.cc:      TRACE_HANDLER_STATS(isolate(), StoreIC_SlowStub);
ic/ic.cc:        TRACE_HANDLER_STATS(isolate(), StoreIC_SlowStub);
ic/ic.cc:void KeyedStoreIC::UpdateStoreElement(Handle<Map> receiver_map,
ic/ic.cc:Handle<Object> KeyedStoreIC::StoreElementHandler(
ic/ic.cc:    TRACE_HANDLER_STATS(isolate(), KeyedStoreIC_SlowStub);
ic/ic.cc:    TRACE_HANDLER_STATS(isolate(), KeyedStoreIC_KeyedStoreSloppyArgumentsStub);
ic/ic.cc:    TRACE_HANDLER_STATS(isolate(), KeyedStoreIC_StoreFastElementStub);
ic/ic.cc:    TRACE_HANDLER_STATS(isolate(), KeyedStoreIC_StoreElementStub);
ic/ic.cc:void KeyedStoreIC::StoreElementPolymorphicHandlers(
ic/ic.cc:      TRACE_HANDLER_STATS(isolate(), KeyedStoreIC_SlowStub);
ic/ic.cc:                            KeyedStoreIC_ElementsTransitionAndStoreStub);
ic/ic.cc:MaybeHandle<Object> KeyedStoreIC::Store(Handle<JSAny> object,
ic/ic.cc:    // TODO(v8:12548): refactor DefineKeyedOwnIC as a subclass of StoreIC
ic/ic.cc:        StoreIC::Store(object, maybe_name, value, StoreOrigin::kMaybeKeyed));
ic/ic.cc:        TraceIC("StoreIC", key);
ic/ic.cc:  // TODO(v8:12548): refactor DefineKeyedOwnIC as a subclass of StoreIC
ic/ic.cc:  TraceIC("StoreIC", key);
ic/ic.cc:RUNTIME_FUNCTION(Runtime_LoadIC_Miss) {
ic/ic.cc:  // A monomorphic or polymorphic KeyedLoadIC with a string key can call the
ic/ic.cc:  // LoadIC miss handler if the handler misses. Since the vector Nexus is
ic/ic.cc:  if (IsLoadICKind(kind)) {
ic/ic.cc:    LoadIC ic(isolate, vector, vector_slot, kind);
ic/ic.cc:    DCHECK(IsKeyedLoadICKind(kind));
ic/ic.cc:    KeyedLoadIC ic(isolate, vector, vector_slot, kind);
ic/ic.cc:  // it is safe to call LoadIC::Load for global loads as well.
ic/ic.cc:  LoadIC ic(isolate, vector, vector_slot, kind);
ic/ic.cc:  LoadIC ic(isolate, vector, vector_slot, FeedbackSlotKind::kLoadProperty);
ic/ic.cc:  DCHECK(IsLoadICKind(vector->GetKind(vector_slot)));
ic/ic.cc:  LoadIC ic(isolate, vector, vector_slot, FeedbackSlotKind::kLoadProperty);
ic/ic.cc:RUNTIME_FUNCTION(Runtime_KeyedLoadIC_Miss) {
ic/ic.cc:  KeyedLoadIC ic(isolate, vector, vector_slot, FeedbackSlotKind::kLoadKeyed);
ic/ic.cc:RUNTIME_FUNCTION(Runtime_StoreIC_Miss) {
ic/ic.cc:  StoreIC ic(isolate, vector, vector_slot, kind);
ic/ic.cc:  // TODO(v8:12548): refactor DefineNamedOwnIC as a subclass of StoreIC, which
ic/ic.cc:  StoreIC ic(isolate, vector, vector_slot, kind);
ic/ic.cc:RUNTIME_FUNCTION(Runtime_KeyedStoreIC_Miss) {
ic/ic.cc:  // TODO(v8:12548): refactor DefineKeyedOwnIC as a subclass of KeyedStoreIC,
ic/ic.cc:  if (IsKeyedStoreICKind(kind) || IsDefineKeyedOwnICKind(kind)) {
ic/ic.cc:    KeyedStoreIC ic(isolate, vector, vector_slot, kind);
ic/ic.cc:  // TODO(v8:12548): refactor DefineKeyedOwnIC as a subclass of KeyedStoreIC,
ic/ic.cc:  KeyedStoreIC ic(isolate, vector, vector_slot, kind);
ic/ic.cc:RUNTIME_FUNCTION(Runtime_KeyedStoreIC_Slow) {
ic/ic.cc:RUNTIME_FUNCTION(Runtime_ElementsTransitionAndStoreIC_Miss) {
ic/ic.cc:    DCHECK(IsKeyedStoreICKind(kind) || IsSetNamedICKind(kind) ||
ic/ic.cc:  if (!LoadIC::ShouldThrowReferenceError(slot_kind)) {
ic/ic.cc:    // Stores initiated by StoreICs don't care about the exact result of
ic/ic.cc:  KeyedLoadIC ic(isolate, vector, vector_slot, FeedbackSlotKind::kHasKeyed);
compiler/turboshaft/maglev-graph-building-phase.cc:    GENERATE_AND_MAP_BUILTIN_CALL(node, Builtin::kKeyedStoreIC, frame_state,
compiler/turboshaft/maglev-graph-building-phase.cc:    GENERATE_AND_MAP_BUILTIN_CALL(node, Builtin::kKeyedLoadIC, frame_state,
compiler/turboshaft/maglev-graph-building-phase.cc:    GENERATE_AND_MAP_BUILTIN_CALL(node, Builtin::kStoreIC, frame_state,
compiler/turboshaft/maglev-graph-building-phase.cc:    GENERATE_AND_MAP_BUILTIN_CALL(node, Builtin::kLoadIC, frame_state,
[Step 9: Duration 10.47 seconds| Input tokens: 128,202 | Output tokens: 1,975]
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ Step 10 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'ripgrep' with arguments: {'pattern': 'AccessInfoFactory|AccessInfo::|AccessInfoFactory::', 'options': ''}                                                               │
╰────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
Command: cd /Users/tarun/v8/v8/src && rg 'AccessInfoFactory|AccessInfo::|AccessInfoFactory::' | head -n 1000
Observations: compiler/js-call-reducer.cc:  AccessInfoFactory access_info_factory(broker(), graph()->zone());
compiler/compilation-dependencies.cc:      // AccessInfoFactory::ComputePropertyAccessInfo allows.
compiler/compilation-dependencies.cc:    // Note: Keep sync'd with AccessInfoFactory::ComputePropertyAccessInfo.
compiler/js-heap-broker.cc:  AccessInfoFactory factory(this, zone());
compiler/property-access-builder.cc:    // Non-JSReceivers that passed AccessInfoFactory::ComputePropertyAccessInfo
compiler/js-native-context-specialization.cc:  AccessInfoFactory access_info_factory(broker(), graph()->zone());
compiler/js-native-context-specialization.cc:    AccessInfoFactory access_info_factory(broker(), graph()->zone());
compiler/js-native-context-specialization.cc:  AccessInfoFactory access_info_factory(broker(), graph()->zone());
compiler/access-info.h:class AccessInfoFactory final {
compiler/access-info.h:  AccessInfoFactory(JSHeapBroker* broker, Zone* zone);
compiler/access-info.h:    return PropertyAccessInfo::Invalid(zone());
compiler/access-info.h:  AccessInfoFactory(const AccessInfoFactory&) = delete;
compiler/access-info.h:  AccessInfoFactory& operator=(const AccessInfoFactory&) = delete;
compiler/access-info.cc:ElementAccessInfo::ElementAccessInfo(
compiler/access-info.cc:PropertyAccessInfo PropertyAccessInfo::Invalid(Zone* zone) {
compiler/access-info.cc:PropertyAccessInfo PropertyAccessInfo::NotFound(Zone* zone, MapRef receiver_map,
compiler/access-info.cc:PropertyAccessInfo PropertyAccessInfo::DataField(
compiler/access-info.cc:PropertyAccessInfo PropertyAccessInfo::FastDataConstant(
compiler/access-info.cc:PropertyAccessInfo PropertyAccessInfo::FastAccessorConstant(
compiler/access-info.cc:PropertyAccessInfo PropertyAccessInfo::ModuleExport(Zone* zone,
compiler/access-info.cc:PropertyAccessInfo PropertyAccessInfo::StringLength(Zone* zone,
compiler/access-info.cc:PropertyAccessInfo PropertyAccessInfo::StringWrapperLength(
compiler/access-info.cc:PropertyAccessInfo PropertyAccessInfo::DictionaryProtoDataConstant(
compiler/access-info.cc:PropertyAccessInfo PropertyAccessInfo::DictionaryProtoAccessorConstant(
compiler/access-info.cc:PropertyAccessInfo::PropertyAccessInfo(Zone* zone)
compiler/access-info.cc:PropertyAccessInfo::PropertyAccessInfo(
compiler/access-info.cc:PropertyAccessInfo::PropertyAccessInfo(
compiler/access-info.cc:PropertyAccessInfo::PropertyAccessInfo(
compiler/access-info.cc:PropertyAccessInfo::PropertyAccessInfo(
compiler/access-info.cc:bool PropertyAccessInfo::Merge(PropertyAccessInfo const* that,
compiler/access-info.cc:ConstFieldInfo PropertyAccessInfo::GetConstFieldInfo() const {
compiler/access-info.cc:AccessInfoFactory::AccessInfoFactory(JSHeapBroker* broker, Zone* zone)
compiler/access-info.cc:std::optional<ElementAccessInfo> AccessInfoFactory::ComputeElementAccessInfo(
compiler/access-info.cc:bool AccessInfoFactory::ComputeElementAccessInfos(
compiler/access-info.cc:PropertyAccessInfo AccessInfoFactory::ComputeDataFieldAccessInfo(
compiler/access-info.cc:      return PropertyAccessInfo::DataField(
compiler/access-info.cc:      return PropertyAccessInfo::FastDataConstant(
compiler/access-info.cc:    const AccessInfoFactory* ai_factory, MapRef receiver_map, NameRef name,
compiler/access-info.cc:      return PropertyAccessInfo::Invalid(zone);
compiler/access-info.cc:      return PropertyAccessInfo::Invalid(zone);
compiler/access-info.cc:      return PropertyAccessInfo::Invalid(zone);
compiler/access-info.cc:    return PropertyAccessInfo::ModuleExport(zone, receiver_map,
compiler/access-info.cc:    return PropertyAccessInfo::FastAccessorConstant(zone, receiver_map, holder,
compiler/access-info.cc:    return PropertyAccessInfo::Invalid(zone);
compiler/access-info.cc:  if (!accessor_ref.has_value()) return PropertyAccessInfo::Invalid(zone);
compiler/access-info.cc:      return PropertyAccessInfo::Invalid(zone);
compiler/access-info.cc:      return PropertyAccessInfo::Invalid(zone);
compiler/access-info.cc:      if (!api_holder_ref.has_value()) return PropertyAccessInfo::Invalid(zone);
compiler/access-info.cc:    return PropertyAccessInfo::DictionaryProtoAccessorConstant(
compiler/access-info.cc:    return PropertyAccessInfo::FastAccessorConstant(
compiler/access-info.cc:PropertyAccessInfo AccessInfoFactory::ComputeAccessorDescriptorAccessInfo(
compiler/access-info.cc:PropertyAccessInfo AccessInfoFactory::ComputeDictionaryProtoAccessInfo(
compiler/access-info.cc:    return PropertyAccessInfo::DictionaryProtoDataConstant(
compiler/access-info.cc:bool AccessInfoFactory::TryLoadPropertyDetails(
compiler/access-info.cc:PropertyAccessInfo AccessInfoFactory::ComputePropertyAccessInfo(
compiler/access-info.cc:      return PropertyAccessInfo::NotFound(zone(), receiver_map, holder);
compiler/access-info.cc:    // AccessInfoFactory.
compiler/access-info.cc:PropertyAccessInfo AccessInfoFactory::FinalizePropertyAccessInfosAsOne(
compiler/access-info.cc:void PropertyAccessInfo::RecordDependencies(
compiler/access-info.cc:bool AccessInfoFactory::FinalizePropertyAccessInfos(
compiler/access-info.cc:void AccessInfoFactory::MergePropertyAccessInfos(
compiler/access-info.cc:CompilationDependencies* AccessInfoFactory::dependencies() const {
compiler/access-info.cc:Isolate* AccessInfoFactory::isolate() const { return broker()->isolate(); }
compiler/access-info.cc:std::optional<ElementAccessInfo> AccessInfoFactory::ConsolidateElementLoad(
compiler/access-info.cc:PropertyAccessInfo AccessInfoFactory::LookupSpecialFieldAccessor(
compiler/access-info.cc:      return PropertyAccessInfo::StringLength(zone(), map);
compiler/access-info.cc:      return PropertyAccessInfo::StringWrapperLength(zone(), map);
compiler/access-info.cc:    return PropertyAccessInfo::DataField(broker(), zone(), map, {{}, zone()},
compiler/access-info.cc:PropertyAccessInfo AccessInfoFactory::LookupTransition(
compiler/access-info.cc:      return PropertyAccessInfo::DataField(
compiler/access-info.cc:      return PropertyAccessInfo::FastDataConstant(
maglev/maglev-graph-builder.cc:    // Non-JSReceivers that passed AccessInfoFactory::ComputePropertyAccessInfo
maglev/maglev-graph-builder.cc:    case compiler::PropertyAccessInfo::kInvalid:
maglev/maglev-graph-builder.cc:    case compiler::PropertyAccessInfo::kNotFound:
maglev/maglev-graph-builder.cc:    case compiler::PropertyAccessInfo::kDataField:
maglev/maglev-graph-builder.cc:    case compiler::PropertyAccessInfo::kFastDataConstant: {
maglev/maglev-graph-builder.cc:    case compiler::PropertyAccessInfo::kDictionaryProtoDataConstant: {
maglev/maglev-graph-builder.cc:    case compiler::PropertyAccessInfo::kFastAccessorConstant:
maglev/maglev-graph-builder.cc:    case compiler::PropertyAccessInfo::kDictionaryProtoAccessorConstant:
maglev/maglev-graph-builder.cc:    case compiler::PropertyAccessInfo::kModuleExport: {
maglev/maglev-graph-builder.cc:    case compiler::PropertyAccessInfo::kStringLength: {
maglev/maglev-graph-builder.cc:    case compiler::PropertyAccessInfo::kStringWrapperLength: {
maglev/maglev-graph-builder.cc:    case compiler::PropertyAccessInfo::kFastAccessorConstant: {
maglev/maglev-graph-builder.cc:    case compiler::PropertyAccessInfo::kDataField:
maglev/maglev-graph-builder.cc:    case compiler::PropertyAccessInfo::kFastDataConstant: {
maglev/maglev-graph-builder.cc:    case compiler::PropertyAccessInfo::kInvalid:
maglev/maglev-graph-builder.cc:    case compiler::PropertyAccessInfo::kNotFound:
maglev/maglev-graph-builder.cc:    case compiler::PropertyAccessInfo::kDictionaryProtoDataConstant:
maglev/maglev-graph-builder.cc:    case compiler::PropertyAccessInfo::kDictionaryProtoAccessorConstant:
maglev/maglev-graph-builder.cc:    case compiler::PropertyAccessInfo::kModuleExport:
maglev/maglev-graph-builder.cc:    case compiler::PropertyAccessInfo::kStringLength:
maglev/maglev-graph-builder.cc:    case compiler::PropertyAccessInfo::kStringWrapperLength:
maglev/maglev-graph-builder.cc:  compiler::AccessInfoFactory access_info_factory(broker(), zone());
maglev/maglev-graph-builder.cc:  compiler::AccessInfoFactory access_info_factory(broker(), zone());
[Step 10: Duration 9.09 seconds| Input tokens: 169,064 | Output tokens: 2,526]
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ Step 11 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'tree' with arguments: {'options': '-L 2 -f'}                                                                                                                            │
╰────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
Command: cd /Users/tarun/v8/v8/src && tree -L 2 -f | head -n 1000
Observations: .
├── ./api
│   ├── ./api/api-arguments-inl.h
│   ├── ./api/api-arguments.cc
│   ├── ./api/api-arguments.h
│   ├── ./api/api-inl.h
│   ├── ./api/api-macros-undef.h
│   ├── ./api/api-macros.h
│   ├── ./api/api-natives.cc
│   ├── ./api/api-natives.h
│   ├── ./api/api.cc
│   ├── ./api/api.h
│   ├── ./api/DIR_METADATA
│   └── ./api/OWNERS
├── ./asmjs
│   ├── ./asmjs/asm-js.cc
│   ├── ./asmjs/asm-js.h
│   ├── ./asmjs/asm-names.h
│   ├── ./asmjs/asm-parser.cc
│   ├── ./asmjs/asm-parser.h
│   ├── ./asmjs/asm-scanner.cc
│   ├── ./asmjs/asm-scanner.h
│   ├── ./asmjs/asm-types.cc
│   ├── ./asmjs/asm-types.h
│   ├── ./asmjs/DIR_METADATA
│   └── ./asmjs/OWNERS
├── ./ast
│   ├── ./ast/ast-function-literal-id-reindexer.cc
│   ├── ./ast/ast-function-literal-id-reindexer.h
│   ├── ./ast/ast-source-ranges.h
│   ├── ./ast/ast-traversal-visitor.h
│   ├── ./ast/ast-value-factory.cc
│   ├── ./ast/ast-value-factory.h
│   ├── ./ast/ast.cc
│   ├── ./ast/ast.h
│   ├── ./ast/DIR_METADATA
│   ├── ./ast/modules.cc
│   ├── ./ast/modules.h
│   ├── ./ast/OWNERS
│   ├── ./ast/prettyprinter.cc
│   ├── ./ast/prettyprinter.h
│   ├── ./ast/scopes.cc
│   ├── ./ast/scopes.h
│   ├── ./ast/source-range-ast-visitor.cc
│   ├── ./ast/source-range-ast-visitor.h
│   ├── ./ast/variables.cc
│   └── ./ast/variables.h
├── ./base
│   ├── ./base/abort-mode.cc
│   ├── ./base/abort-mode.h
│   ├── ./base/address-region.h
│   ├── ./base/atomic-utils.h
│   ├── ./base/atomicops.h
│   ├── ./base/base-export.h
│   ├── ./base/bit-field.h
│   ├── ./base/bits-iterator.h
│   ├── ./base/bits.cc
│   ├── ./base/bits.h
│   ├── ./base/bounded-page-allocator.cc
│   ├── ./base/bounded-page-allocator.h
│   ├── ./base/bounds.h
│   ├── ./base/build_config.h
│   ├── ./base/compiler-specific.h
│   ├── ./base/container-utils.h
│   ├── ./base/contextual.h
│   ├── ./base/cpu.cc
│   ├── ./base/cpu.h
│   ├── ./base/debug
│   ├── ./base/DEPS
│   ├── ./base/DIR_METADATA
│   ├── ./base/discriminated-union.h
│   ├── ./base/division-by-constant.cc
│   ├── ./base/division-by-constant.h
│   ├── ./base/doubly-threaded-list.h
│   ├── ./base/emulated-virtual-address-subspace.cc
│   ├── ./base/emulated-virtual-address-subspace.h
│   ├── ./base/enum-set.h
│   ├── ./base/export-template.h
│   ├── ./base/file-utils.cc
│   ├── ./base/file-utils.h
│   ├── ./base/flags.h
│   ├── ./base/free_deleter.h
│   ├── ./base/hashing.h
│   ├── ./base/hashmap-entry.h
│   ├── ./base/hashmap.h
│   ├── ./base/ieee754.cc
│   ├── ./base/ieee754.h
│   ├── ./base/immediate-crash.h
│   ├── ./base/intrusive-set.h
│   ├── ./base/ios-headers.h
│   ├── ./base/iterator.h
│   ├── ./base/lazy-instance.h
│   ├── ./base/logging.cc
│   ├── ./base/logging.h
│   ├── ./base/macros.h
│   ├── ./base/memory.h
│   ├── ./base/numbers
│   ├── ./base/once.cc
│   ├── ./base/once.h
│   ├── ./base/overflowing-math.h
│   ├── ./base/OWNERS
│   ├── ./base/page-allocator.cc
│   ├── ./base/page-allocator.h
│   ├── ./base/platform
│   ├── ./base/pointer-with-payload.h
│   ├── ./base/qnx-math.h
│   ├── ./base/region-allocator.cc
│   ├── ./base/region-allocator.h
│   ├── ./base/ring-buffer.h
│   ├── ./base/safe_conversions_arm_impl.h
│   ├── ./base/safe_conversions_impl.h
│   ├── ./base/safe_conversions.h
│   ├── ./base/sanitizer
│   ├── ./base/small-map.h
│   ├── ./base/small-vector.h
│   ├── ./base/string-format.h
│   ├── ./base/strings.cc
│   ├── ./base/strings.h
│   ├── ./base/strong-alias.h
│   ├── ./base/sys-info.cc
│   ├── ./base/sys-info.h
│   ├── ./base/template-meta-programming
│   ├── ./base/template-utils.h
│   ├── ./base/threaded-list.h
│   ├── ./base/timezone-cache.h
│   ├── ./base/ubsan.cc
│   ├── ./base/utils
│   ├── ./base/vector.h
│   ├── ./base/virtual-address-space-page-allocator.cc
│   ├── ./base/virtual-address-space-page-allocator.h
│   ├── ./base/virtual-address-space.cc
│   ├── ./base/virtual-address-space.h
│   ├── ./base/vlq-base64.cc
│   ├── ./base/vlq-base64.h
│   ├── ./base/vlq.h
│   └── ./base/win32-headers.h
├── ./baseline
│   ├── ./baseline/arm
│   ├── ./baseline/arm64
│   ├── ./baseline/baseline-assembler-inl.h
│   ├── ./baseline/baseline-assembler.h
│   ├── ./baseline/baseline-batch-compiler.cc
│   ├── ./baseline/baseline-batch-compiler.h
│   ├── ./baseline/baseline-compiler.cc
│   ├── ./baseline/baseline-compiler.h
│   ├── ./baseline/baseline.cc
│   ├── ./baseline/baseline.h
│   ├── ./baseline/bytecode-offset-iterator.cc
│   ├── ./baseline/bytecode-offset-iterator.h
│   ├── ./baseline/DEPS
│   ├── ./baseline/ia32
│   ├── ./baseline/loong64
│   ├── ./baseline/mips64
│   ├── ./baseline/OWNERS
│   ├── ./baseline/ppc
│   ├── ./baseline/riscv
│   ├── ./baseline/s390
│   └── ./baseline/x64
├── ./bigint
│   ├── ./bigint/bigint-internal.cc
│   ├── ./bigint/bigint-internal.h
│   ├── ./bigint/bigint.h
│   ├── ./bigint/bitwise.cc
│   ├── ./bigint/CPPLINT.cfg
│   ├── ./bigint/DEPS
│   ├── ./bigint/digit-arithmetic.h
│   ├── ./bigint/div-barrett.cc
│   ├── ./bigint/div-burnikel.cc
│   ├── ./bigint/div-helpers.cc
│   ├── ./bigint/div-helpers.h
│   ├── ./bigint/div-schoolbook.cc
│   ├── ./bigint/fromstring.cc
│   ├── ./bigint/mul-fft.cc
│   ├── ./bigint/mul-karatsuba.cc
│   ├── ./bigint/mul-schoolbook.cc
│   ├── ./bigint/mul-toom.cc
│   ├── ./bigint/OWNERS
│   ├── ./bigint/tostring.cc
│   ├── ./bigint/util.h
│   ├── ./bigint/vector-arithmetic.cc
│   └── ./bigint/vector-arithmetic.h
├── ./builtins
│   ├── ./builtins/accessors.cc
│   ├── ./builtins/accessors.h
│   ├── ./builtins/aggregate-error.tq
│   ├── ./builtins/arm
│   ├── ./builtins/arm64
│   ├── ./builtins/array-at.tq
│   ├── ./builtins/array-concat.tq
│   ├── ./builtins/array-copywithin.tq
│   ├── ./builtins/array-every.tq
│   ├── ./builtins/array-filter.tq
│   ├── ./builtins/array-find.tq
│   ├── ./builtins/array-findindex.tq
│   ├── ./builtins/array-findlast.tq
│   ├── ./builtins/array-findlastindex.tq
│   ├── ./builtins/array-flat.tq
│   ├── ./builtins/array-foreach.tq
│   ├── ./builtins/array-from-async.tq
│   ├── ./builtins/array-from.tq
│   ├── ./builtins/array-isarray.tq
│   ├── ./builtins/array-join.tq
│   ├── ./builtins/array-lastindexof.tq
│   ├── ./builtins/array-map.tq
│   ├── ./builtins/array-of.tq
│   ├── ./builtins/array-reduce-right.tq
│   ├── ./builtins/array-reduce.tq
│   ├── ./builtins/array-reverse.tq
│   ├── ./builtins/array-shift.tq
│   ├── ./builtins/array-slice.tq
│   ├── ./builtins/array-some.tq
│   ├── ./builtins/array-splice.tq
│   ├── ./builtins/array-to-reversed.tq
│   ├── ./builtins/array-to-sorted.tq
│   ├── ./builtins/array-to-spliced.tq
│   ├── ./builtins/array-unshift.tq
│   ├── ./builtins/array-with.tq
│   ├── ./builtins/array.tq
│   ├── ./builtins/arraybuffer.tq
│   ├── ./builtins/base.tq
│   ├── ./builtins/boolean.tq
│   ├── ./builtins/builtins-abstract-module-source.cc
│   ├── ./builtins/builtins-api.cc
│   ├── ./builtins/builtins-array-gen.cc
│   ├── ./builtins/builtins-array-gen.h
│   ├── ./builtins/builtins-array.cc
│   ├── ./builtins/builtins-arraybuffer.cc
│   ├── ./builtins/builtins-async-disposable-stack.cc
│   ├── ./builtins/builtins-async-function-gen.cc
│   ├── ./builtins/builtins-async-gen.cc
│   ├── ./builtins/builtins-async-gen.h
│   ├── ./builtins/builtins-async-generator-gen.cc
│   ├── ./builtins/builtins-async-iterator-gen.cc
│   ├── ./builtins/builtins-async-module.cc
│   ├── ./builtins/builtins-atomics-synchronization.cc
│   ├── ./builtins/builtins-bigint-gen.cc
│   ├── ./builtins/builtins-bigint-gen.h
│   ├── ./builtins/builtins-bigint.cc
│   ├── ./builtins/builtins-bigint.tq
│   ├── ./builtins/builtins-call-gen.cc
│   ├── ./builtins/builtins-call-gen.h
│   ├── ./builtins/builtins-callsite.cc
│   ├── ./builtins/builtins-collections-gen.cc
│   ├── ./builtins/builtins-collections-gen.h
│   ├── ./builtins/builtins-collections.cc
│   ├── ./builtins/builtins-console.cc
│   ├── ./builtins/builtins-constructor-gen.cc
│   ├── ./builtins/builtins-constructor-gen.h
│   ├── ./builtins/builtins-constructor.h
│   ├── ./builtins/builtins-conversion-gen.cc
│   ├── ./builtins/builtins-data-view-gen.h
│   ├── ./builtins/builtins-dataview.cc
│   ├── ./builtins/builtins-date-gen.cc
│   ├── ./builtins/builtins-date.cc
│   ├── ./builtins/builtins-definitions.h
│   ├── ./builtins/builtins-descriptors.h
│   ├── ./builtins/builtins-disposable-stack.cc
│   ├── ./builtins/builtins-error.cc
│   ├── ./builtins/builtins-function.cc
│   ├── ./builtins/builtins-generator-gen.cc
│   ├── ./builtins/builtins-global-gen.cc
│   ├── ./builtins/builtins-global.cc
│   ├── ./builtins/builtins-handler-gen.cc
│   ├── ./builtins/builtins-ic-gen.cc
│   ├── ./builtins/builtins-inl.h
│   ├── ./builtins/builtins-internal-gen.cc
│   ├── ./builtins/builtins-internal.cc
│   ├── ./builtins/builtins-interpreter-gen.cc
│   ├── ./builtins/builtins-intl-gen.cc
│   ├── ./builtins/builtins-intl.cc
│   ├── ./builtins/builtins-iterator-gen.cc
│   ├── ./builtins/builtins-iterator-gen.h
│   ├── ./builtins/builtins-json.cc
│   ├── ./builtins/builtins-lazy-gen.cc
│   ├── ./builtins/builtins-lazy-gen.h
│   ├── ./builtins/builtins-microtask-queue-gen.cc
│   ├── ./builtins/builtins-number-gen.cc
│   ├── ./builtins/builtins-number-tsa.cc
│   ├── ./builtins/builtins-number.cc
│   ├── ./builtins/builtins-object-gen.cc
│   ├── ./builtins/builtins-object-gen.h
│   ├── ./builtins/builtins-object.cc
│   ├── ./builtins/builtins-promise-gen.cc
│   ├── ./builtins/builtins-promise-gen.h
│   ├── ./builtins/builtins-promise.h
│   ├── ./builtins/builtins-proxy-gen.cc
│   ├── ./builtins/builtins-proxy-gen.h
│   ├── ./builtins/builtins-reflect.cc
│   ├── ./builtins/builtins-regexp-gen.cc
│   ├── ./builtins/builtins-regexp-gen.h
│   ├── ./builtins/builtins-regexp.cc
│   ├── ./builtins/builtins-shadow-realm-gen.cc
│   ├── ./builtins/builtins-shadow-realm.cc
│   ├── ./builtins/builtins-shared-array.cc
│   ├── ./builtins/builtins-sharedarraybuffer-gen.cc
│   ├── ./builtins/builtins-sharedarraybuffer.cc
│   ├── ./builtins/builtins-string-gen.cc
│   ├── ./builtins/builtins-string-gen.h
│   ├── ./builtins/builtins-string-tsa.cc
│   ├── ./builtins/builtins-string.cc
│   ├── ./builtins/builtins-string.tq
│   ├── ./builtins/builtins-struct.cc
│   ├── ./builtins/builtins-symbol.cc
│   ├── ./builtins/builtins-temporal-gen.cc
│   ├── ./builtins/builtins-temporal.cc
│   ├── ./builtins/builtins-trace.cc
│   ├── ./builtins/builtins-typed-array-gen.cc
│   ├── ./builtins/builtins-typed-array-gen.h
│   ├── ./builtins/builtins-typed-array.cc
│   ├── ./builtins/builtins-utils-gen.h
│   ├── ./builtins/builtins-utils-inl.h
│   ├── ./builtins/builtins-utils.h
│   ├── ./builtins/builtins-wasm-gen.cc
│   ├── ./builtins/builtins-wasm-gen.h
│   ├── ./builtins/builtins-weak-refs.cc
│   ├── ./builtins/builtins.cc
│   ├── ./builtins/builtins.h
│   ├── ./builtins/cast.tq
│   ├── ./builtins/collections.tq
│   ├── ./builtins/console.tq
│   ├── ./builtins/constants-table-builder.cc
│   ├── ./builtins/constants-table-builder.h
│   ├── ./builtins/constructor.tq
│   ├── ./builtins/conversion.tq
│   ├── ./builtins/convert.tq
│   ├── ./builtins/data-view-ops.h
│   ├── ./builtins/data-view.tq
│   ├── ./builtins/DEPS
│   ├── ./builtins/DIR_METADATA
│   ├── ./builtins/finalization-registry.tq
│   ├── ./builtins/frame-arguments.tq
│   ├── ./builtins/frames.tq
│   ├── ./builtins/function.tq
│   ├── ./builtins/generate-bytecodes-builtins-list.cc
│   ├── ./builtins/growable-fixed-array-gen.cc
│   ├── ./builtins/growable-fixed-array-gen.h
│   ├── ./builtins/growable-fixed-array.tq
│   ├── ./builtins/ia32
│   ├── ./builtins/ic-callable.tq
│   ├── ./builtins/ic.tq
│   ├── ./builtins/internal-coverage.tq
│   ├── ./builtins/internal.tq
│   ├── ./builtins/iterator-from.tq
│   ├── ./builtins/iterator-helpers.tq
│   ├── ./builtins/iterator.tq
│   ├── ./builtins/js-to-js.tq
│   ├── ./builtins/js-to-wasm.tq
│   ├── ./builtins/loong64
│   ├── ./builtins/map-groupby.tq
│   ├── ./builtins/math.tq
│   ├── ./builtins/mips64
│   ├── ./builtins/number-builtins-reducer-inl.h
│   ├── ./builtins/number.tq
│   ├── ./builtins/object-fromentries.tq
│   ├── ./builtins/object-groupby.tq
│   ├── ./builtins/object.tq
│   ├── ./builtins/OWNERS
│   ├── ./builtins/ppc
│   ├── ./builtins/profile-data-reader.cc
│   ├── ./builtins/profile-data-reader.h
│   ├── ./builtins/promise-abstract-operations.tq
│   ├── ./builtins/promise-all-element-closure.tq
│   ├── ./builtins/promise-all.tq
│   ├── ./builtins/promise-any.tq
│   ├── ./builtins/promise-constructor.tq
│   ├── ./builtins/promise-finally.tq
│   ├── ./builtins/promise-jobs.tq
│   ├── ./builtins/promise-misc.tq
│   ├── ./builtins/promise-race.tq
│   ├── ./builtins/promise-reaction-job.tq
│   ├── ./builtins/promise-resolve.tq
│   ├── ./builtins/promise-then.tq
│   ├── ./builtins/promise-try.tq
│   ├── ./builtins/promise-withresolvers.tq
│   ├── ./builtins/proxy-constructor.tq
│   ├── ./builtins/proxy-delete-property.tq
│   ├── ./builtins/proxy-get-property.tq
│   ├── ./builtins/proxy-get-prototype-of.tq
│   ├── ./builtins/proxy-has-property.tq
│   ├── ./builtins/proxy-is-extensible.tq
│   ├── ./builtins/proxy-prevent-extensions.tq
│   ├── ./builtins/proxy-revocable.tq
│   ├── ./builtins/proxy-revoke.tq
│   ├── ./builtins/proxy-set-property.tq
│   ├── ./builtins/proxy-set-prototype-of.tq
│   ├── ./builtins/proxy.tq
│   ├── ./builtins/reflect.tq
│   ├── ./builtins/regexp-exec.tq
│   ├── ./builtins/regexp-match-all.tq
│   ├── ./builtins/regexp-match.tq
│   ├── ./builtins/regexp-replace.tq
│   ├── ./builtins/regexp-search.tq
│   ├── ./builtins/regexp-source.tq
│   ├── ./builtins/regexp-split.tq
│   ├── ./builtins/regexp-test.tq
│   ├── ./builtins/regexp.tq
│   ├── ./builtins/riscv
│   ├── ./builtins/s390
│   ├── ./builtins/set-difference.tq
│   ├── ./builtins/set-intersection.tq
│   ├── ./builtins/set-is-disjoint-from.tq
│   ├── ./builtins/set-is-subset-of.tq
│   ├── ./builtins/set-is-superset-of.tq
│   ├── ./builtins/set-symmetric-difference.tq
│   ├── ./builtins/set-union.tq
│   ├── ./builtins/setup-builtins-internal.cc
│   ├── ./builtins/string-at.tq
│   ├── ./builtins/string-endswith.tq
│   ├── ./builtins/string-html.tq
│   ├── ./builtins/string-includes.tq
│   ├── ./builtins/string-indexof.tq
│   ├── ./builtins/string-iswellformed.tq
│   ├── ./builtins/string-iterator.tq
│   ├── ./builtins/string-match-search.tq
│   ├── ./builtins/string-pad.tq
│   ├── ./builtins/string-repeat.tq
│   ├── ./builtins/string-replaceall.tq
│   ├── ./builtins/string-slice.tq
│   ├── ./builtins/string-startswith.tq
│   ├── ./builtins/string-substr.tq
│   ├── ./builtins/string-substring.tq
│   ├── ./builtins/string-towellformed.tq
│   ├── ./builtins/string-trim.tq
│   ├── ./builtins/suppressed-error.tq
│   ├── ./builtins/symbol.tq
│   ├── ./builtins/torque-csa-header-includes.h
│   ├── ./builtins/torque-internal.tq
│   ├── ./builtins/typed-array-at.tq
│   ├── ./builtins/typed-array-createtypedarray.tq
│   ├── ./builtins/typed-array-entries.tq
│   ├── ./builtins/typed-array-every.tq
│   ├── ./builtins/typed-array-filter.tq
│   ├── ./builtins/typed-array-find.tq
│   ├── ./builtins/typed-array-findindex.tq
│   ├── ./builtins/typed-array-findlast.tq
│   ├── ./builtins/typed-array-findlastindex.tq
│   ├── ./builtins/typed-array-foreach.tq
│   ├── ./builtins/typed-array-from.tq
│   ├── ./builtins/typed-array-keys.tq
│   ├── ./builtins/typed-array-of.tq
│   ├── ./builtins/typed-array-reduce.tq
│   ├── ./builtins/typed-array-reduceright.tq
│   ├── ./builtins/typed-array-set.tq
│   ├── ./builtins/typed-array-slice.tq
│   ├── ./builtins/typed-array-some.tq
│   ├── ./builtins/typed-array-sort.tq
│   ├── ./builtins/typed-array-subarray.tq
│   ├── ./builtins/typed-array-to-reversed.tq
│   ├── ./builtins/typed-array-to-sorted.tq
│   ├── ./builtins/typed-array-values.tq
│   ├── ./builtins/typed-array-with.tq
│   ├── ./builtins/typed-array.tq
│   ├── ./builtins/wasm-strings.tq
│   ├── ./builtins/wasm-to-js.tq
│   ├── ./builtins/wasm.tq
│   ├── ./builtins/weak-ref.tq
│   └── ./builtins/x64
├── ./codegen
│   ├── ./codegen/aligned-slot-allocator.cc
│   ├── ./codegen/aligned-slot-allocator.h
│   ├── ./codegen/arm
│   ├── ./codegen/arm64
│   ├── ./codegen/assembler-arch.h
│   ├── ./codegen/assembler-inl.h
│   ├── ./codegen/assembler.cc
│   ├── ./codegen/assembler.h
│   ├── ./codegen/atomic-memory-order.h
│   ├── ./codegen/background-merge-task.h
│   ├── ./codegen/bailout-reason.cc
│   ├── ./codegen/bailout-reason.h
│   ├── ./codegen/callable.h
│   ├── ./codegen/code-comments.cc
│   ├── ./codegen/code-comments.h
│   ├── ./codegen/code-desc.cc
│   ├── ./codegen/code-desc.h
│   ├── ./codegen/code-factory.cc
│   ├── ./codegen/code-factory.h
│   ├── ./codegen/code-reference.cc
│   ├── ./codegen/code-reference.h
│   ├── ./codegen/code-stub-assembler-inl.h
│   ├── ./codegen/code-stub-assembler.cc
│   ├── ./codegen/code-stub-assembler.h
│   ├── ./codegen/compilation-cache.cc
│   ├── ./codegen/compilation-cache.h
│   ├── ./codegen/compiler.cc
│   ├── ./codegen/compiler.h
│   ├── ./codegen/constant-pool.cc
│   ├── ./codegen/constant-pool.h
│   ├── ./codegen/constants-arch.h
│   ├── ./codegen/cpu-features.h
│   ├── ./codegen/define-code-stub-assembler-macros.inc
│   ├── ./codegen/DEPS
│   ├── ./codegen/DIR_METADATA
│   ├── ./codegen/external-reference-encoder.cc
│   ├── ./codegen/external-reference-encoder.h
│   ├── ./codegen/external-reference-table.cc
│   ├── ./codegen/external-reference-table.h
│   ├── ./codegen/external-reference.cc
│   ├── ./codegen/external-reference.h
│   ├── ./codegen/flush-instruction-cache.cc
│   ├── ./codegen/flush-instruction-cache.h
│   ├── ./codegen/handler-table.cc
│   ├── ./codegen/handler-table.h
│   ├── ./codegen/heap-object-list.h
│   ├── ./codegen/ia32
│   ├── ./codegen/interface-descriptors-inl.h
│   ├── ./codegen/interface-descriptors.cc
│   ├── ./codegen/interface-descriptors.h
│   ├── ./codegen/label.h
│   ├── ./codegen/linkage-location.h
│   ├── ./codegen/loong64
│   ├── ./codegen/machine-type.cc
│   ├── ./codegen/machine-type.h
│   ├── ./codegen/macro-assembler-base.cc
│   ├── ./codegen/macro-assembler-base.h
│   ├── ./codegen/macro-assembler-inl.h
│   ├── ./codegen/macro-assembler.h
│   ├── ./codegen/maglev-safepoint-table.cc
│   ├── ./codegen/maglev-safepoint-table.h
│   ├── ./codegen/mips64
│   ├── ./codegen/optimized-compilation-info.cc
│   ├── ./codegen/optimized-compilation-info.h
│   ├── ./codegen/OWNERS
│   ├── ./codegen/pending-optimization-table.cc
│   ├── ./codegen/pending-optimization-table.h
│   ├── ./codegen/ppc
│   ├── ./codegen/register-arch.h
│   ├── ./codegen/register-base.h
│   ├── ./codegen/register-configuration.cc
│   ├── ./codegen/register-configuration.h
│   ├── ./codegen/register.h
│   ├── ./codegen/reglist-base.h
│   ├── ./codegen/reglist.h
│   ├── ./codegen/reloc-info-inl.h
│   ├── ./codegen/reloc-info.cc
│   ├── ./codegen/reloc-info.h
│   ├── ./codegen/riscv
│   ├── ./codegen/s390
│   ├── ./codegen/safepoint-table-base.h
│   ├── ./codegen/safepoint-table.cc
│   ├── ./codegen/safepoint-table.h
│   ├── ./codegen/script-details.h
│   ├── ./codegen/shared-ia32-x64
│   ├── ./codegen/signature.h
│   ├── ./codegen/source-position-table.cc
│   ├── ./codegen/source-position-table.h
│   ├── ./codegen/source-position.cc
│   ├── ./codegen/source-position.h
│   ├── ./codegen/tick-counter.cc
│   ├── ./codegen/tick-counter.h
│   ├── ./codegen/tnode.cc
│   ├── ./codegen/tnode.h
│   ├── ./codegen/turboshaft-builtins-assembler-inl.h
│   ├── ./codegen/undef-code-stub-assembler-macros.inc
│   ├── ./codegen/unoptimized-compilation-info.cc
│   ├── ./codegen/unoptimized-compilation-info.h
│   └── ./codegen/x64
├── ./common
│   ├── ./common/assert-scope.cc
│   ├── ./common/assert-scope.h
│   ├── ./common/checks.h
│   ├── ./common/code-memory-access-inl.h
│   ├── ./common/code-memory-access.cc
│   ├── ./common/code-memory-access.h
│   ├── ./common/DIR_METADATA
│   ├── ./common/globals.h
│   ├── ./common/high-allocation-throughput-scope.h
│   ├── ./common/message-template.h
│   ├── ./common/operation.h
│   ├── ./common/OWNERS
│   ├── ./common/ptr-compr-inl.h
│   ├── ./common/ptr-compr.cc
│   ├── ./common/ptr-compr.h
│   ├── ./common/segmented-table-inl.h
│   ├── ./common/segmented-table.h
│   ├── ./common/simd128.h
│   └── ./common/thread-local-storage.h
├── ./compiler
│   ├── ./compiler/access-builder.cc
│   ├── ./compiler/access-builder.h
│   ├── ./compiler/access-info.cc
│   ├── ./compiler/access-info.h
│   ├── ./compiler/add-type-assertions-reducer.cc
│   ├── ./compiler/add-type-assertions-reducer.h
│   ├── ./compiler/all-nodes.cc
│   ├── ./compiler/all-nodes.h
│   ├── ./compiler/allocation-builder-inl.h
│   ├── ./compiler/allocation-builder.h
│   ├── ./compiler/backend
│   ├── ./compiler/basic-block-instrumentor.cc
│   ├── ./compiler/basic-block-instrumentor.h
│   ├── ./compiler/branch-condition-duplicator.cc
│   ├── ./compiler/branch-condition-duplicator.h
│   ├── ./compiler/branch-elimination.cc
│   ├── ./compiler/branch-elimination.h
│   ├── ./compiler/bytecode-analysis.cc
│   ├── ./compiler/bytecode-analysis.h
│   ├── ./compiler/bytecode-graph-builder.cc
│   ├── ./compiler/bytecode-graph-builder.h
│   ├── ./compiler/bytecode-liveness-map.cc
│   ├── ./compiler/bytecode-liveness-map.h
│   ├── ./compiler/c-linkage.cc
│   ├── ./compiler/checkpoint-elimination.cc
│   ├── ./compiler/checkpoint-elimination.h
│   ├── ./compiler/code-assembler-compilation-job.h
│   ├── ./compiler/code-assembler.cc
│   ├── ./compiler/code-assembler.h
│   ├── ./compiler/common-node-cache.cc
│   ├── ./compiler/common-node-cache.h
│   ├── ./compiler/common-operator-reducer.cc
│   ├── ./compiler/common-operator-reducer.h
│   ├── ./compiler/common-operator.cc
│   ├── ./compiler/common-operator.h
│   ├── ./compiler/compilation-dependencies.cc
│   ├── ./compiler/compilation-dependencies.h
│   ├── ./compiler/compiler-source-position-table.cc
│   ├── ./compiler/compiler-source-position-table.h
│   ├── ./compiler/constant-folding-reducer.cc
│   ├── ./compiler/constant-folding-reducer.h
│   ├── ./compiler/control-equivalence.cc
│   ├── ./compiler/control-equivalence.h
│   ├── ./compiler/control-path-state.h
│   ├── ./compiler/csa-load-elimination.cc
│   ├── ./compiler/csa-load-elimination.h
│   ├── ./compiler/dead-code-elimination.cc
│   ├── ./compiler/dead-code-elimination.h
│   ├── ./compiler/decompression-optimizer.cc
│   ├── ./compiler/decompression-optimizer.h
│   ├── ./compiler/DEPS
│   ├── ./compiler/diamond.h
│   ├── ./compiler/DIR_METADATA
│   ├── ./compiler/escape-analysis-reducer.cc
│   ├── ./compiler/escape-analysis-reducer.h
│   ├── ./compiler/escape-analysis.cc
│   ├── ./compiler/escape-analysis.h
│   ├── ./compiler/fast-api-calls.cc
│   ├── ./compiler/fast-api-calls.h
│   ├── ./compiler/feedback-source.cc
│   ├── ./compiler/feedback-source.h
│   ├── ./compiler/frame-states.cc
│   ├── ./compiler/frame-states.h
│   ├── ./compiler/frame.cc
│   ├── ./compiler/frame.h
│   ├── ./compiler/functional-list.h
│   ├── ./compiler/globals.h
│   ├── ./compiler/graph-assembler.cc
│   ├── ./compiler/graph-assembler.h
│   ├── ./compiler/graph-reducer.cc
│   ├── ./compiler/graph-reducer.h
│   ├── ./compiler/graph-trimmer.cc
│   ├── ./compiler/graph-trimmer.h
│   ├── ./compiler/graph-zone-traits.h
│   ├── ./compiler/heap-refs.cc
│   ├── ./compiler/heap-refs.h
│   ├── ./compiler/int64-lowering.cc
│   ├── ./compiler/int64-lowering.h
│   ├── ./compiler/js-call-reducer.cc
│   ├── ./compiler/js-call-reducer.h
│   ├── ./compiler/js-context-specialization.cc
│   ├── ./compiler/js-context-specialization.h
│   ├── ./compiler/js-create-lowering.cc
│   ├── ./compiler/js-create-lowering.h
│   ├── ./compiler/js-generic-lowering.cc
│   ├── ./compiler/js-generic-lowering.h
│   ├── ./compiler/js-graph.cc
│   ├── ./compiler/js-graph.h
│   ├── ./compiler/js-heap-broker-inl.h
│   ├── ./compiler/js-heap-broker.cc
│   ├── ./compiler/js-heap-broker.h
│   ├── ./compiler/js-inlining-heuristic.cc
│   ├── ./compiler/js-inlining-heuristic.h
│   ├── ./compiler/js-inlining.cc
│   ├── ./compiler/js-inlining.h
│   ├── ./compiler/js-intrinsic-lowering.cc
│   ├── ./compiler/js-intrinsic-lowering.h
│   ├── ./compiler/js-native-context-specialization.cc
│   ├── ./compiler/js-native-context-specialization.h
│   ├── ./compiler/js-operator.cc
│   ├── ./compiler/js-operator.h
│   ├── ./compiler/js-type-hint-lowering.cc
│   ├── ./compiler/js-type-hint-lowering.h
│   ├── ./compiler/js-typed-lowering.cc
│   ├── ./compiler/js-typed-lowering.h
│   ├── ./compiler/late-escape-analysis.cc
│   ├── ./compiler/late-escape-analysis.h
│   ├── ./compiler/linear-scheduler.cc
│   ├── ./compiler/linear-scheduler.h
│   ├── ./compiler/linkage.cc
│   ├── ./compiler/linkage.h
│   ├── ./compiler/load-elimination.cc
│   ├── ./compiler/load-elimination.h
│   ├── ./compiler/loop-analysis.cc
│   ├── ./compiler/loop-analysis.h
│   ├── ./compiler/loop-peeling.cc
│   ├── ./compiler/loop-peeling.h
│   ├── ./compiler/loop-unrolling.cc
│   ├── ./compiler/loop-unrolling.h
│   ├── ./compiler/loop-variable-optimizer.cc
│   ├── ./compiler/loop-variable-optimizer.h
│   ├── ./compiler/machine-graph-verifier.cc
│   ├── ./compiler/machine-graph-verifier.h
│   ├── ./compiler/machine-graph.cc
│   ├── ./compiler/machine-graph.h
│   ├── ./compiler/machine-operator-reducer.cc
│   ├── ./compiler/machine-operator-reducer.h
│   ├── ./compiler/machine-operator.cc
│   ├── ./compiler/machine-operator.h
│   ├── ./compiler/map-inference.cc
│   ├── ./compiler/map-inference.h
│   ├── ./compiler/memory-lowering.cc
│   ├── ./compiler/memory-lowering.h
│   ├── ./compiler/memory-optimizer.cc
│   ├── ./compiler/memory-optimizer.h
│   ├── ./compiler/node-aux-data.h
│   ├── ./compiler/node-cache.h
│   ├── ./compiler/node-marker.cc
│   ├── ./compiler/node-marker.h
│   ├── ./compiler/node-matchers.cc
│   ├── ./compiler/node-matchers.h
│   ├── ./compiler/node-observer.cc
│   ├── ./compiler/node-observer.h
│   ├── ./compiler/node-origin-table.cc
│   ├── ./compiler/node-origin-table.h
│   ├── ./compiler/node-properties.cc
│   ├── ./compiler/node-properties.h
│   ├── ./compiler/node.cc
│   ├── ./compiler/node.h
│   ├── ./compiler/opcodes.cc
│   ├── ./compiler/opcodes.h
│   ├── ./compiler/operation-typer.cc
│   ├── ./compiler/operation-typer.h
│   ├── ./compiler/operator-properties.cc
│   ├── ./compiler/operator-properties.h
│   ├── ./compiler/operator.cc
│   ├── ./compiler/operator.h
│   ├── ./compiler/osr.cc
│   ├── ./compiler/osr.h
│   ├── ./compiler/OWNERS
│   ├── ./compiler/pair-load-store-reducer.cc
│   ├── ./compiler/pair-load-store-reducer.h
│   ├── ./compiler/per-isolate-compiler-cache.h
│   ├── ./compiler/persistent-map.h
│   ├── ./compiler/phase.h
│   ├── ./compiler/pipeline-data-inl.h
│   ├── ./compiler/pipeline-statistics.cc
│   ├── ./compiler/pipeline-statistics.h
│   ├── ./compiler/pipeline.cc
│   ├── ./compiler/pipeline.h
│   ├── ./compiler/processed-feedback.h
│   ├── ./compiler/property-access-builder.cc
│   ├── ./compiler/property-access-builder.h
│   ├── ./compiler/raw-machine-assembler.cc
│   ├── ./compiler/raw-machine-assembler.h
│   ├── ./compiler/redundancy-elimination.cc
│   ├── ./compiler/redundancy-elimination.h
│   ├── ./compiler/refs-map.cc
│   ├── ./compiler/refs-map.h
│   ├── ./compiler/representation-change.cc
│   ├── ./compiler/representation-change.h
│   ├── ./compiler/revectorizer.cc
│   ├── ./compiler/revectorizer.h
│   ├── ./compiler/schedule.cc
│   ├── ./compiler/schedule.h
│   ├── ./compiler/scheduler.cc
│   ├── ./compiler/scheduler.h
│   ├── ./compiler/select-lowering.cc
│   ├── ./compiler/select-lowering.h
│   ├── ./compiler/simplified-lowering-verifier.cc
│   ├── ./compiler/simplified-lowering-verifier.h
│   ├── ./compiler/simplified-lowering.cc
│   ├── ./compiler/simplified-lowering.h
│   ├── ./compiler/simplified-operator-reducer.cc
│   ├── ./compiler/simplified-operator-reducer.h
│   ├── ./compiler/simplified-operator.cc
│   ├── ./compiler/simplified-operator.h
│   ├── ./compiler/state-values-utils.cc
│   ├── ./compiler/state-values-utils.h
│   ├── ./compiler/string-builder-optimizer.cc
│   ├── ./compiler/string-builder-optimizer.h
│   ├── ./compiler/turbofan-disabled.cc
│   ├── ./compiler/turbofan-enabled.cc
│   ├── ./compiler/turbofan-graph-visualizer.cc
│   ├── ./compiler/turbofan-graph-visualizer.h
│   ├── ./compiler/turbofan-graph.cc
│   ├── ./compiler/turbofan-graph.h
│   ├── ./compiler/turbofan-typer.cc
│   ├── ./compiler/turbofan-typer.h
│   ├── ./compiler/turbofan-types.cc
│   ├── ./compiler/turbofan-types.h
│   ├── ./compiler/turbofan.h
│   ├── ./compiler/turboshaft
│   ├── ./compiler/type-cache.cc
│   ├── ./compiler/type-cache.h
│   ├── ./compiler/type-narrowing-reducer.cc
│   ├── ./compiler/type-narrowing-reducer.h
│   ├── ./compiler/typed-optimization.cc
│   ├── ./compiler/typed-optimization.h
│   ├── ./compiler/use-info.h
│   ├── ./compiler/value-numbering-reducer.cc
│   ├── ./compiler/value-numbering-reducer.h
│   ├── ./compiler/verifier.cc
│   ├── ./compiler/verifier.h
│   ├── ./compiler/wasm-address-reassociation.cc
│   ├── ./compiler/wasm-address-reassociation.h
│   ├── ./compiler/wasm-call-descriptors.cc
│   ├── ./compiler/wasm-call-descriptors.h
│   ├── ./compiler/wasm-compiler-definitions.cc
│   ├── ./compiler/wasm-compiler-definitions.h
│   ├── ./compiler/wasm-compiler.cc
│   ├── ./compiler/wasm-compiler.h
│   ├── ./compiler/wasm-escape-analysis.cc
│   ├── ./compiler/wasm-escape-analysis.h
│   ├── ./compiler/wasm-gc-lowering.cc
│   ├── ./compiler/wasm-gc-lowering.h
│   ├── ./compiler/wasm-gc-operator-reducer.cc
│   ├── ./compiler/wasm-gc-operator-reducer.h
│   ├── ./compiler/wasm-graph-assembler.cc
│   ├── ./compiler/wasm-graph-assembler.h
│   ├── ./compiler/wasm-inlining-into-js.cc
│   ├── ./compiler/wasm-inlining-into-js.h
│   ├── ./compiler/wasm-inlining.cc
│   ├── ./compiler/wasm-inlining.h
│   ├── ./compiler/wasm-js-lowering.cc
│   ├── ./compiler/wasm-js-lowering.h
│   ├── ./compiler/wasm-load-elimination.cc
│   ├── ./compiler/wasm-load-elimination.h
│   ├── ./compiler/wasm-loop-peeling.cc
│   ├── ./compiler/wasm-loop-peeling.h
│   ├── ./compiler/wasm-typer.cc
│   ├── ./compiler/wasm-typer.h
│   ├── ./compiler/write-barrier-kind.h
│   ├── ./compiler/zone-stats.cc
│   └── ./compiler/zone-stats.h
├── ./compiler-dispatcher
│   ├── ./compiler-dispatcher/DIR_METADATA
│   ├── ./compiler-dispatcher/lazy-compile-dispatcher.cc
│   ├── ./compiler-dispatcher/lazy-compile-dispatcher.h
│   ├── ./compiler-dispatcher/optimizing-compile-dispatcher.cc
│   ├── ./compiler-dispatcher/optimizing-compile-dispatcher.h
│   └── ./compiler-dispatcher/OWNERS
├── ./d8
│   ├── ./d8/async-hooks-wrapper.cc
│   ├── ./d8/async-hooks-wrapper.h
│   ├── ./d8/d8-console.cc
│   ├── ./d8/d8-console.h
│   ├── ./d8/d8-js.cc
│   ├── ./d8/d8-platforms.cc
│   ├── ./d8/d8-platforms.h
│   ├── ./d8/d8-posix.cc
│   ├── ./d8/d8-test.cc
│   ├── ./d8/d8-windows.cc
│   ├── ./d8/d8.cc
│   ├── ./d8/d8.h
│   └── ./d8/OWNERS
├── ./date
│   ├── ./date/date.cc
│   ├── ./date/date.h
│   ├── ./date/dateparser-inl.h
│   ├── ./date/dateparser.cc
│   ├── ./date/dateparser.h
│   ├── ./date/DIR_METADATA
│   └── ./date/OWNERS
├── ./debug
│   ├── ./debug/debug-coverage.cc
│   ├── ./debug/debug-coverage.h
│   ├── ./debug/debug-evaluate.cc
│   ├── ./debug/debug-evaluate.h
│   ├── ./debug/debug-frames.cc
│   ├── ./debug/debug-frames.h
│   ├── ./debug/debug-interface.cc
│   ├── ./debug/debug-interface.h
│   ├── ./debug/debug-property-iterator.cc
│   ├── ./debug/debug-property-iterator.h
│   ├── ./debug/debug-scope-iterator.cc
│   ├── ./debug/debug-scope-iterator.h
│   ├── ./debug/debug-scopes.cc
│   ├── ./debug/debug-scopes.h
│   ├── ./debug/debug-stack-trace-iterator.cc
│   ├── ./debug/debug-stack-trace-iterator.h
│   ├── ./debug/debug-wasm-objects-inl.h
│   ├── ./debug/debug-wasm-objects.cc
│   ├── ./debug/debug-wasm-objects.h
│   ├── ./debug/debug-wasm-objects.tq
│   ├── ./debug/debug.cc
│   ├── ./debug/debug.h
│   ├── ./debug/DIR_METADATA
│   ├── ./debug/interface-types.h
│   ├── ./debug/liveedit-diff.cc
│   ├── ./debug/liveedit-diff.h
│   ├── ./debug/liveedit.cc
│   ├── ./debug/liveedit.h
│   ├── ./debug/OWNERS
│   └── ./debug/wasm
├── ./deoptimizer
│   ├── ./deoptimizer/arm
│   ├── ./deoptimizer/arm64
│   ├── ./deoptimizer/deoptimize-reason.cc
│   ├── ./deoptimizer/deoptimize-reason.h
│   ├── ./deoptimizer/deoptimized-frame-info.cc
│   ├── ./deoptimizer/deoptimized-frame-info.h
│   ├── ./deoptimizer/deoptimizer.cc
│   ├── ./deoptimizer/deoptimizer.h
│   ├── ./deoptimizer/DEPS
│   ├── ./deoptimizer/DIR_METADATA
│   ├── ./deoptimizer/frame-description.h
│   ├── ./deoptimizer/frame-translation-builder.cc
│   ├── ./deoptimizer/frame-translation-builder.h
│   ├── ./deoptimizer/ia32
│   ├── ./deoptimizer/loong64
│   ├── ./deoptimizer/materialized-object-store.cc
│   ├── ./deoptimizer/materialized-object-store.h
│   ├── ./deoptimizer/mips64
│   ├── ./deoptimizer/OWNERS
│   ├── ./deoptimizer/ppc
│   ├── ./deoptimizer/riscv
│   ├── ./deoptimizer/s390
│   ├── ./deoptimizer/translated-state.cc
│   ├── ./deoptimizer/translated-state.h
│   ├── ./deoptimizer/translation-opcode.h
│   └── ./deoptimizer/x64
├── ./DEPS
├── ./diagnostics
│   ├── ./diagnostics/arm
│   ├── ./diagnostics/arm64
│   ├── ./diagnostics/basic-block-profiler.cc
│   ├── ./diagnostics/basic-block-profiler.h
│   ├── ./diagnostics/code-tracer.h
│   ├── ./diagnostics/compilation-statistics.cc
│   ├── ./diagnostics/compilation-statistics.h
│   ├── ./diagnostics/DEPS
│   ├── ./diagnostics/disasm.h
│   ├── ./diagnostics/disassembler.cc
│   ├── ./diagnostics/disassembler.h
│   ├── ./diagnostics/eh-frame.cc
│   ├── ./diagnostics/eh-frame.h
│   ├── ./diagnostics/etw-debug-win.cc
│   ├── ./diagnostics/etw-debug-win.h
│   ├── ./diagnostics/etw-isolate-capture-state-monitor-win.cc
│   ├── ./diagnostics/etw-isolate-capture-state-monitor-win.h
│   ├── ./diagnostics/etw-isolate-load-script-data-win.cc
│   ├── ./diagnostics/etw-isolate-load-script-data-win.h
│   ├── ./diagnostics/etw-isolate-operations-win.cc
│   ├── ./diagnostics/etw-isolate-operations-win.h
│   ├── ./diagnostics/etw-jit-metadata-win.cc
│   ├── ./diagnostics/etw-jit-metadata-win.h
│   ├── ./diagnostics/etw-jit-win.cc
│   ├── ./diagnostics/etw-jit-win.h
│   ├── ./diagnostics/gdb-jit.cc
│   ├── ./diagnostics/gdb-jit.h
│   ├── ./diagnostics/ia32
│   ├── ./diagnostics/loong64
│   ├── ./diagnostics/mips64
│   ├── ./diagnostics/objects-debug.cc
│   ├── ./diagnostics/objects-printer.cc
│   ├── ./diagnostics/OWNERS
│   ├── ./diagnostics/perf-jit.cc
│   ├── ./diagnostics/perf-jit.h
│   ├── ./diagnostics/ppc
│   ├── ./diagnostics/riscv
│   ├── ./diagnostics/s390
│   ├── ./diagnostics/unwinder.cc
│   ├── ./diagnostics/unwinder.h
│   ├── ./diagnostics/unwinding-info-win64.cc
│   ├── ./diagnostics/unwinding-info-win64.h
│   └── ./diagnostics/x64
├── ./DIR_METADATA
├── ./execution
│   ├── ./execution/arguments-inl.h
│   ├── ./execution/arguments.cc
│   ├── ./execution/arguments.h
│   ├── ./execution/arm
│   ├── ./execution/arm64
│   ├── ./execution/clobber-registers.cc
│   ├── ./execution/clobber-registers.h
│   ├── ./execution/DEPS
│   ├── ./execution/DIR_METADATA
│   ├── ./execution/embedder-state.cc
│   ├── ./execution/embedder-state.h
│   ├── ./execution/encoded-c-signature.cc
│   ├── ./execution/encoded-c-signature.h
│   ├── ./execution/execution.cc
│   ├── ./execution/execution.h
│   ├── ./execution/frame-constants.h
│   ├── ./execution/frames-inl.h
│   ├── ./execution/frames.cc
│   ├── ./execution/frames.h
│   ├── ./execution/futex-emulation.cc
│   ├── ./execution/futex-emulation.h
│   ├── ./execution/ia32
│   ├── ./execution/interrupts-scope.cc
│   ├── ./execution/interrupts-scope.h
│   ├── ./execution/isolate-data.h
│   ├── ./execution/isolate-inl.h
│   ├── ./execution/isolate-utils-inl.h
│   ├── ./execution/isolate-utils.h
│   ├── ./execution/isolate.cc
│   ├── ./execution/isolate.h
│   ├── ./execution/local-isolate-inl.h
│   ├── ./execution/local-isolate.cc
│   ├── ./execution/local-isolate.h
[Step 11: Duration 7.40 seconds| Input tokens: 211,738 | Output tokens: 2,809]
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ Step 12 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'ripgrep' with arguments: {'pattern': 'TransitionElementsKind', 'options': ''}                                                                                           │
╰────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
Command: cd /Users/tarun/v8/v8/src && rg 'TransitionElementsKind' | head -n 1000
Observations: debug/debug-evaluate.cc:  V(TransitionElementsKind)              \
runtime/runtime-object.cc:          JSObject::TransitionElementsKind(lookup_start_object, elements_kind);
maglev/maglev-graph-builder.cc:    case Opcode::kTransitionElementsKind:
maglev/maglev-graph-builder.cc:ReduceResult MaglevGraphBuilder::BuildTransitionElementsKindOrCheckMap(
maglev/maglev-graph-builder.cc:  // TransitionElementsKind doesn't happen in cases where we'd need to do
maglev/maglev-graph-builder.cc:  AddNewNode<TransitionElementsKindOrCheckMap>(
maglev/maglev-graph-builder.cc:ReduceResult MaglevGraphBuilder::BuildTransitionElementsKindAndCompareMaps(
maglev/maglev-graph-builder.cc:  ValueNode* new_map = AddNewNode<TransitionElementsKind>(
maglev/maglev-graph-builder.cc:      RETURN_IF_ABORT(BuildTransitionElementsKindOrCheckMap(
maglev/maglev-graph-builder.cc:        map_check_result = BuildTransitionElementsKindOrCheckMap(
maglev/maglev-graph-builder.cc:        map_check_result = BuildTransitionElementsKindAndCompareMaps(
maglev/maglev-graph-builder.h:  ReduceResult BuildTransitionElementsKindOrCheckMap(
maglev/maglev-graph-builder.h:  ReduceResult BuildTransitionElementsKindAndCompareMaps(
runtime/runtime.h:  F(TransitionElementsKind, 2, 1)      \
runtime/runtime.h:  F(TransitionElementsKindWithKind, 2, 1)
maglev/maglev-ir.cc:void GenerateTransitionElementsKind(
maglev/maglev-ir.cc:                __ CallRuntime(Runtime::kTransitionElementsKind);
maglev/maglev-ir.cc:int TransitionElementsKind::MaxCallStackArgs() const {
maglev/maglev-ir.cc:void TransitionElementsKind::SetValueLocationConstraints() {
maglev/maglev-ir.cc:void TransitionElementsKind::GenerateCode(MaglevAssembler* masm,
maglev/maglev-ir.cc:  GenerateTransitionElementsKind(masm, this, object, map,
maglev/maglev-ir.cc:int TransitionElementsKindOrCheckMap::MaxCallStackArgs() const {
maglev/maglev-ir.cc:void TransitionElementsKindOrCheckMap::SetValueLocationConstraints() {
maglev/maglev-ir.cc:void TransitionElementsKindOrCheckMap::GenerateCode(
maglev/maglev-ir.cc:  GenerateTransitionElementsKind(masm, this, object, map,
maglev/maglev-ir.cc:void TransitionElementsKindOrCheckMap::PrintParams(
maglev/maglev-ir.h:  V(TransitionElementsKind)                         \
maglev/maglev-ir.h:  V(TransitionElementsKindOrCheckMap)         \
maglev/maglev-ir.h:class TransitionElementsKind
maglev/maglev-ir.h:    : public FixedInputValueNodeT<2, TransitionElementsKind> {
maglev/maglev-ir.h:  using Base = FixedInputValueNodeT<2, TransitionElementsKind>;
maglev/maglev-ir.h:  explicit TransitionElementsKind(
maglev/maglev-ir.h:class TransitionElementsKindOrCheckMap
maglev/maglev-ir.h:    : public FixedInputNodeT<2, TransitionElementsKindOrCheckMap> {
maglev/maglev-ir.h:  using Base = FixedInputNodeT<2, TransitionElementsKindOrCheckMap>;
maglev/maglev-ir.h:  explicit TransitionElementsKindOrCheckMap(
runtime/runtime-array.cc:RUNTIME_FUNCTION(Runtime_TransitionElementsKind) {
runtime/runtime-array.cc:          ->TransitionElementsKind(object, to_map)
runtime/runtime-array.cc:    // TODO(victorgomes): EffectControlLinearizer::LowerTransitionElementsKind
runtime/runtime-array.cc:RUNTIME_FUNCTION(Runtime_TransitionElementsKindWithKind) {
runtime/runtime-array.cc:  JSObject::TransitionElementsKind(object, to_kind);
compiler/typed-optimization.cc:    case IrOpcode::kTransitionElementsKindOrCheckMap:
compiler/typed-optimization.cc:      return ReduceTransitionElementsKindOrCheckMap(node);
compiler/typed-optimization.cc:Reduction TypedOptimization::ReduceTransitionElementsKindOrCheckMap(
compiler/simplified-operator.cc:  DCHECK_EQ(IrOpcode::kTransitionElementsKind, op->opcode());
compiler/simplified-operator.cc:  DCHECK_EQ(IrOpcode::kTransitionElementsKindOrCheckMap, op->opcode());
compiler/simplified-operator.cc:const Operator* SimplifiedOperatorBuilder::TransitionElementsKind(
compiler/simplified-operator.cc:      IrOpcode::kTransitionElementsKind,              // opcode
compiler/simplified-operator.cc:      "TransitionElementsKind",                       // name
compiler/simplified-operator.cc:const Operator* SimplifiedOperatorBuilder::TransitionElementsKindOrCheckMap(
compiler/simplified-operator.cc:      IrOpcode::kTransitionElementsKindOrCheckMap,  // opcode
compiler/simplified-operator.cc:      "TransitionElementsKindOrCheckMap",           // name
codegen/code-stub-assembler.cc:void CodeStubAssembler::TransitionElementsKind(TNode<JSObject> object,
codegen/code-stub-assembler.h:  void TransitionElementsKind(TNode<JSObject> object, TNode<Map> map,
builtins/array-to-spliced.tq:  elementsKind = TransitionElementsKindForInsertionIfNeeded(
builtins/builtins-handler-gen.cc:          TransitionElementsKind(receiver, map, from_kind, to_kind, &miss);
compiler/js-native-context-specialization.cc:      effect = graph()->NewNode(simplified()->TransitionElementsKindOrCheckMap(
compiler/js-native-context-specialization.cc:            simplified()->TransitionElementsKind(ElementsTransition(
compiler/load-elimination.h:  Reduction ReduceTransitionElementsKind(Node* node);
compiler/load-elimination.h:  Reduction ReduceTransitionElementsKindOrCheckMap(Node* node);
compiler/node-properties.cc:      case IrOpcode::kTransitionElementsKindOrCheckMap: {
objects/allocation-site-inl.h:        JSObject::TransitionElementsKind(boilerplate, to_kind);
compiler/verifier.cc:    case IrOpcode::kTransitionElementsKind:
compiler/verifier.cc:    case IrOpcode::kTransitionElementsKindOrCheckMap:
ic/ic.cc:    JSObject::TransitionElementsKind(Cast<JSObject>(object),
builtins/builtins-array.cc:    JSObject::TransitionElementsKind(array, target_kind);
builtins/builtins-array.cc:    JSObject::TransitionElementsKind(array, PACKED_ELEMENTS);
compiler/turboshaft/maglev-early-lowering-reducer-inl.h:    TransitionElementsKind(object, map, transition_sources, transition_target,
compiler/turboshaft/maglev-early-lowering-reducer-inl.h:  void TransitionElementsKind(
compiler/turboshaft/maglev-early-lowering-reducer-inl.h:    // Turboshaft's TransitionElementsKind operation loads the map everytime, so
compiler/turboshaft/maglev-early-lowering-reducer-inl.h:          __ CallRuntime_TransitionElementsKind(
compiler/simplified-lowering.cc:      case IrOpcode::kTransitionElementsKind: {
compiler/simplified-lowering.cc:      case IrOpcode::kTransitionElementsKindOrCheckMap: {
compiler/access-info.cc:    // TransitionElementsKind for a CheckMaps, avoiding mutation of the array.
builtins/array-splice.tq:transitioning macro TransitionElementsKindForInsertionIfNeeded(
builtins/array-splice.tq:    TransitionElementsKindWithKind(context, a, smiElementsKind);
builtins/array-splice.tq:  elementsKind = TransitionElementsKindForInsertionIfNeeded(
compiler/turboshaft/graph-builder.cc:    case IrOpcode::kTransitionElementsKind:
compiler/turboshaft/graph-builder.cc:      __ TransitionElementsKind(Map(node->InputAt(0)),
compiler/turboshaft/graph-builder.cc:    case IrOpcode::kTransitionElementsKindOrCheckMap: {
compiler/turboshaft/graph-builder.cc:      __ TransitionElementsKindOrCheckMap(
compiler/simplified-operator.h:  const Operator* TransitionElementsKind(ElementsTransition transition);
compiler/simplified-operator.h:  const Operator* TransitionElementsKindOrCheckMap(
compiler/typed-optimization.h:  Reduction ReduceTransitionElementsKindOrCheckMap(Node* node);
compiler/load-elimination.cc:    case IrOpcode::kTransitionElementsKind:
compiler/load-elimination.cc:      return ReduceTransitionElementsKind(node);
compiler/load-elimination.cc:    case IrOpcode::kTransitionElementsKindOrCheckMap:
compiler/load-elimination.cc:      return ReduceTransitionElementsKindOrCheckMap(node);
compiler/load-elimination.cc:Reduction LoadElimination::ReduceTransitionElementsKind(Node* node) {
compiler/load-elimination.cc:Reduction LoadElimination::ReduceTransitionElementsKindOrCheckMap(Node* node) {
compiler/load-elimination.cc:  struct TransitionElementsKindInfo {
compiler/load-elimination.cc:  ZoneVector<TransitionElementsKindInfo> element_transitions_(&temp_zone);
compiler/load-elimination.cc:          case IrOpcode::kTransitionElementsKind: {
compiler/load-elimination.cc:          case IrOpcode::kTransitionElementsKindOrCheckMap: {
compiler/load-elimination.cc:  for (const TransitionElementsKindInfo& t : element_transitions_) {
compiler/load-elimination.cc:  for (const TransitionElementsKindInfo& t : element_transitions_) {
compiler/turboshaft/machine-lowering-reducer-inl.h:  V<None> REDUCE(TransitionElementsKind)(V<HeapObject> object,
compiler/turboshaft/machine-lowering-reducer-inl.h:          __ CallRuntime_TransitionElementsKind(
compiler/turboshaft/machine-lowering-reducer-inl.h:  V<None> REDUCE(TransitionElementsKindOrCheckMap)(
compiler/turboshaft/machine-lowering-reducer-inl.h:          __ CallRuntime_TransitionElementsKind(
compiler/turboshaft/machine-lowering-reducer-inl.h:      __ CallRuntime_TransitionElementsKind(isolate_, __ NoContextConstant(),
compiler/escape-analysis.cc:    case IrOpcode::kTransitionElementsKindOrCheckMap: {
compiler/opcodes.h:  V(TransitionElementsKind)             \
compiler/opcodes.h:  V(TransitionElementsKindOrCheckMap)   \
compiler/turbofan-typer.cc:Type Typer::Visitor::TypeTransitionElementsKind(Node* node) { UNREACHABLE(); }
compiler/turbofan-typer.cc:Type Typer::Visitor::TypeTransitionElementsKindOrCheckMap(Node* node) {
compiler/turboshaft/assembler.h:  V<Object> CallRuntime_TransitionElementsKind(Isolate* isolate,
compiler/turboshaft/assembler.h:    return CallRuntime<typename RuntimeCallDescriptor::TransitionElementsKind>(
compiler/turboshaft/assembler.h:  void TransitionElementsKind(V<HeapObject> object,
compiler/turboshaft/assembler.h:    ReduceIfReachableTransitionElementsKind(object, transition);
compiler/turboshaft/assembler.h:  void TransitionElementsKindOrCheckMap(
compiler/turboshaft/assembler.h:    ReduceIfReachableTransitionElementsKindOrCheckMap(object, map, frame_state,
builtins/base.tq:extern transitioning runtime TransitionElementsKindWithKind(
builtins/base.tq:extern macro TransitionElementsKind(
compiler/turboshaft/maglev-graph-building-phase.cc:  maglev::ProcessResult Process(maglev::TransitionElementsKindOrCheckMap* node,
compiler/turboshaft/maglev-graph-building-phase.cc:    __ TransitionElementsKindOrCheckMap(
compiler/turboshaft/maglev-graph-building-phase.cc:  maglev::ProcessResult Process(maglev::TransitionElementsKind* node,
compiler/turboshaft/operations.h:  V(TransitionElementsKind)                     \
compiler/turboshaft/operations.h:  V(TransitionElementsKindOrCheckMap)           \
compiler/turboshaft/operations.h:struct TransitionElementsKindOp
compiler/turboshaft/operations.h:    : FixedArityOperationT<1, TransitionElementsKindOp> {
compiler/turboshaft/operations.h:  TransitionElementsKindOp(OpIndex object, const ElementsTransition& transition)
compiler/turboshaft/operations.h:struct TransitionElementsKindOrCheckMapOp
compiler/turboshaft/operations.h:    : FixedArityOperationT<3, TransitionElementsKindOrCheckMapOp> {
compiler/turboshaft/operations.h:  TransitionElementsKindOrCheckMapOp(
compiler/turboshaft/runtime-call-descriptors.h:  struct TransitionElementsKind : public Descriptor<TransitionElementsKind> {
compiler/turboshaft/runtime-call-descriptors.h:    static constexpr auto kFunction = Runtime::kTransitionElementsKind;
objects/js-objects-inl.h:      TransitionElementsKind(object, HOLEY_ELEMENTS);
objects/js-objects-inl.h:      TransitionElementsKind(object, PACKED_ELEMENTS);
objects/js-objects-inl.h:    TransitionElementsKind(object, target_kind);
objects/js-objects-inl.h:    TransitionElementsKind(object, HOLEY_DOUBLE_ELEMENTS);
objects/js-objects-inl.h:        TransitionElementsKind(object, HOLEY_DOUBLE_ELEMENTS);
objects/js-objects-inl.h:    TransitionElementsKind(object, PACKED_DOUBLE_ELEMENTS);
objects/elements.h:  V8_WARN_UNUSED_RESULT virtual Maybe<bool> TransitionElementsKind(
objects/elements-kind.cc:ElementsKind GetNextTransitionElementsKind(ElementsKind kind) {
objects/map.cc:  bool allow_store_transition = IsTransitionElementsKind(from_kind);
objects/map.cc:  DCHECK(IsTransitionElementsKind(map->elements_kind()));
objects/map.cc:        kind = GetNextTransitionElementsKind(kind);
objects/js-objects.cc:      TransitionElementsKind(object, to_kind);
objects/js-objects.cc:        JSObject::TransitionElementsKind(object, PACKED_ELEMENTS);
objects/js-objects.cc:        JSObject::TransitionElementsKind(object, HOLEY_ELEMENTS);
objects/js-objects.cc:void JSObject::TransitionElementsKind(DirectHandle<JSObject> object,
objects/js-objects.cc:      // overflow, until all users of TransitionElementsKind can handle
objects/elements-kind.h:ElementsKind GetNextTransitionElementsKind(ElementsKind elements_kind);
objects/elements-kind.h:inline bool IsTransitionElementsKind(ElementsKind kind) {
objects/lookup.cc:      JSObject::TransitionElementsKind(holder_obj, to);
objects/elements.cc:        JSObject::TransitionElementsKind(array, kind);
objects/elements.cc:  static Maybe<bool> TransitionElementsKindImpl(DirectHandle<JSObject> object,
objects/elements.cc:  Maybe<bool> TransitionElementsKind(DirectHandle<JSObject> object,
objects/elements.cc:    return Subclass::TransitionElementsKindImpl(object, map);
objects/elements.cc:        JSObject::TransitionElementsKind(object, to_kind);
objects/elements.cc:      JSObject::TransitionElementsKind(obj, GetHoleyElementsKind(kind));
objects/elements.cc:  static Maybe<bool> TransitionElementsKindImpl(DirectHandle<JSObject> object,
objects/elements.cc:        JSObject::TransitionElementsKind(array, elements_kind);
objects/js-objects.h:  V8_EXPORT_PRIVATE static void TransitionElementsKind(
[Step 12: Duration 7.91 seconds| Input tokens: 267,845 | Output tokens: 3,159]
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ Step 13 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'init_rag_db' with arguments: {'id': 'v8_elements_loci'}                                                                                                                 │
╰────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
Error executing tool 'init_rag_db' with arguments {'id': 'v8_elements_loci'}: NameError: name 'rag_db_id' is not defined
Please try again or use another tool
[Step 13: Duration 20.03 seconds| Input tokens: 327,202 | Output tokens: 4,212]
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ Step 14 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'final_answer' with arguments: {'answer': '### 1. Task outcome (short version):\nI scanned the V8 main-branch source (Torque/CSA/and C++) for the keyed array element    │
│ access / elements-kind-transition region and produced a targeted loci inventory grouped by your six subsections (a)-(f). Each item includes an ID, exact repository path, main         │
│ symbol(s)/function(s), and a short note. These IDs let us point at any locus for deeper Stage 2–4 inspection.\n\nSummary: I located core C++ objects and helpers (objects/elements.*   │
│ and objects/*array*.cc/h), CSA/CodeStubAssembler helpers (codegen/code-stub-assembler.*), IC machinery and builtins generators (ic/*, builtins/*-gen.cc, builtins/*.tq), compiler      │
│ lowering & reducers (compiler/*: AccessInfoFactory, JSCreateLowering, JSCallReducer, JSNativeContextSpecialization), and runtime handlers (runtime/runtime-array.cc). See the detailed │
│ inventory below (grouped per subsection).\n\n---\n\n### 2. Task outcome (extremely detailed version)\nNote: IDs are arbitrary stable integers for referencing loci later. Paths are    │
│ relative to repo root. I grouped entries per your subsections (a)–(f). Where a concept spans Torque/CSA/C++ I included items from each area.\n\n(a) Elements operations:               │
│ TransitionElementsKind, EnsureCapacity/GrowElementsCapacity, CopyElements, SetLength, helpers\n- [1001] objects/elements.cc : TransitionElementsKindImpl / TransitionElementsKind /    │
│ CopyElements / MoveElements\n  - Note: central C++ implementations for elements accessors & transitions. Implements per-subclass TransitionElementsKindImpl and CopyElements utilities │
│ used by Map & JSObject transitions.\n- [1002] objects/elements.h : ElementsAccessor base class\n  - Note: virtuals like Maybe<bool> TransitionElementsKind(...), SetLength and other   │
│ accessor APIs declared here.\n- [1003] objects/elements-inl.h : inline accessors and helpers\n  - Note: inlined accessors, helpers for element reads/writes, fast-path selection.\n-   │
│ [1004] codegen/code-stub-assembler.cc : CSA helpers: GrowElementsCapacity / TryGrowElementsCapacity / CopyElements / PossiblyGrowElementsCapacity / TransitionElementsKind (CSA        │
│ wrappers)\n  - Note: CodeStubAssembler (CSA) implementations used by builtins and generated stubs when building optimized code.\n- [1005] codegen/code-stub-assembler.h : declarations │
│ for the CSA helpers above\n- [1006] objects/fixed-array.h / objects/fixed-array.cc : FixedArrayBase::CopyElements and CopyElements helpers\n  - Note: low-level copy/memmove helpers   │
│ for backing storage arrays.\n- [1007] objects/js-objects.cc / objects/js-objects-inl.h : JSObject::TransitionElementsKind (public wrapper) and inline checks\n  - Note: high-level     │
│ entrypoint called by runtime or C++ callers to perform a transition on a JSObject/JSArray.\n- [1008] runtime/runtime-array.cc : RUNTIME_FUNCTION(Runtime_TransitionElementsKind) and   │
│ Runtime_TransitionElementsKindWithKind\n  - Note: runtime entry used by builtins/stubs to perform transition at runtime (also referenced by Builtins.)\n- [1009] builtins/base.tq &    │
│ builtins/*-handler-gen.cc : builtin/runtime declarations for TransitionElementsKind (Torque externs)\n  - Note: torque declarations (e.g. extern transitioning runtime                 │
│ TransitionElementsKindWithKind) and handler generators that tail-call runtime slow path.\n\n(b) Arrays core: JSArray::SetLength and helpers; elements accessors for JSArray/JSObject;  │
│ backing store & length/capacity growth\n- [2001] objects/objects.cc : JSArray::SetLength / JSArray::ArraySetLength / SetLengthWouldNormalize\n  - Note: implements ES semantics        │
│ (ArraySetLength) and delegates to elements accessor SetLength when possible.\n- [2002] objects/elements.* (elements.cc / elements.h / elements-inl.h) — (already listed at             │
│ 1001–1003)\n  - Note: contains ElementsAccessorBase::SetLengthImpl and per-kind SetLength implementations; contact point for array length/normalization.\n- [2003]                     │
│ codegen/code-stub-assembler.cc : ArrayListSetLength / BuildAppendJSArray / PossiblyGrowElementsCapacity / GrowElementsCapacity\n  - Note: CSA helpers used by builtins (e.g.           │
│ push/unshift) to fast-path growing backing store.\n- [2004] builtins/array.tq and builtins/*array-*.tq (array-from.tq, array-slice.tq, array-splice.tq, array-unshift.tq,              │
│ array-to-spliced.tq etc.)\n  - Note: Torque definitions of Array prototype builtins and helpers. Many specialized fast paths live here.\n- [2005] builtins/builtins-array-gen.cc &     │
│ builtins/builtins-array.cc : generated C++ entrypoints and dispatch wrappers for array builtins\n  - Note: generated glue that connects Torque builtins to their C++ assembly/CSA      │
│ implementations and tail-calls slow-path runtime.\n- [2006] objects/fixed-array.h/.cc & builtin/growable-fixed-array.* : backing store alloc helpers\n  - Note: allocation and         │
│ resizing helpers for fixed arrays & growable-fixed-array used for capacity growth.\n\n(c) Inline caches: KeyedStoreIC / KeyedLoadIC / StoreIC/LoadIC participation; IC stub            │
│ transitions; feedback collection; runtime/TF handlers\n- [3001] ic/ic.h : class IC + LoadIC/StoreIC/KeyedLoadIC/KeyedStoreIC declarations\n  - Note: the IC class hierarchy, and       │
│ helper APIs to update/compute handlers and feedback.\n- [3002] ic/ic.cc : KeyedLoadIC::UpdateLoadElement, KeyedStoreIC::UpdateStoreElement, runtime miss handling\n  - Note: logic     │
│ that maps keyed access feedback to handlers and elements transition handlers.\n- [3003] ic/keyed-store-generic.cc / ic/keyed-store-generic.h : generic KeyedStoreIC assembler logic\n  │
│ - Note: contains FindCandidateStoreICTransitionMapHandler, handler selection & transition handling used by KeyedStoreIC stubs.\n- [3004] ic/accessor-assembler.cc /                    │
│ ic/accessor-assembler.h : generates LoadIC/KeyedLoadIC/StoreIC/KeyedStoreIC CSA codepaths (polymorphic/megamorphic/uninitialized logic)\n  - Note: core generation of IC-fastpaths,    │
│ including branching to megamorphic trampolines and tailcalls to runtime misses (KeyedStoreIC_Miss etc.).\n- [3005] builtins/builtins-ic-gen.cc & builtins/builtins-handler-gen.cc :    │
│ codegen for IC builtins & handlers (KeyedLoadIC, KeyedStoreIC, variants)\n  - Note: generated stubs for e.g. KeyedStoreIC_StoreFastElementStub,                                        │
│ KeyedStoreIC_ElementsTransitionAndStoreStub, KeyedLoadIC_LoadElementDH etc.\n- [3006] objects/feedback-vector.h / objects/feedback-vector.cc : feedback slot kinds and slot creation   │
│ (AddKeyedLoadICSlot/AddKeyedStoreICSlot)\n  - Note: where feedback slot kinds (kLoadKeyed / kStoreKeyed) are defined and used; used by interpreter bytecode generator to allocate      │
│ slots.\n- [3007] builtins/builtins-definitions.h : Builtin names for IC entrypoints (KeyedLoadIC, KeyedStoreIC, their megamorphic/trampoline forms)\n  - Note: canonical names used    │
│ across generator and runtime.\n- [3008] builtins/builtins-handler-gen.cc : places where stubs tail-call to runtime misses / ElementsTransitionAndStoreIC miss handlers\n\n(d) Builtins │
│ fast paths: ArrayPrototypePush/Pop/Slice/Splice/Concat/From/Spread; Torque/CSA definitions; generated C++ entry points; guards & branch to slow-path\n- [4001] builtins/array.tq :     │
│ main Torque file with many Array prototype builtin definitions and helpers\n  - Note: contains the Torque-level logic for many array methods and calls into CSA helpers for fast       │
│ paths.\n- [4002] builtins/array-from.tq, builtins/array-slice.tq, builtins/array-splice.tq, builtins/array-to-spliced.tq, builtins/array-push/unshift/shift-handling parts (files      │
│ listed in builtins directory)\n  - Note: dedicated Torque sources for specific Array methods / special-casing.\n- [4003] builtins/builtins-array-gen.cc and builtins/builtins-array.cc │
│ : generated C++ entrypoints, caller wrappers and runtime fallbacks\n  - Note: show where builtins fast-paths (Torque) are compiled into C++ glue; there are also CSA calls inside      │
│ generated code.\n- [4004] codegen/code-stub-assembler.cc & ic/accessor-assembler.cc : the CSA fast-path guards used by builtins (e.g. load elements kind, bounds check, hole checks)   │
│ and bailout to slow path via TailCallRuntime or TailCallBuiltin\n  - Note: the conditional guards (IsFastElementsKind, IsHoley fast checks, TypedArray checks) are here; slow-paths go │
│ to Runtime::kKeyedStoreIC_Miss or builtin slow stubs.\n- [4005] builtins/builtins-handler-gen.cc : stubs that implement the small C++/CSA fast handlers (StoreElementStub variants and │
│ ElementsTransitionAndStoreStub) and call runtime for misses.\n\n(e) Compiler lowering: AccessInfo/AccessInfoFactory, JSCreateLowering, JSNativeContextSpecialization, JSCallReducer,   │
│ JS(Load|Store)Indexed lowering, SimplifiedLowering\n- [5001] compiler/access-info.h / compiler/access-info.cc : AccessInfoFactory and ElementAccessInfo / PropertyAccessInfo           │
│ computation\n  - Note: AccessInfoFactory::ComputeElementAccessInfo, ConsolidateElementLoad etc. are used by lowering passes and JSCallReducer.\n- [5002]                               │
│ compiler/js-create-lowering.cc / js-create-lowering.h : JSCreateLowering\n  - Note: lowering of JSCreate/array-instantiation patterns (e.g., AllocateJSArray) and interaction with     │
│ elements kinds.\n- [5003] compiler/js-native-context-specialization.cc / .h : JSNativeContextSpecialization\n  - Note: uses AccessInfoFactory and rewrites calls using native-context  │
│ constants and known maps/elements kinds.\n- [5004] compiler/js-call-reducer.cc / .h : JSCallReducer and iterating array builtins reducer\n  - Note: many                               │
│ ReduceArrayPrototypePush/Pop/Slice/Splice implementations here; checks elements kind and emits simplified node sequences; has helpers like LoadJSArrayLength, CheckIfElementsKind,     │
│ ConvertHoleToUndefined.\n- [5005] compiler/js-generic-lowering.cc / .h : generic lowering emits builtin calls to the appropriate KeyedLoadIC/KeyedStoreIC builtins (e.g.               │
│ Builtin::kKeyedLoadIC or Builtin::kKeyedLoadIC_Megamorphic based on feedback)\n  - Note: used in TurboFan lowering path to canonicalize property/keyed accesses into IC calls or       │
│ direct loads.\n- [5006] compiler/simplified-lowering.cc / simplified-operator.{h,cc} : SimplifiedOperatorBuilder includes TransitionElementsKind op; SimplifiedLowering emits checks   │
│ concerning ElementsKind\n  - Note: contains lowering for TransitionElementsKind/CheckMap nodes.\n- [5007] compiler/js-heap-broker.cc / compiler/js-heap-broker.h and                   │
│ compiler/heap-refs.* : helpers used during JSNativeContextSpecialization and JSCallReducer to read map/elements kind info from the heap broker.\n\n(f) Deopt/feedback: deopt guards    │
│ for elements kind & bounds; feedback-vector slot kinds; transitions updating/invalidate IC state; map stability checks\n- [6001] codegen/code-stub-assembler.cc : CSA guards and       │
│ bailout primitives; helper functions that emit deopt or tail-to-runtime when guards fail (e.g. IsFastElementsKind checks, bounds checks, hole checks)\n  - Note: these functions       │
│ generate the low-level deopt/slow-path transitions used by both builtins and generated IC stubs.\n- [6002] compiler/js-call-reducer.cc : CheckIfElementsKind & CheckArrayLength /      │
│ checks that produce deopt nodes; conversion of holes to undefined tied to elements kind\n  - Note: compiler uses these to insert guard nodes that can trigger deopt or bailout to      │
│ generic code.\n- [6003] ic/ic.cc / ic/ic.h : Update caches and ComputeHandler code: updates to feedback vector and mapping from feedback to stub states; code paths that               │
│ clear/invalidate stubs on transitions\n  - Note: KeyedStoreIC::UpdateStoreElement and KeyedLoadIC::UpdateLoadElement change handlers and occasionally install transition handlers      │
│ (ElementsTransitionAndStore) which in turn update feedback slots.\n- [6004] objects/feedback-vector.h / .cc : FeedbackSlotKind enums for keyed loads/stores and helpers                │
│ IsKeyedLoadICKind / IsKeyedStoreICKind\n  - Note: feedback slot types used by bytecode/interpreter and ICs to know which builtin/runtime to call and what feedback to collect.\n-      │
│ [6005] objects/map.cc / objects/map-updater.h : ReconfigureElementsKind / transitions and checks for map stability\n  - Note: where map transitions are validated and how transitions  │
│ influence element kinds; also used in AllocationSite tracking code.\n- [6006] runtime/runtime-array.cc : runtime implementations that are invoked when inline stubs miss and must      │
│ perform transitions at runtime (also update feedback, sometimes install handlers)\n\n---\n\nHow I found these (short methodology):\n- Focused ripgrep queries for canonical symbols:   │
│ TransitionElementsKind, GrowElementsCapacity, CopyElements, JSArray::SetLength, KeyedLoadIC, KeyedStoreIC, AccessInfoFactory, JSCallReducer, CodeStubAssembler helpers, and            │
│ builtins/array *.tq files.\n- Navigated to canonical directories: src/objects, src/codegen, src/ic, src/builtins, src/compiler, src/runtime.\n- Confirmed CSA implementations exist in │
│ codegen/code-stub-assembler.cc (they are heavily used by builtins and IC generators).\n\nRecommendations / next steps (Stage 2+):\n- For each ID above I can open the specific file &  │
│ symbol and extract the precise function bodies and the exact call chains. Suggested prioritized follow-ups (choose by ID):\n  - Deep dive on Transition path: [1001], [1007], [1008],  │
│ [3003]\n  - CSA growth/copy helpers used by Push/Append: [1004], [2003], [4004]\n  - IC handler lifecycle & feedback: [3002], [3006], [6003]\n  - Compiler lowering + reducers for     │
│ array builtins: [5004], [5001], [5005]\n\nIf you want, I will proceed to Stage 2: run ripgrep on the specific files listed above for lines that show how (a) transitions are chosen    │
│ and applied, (b) inlined fast-path guards branch to slow-path, (c) IC handler installation updates feedback slots and elements-kind sticky behavior. Provide a list of the IDs you     │
│ want me to expand first, or I will start with the TransitionElementsKind path (IDs: 1001/1007/1008/1004) and the IC update path (IDs: 3002/3003/3006).\n\n---\n\n### 3. Additional     │
│ context (if relevant)\n- Many operations live in both C++ (objects/elements.* and runtime/*) and CSA-generated code (codegen/code-stub-assembler.cc plus generated builtins under      │
│ builtins/*-gen.cc). The canonical flow often is: JS bytecode/JSTurboFan lowered node -> IC builtin (KeyedLoadIC/KeyedStoreIC) or direct CSA sequence -> CSA emits guard(s)             │
│ (map/elements-kind/bounds) -> on success do direct element load/store with CopyElements/GrowElementsCapacity -> on failure tail-call Runtime::kKeyedStoreIC_Miss or                    │
│ TransitionElementsKind runtime function -> runtime performs map transition or slow semantics.\n- ElementsKind semantics are pervasive and affect many layers: objects (maps), ICs,     │
│ builtins, and compiler. AccessInfoFactory and JSCallReducer/JSNativeContextSpecialization are the compiler-side places that reason about elements kinds and try to produce efficient   │
│ code using that info.\n\nIf you confirm, I will now begin Stage 2 and open the top-priority files (e.g., objects/elements.cc, codegen/code-stub-assembler.cc, ic/ic.cc,                │
│ runtime/runtime-array.cc, compiler/js-call-reducer.cc) to extract the exact lines and call chains. I can also initialize the RAG DB and write each locus (Stage 5) once you want me to │
│ persist this inventory into the RAG store.'}                                                                                                                                           │
╰────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
Observations: ### 1. Task outcome (short version):
I scanned the V8 main-branch source (Torque/CSA/and C++) for the keyed array element access / elements-kind-transition region and produced a targeted loci inventory grouped by your six 
subsections (a)-(f). Each item includes an ID, exact repository path, main symbol(s)/function(s), and a short note. These IDs let us point at any locus for deeper Stage 2–4 inspection.

Summary: I located core C++ objects and helpers (objects/elements.* and objects/*array*.cc/h), CSA/CodeStubAssembler helpers (codegen/code-stub-assembler.*), IC machinery and builtins 
generators (ic/*, builtins/*-gen.cc, builtins/*.tq), compiler lowering & reducers (compiler/*: AccessInfoFactory, JSCreateLowering, JSCallReducer, JSNativeContextSpecialization), and 
runtime handlers (runtime/runtime-array.cc). See the detailed inventory below (grouped per subsection).

---

### 2. Task outcome (extremely detailed version)
Note: IDs are arbitrary stable integers for referencing loci later. Paths are relative to repo root. I grouped entries per your subsections (a)–(f). Where a concept spans Torque/CSA/C++ 
I included items from each area.

(a) Elements operations: TransitionElementsKind, EnsureCapacity/GrowElementsCapacity, CopyElements, SetLength, helpers
- |1001] objects/elements.cc : TransitionElementsKindImpl / TransitionElementsKind / CopyElements / MoveElements
  - Note: central C++ implementations for elements accessors & transitions. Implements per-subclass TransitionElementsKindImpl and CopyElements utilities used by Map & JSObject 
transitions.
- |1002] objects/elements.h : ElementsAccessor base class
  - Note: virtuals like Maybe<bool> TransitionElementsKind(...), SetLength and other accessor APIs declared here.
- |1003] objects/elements-inl.h : inline accessors and helpers
  - Note: inlined accessors, helpers for element reads/writes, fast-path selection.
- |1004] codegen/code-stub-assembler.cc : CSA helpers: GrowElementsCapacity / TryGrowElementsCapacity / CopyElements / PossiblyGrowElementsCapacity / TransitionElementsKind (CSA 
wrappers)
  - Note: CodeStubAssembler (CSA) implementations used by builtins and generated stubs when building optimized code.
- |1005] codegen/code-stub-assembler.h : declarations for the CSA helpers above
- |1006] objects/fixed-array.h / objects/fixed-array.cc : FixedArrayBase::CopyElements and CopyElements helpers
  - Note: low-level copy/memmove helpers for backing storage arrays.
- |1007] objects/js-objects.cc / objects/js-objects-inl.h : JSObject::TransitionElementsKind (public wrapper) and inline checks
  - Note: high-level entrypoint called by runtime or C++ callers to perform a transition on a JSObject/JSArray.
- |1008] runtime/runtime-array.cc : RUNTIME_FUNCTION(Runtime_TransitionElementsKind) and Runtime_TransitionElementsKindWithKind
  - Note: runtime entry used by builtins/stubs to perform transition at runtime (also referenced by Builtins.)
- |1009] builtins/base.tq & builtins/*-handler-gen.cc : builtin/runtime declarations for TransitionElementsKind (Torque externs)
  - Note: torque declarations (e.g. extern transitioning runtime TransitionElementsKindWithKind) and handler generators that tail-call runtime slow path.

(b) Arrays core: JSArray::SetLength and helpers; elements accessors for JSArray/JSObject; backing store & length/capacity growth
- |2001] objects/objects.cc : JSArray::SetLength / JSArray::ArraySetLength / SetLengthWouldNormalize
  - Note: implements ES semantics (ArraySetLength) and delegates to elements accessor SetLength when possible.
- |2002] objects/elements.* (elements.cc / elements.h / elements-inl.h) — (already listed at 1001–1003)
  - Note: contains ElementsAccessorBase::SetLengthImpl and per-kind SetLength implementations; contact point for array length/normalization.
- |2003] codegen/code-stub-assembler.cc : ArrayListSetLength / BuildAppendJSArray / PossiblyGrowElementsCapacity / GrowElementsCapacity
  - Note: CSA helpers used by builtins (e.g. push/unshift) to fast-path growing backing store.
- |2004] builtins/array.tq and builtins/*array-*.tq (array-from.tq, array-slice.tq, array-splice.tq, array-unshift.tq, array-to-spliced.tq etc.)
  - Note: Torque definitions of Array prototype builtins and helpers. Many specialized fast paths live here.
- |2005] builtins/builtins-array-gen.cc & builtins/builtins-array.cc : generated C++ entrypoints and dispatch wrappers for array builtins
  - Note: generated glue that connects Torque builtins to their C++ assembly/CSA implementations and tail-calls slow-path runtime.
- |2006] objects/fixed-array.h/.cc & builtin/growable-fixed-array.* : backing store alloc helpers
  - Note: allocation and resizing helpers for fixed arrays & growable-fixed-array used for capacity growth.

(c) Inline caches: KeyedStoreIC / KeyedLoadIC / StoreIC/LoadIC participation; IC stub transitions; feedback collection; runtime/TF handlers
- |3001] ic/ic.h : class IC + LoadIC/StoreIC/KeyedLoadIC/KeyedStoreIC declarations
  - Note: the IC class hierarchy, and helper APIs to update/compute handlers and feedback.
- |3002] ic/ic.cc : KeyedLoadIC::UpdateLoadElement, KeyedStoreIC::UpdateStoreElement, runtime miss handling
  - Note: logic that maps keyed access feedback to handlers and elements transition handlers.
- |3003] ic/keyed-store-generic.cc / ic/keyed-store-generic.h : generic KeyedStoreIC assembler logic
  - Note: contains FindCandidateStoreICTransitionMapHandler, handler selection & transition handling used by KeyedStoreIC stubs.
- |3004] ic/accessor-assembler.cc / ic/accessor-assembler.h : generates LoadIC/KeyedLoadIC/StoreIC/KeyedStoreIC CSA codepaths (polymorphic/megamorphic/uninitialized logic)
  - Note: core generation of IC-fastpaths, including branching to megamorphic trampolines and tailcalls to runtime misses (KeyedStoreIC_Miss etc.).
- |3005] builtins/builtins-ic-gen.cc & builtins/builtins-handler-gen.cc : codegen for IC builtins & handlers (KeyedLoadIC, KeyedStoreIC, variants)
  - Note: generated stubs for e.g. KeyedStoreIC_StoreFastElementStub, KeyedStoreIC_ElementsTransitionAndStoreStub, KeyedLoadIC_LoadElementDH etc.
- |3006] objects/feedback-vector.h / objects/feedback-vector.cc : feedback slot kinds and slot creation (AddKeyedLoadICSlot/AddKeyedStoreICSlot)
  - Note: where feedback slot kinds (kLoadKeyed / kStoreKeyed) are defined and used; used by interpreter bytecode generator to allocate slots.
- |3007] builtins/builtins-definitions.h : Builtin names for IC entrypoints (KeyedLoadIC, KeyedStoreIC, their megamorphic/trampoline forms)
  - Note: canonical names used across generator and runtime.
- |3008] builtins/builtins-handler-gen.cc : places where stubs tail-call to runtime misses / ElementsTransitionAndStoreIC miss handlers

(d) Builtins fast paths: ArrayPrototypePush/Pop/Slice/Splice/Concat/From/Spread; Torque/CSA definitions; generated C++ entry points; guards & branch to slow-path
- |4001] builtins/array.tq : main Torque file with many Array prototype builtin definitions and helpers
  - Note: contains the Torque-level logic for many array methods and calls into CSA helpers for fast paths.
- |4002] builtins/array-from.tq, builtins/array-slice.tq, builtins/array-splice.tq, builtins/array-to-spliced.tq, builtins/array-push/unshift/shift-handling parts (files listed in 
builtins directory)
  - Note: dedicated Torque sources for specific Array methods / special-casing.
- |4003] builtins/builtins-array-gen.cc and builtins/builtins-array.cc : generated C++ entrypoints, caller wrappers and runtime fallbacks
  - Note: show where builtins fast-paths (Torque) are compiled into C++ glue; there are also CSA calls inside generated code.
- |4004] codegen/code-stub-assembler.cc & ic/accessor-assembler.cc : the CSA fast-path guards used by builtins (e.g. load elements kind, bounds check, hole checks) and bailout to slow 
path via TailCallRuntime or TailCallBuiltin
  - Note: the conditional guards (IsFastElementsKind, IsHoley fast checks, TypedArray checks) are here; slow-paths go to Runtime::kKeyedStoreIC_Miss or builtin slow stubs.
- |4005] builtins/builtins-handler-gen.cc : stubs that implement the small C++/CSA fast handlers (StoreElementStub variants and ElementsTransitionAndStoreStub) and call runtime for 
misses.

(e) Compiler lowering: AccessInfo/AccessInfoFactory, JSCreateLowering, JSNativeContextSpecialization, JSCallReducer, JS(Load|Store)Indexed lowering, SimplifiedLowering
- |5001] compiler/access-info.h / compiler/access-info.cc : AccessInfoFactory and ElementAccessInfo / PropertyAccessInfo computation
  - Note: AccessInfoFactory::ComputeElementAccessInfo, ConsolidateElementLoad etc. are used by lowering passes and JSCallReducer.
- |5002] compiler/js-create-lowering.cc / js-create-lowering.h : JSCreateLowering
  - Note: lowering of JSCreate/array-instantiation patterns (e.g., AllocateJSArray) and interaction with elements kinds.
- |5003] compiler/js-native-context-specialization.cc / .h : JSNativeContextSpecialization
  - Note: uses AccessInfoFactory and rewrites calls using native-context constants and known maps/elements kinds.
- |5004] compiler/js-call-reducer.cc / .h : JSCallReducer and iterating array builtins reducer
  - Note: many ReduceArrayPrototypePush/Pop/Slice/Splice implementations here; checks elements kind and emits simplified node sequences; has helpers like LoadJSArrayLength, 
CheckIfElementsKind, ConvertHoleToUndefined.
- |5005] compiler/js-generic-lowering.cc / .h : generic lowering emits builtin calls to the appropriate KeyedLoadIC/KeyedStoreIC builtins (e.g. Builtin::kKeyedLoadIC or 
Builtin::kKeyedLoadIC_Megamorphic based on feedback)
  - Note: used in TurboFan lowering path to canonicalize property/keyed accesses into IC calls or direct loads.
- |5006] compiler/simplified-lowering.cc / simplified-operator.{h,cc} : SimplifiedOperatorBuilder includes TransitionElementsKind op; SimplifiedLowering emits checks concerning 
ElementsKind
  - Note: contains lowering for TransitionElementsKind/CheckMap nodes.
- |5007] compiler/js-heap-broker.cc / compiler/js-heap-broker.h and compiler/heap-refs.* : helpers used during JSNativeContextSpecialization and JSCallReducer to read map/elements kind 
info from the heap broker.

(f) Deopt/feedback: deopt guards for elements kind & bounds; feedback-vector slot kinds; transitions updating/invalidate IC state; map stability checks
- |6001] codegen/code-stub-assembler.cc : CSA guards and bailout primitives; helper functions that emit deopt or tail-to-runtime when guards fail (e.g. IsFastElementsKind checks, bounds 
checks, hole checks)
  - Note: these functions generate the low-level deopt/slow-path transitions used by both builtins and generated IC stubs.
- |6002] compiler/js-call-reducer.cc : CheckIfElementsKind & CheckArrayLength / checks that produce deopt nodes; conversion of holes to undefined tied to elements kind
  - Note: compiler uses these to insert guard nodes that can trigger deopt or bailout to generic code.
- |6003] ic/ic.cc / ic/ic.h : Update caches and ComputeHandler code: updates to feedback vector and mapping from feedback to stub states; code paths that clear/invalidate stubs on 
transitions
  - Note: KeyedStoreIC::UpdateStoreElement and KeyedLoadIC::UpdateLoadElement change handlers and occasionally install transition handlers (ElementsTransitionAndStore) which in turn 
update feedback slots.
- |6004] objects/feedback-vector.h / .cc : FeedbackSlotKind enums for keyed loads/stores and helpers IsKeyedLoadICKind / IsKeyedStoreICKind
  - Note: feedback slot types used by bytecode/interpreter and ICs to know which builtin/runtime to call and what feedback to collect.
- |6005] objects/map.cc / objects/map-updater.h : ReconfigureElementsKind / transitions and checks for map stability
  - Note: where map transitions are validated and how transitions influence element kinds; also used in AllocationSite tracking code.
- |6006] runtime/runtime-array.cc : runtime implementations that are invoked when inline stubs miss and must perform transitions at runtime (also update feedback, sometimes install 
handlers)

---

How I found these (short methodology):
- Focused ripgrep queries for canonical symbols: TransitionElementsKind, GrowElementsCapacity, CopyElements, JSArray::SetLength, KeyedLoadIC, KeyedStoreIC, AccessInfoFactory, 
JSCallReducer, CodeStubAssembler helpers, and builtins/array *.tq files.
- Navigated to canonical directories: src/objects, src/codegen, src/ic, src/builtins, src/compiler, src/runtime.
- Confirmed CSA implementations exist in codegen/code-stub-assembler.cc (they are heavily used by builtins and IC generators).

Recommendations / next steps (Stage 2+):
- For each ID above I can open the specific file & symbol and extract the precise function bodies and the exact call chains. Suggested prioritized follow-ups (choose by ID):
  - Deep dive on Transition path: |1001], |1007], |1008], |3003]
  - CSA growth/copy helpers used by Push/Append: |1004], |2003], |4004]
  - IC handler lifecycle & feedback: |3002], |3006], |6003]
  - Compiler lowering + reducers for array builtins: |5004], |5001], |5005]

If you want, I will proceed to Stage 2: run ripgrep on the specific files listed above for lines that show how (a) transitions are chosen and applied, (b) inlined fast-path guards branch
to slow-path, (c) IC handler installation updates feedback slots and elements-kind sticky behavior. Provide a list of the IDs you want me to expand first, or I will start with the 
TransitionElementsKind path (IDs: 1001/1007/1008/1004) and the IC update path (IDs: 3002/3003/3006).

---

### 3. Additional context (if relevant)
- Many operations live in both C++ (objects/elements.* and runtime/*) and CSA-generated code (codegen/code-stub-assembler.cc plus generated builtins under builtins/*-gen.cc). The 
canonical flow often is: JS bytecode/JSTurboFan lowered node -> IC builtin (KeyedLoadIC/KeyedStoreIC) or direct CSA sequence -> CSA emits guard(s) (map/elements-kind/bounds) -> on 
success do direct element load/store with CopyElements/GrowElementsCapacity -> on failure tail-call Runtime::kKeyedStoreIC_Miss or TransitionElementsKind runtime function -> runtime 
performs map transition or slow semantics.
- ElementsKind semantics are pervasive and affect many layers: objects (maps), ICs, builtins, and compiler. AccessInfoFactory and JSCallReducer/JSNativeContextSpecialization are the 
compiler-side places that reason about elements kinds and try to produce efficient code using that info.

If you confirm, I will now begin Stage 2 and open the top-priority files (e.g., objects/elements.cc, codegen/code-stub-assembler.cc, ic/ic.cc, runtime/runtime-array.cc, 
compiler/js-call-reducer.cc) to extract the exact lines and call chains. I can also initialize the RAG DB and write each locus (Stage 5) once you want me to persist this inventory into 
the RAG store.
Final answer: ### 1. Task outcome (short version):
I scanned the V8 main-branch source (Torque/CSA/and C++) for the keyed array element access / elements-kind-transition region and produced a targeted loci inventory grouped by your six 
subsections (a)-(f). Each item includes an ID, exact repository path, main symbol(s)/function(s), and a short note. These IDs let us point at any locus for deeper Stage 2–4 inspection.

Summary: I located core C++ objects and helpers (objects/elements.* and objects/*array*.cc/h), CSA/CodeStubAssembler helpers (codegen/code-stub-assembler.*), IC machinery and builtins 
generators (ic/*, builtins/*-gen.cc, builtins/*.tq), compiler lowering & reducers (compiler/*: AccessInfoFactory, JSCreateLowering, JSCallReducer, JSNativeContextSpecialization), and 
runtime handlers (runtime/runtime-array.cc). See the detailed inventory below (grouped per subsection).

---

### 2. Task outcome (extremely detailed version)
Note: IDs are arbitrary stable integers for referencing loci later. Paths are relative to repo root. I grouped entries per your subsections (a)–(f). Where a concept spans Torque/CSA/C++ 
I included items from each area.

(a) Elements operations: TransitionElementsKind, EnsureCapacity/GrowElementsCapacity, CopyElements, SetLength, helpers
- [1001] objects/elements.cc : TransitionElementsKindImpl / TransitionElementsKind / CopyElements / MoveElements
  - Note: central C++ implementations for elements accessors & transitions. Implements per-subclass TransitionElementsKindImpl and CopyElements utilities used by Map & JSObject 
transitions.
- [1002] objects/elements.h : ElementsAccessor base class
  - Note: virtuals like Maybe<bool> TransitionElementsKind(...), SetLength and other accessor APIs declared here.
- [1003] objects/elements-inl.h : inline accessors and helpers
  - Note: inlined accessors, helpers for element reads/writes, fast-path selection.
- [1004] codegen/code-stub-assembler.cc : CSA helpers: GrowElementsCapacity / TryGrowElementsCapacity / CopyElements / PossiblyGrowElementsCapacity / TransitionElementsKind (CSA 
wrappers)
  - Note: CodeStubAssembler (CSA) implementations used by builtins and generated stubs when building optimized code.
- [1005] codegen/code-stub-assembler.h : declarations for the CSA helpers above
- [1006] objects/fixed-array.h / objects/fixed-array.cc : FixedArrayBase::CopyElements and CopyElements helpers
  - Note: low-level copy/memmove helpers for backing storage arrays.
- [1007] objects/js-objects.cc / objects/js-objects-inl.h : JSObject::TransitionElementsKind (public wrapper) and inline checks
  - Note: high-level entrypoint called by runtime or C++ callers to perform a transition on a JSObject/JSArray.
- [1008] runtime/runtime-array.cc : RUNTIME_FUNCTION(Runtime_TransitionElementsKind) and Runtime_TransitionElementsKindWithKind
  - Note: runtime entry used by builtins/stubs to perform transition at runtime (also referenced by Builtins.)
- [1009] builtins/base.tq & builtins/*-handler-gen.cc : builtin/runtime declarations for TransitionElementsKind (Torque externs)
  - Note: torque declarations (e.g. extern transitioning runtime TransitionElementsKindWithKind) and handler generators that tail-call runtime slow path.

(b) Arrays core: JSArray::SetLength and helpers; elements accessors for JSArray/JSObject; backing store & length/capacity growth
- [2001] objects/objects.cc : JSArray::SetLength / JSArray::ArraySetLength / SetLengthWouldNormalize
  - Note: implements ES semantics (ArraySetLength) and delegates to elements accessor SetLength when possible.
- [2002] objects/elements.* (elements.cc / elements.h / elements-inl.h) — (already listed at 1001–1003)
  - Note: contains ElementsAccessorBase::SetLengthImpl and per-kind SetLength implementations; contact point for array length/normalization.
- [2003] codegen/code-stub-assembler.cc : ArrayListSetLength / BuildAppendJSArray / PossiblyGrowElementsCapacity / GrowElementsCapacity
  - Note: CSA helpers used by builtins (e.g. push/unshift) to fast-path growing backing store.
- [2004] builtins/array.tq and builtins/*array-*.tq (array-from.tq, array-slice.tq, array-splice.tq, array-unshift.tq, array-to-spliced.tq etc.)
  - Note: Torque definitions of Array prototype builtins and helpers. Many specialized fast paths live here.
- [2005] builtins/builtins-array-gen.cc & builtins/builtins-array.cc : generated C++ entrypoints and dispatch wrappers for array builtins
  - Note: generated glue that connects Torque builtins to their C++ assembly/CSA implementations and tail-calls slow-path runtime.
- [2006] objects/fixed-array.h/.cc & builtin/growable-fixed-array.* : backing store alloc helpers
  - Note: allocation and resizing helpers for fixed arrays & growable-fixed-array used for capacity growth.

(c) Inline caches: KeyedStoreIC / KeyedLoadIC / StoreIC/LoadIC participation; IC stub transitions; feedback collection; runtime/TF handlers
- [3001] ic/ic.h : class IC + LoadIC/StoreIC/KeyedLoadIC/KeyedStoreIC declarations
  - Note: the IC class hierarchy, and helper APIs to update/compute handlers and feedback.
- [3002] ic/ic.cc : KeyedLoadIC::UpdateLoadElement, KeyedStoreIC::UpdateStoreElement, runtime miss handling
  - Note: logic that maps keyed access feedback to handlers and elements transition handlers.
- [3003] ic/keyed-store-generic.cc / ic/keyed-store-generic.h : generic KeyedStoreIC assembler logic
  - Note: contains FindCandidateStoreICTransitionMapHandler, handler selection & transition handling used by KeyedStoreIC stubs.
- [3004] ic/accessor-assembler.cc / ic/accessor-assembler.h : generates LoadIC/KeyedLoadIC/StoreIC/KeyedStoreIC CSA codepaths (polymorphic/megamorphic/uninitialized logic)
  - Note: core generation of IC-fastpaths, including branching to megamorphic trampolines and tailcalls to runtime misses (KeyedStoreIC_Miss etc.).
- [3005] builtins/builtins-ic-gen.cc & builtins/builtins-handler-gen.cc : codegen for IC builtins & handlers (KeyedLoadIC, KeyedStoreIC, variants)
  - Note: generated stubs for e.g. KeyedStoreIC_StoreFastElementStub, KeyedStoreIC_ElementsTransitionAndStoreStub, KeyedLoadIC_LoadElementDH etc.
- [3006] objects/feedback-vector.h / objects/feedback-vector.cc : feedback slot kinds and slot creation (AddKeyedLoadICSlot/AddKeyedStoreICSlot)
  - Note: where feedback slot kinds (kLoadKeyed / kStoreKeyed) are defined and used; used by interpreter bytecode generator to allocate slots.
- [3007] builtins/builtins-definitions.h : Builtin names for IC entrypoints (KeyedLoadIC, KeyedStoreIC, their megamorphic/trampoline forms)
  - Note: canonical names used across generator and runtime.
- [3008] builtins/builtins-handler-gen.cc : places where stubs tail-call to runtime misses / ElementsTransitionAndStoreIC miss handlers

(d) Builtins fast paths: ArrayPrototypePush/Pop/Slice/Splice/Concat/From/Spread; Torque/CSA definitions; generated C++ entry points; guards & branch to slow-path
- [4001] builtins/array.tq : main Torque file with many Array prototype builtin definitions and helpers
  - Note: contains the Torque-level logic for many array methods and calls into CSA helpers for fast paths.
- [4002] builtins/array-from.tq, builtins/array-slice.tq, builtins/array-splice.tq, builtins/array-to-spliced.tq, builtins/array-push/unshift/shift-handling parts (files listed in 
builtins directory)
  - Note: dedicated Torque sources for specific Array methods / special-casing.
- [4003] builtins/builtins-array-gen.cc and builtins/builtins-array.cc : generated C++ entrypoints, caller wrappers and runtime fallbacks
  - Note: show where builtins fast-paths (Torque) are compiled into C++ glue; there are also CSA calls inside generated code.
- [4004] codegen/code-stub-assembler.cc & ic/accessor-assembler.cc : the CSA fast-path guards used by builtins (e.g. load elements kind, bounds check, hole checks) and bailout to slow 
path via TailCallRuntime or TailCallBuiltin
  - Note: the conditional guards (IsFastElementsKind, IsHoley fast checks, TypedArray checks) are here; slow-paths go to Runtime::kKeyedStoreIC_Miss or builtin slow stubs.
- [4005] builtins/builtins-handler-gen.cc : stubs that implement the small C++/CSA fast handlers (StoreElementStub variants and ElementsTransitionAndStoreStub) and call runtime for 
misses.

(e) Compiler lowering: AccessInfo/AccessInfoFactory, JSCreateLowering, JSNativeContextSpecialization, JSCallReducer, JS(Load|Store)Indexed lowering, SimplifiedLowering
- [5001] compiler/access-info.h / compiler/access-info.cc : AccessInfoFactory and ElementAccessInfo / PropertyAccessInfo computation
  - Note: AccessInfoFactory::ComputeElementAccessInfo, ConsolidateElementLoad etc. are used by lowering passes and JSCallReducer.
- [5002] compiler/js-create-lowering.cc / js-create-lowering.h : JSCreateLowering
  - Note: lowering of JSCreate/array-instantiation patterns (e.g., AllocateJSArray) and interaction with elements kinds.
- [5003] compiler/js-native-context-specialization.cc / .h : JSNativeContextSpecialization
  - Note: uses AccessInfoFactory and rewrites calls using native-context constants and known maps/elements kinds.
- [5004] compiler/js-call-reducer.cc / .h : JSCallReducer and iterating array builtins reducer
  - Note: many ReduceArrayPrototypePush/Pop/Slice/Splice implementations here; checks elements kind and emits simplified node sequences; has helpers like LoadJSArrayLength, 
CheckIfElementsKind, ConvertHoleToUndefined.
- [5005] compiler/js-generic-lowering.cc / .h : generic lowering emits builtin calls to the appropriate KeyedLoadIC/KeyedStoreIC builtins (e.g. Builtin::kKeyedLoadIC or 
Builtin::kKeyedLoadIC_Megamorphic based on feedback)
  - Note: used in TurboFan lowering path to canonicalize property/keyed accesses into IC calls or direct loads.
- [5006] compiler/simplified-lowering.cc / simplified-operator.{h,cc} : SimplifiedOperatorBuilder includes TransitionElementsKind op; SimplifiedLowering emits checks concerning 
ElementsKind
  - Note: contains lowering for TransitionElementsKind/CheckMap nodes.
- [5007] compiler/js-heap-broker.cc / compiler/js-heap-broker.h and compiler/heap-refs.* : helpers used during JSNativeContextSpecialization and JSCallReducer to read map/elements kind 
info from the heap broker.

(f) Deopt/feedback: deopt guards for elements kind & bounds; feedback-vector slot kinds; transitions updating/invalidate IC state; map stability checks
- [6001] codegen/code-stub-assembler.cc : CSA guards and bailout primitives; helper functions that emit deopt or tail-to-runtime when guards fail (e.g. IsFastElementsKind checks, bounds 
checks, hole checks)
  - Note: these functions generate the low-level deopt/slow-path transitions used by both builtins and generated IC stubs.
- [6002] compiler/js-call-reducer.cc : CheckIfElementsKind & CheckArrayLength / checks that produce deopt nodes; conversion of holes to undefined tied to elements kind
  - Note: compiler uses these to insert guard nodes that can trigger deopt or bailout to generic code.
- [6003] ic/ic.cc / ic/ic.h : Update caches and ComputeHandler code: updates to feedback vector and mapping from feedback to stub states; code paths that clear/invalidate stubs on 
transitions
  - Note: KeyedStoreIC::UpdateStoreElement and KeyedLoadIC::UpdateLoadElement change handlers and occasionally install transition handlers (ElementsTransitionAndStore) which in turn 
update feedback slots.
- [6004] objects/feedback-vector.h / .cc : FeedbackSlotKind enums for keyed loads/stores and helpers IsKeyedLoadICKind / IsKeyedStoreICKind
  - Note: feedback slot types used by bytecode/interpreter and ICs to know which builtin/runtime to call and what feedback to collect.
- [6005] objects/map.cc / objects/map-updater.h : ReconfigureElementsKind / transitions and checks for map stability
  - Note: where map transitions are validated and how transitions influence element kinds; also used in AllocationSite tracking code.
- [6006] runtime/runtime-array.cc : runtime implementations that are invoked when inline stubs miss and must perform transitions at runtime (also update feedback, sometimes install 
handlers)

---

How I found these (short methodology):
- Focused ripgrep queries for canonical symbols: TransitionElementsKind, GrowElementsCapacity, CopyElements, JSArray::SetLength, KeyedLoadIC, KeyedStoreIC, AccessInfoFactory, 
JSCallReducer, CodeStubAssembler helpers, and builtins/array *.tq files.
- Navigated to canonical directories: src/objects, src/codegen, src/ic, src/builtins, src/compiler, src/runtime.
- Confirmed CSA implementations exist in codegen/code-stub-assembler.cc (they are heavily used by builtins and IC generators).

Recommendations / next steps (Stage 2+):
- For each ID above I can open the specific file & symbol and extract the precise function bodies and the exact call chains. Suggested prioritized follow-ups (choose by ID):
  - Deep dive on Transition path: [1001], [1007], [1008], [3003]
  - CSA growth/copy helpers used by Push/Append: [1004], [2003], [4004]
  - IC handler lifecycle & feedback: [3002], [3006], [6003]
  - Compiler lowering + reducers for array builtins: [5004], [5001], [5005]

If you want, I will proceed to Stage 2: run ripgrep on the specific files listed above for lines that show how (a) transitions are chosen and applied, (b) inlined fast-path guards branch
to slow-path, (c) IC handler installation updates feedback slots and elements-kind sticky behavior. Provide a list of the IDs you want me to expand first, or I will start with the 
TransitionElementsKind path (IDs: 1001/1007/1008/1004) and the IC update path (IDs: 3002/3003/3006).

---

### 3. Additional context (if relevant)
- Many operations live in both C++ (objects/elements.* and runtime/*) and CSA-generated code (codegen/code-stub-assembler.cc plus generated builtins under builtins/*-gen.cc). The 
canonical flow often is: JS bytecode/JSTurboFan lowered node -> IC builtin (KeyedLoadIC/KeyedStoreIC) or direct CSA sequence -> CSA emits guard(s) (map/elements-kind/bounds) -> on 
success do direct element load/store with CopyElements/GrowElementsCapacity -> on failure tail-call Runtime::kKeyedStoreIC_Miss or TransitionElementsKind runtime function -> runtime 
performs map transition or slow semantics.
- ElementsKind semantics are pervasive and affect many layers: objects (maps), ICs, builtins, and compiler. AccessInfoFactory and JSCallReducer/JSNativeContextSpecialization are the 
compiler-side places that reason about elements kinds and try to produce efficient code using that info.

If you confirm, I will now begin Stage 2 and open the top-priority files (e.g., objects/elements.cc, codegen/code-stub-assembler.cc, ic/ic.cc, runtime/runtime-array.cc, 
compiler/js-call-reducer.cc) to extract the exact lines and call chains. I can also initialize the RAG DB and write each locus (Stage 5) once you want me to persist this inventory into 
the RAG store.
[Step 14: Duration 89.38 seconds| Input tokens: 386,634 | Output tokens: 10,436]
Observations: Here is the final answer from your managed agent 'V8Search':
### 1. Task outcome (short version):
I scanned the V8 main-branch source (Torque/CSA/and C++) for the keyed array element access / elements-kind-transition region and produced a targeted loci inventory grouped by your six 
subsections (a)-(f). Each item includes an ID, exact repository path, main symbol(s)/function(s), and a short note. These IDs let us point at any locus for deeper Stage 2–4 inspection.

Summary: I located core C++ objects and helpers (objects/elements.* and objects/*array*.cc/h), CSA/CodeStubAssembler helpers (codegen/code-stub-assembler.*), IC machinery and builtins 
generators (ic/*, builtins/*-gen.cc, builtins/*.tq), compiler lowering & reducers (compiler/*: AccessInfoFactory, JSCreateLowering, JSCallReducer, JSNativeContextSpecialization), and 
runtime handlers (runtime/runtime-array.cc). See the detailed inventory below (grouped per subsection).

---

### 2. Task outcome (extremely detailed version)
Note: IDs are arbitrary stable integers for referencing loci later. Paths are relative to repo root. I grouped entries per your subsections (a)–(f). Where a concept spans Torque/CSA/C++ 
I included items from each area.

(a) Elements operations: TransitionElementsKind, EnsureCapacity/GrowElementsCapacity, CopyElements, SetLength, helpers
- |1001] objects/elements.cc : TransitionElementsKindImpl / TransitionElementsKind / CopyElements / MoveElements
  - Note: central C++ implementations for elements accessors & transitions. Implements per-subclass TransitionElementsKindImpl and CopyElements utilities used by Map & JSObject 
transitions.
- |1002] objects/elements.h : ElementsAccessor base class
  - Note: virtuals like Maybe<bool> TransitionElementsKind(...), SetLength and other accessor APIs declared here.
- |1003] objects/elements-inl.h : inline accessors and helpers
  - Note: inlined accessors, helpers for element reads/writes, fast-path selection.
- |1004] codegen/code-stub-assembler.cc : CSA helpers: GrowElementsCapacity / TryGrowElementsCapacity / CopyElements / PossiblyGrowElementsCapacity / TransitionElementsKind (CSA 
wrappers)
  - Note: CodeStubAssembler (CSA) implementations used by builtins and generated stubs when building optimized code.
- |1005] codegen/code-stub-assembler.h : declarations for the CSA helpers above
- |1006] objects/fixed-array.h / objects/fixed-array.cc : FixedArrayBase::CopyElements and CopyElements helpers
  - Note: low-level copy/memmove helpers for backing storage arrays.
- |1007] objects/js-objects.cc / objects/js-objects-inl.h : JSObject::TransitionElementsKind (public wrapper) and inline checks
  - Note: high-level entrypoint called by runtime or C++ callers to perform a transition on a JSObject/JSArray.
- |1008] runtime/runtime-array.cc : RUNTIME_FUNCTION(Runtime_TransitionElementsKind) and Runtime_TransitionElementsKindWithKind
  - Note: runtime entry used by builtins/stubs to perform transition at runtime (also referenced by Builtins.)
- |1009] builtins/base.tq & builtins/*-handler-gen.cc : builtin/runtime declarations for TransitionElementsKind (Torque externs)
  - Note: torque declarations (e.g. extern transitioning runtime TransitionElementsKindWithKind) and handler generators that tail-call runtime slow path.

(b) Arrays core: JSArray::SetLength and helpers; elements accessors for JSArray/JSObject; backing store & length/capacity growth
- |2001] objects/objects.cc : JSArray::SetLength / JSArray::ArraySetLength / SetLengthWouldNormalize
  - Note: implements ES semantics (ArraySetLength) and delegates to elements accessor SetLength when possible.
- |2002] objects/elements.* (elements.cc / elements.h / elements-inl.h) — (already listed at 1001–1003)
  - Note: contains ElementsAccessorBase::SetLengthImpl and per-kind SetLength implementations; contact point for array length/normalization.
- |2003] codegen/code-stub-assembler.cc : ArrayListSetLength / BuildAppendJSArray / PossiblyGrowElementsCapacity / GrowElementsCapacity
  - Note: CSA helpers used by builtins (e.g. push/unshift) to fast-path growing backing store.
- |2004] builtins/array.tq and builtins/*array-*.tq (array-from.tq, array-slice.tq, array-splice.tq, array-unshift.tq, array-to-spliced.tq etc.)
  - Note: Torque definitions of Array prototype builtins and helpers. Many specialized fast paths live here.
- |2005] builtins/builtins-array-gen.cc & builtins/builtins-array.cc : generated C++ entrypoints and dispatch wrappers for array builtins
  - Note: generated glue that connects Torque builtins to their C++ assembly/CSA implementations and tail-calls slow-path runtime.
- |2006] objects/fixed-array.h/.cc & builtin/growable-fixed-array.* : backing store alloc helpers
  - Note: allocation and resizing helpers for fixed arrays & growable-fixed-array used for capacity growth.

(c) Inline caches: KeyedStoreIC / KeyedLoadIC / StoreIC/LoadIC participation; IC stub transitions; feedback collection; runtime/TF handlers
- |3001] ic/ic.h : class IC + LoadIC/StoreIC/KeyedLoadIC/KeyedStoreIC declarations
  - Note: the IC class hierarchy, and helper APIs to update/compute handlers and feedback.
- |3002] ic/ic.cc : KeyedLoadIC::UpdateLoadElement, KeyedStoreIC::UpdateStoreElement, runtime miss handling
  - Note: logic that maps keyed access feedback to handlers and elements transition handlers.
- |3003] ic/keyed-store-generic.cc / ic/keyed-store-generic.h : generic KeyedStoreIC assembler logic
  - Note: contains FindCandidateStoreICTransitionMapHandler, handler selection & transition handling used by KeyedStoreIC stubs.
- |3004] ic/accessor-assembler.cc / ic/accessor-assembler.h : generates LoadIC/KeyedLoadIC/StoreIC/KeyedStoreIC CSA codepaths (polymorphic/megamorphic/uninitialized logic)
  - Note: core generation of IC-fastpaths, including branching to megamorphic trampolines and tailcalls to runtime misses (KeyedStoreIC_Miss etc.).
- |3005] builtins/builtins-ic-gen.cc & builtins/builtins-handler-gen.cc : codegen for IC builtins & handlers (KeyedLoadIC, KeyedStoreIC, variants)
  - Note: generated stubs for e.g. KeyedStoreIC_StoreFastElementStub, KeyedStoreIC_ElementsTransitionAndStoreStub, KeyedLoadIC_LoadElementDH etc.
- |3006] objects/feedback-vector.h / objects/feedback-vector.cc : feedback slot kinds and slot creation (AddKeyedLoadICSlot/AddKeyedStoreICSlot)
  - Note: where feedback slot kinds (kLoadKeyed / kStoreKeyed) are defined and used; used by interpreter bytecode generator to allocate slots.
- |3007] builtins/builtins-definitions.h : Builtin names for IC entrypoints (KeyedLoadIC, KeyedStoreIC, their megamorphic/trampoline forms)
  - Note: canonical names used across generator and runtime.
- |3008] builtins/builtins-handler-gen.cc : places where stubs tail-call to runtime misses / ElementsTransitionAndStoreIC miss handlers

(d) Builtins fast paths: ArrayPrototypePush/Pop/Slice/Splice/Concat/From/Spread; Torque/CSA definitions; generated C++ entry points; guards & branch to slow-path
- |4001] builtins/array.tq : main Torque file with many Array prototype builtin definitions and helpers
  - Note: contains the Torque-level logic for many array methods and calls into CSA helpers for fast paths.
- |4002] builtins/array-from.tq, builtins/array-slice.tq, builtins/array-splice.tq, builtins/array-to-spliced.tq, builtins/array-push/unshift/shift-handling parts (files listed in 
builtins directory)
  - Note: dedicated Torque sources for specific Array methods / special-casing.
- |4003] builtins/builtins-array-gen.cc and builtins/builtins-array.cc : generated C++ entrypoints, caller wrappers and runtime fallbacks
  - Note: show where builtins fast-paths (Torque) are compiled into C++ glue; there are also CSA calls inside generated code.
- |4004] codegen/code-stub-assembler.cc & ic/accessor-assembler.cc : the CSA fast-path guards used by builtins (e.g. load elements kind, bounds check, hole checks) and bailout to slow 
path via TailCallRuntime or TailCallBuiltin
  - Note: the conditional guards (IsFastElementsKind, IsHoley fast checks, TypedArray checks) are here; slow-paths go to Runtime::kKeyedStoreIC_Miss or builtin slow stubs.
- |4005] builtins/builtins-handler-gen.cc : stubs that implement the small C++/CSA fast handlers (StoreElementStub variants and ElementsTransitionAndStoreStub) and call runtime for 
misses.

(e) Compiler lowering: AccessInfo/AccessInfoFactory, JSCreateLowering, JSNativeContextSpecialization, JSCallReducer, JS(Load|Store)Indexed lowering, SimplifiedLowering
- |5001] compiler/access-info.h / compiler/access-info.cc : AccessInfoFactory and ElementAccessInfo / PropertyAccessInfo computation
  - Note: AccessInfoFactory::ComputeElementAccessInfo, ConsolidateElementLoad etc. are used by lowering passes and JSCallReducer.
- |5002] compiler/js-create-lowering.cc / js-create-lowering.h : JSCreateLowering
  - Note: lowering of JSCreate/array-instantiation patterns (e.g., AllocateJSArray) and interaction with elements kinds.
- |5003] compiler/js-native-context-specialization.cc / .h : JSNativeContextSpecialization
  - Note: uses AccessInfoFactory and rewrites calls using native-context constants and known maps/elements kinds.
- |5004] compiler/js-call-reducer.cc / .h : JSCallReducer and iterating array builtins reducer
  - Note: many ReduceArrayPrototypePush/Pop/Slice/Splice implementations here; checks elements kind and emits simplified node sequences; has helpers like LoadJSArrayLength, 
CheckIfElementsKind, ConvertHoleToUndefined.
- |5005] compiler/js-generic-lowering.cc / .h : generic lowering emits builtin calls to the appropriate KeyedLoadIC/KeyedStoreIC builtins (e.g. Builtin::kKeyedLoadIC or 
Builtin::kKeyedLoadIC_Megamorphic based on feedback)
  - Note: used in TurboFan lowering path to canonicalize property/keyed accesses into IC calls or direct loads.
- |5006] compiler/simplified-lowering.cc / simplified-operator.{h,cc} : SimplifiedOperatorBuilder includes TransitionElementsKind op; SimplifiedLowering emits checks concerning 
ElementsKind
  - Note: contains lowering for TransitionElementsKind/CheckMap nodes.
- |5007] compiler/js-heap-broker.cc / compiler/js-heap-broker.h and compiler/heap-refs.* : helpers used during JSNativeContextSpecialization and JSCallReducer to read map/elements kind 
info from the heap broker.

(f) Deopt/feedback: deopt guards for elements kind & bounds; feedback-vector slot kinds; transitions updating/invalidate IC state; map stability checks
- |6001] codegen/code-stub-assembler.cc : CSA guards and bailout primitives; helper functions that emit deopt or tail-to-runtime when guards fail (e.g. IsFastElementsKind checks, bounds 
checks, hole checks)
  - Note: these functions generate the low-level deopt/slow-path transitions used by both builtins and generated IC stubs.
- |6002] compiler/js-call-reducer.cc : CheckIfElementsKind & CheckArrayLength / checks that produce deopt nodes; conversion of holes to undefined tied to elements kind
  - Note: compiler uses these to insert guard nodes that can trigger deopt or bailout to generic code.
- |6003] ic/ic.cc / ic/ic.h : Update caches and ComputeHandler code: updates to feedback vector and mapping from feedback to stub states; code paths that clear/invalidate stubs on 
transitions
  - Note: KeyedStoreIC::UpdateStoreElement and KeyedLoadIC::UpdateLoadElement change handlers and occasionally install transition handlers (ElementsTransitionAndStore) which in turn 
update feedback slots.
- |6004] objects/feedback-vector.h / .cc : FeedbackSlotKind enums for keyed loads/stores and helpers IsKeyedLoadICKind / IsKeyedStoreICKind
  - Note: feedback slot types used by bytecode/interpreter and ICs to know which builtin/runtime to call and what feedback to collect.
- |6005] objects/map.cc / objects/map-updater.h : ReconfigureElementsKind / transitions and checks for map stability
  - Note: where map transitions are validated and how transitions influence element kinds; also used in AllocationSite tracking code.
- |6006] runtime/runtime-array.cc : runtime implementations that are invoked when inline stubs miss and must perform transitions at runtime (also update feedback, sometimes install 
handlers)

---

How I found these (short methodology):
- Focused ripgrep queries for canonical symbols: TransitionElementsKind, GrowElementsCapacity, CopyElements, JSArray::SetLength, KeyedLoadIC, KeyedStoreIC, AccessInfoFactory, 
JSCallReducer, CodeStubAssembler helpers, and builtins/array *.tq files.
- Navigated to canonical directories: src/objects, src/codegen, src/ic, src/builtins, src/compiler, src/runtime.
- Confirmed CSA implementations exist in codegen/code-stub-assembler.cc (they are heavily used by builtins and IC generators).

Recommendations / next steps (Stage 2+):
- For each ID above I can open the specific file & symbol and extract the precise function bodies and the exact call chains. Suggested prioritized follow-ups (choose by ID):
  - Deep dive on Transition path: |1001], |1007], |1008], |3003]
  - CSA growth/copy helpers used by Push/Append: |1004], |2003], |4004]
  - IC handler lifecycle & feedback: |3002], |3006], |6003]
  - Compiler lowering + reducers for array builtins: |5004], |5001], |5005]

If you want, I will proceed to Stage 2: run ripgrep on the specific files listed above for lines that show how (a) transitions are chosen and applied, (b) inlined fast-path guards branch
to slow-path, (c) IC handler installation updates feedback slots and elements-kind sticky behavior. Provide a list of the IDs you want me to expand first, or I will start with the 
TransitionElementsKind path (IDs: 1001/1007/1008/1004) and the IC update path (IDs: 3002/3003/3006).

---

### 3. Additional context (if relevant)
- Many operations live in both C++ (objects/elements.* and runtime/*) and CSA-generated code (codegen/code-stub-assembler.cc plus generated builtins under builtins/*-gen.cc). The 
canonical flow often is: JS bytecode/JSTurboFan lowered node -> IC builtin (KeyedLoadIC/KeyedStoreIC) or direct CSA sequence -> CSA emits guard(s) (map/elements-kind/bounds) -> on 
success do direct element load/store with CopyElements/GrowElementsCapacity -> on failure tail-call Runtime::kKeyedStoreIC_Miss or TransitionElementsKind runtime function -> runtime 
performs map transition or slow semantics.
- ElementsKind semantics are pervasive and affect many layers: objects (maps), ICs, builtins, and compiler. AccessInfoFactory and JSCallReducer/JSNativeContextSpecialization are the 
compiler-side places that reason about elements kinds and try to produce efficient code using that info.

If you confirm, I will now begin Stage 2 and open the top-priority files (e.g., objects/elements.cc, codegen/code-stub-assembler.cc, ic/ic.cc, runtime/runtime-array.cc, 
compiler/js-call-reducer.cc) to extract the exact lines and call chains. I can also initialize the RAG DB and write each locus (Stage 5) once you want me to persist this inventory into 
the RAG store.
[Step 1: Duration 198.80 seconds| Input tokens: 2,982 | Output tokens: 1,078]
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ Step 2 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'V8Search' with arguments: {'task': 'Stage 1 reconnaissance. Please scan current V8 main branch for the primary region: Keyed array element access & elements-kind       │
│ transitions. Goal: produce an up-to-date loci inventory with exact file paths and key functions/classes. Cover these subsections and return IDs for each relevant item so we can dive  │
│ deeper later:\n\n(a) Elements operations: TransitionElementsKind, EnsureCapacity/GrowElementsCapacity, CopyElements, SetLength, and general elements helper utilities. Include both    │
│ CSA/Torque and C++ if applicable.\n\n(b) Arrays core: JSArray::SetLength and helpers; elements accessors for JSArray/JSObject touching elements backing store, length updates, and     │
│ capacity growth.\n\n(c) Inline caches: KeyedStoreIC/KeyedLoadIC (plus StoreIC/LoadIC if they participate), IC stub state transitions (mono/poly/mega), generic stubs, feedback         │
│ collection for keyed accesses including elements-kind and KeyedStoreMode, and any Runtime/TF handlers involved.\n\n(d) Builtins fast paths:                                            │
│ ArrayPrototypePush/Pop/Slice/Splice/Concat/From/Spread – point to Torque/CSA definitions (array.tq/array-helpers.tq etc.) and generated C++ entry points or dispatch wrappers. Include │
│ fast-path guards and where they branch to slow-path.\n\n(e) Compiler lowering: AccessInfo/AccessInfoFactory, JSCreateLowering, JSNativeContextSpecialization, JSCallReducer for array  │
│ builtins, JS(Load|Store)Indexed lowering, SimplifiedLowering logic related to ElementsKind, index bounds/hole checks, and any graph builder helpers for keyed accesses.\n\n(f)         │
│ Deopt/feedback: locations of deopt guards for elements kind and bounds; feedback vector slot kinds for keyed loads/stores; transitions that update or invalidate IC state; places      │
│ where map stability is assumed/checked.\n\nPlease return a structured list of candidates with: [id, file path, symbol/function name, brief note], grouped per subsection, and prefer   │
│ most-current paths (Torque sources under src/builtins/*.tq, ICs under src/ic, elements under src/objects, compiler under src/compiler). Where names were renamed recently (e.g.,       │
│ EnsureCapacity vs GrowElementsCapacity), include both old/new. If multiple overloads exist, include the main entry and helpers.'}                                                      │
╰────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────── New run - V8Search ──────────────────────────────────────────────────────────────────────────────────╮
│                                                                                                                                                                                        │
│ You're a helpful agent named 'V8Search'.                                                                                                                                               │
│ You have been submitted this task by your manager.                                                                                                                                     │
│ ---                                                                                                                                                                                    │
│ Task:                                                                                                                                                                                  │
│ Stage 1 reconnaissance. Please scan current V8 main branch for the primary region: Keyed array element access & elements-kind transitions. Goal: produce an up-to-date loci inventory  │
│ with exact file paths and key functions/classes. Cover these subsections and return IDs for each relevant item so we can dive deeper later:                                            │
│                                                                                                                                                                                        │
│ (a) Elements operations: TransitionElementsKind, EnsureCapacity/GrowElementsCapacity, CopyElements, SetLength, and general elements helper utilities. Include both CSA/Torque and C++  │
│ if applicable.                                                                                                                                                                         │
│                                                                                                                                                                                        │
│ (b) Arrays core: JSArray::SetLength and helpers; elements accessors for JSArray/JSObject touching elements backing store, length updates, and capacity growth.                         │
│                                                                                                                                                                                        │
│ (c) Inline caches: KeyedStoreIC/KeyedLoadIC (plus StoreIC/LoadIC if they participate), IC stub state transitions (mono/poly/mega), generic stubs, feedback collection for keyed        │
│ accesses including elements-kind and KeyedStoreMode, and any Runtime/TF handlers involved.                                                                                             │
│                                                                                                                                                                                        │
│ (d) Builtins fast paths: ArrayPrototypePush/Pop/Slice/Splice/Concat/From/Spread – point to Torque/CSA definitions (array.tq/array-helpers.tq etc.) and generated C++ entry points or   │
│ dispatch wrappers. Include fast-path guards and where they branch to slow-path.                                                                                                        │
│                                                                                                                                                                                        │
│ (e) Compiler lowering: AccessInfo/AccessInfoFactory, JSCreateLowering, JSNativeContextSpecialization, JSCallReducer for array builtins, JS(Load|Store)Indexed lowering,                │
│ SimplifiedLowering logic related to ElementsKind, index bounds/hole checks, and any graph builder helpers for keyed accesses.                                                          │
│                                                                                                                                                                                        │
│ (f) Deopt/feedback: locations of deopt guards for elements kind and bounds; feedback vector slot kinds for keyed loads/stores; transitions that update or invalidate IC state; places  │
│ where map stability is assumed/checked.                                                                                                                                                │
│                                                                                                                                                                                        │
│ Please return a structured list of candidates with: [id, file path, symbol/function name, brief note\], grouped per subsection, and prefer most-current paths (Torque sources under    │
│ src/builtins/*.tq, ICs under src/ic, elements under src/objects, compiler under src/compiler). Where names were renamed recently (e.g., EnsureCapacity vs GrowElementsCapacity),       │
│ include both old/new. If multiple overloads exist, include the main entry and helpers.                                                                                                 │
│ ---                                                                                                                                                                                    │
│ You're helping your manager solve a wider task: so make sure to not provide a one-line answer, but give as much information as possible to give them a clear understanding of the      │
│ answer.                                                                                                                                                                                │
│                                                                                                                                                                                        │
│ Your final_answer WILL HAVE to contain these parts:                                                                                                                                    │
│ ### 1. Task outcome (short version):                                                                                                                                                   │
│ ### 2. Task outcome (extremely detailed version):                                                                                                                                      │
│ ### 3. Additional context (if relevant):                                                                                                                                               │
│                                                                                                                                                                                        │
│ Put all these in your final_answer tool, everything that you do not pass as an argument to final_answer will be lost.                                                                  │
│ And even if your task resolution is not successful, please return as much context as possible, so that your manager can act upon this feedback.                                        │
│                                                                                                                                                                                        │
╰─ LiteLLMModel - gpt-5-mini ────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ Step 1 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'tree' with arguments: {'options': '-L 2 src -f'}                                                                                                                        │
╰────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
Command: cd /Users/tarun/v8/v8/src && tree -L 2 src -f | head -n 1000
Observations: src  |error opening dir]

0 directories, 0 files
[Step 1: Duration 2.38 seconds| Input tokens: 2,265 | Output tokens: 28]
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ Step 2 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'fuzzy_finder' with arguments: {'pattern': 'TransitionElementsKind', 'options': '--filter'}                                                                              │
╰────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
Command: cd /Users/tarun/v8/v8/src && rg --hidden --no-follow --no-ignore-vcs --files 2>/dev/null | fzf --filter 'TransitionElementsKind' | head -n 1000
Observations: None
[Step 2: Duration 2.78 seconds| Input tokens: 4,575 | Output tokens: 124]
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ Step 3 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'ripgrep' with arguments: {'pattern': 'TransitionElementsKind', 'options': ''}                                                                                           │
╰────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
Command: cd /Users/tarun/v8/v8/src && rg 'TransitionElementsKind' | head -n 1000
Observations: debug/debug-evaluate.cc:  V(TransitionElementsKind)              \
runtime/runtime-array.cc:RUNTIME_FUNCTION(Runtime_TransitionElementsKind) {
runtime/runtime-array.cc:          ->TransitionElementsKind(object, to_map)
runtime/runtime-array.cc:    // TODO(victorgomes): EffectControlLinearizer::LowerTransitionElementsKind
runtime/runtime-array.cc:RUNTIME_FUNCTION(Runtime_TransitionElementsKindWithKind) {
runtime/runtime-array.cc:  JSObject::TransitionElementsKind(object, to_kind);
runtime/runtime-object.cc:          JSObject::TransitionElementsKind(lookup_start_object, elements_kind);
runtime/runtime.h:  F(TransitionElementsKind, 2, 1)      \
runtime/runtime.h:  F(TransitionElementsKindWithKind, 2, 1)
objects/allocation-site-inl.h:        JSObject::TransitionElementsKind(boilerplate, to_kind);
codegen/code-stub-assembler.cc:void CodeStubAssembler::TransitionElementsKind(TNode<JSObject> object,
maglev/maglev-ir.h:  V(TransitionElementsKind)                         \
maglev/maglev-ir.h:  V(TransitionElementsKindOrCheckMap)         \
maglev/maglev-ir.h:class TransitionElementsKind
maglev/maglev-ir.h:    : public FixedInputValueNodeT<2, TransitionElementsKind> {
maglev/maglev-ir.h:  using Base = FixedInputValueNodeT<2, TransitionElementsKind>;
maglev/maglev-ir.h:  explicit TransitionElementsKind(
maglev/maglev-ir.h:class TransitionElementsKindOrCheckMap
maglev/maglev-ir.h:    : public FixedInputNodeT<2, TransitionElementsKindOrCheckMap> {
maglev/maglev-ir.h:  using Base = FixedInputNodeT<2, TransitionElementsKindOrCheckMap>;
maglev/maglev-ir.h:  explicit TransitionElementsKindOrCheckMap(
maglev/maglev-ir.cc:void GenerateTransitionElementsKind(
maglev/maglev-ir.cc:                __ CallRuntime(Runtime::kTransitionElementsKind);
maglev/maglev-ir.cc:int TransitionElementsKind::MaxCallStackArgs() const {
maglev/maglev-ir.cc:void TransitionElementsKind::SetValueLocationConstraints() {
maglev/maglev-ir.cc:void TransitionElementsKind::GenerateCode(MaglevAssembler* masm,
maglev/maglev-ir.cc:  GenerateTransitionElementsKind(masm, this, object, map,
maglev/maglev-ir.cc:int TransitionElementsKindOrCheckMap::MaxCallStackArgs() const {
maglev/maglev-ir.cc:void TransitionElementsKindOrCheckMap::SetValueLocationConstraints() {
maglev/maglev-ir.cc:void TransitionElementsKindOrCheckMap::GenerateCode(
maglev/maglev-ir.cc:  GenerateTransitionElementsKind(masm, this, object, map,
maglev/maglev-ir.cc:void TransitionElementsKindOrCheckMap::PrintParams(
objects/js-objects-inl.h:      TransitionElementsKind(object, HOLEY_ELEMENTS);
objects/js-objects-inl.h:      TransitionElementsKind(object, PACKED_ELEMENTS);
objects/js-objects-inl.h:    TransitionElementsKind(object, target_kind);
objects/js-objects-inl.h:    TransitionElementsKind(object, HOLEY_DOUBLE_ELEMENTS);
objects/js-objects-inl.h:        TransitionElementsKind(object, HOLEY_DOUBLE_ELEMENTS);
objects/js-objects-inl.h:    TransitionElementsKind(object, PACKED_DOUBLE_ELEMENTS);
builtins/builtins-handler-gen.cc:          TransitionElementsKind(receiver, map, from_kind, to_kind, &miss);
codegen/code-stub-assembler.h:  void TransitionElementsKind(TNode<JSObject> object, TNode<Map> map,
maglev/maglev-graph-builder.h:  ReduceResult BuildTransitionElementsKindOrCheckMap(
maglev/maglev-graph-builder.h:  ReduceResult BuildTransitionElementsKindAndCompareMaps(
maglev/maglev-graph-builder.cc:    case Opcode::kTransitionElementsKind:
maglev/maglev-graph-builder.cc:ReduceResult MaglevGraphBuilder::BuildTransitionElementsKindOrCheckMap(
maglev/maglev-graph-builder.cc:  // TransitionElementsKind doesn't happen in cases where we'd need to do
maglev/maglev-graph-builder.cc:  AddNewNode<TransitionElementsKindOrCheckMap>(
maglev/maglev-graph-builder.cc:ReduceResult MaglevGraphBuilder::BuildTransitionElementsKindAndCompareMaps(
maglev/maglev-graph-builder.cc:  ValueNode* new_map = AddNewNode<TransitionElementsKind>(
maglev/maglev-graph-builder.cc:      RETURN_IF_ABORT(BuildTransitionElementsKindOrCheckMap(
maglev/maglev-graph-builder.cc:        map_check_result = BuildTransitionElementsKindOrCheckMap(
maglev/maglev-graph-builder.cc:        map_check_result = BuildTransitionElementsKindAndCompareMaps(
objects/elements-kind.cc:ElementsKind GetNextTransitionElementsKind(ElementsKind kind) {
objects/elements.h:  V8_WARN_UNUSED_RESULT virtual Maybe<bool> TransitionElementsKind(
objects/map.cc:  bool allow_store_transition = IsTransitionElementsKind(from_kind);
objects/map.cc:  DCHECK(IsTransitionElementsKind(map->elements_kind()));
objects/map.cc:        kind = GetNextTransitionElementsKind(kind);
objects/js-objects.cc:      TransitionElementsKind(object, to_kind);
objects/js-objects.cc:        JSObject::TransitionElementsKind(object, PACKED_ELEMENTS);
objects/js-objects.cc:        JSObject::TransitionElementsKind(object, HOLEY_ELEMENTS);
objects/js-objects.cc:void JSObject::TransitionElementsKind(DirectHandle<JSObject> object,
objects/js-objects.cc:      // overflow, until all users of TransitionElementsKind can handle
compiler/typed-optimization.cc:    case IrOpcode::kTransitionElementsKindOrCheckMap:
compiler/typed-optimization.cc:      return ReduceTransitionElementsKindOrCheckMap(node);
compiler/typed-optimization.cc:Reduction TypedOptimization::ReduceTransitionElementsKindOrCheckMap(
builtins/base.tq:extern transitioning runtime TransitionElementsKindWithKind(
builtins/base.tq:extern macro TransitionElementsKind(
ic/ic.cc:    JSObject::TransitionElementsKind(Cast<JSObject>(object),
objects/elements-kind.h:ElementsKind GetNextTransitionElementsKind(ElementsKind elements_kind);
objects/elements-kind.h:inline bool IsTransitionElementsKind(ElementsKind kind) {
objects/js-objects.h:  V8_EXPORT_PRIVATE static void TransitionElementsKind(
objects/elements.cc:        JSObject::TransitionElementsKind(array, kind);
objects/elements.cc:  static Maybe<bool> TransitionElementsKindImpl(DirectHandle<JSObject> object,
objects/elements.cc:  Maybe<bool> TransitionElementsKind(DirectHandle<JSObject> object,
objects/elements.cc:    return Subclass::TransitionElementsKindImpl(object, map);
objects/elements.cc:        JSObject::TransitionElementsKind(object, to_kind);
objects/elements.cc:      JSObject::TransitionElementsKind(obj, GetHoleyElementsKind(kind));
objects/elements.cc:  static Maybe<bool> TransitionElementsKindImpl(DirectHandle<JSObject> object,
objects/elements.cc:        JSObject::TransitionElementsKind(array, elements_kind);
builtins/array-to-spliced.tq:  elementsKind = TransitionElementsKindForInsertionIfNeeded(
objects/lookup.cc:      JSObject::TransitionElementsKind(holder_obj, to);
builtins/array-splice.tq:transitioning macro TransitionElementsKindForInsertionIfNeeded(
builtins/array-splice.tq:    TransitionElementsKindWithKind(context, a, smiElementsKind);
builtins/array-splice.tq:  elementsKind = TransitionElementsKindForInsertionIfNeeded(
builtins/builtins-array.cc:    JSObject::TransitionElementsKind(array, target_kind);
builtins/builtins-array.cc:    JSObject::TransitionElementsKind(array, PACKED_ELEMENTS);
compiler/js-native-context-specialization.cc:      effect = graph()->NewNode(simplified()->TransitionElementsKindOrCheckMap(
compiler/js-native-context-specialization.cc:            simplified()->TransitionElementsKind(ElementsTransition(
compiler/simplified-operator.cc:  DCHECK_EQ(IrOpcode::kTransitionElementsKind, op->opcode());
compiler/simplified-operator.cc:  DCHECK_EQ(IrOpcode::kTransitionElementsKindOrCheckMap, op->opcode());
compiler/simplified-operator.cc:const Operator* SimplifiedOperatorBuilder::TransitionElementsKind(
compiler/simplified-operator.cc:      IrOpcode::kTransitionElementsKind,              // opcode
compiler/simplified-operator.cc:      "TransitionElementsKind",                       // name
compiler/simplified-operator.cc:const Operator* SimplifiedOperatorBuilder::TransitionElementsKindOrCheckMap(
compiler/simplified-operator.cc:      IrOpcode::kTransitionElementsKindOrCheckMap,  // opcode
compiler/simplified-operator.cc:      "TransitionElementsKindOrCheckMap",           // name
compiler/load-elimination.h:  Reduction ReduceTransitionElementsKind(Node* node);
compiler/load-elimination.h:  Reduction ReduceTransitionElementsKindOrCheckMap(Node* node);
compiler/verifier.cc:    case IrOpcode::kTransitionElementsKind:
compiler/verifier.cc:    case IrOpcode::kTransitionElementsKindOrCheckMap:
compiler/turboshaft/maglev-early-lowering-reducer-inl.h:    TransitionElementsKind(object, map, transition_sources, transition_target,
compiler/turboshaft/maglev-early-lowering-reducer-inl.h:  void TransitionElementsKind(
compiler/turboshaft/maglev-early-lowering-reducer-inl.h:    // Turboshaft's TransitionElementsKind operation loads the map everytime, so
compiler/turboshaft/maglev-early-lowering-reducer-inl.h:          __ CallRuntime_TransitionElementsKind(
compiler/load-elimination.cc:    case IrOpcode::kTransitionElementsKind:
compiler/load-elimination.cc:      return ReduceTransitionElementsKind(node);
compiler/load-elimination.cc:    case IrOpcode::kTransitionElementsKindOrCheckMap:
compiler/load-elimination.cc:      return ReduceTransitionElementsKindOrCheckMap(node);
compiler/load-elimination.cc:Reduction LoadElimination::ReduceTransitionElementsKind(Node* node) {
compiler/load-elimination.cc:Reduction LoadElimination::ReduceTransitionElementsKindOrCheckMap(Node* node) {
compiler/load-elimination.cc:  struct TransitionElementsKindInfo {
compiler/load-elimination.cc:  ZoneVector<TransitionElementsKindInfo> element_transitions_(&temp_zone);
compiler/load-elimination.cc:          case IrOpcode::kTransitionElementsKind: {
compiler/load-elimination.cc:          case IrOpcode::kTransitionElementsKindOrCheckMap: {
compiler/load-elimination.cc:  for (const TransitionElementsKindInfo& t : element_transitions_) {
compiler/load-elimination.cc:  for (const TransitionElementsKindInfo& t : element_transitions_) {
compiler/turboshaft/machine-lowering-reducer-inl.h:  V<None> REDUCE(TransitionElementsKind)(V<HeapObject> object,
compiler/turboshaft/machine-lowering-reducer-inl.h:          __ CallRuntime_TransitionElementsKind(
compiler/turboshaft/machine-lowering-reducer-inl.h:  V<None> REDUCE(TransitionElementsKindOrCheckMap)(
compiler/turboshaft/machine-lowering-reducer-inl.h:          __ CallRuntime_TransitionElementsKind(
compiler/turboshaft/machine-lowering-reducer-inl.h:      __ CallRuntime_TransitionElementsKind(isolate_, __ NoContextConstant(),
compiler/escape-analysis.cc:    case IrOpcode::kTransitionElementsKindOrCheckMap: {
compiler/simplified-lowering.cc:      case IrOpcode::kTransitionElementsKind: {
compiler/simplified-lowering.cc:      case IrOpcode::kTransitionElementsKindOrCheckMap: {
compiler/access-info.cc:    // TransitionElementsKind for a CheckMaps, avoiding mutation of the array.
compiler/turboshaft/graph-builder.cc:    case IrOpcode::kTransitionElementsKind:
compiler/turboshaft/graph-builder.cc:      __ TransitionElementsKind(Map(node->InputAt(0)),
compiler/turboshaft/graph-builder.cc:    case IrOpcode::kTransitionElementsKindOrCheckMap: {
compiler/turboshaft/graph-builder.cc:      __ TransitionElementsKindOrCheckMap(
compiler/node-properties.cc:      case IrOpcode::kTransitionElementsKindOrCheckMap: {
compiler/typed-optimization.h:  Reduction ReduceTransitionElementsKindOrCheckMap(Node* node);
compiler/simplified-operator.h:  const Operator* TransitionElementsKind(ElementsTransition transition);
compiler/simplified-operator.h:  const Operator* TransitionElementsKindOrCheckMap(
compiler/turboshaft/maglev-graph-building-phase.cc:  maglev::ProcessResult Process(maglev::TransitionElementsKindOrCheckMap* node,
compiler/turboshaft/maglev-graph-building-phase.cc:    __ TransitionElementsKindOrCheckMap(
compiler/turboshaft/maglev-graph-building-phase.cc:  maglev::ProcessResult Process(maglev::TransitionElementsKind* node,
compiler/turboshaft/assembler.h:  V<Object> CallRuntime_TransitionElementsKind(Isolate* isolate,
compiler/turboshaft/assembler.h:    return CallRuntime<typename RuntimeCallDescriptor::TransitionElementsKind>(
compiler/turboshaft/assembler.h:  void TransitionElementsKind(V<HeapObject> object,
compiler/turboshaft/assembler.h:    ReduceIfReachableTransitionElementsKind(object, transition);
compiler/turboshaft/assembler.h:  void TransitionElementsKindOrCheckMap(
compiler/turboshaft/assembler.h:    ReduceIfReachableTransitionElementsKindOrCheckMap(object, map, frame_state,
compiler/opcodes.h:  V(TransitionElementsKind)             \
compiler/opcodes.h:  V(TransitionElementsKindOrCheckMap)   \
compiler/turbofan-typer.cc:Type Typer::Visitor::TypeTransitionElementsKind(Node* node) { UNREACHABLE(); }
compiler/turbofan-typer.cc:Type Typer::Visitor::TypeTransitionElementsKindOrCheckMap(Node* node) {
compiler/turboshaft/operations.h:  V(TransitionElementsKind)                     \
compiler/turboshaft/operations.h:  V(TransitionElementsKindOrCheckMap)           \
compiler/turboshaft/operations.h:struct TransitionElementsKindOp
compiler/turboshaft/operations.h:    : FixedArityOperationT<1, TransitionElementsKindOp> {
compiler/turboshaft/operations.h:  TransitionElementsKindOp(OpIndex object, const ElementsTransition& transition)
compiler/turboshaft/operations.h:struct TransitionElementsKindOrCheckMapOp
compiler/turboshaft/operations.h:    : FixedArityOperationT<3, TransitionElementsKindOrCheckMapOp> {
compiler/turboshaft/operations.h:  TransitionElementsKindOrCheckMapOp(
compiler/turboshaft/runtime-call-descriptors.h:  struct TransitionElementsKind : public Descriptor<TransitionElementsKind> {
compiler/turboshaft/runtime-call-descriptors.h:    static constexpr auto kFunction = Runtime::kTransitionElementsKind;
[Step 3: Duration 7.64 seconds| Input tokens: 6,925 | Output tokens: 474]
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ Step 4 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'tree' with arguments: {'options': '-L 2 -f .'}                                                                                                                          │
╰────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
Command: cd /Users/tarun/v8/v8/src && tree -L 2 -f . | head -n 1000
Observations: .
├── ./api
│   ├── ./api/api-arguments-inl.h
│   ├── ./api/api-arguments.cc
│   ├── ./api/api-arguments.h
│   ├── ./api/api-inl.h
│   ├── ./api/api-macros-undef.h
│   ├── ./api/api-macros.h
│   ├── ./api/api-natives.cc
│   ├── ./api/api-natives.h
│   ├── ./api/api.cc
│   ├── ./api/api.h
│   ├── ./api/DIR_METADATA
│   └── ./api/OWNERS
├── ./asmjs
│   ├── ./asmjs/asm-js.cc
│   ├── ./asmjs/asm-js.h
│   ├── ./asmjs/asm-names.h
│   ├── ./asmjs/asm-parser.cc
│   ├── ./asmjs/asm-parser.h
│   ├── ./asmjs/asm-scanner.cc
│   ├── ./asmjs/asm-scanner.h
│   ├── ./asmjs/asm-types.cc
│   ├── ./asmjs/asm-types.h
│   ├── ./asmjs/DIR_METADATA
│   └── ./asmjs/OWNERS
├── ./ast
│   ├── ./ast/ast-function-literal-id-reindexer.cc
│   ├── ./ast/ast-function-literal-id-reindexer.h
│   ├── ./ast/ast-source-ranges.h
│   ├── ./ast/ast-traversal-visitor.h
│   ├── ./ast/ast-value-factory.cc
│   ├── ./ast/ast-value-factory.h
│   ├── ./ast/ast.cc
│   ├── ./ast/ast.h
│   ├── ./ast/DIR_METADATA
│   ├── ./ast/modules.cc
│   ├── ./ast/modules.h
│   ├── ./ast/OWNERS
│   ├── ./ast/prettyprinter.cc
│   ├── ./ast/prettyprinter.h
│   ├── ./ast/scopes.cc
│   ├── ./ast/scopes.h
│   ├── ./ast/source-range-ast-visitor.cc
│   ├── ./ast/source-range-ast-visitor.h
│   ├── ./ast/variables.cc
│   └── ./ast/variables.h
├── ./base
│   ├── ./base/abort-mode.cc
│   ├── ./base/abort-mode.h
│   ├── ./base/address-region.h
│   ├── ./base/atomic-utils.h
│   ├── ./base/atomicops.h
│   ├── ./base/base-export.h
│   ├── ./base/bit-field.h
│   ├── ./base/bits-iterator.h
│   ├── ./base/bits.cc
│   ├── ./base/bits.h
│   ├── ./base/bounded-page-allocator.cc
│   ├── ./base/bounded-page-allocator.h
│   ├── ./base/bounds.h
│   ├── ./base/build_config.h
│   ├── ./base/compiler-specific.h
│   ├── ./base/container-utils.h
│   ├── ./base/contextual.h
│   ├── ./base/cpu.cc
│   ├── ./base/cpu.h
│   ├── ./base/debug
│   ├── ./base/DEPS
│   ├── ./base/DIR_METADATA
│   ├── ./base/discriminated-union.h
│   ├── ./base/division-by-constant.cc
│   ├── ./base/division-by-constant.h
│   ├── ./base/doubly-threaded-list.h
│   ├── ./base/emulated-virtual-address-subspace.cc
│   ├── ./base/emulated-virtual-address-subspace.h
│   ├── ./base/enum-set.h
│   ├── ./base/export-template.h
│   ├── ./base/file-utils.cc
│   ├── ./base/file-utils.h
│   ├── ./base/flags.h
│   ├── ./base/free_deleter.h
│   ├── ./base/hashing.h
│   ├── ./base/hashmap-entry.h
│   ├── ./base/hashmap.h
│   ├── ./base/ieee754.cc
│   ├── ./base/ieee754.h
│   ├── ./base/immediate-crash.h
│   ├── ./base/intrusive-set.h
│   ├── ./base/ios-headers.h
│   ├── ./base/iterator.h
│   ├── ./base/lazy-instance.h
│   ├── ./base/logging.cc
│   ├── ./base/logging.h
│   ├── ./base/macros.h
│   ├── ./base/memory.h
│   ├── ./base/numbers
│   ├── ./base/once.cc
│   ├── ./base/once.h
│   ├── ./base/overflowing-math.h
│   ├── ./base/OWNERS
│   ├── ./base/page-allocator.cc
│   ├── ./base/page-allocator.h
│   ├── ./base/platform
│   ├── ./base/pointer-with-payload.h
│   ├── ./base/qnx-math.h
│   ├── ./base/region-allocator.cc
│   ├── ./base/region-allocator.h
│   ├── ./base/ring-buffer.h
│   ├── ./base/safe_conversions_arm_impl.h
│   ├── ./base/safe_conversions_impl.h
│   ├── ./base/safe_conversions.h
│   ├── ./base/sanitizer
│   ├── ./base/small-map.h
│   ├── ./base/small-vector.h
│   ├── ./base/string-format.h
│   ├── ./base/strings.cc
│   ├── ./base/strings.h
│   ├── ./base/strong-alias.h
│   ├── ./base/sys-info.cc
│   ├── ./base/sys-info.h
│   ├── ./base/template-meta-programming
│   ├── ./base/template-utils.h
│   ├── ./base/threaded-list.h
│   ├── ./base/timezone-cache.h
│   ├── ./base/ubsan.cc
│   ├── ./base/utils
│   ├── ./base/vector.h
│   ├── ./base/virtual-address-space-page-allocator.cc
│   ├── ./base/virtual-address-space-page-allocator.h
│   ├── ./base/virtual-address-space.cc
│   ├── ./base/virtual-address-space.h
│   ├── ./base/vlq-base64.cc
│   ├── ./base/vlq-base64.h
│   ├── ./base/vlq.h
│   └── ./base/win32-headers.h
├── ./baseline
│   ├── ./baseline/arm
│   ├── ./baseline/arm64
│   ├── ./baseline/baseline-assembler-inl.h
│   ├── ./baseline/baseline-assembler.h
│   ├── ./baseline/baseline-batch-compiler.cc
│   ├── ./baseline/baseline-batch-compiler.h
│   ├── ./baseline/baseline-compiler.cc
│   ├── ./baseline/baseline-compiler.h
│   ├── ./baseline/baseline.cc
│   ├── ./baseline/baseline.h
│   ├── ./baseline/bytecode-offset-iterator.cc
│   ├── ./baseline/bytecode-offset-iterator.h
│   ├── ./baseline/DEPS
│   ├── ./baseline/ia32
│   ├── ./baseline/loong64
│   ├── ./baseline/mips64
│   ├── ./baseline/OWNERS
│   ├── ./baseline/ppc
│   ├── ./baseline/riscv
│   ├── ./baseline/s390
│   └── ./baseline/x64
├── ./bigint
│   ├── ./bigint/bigint-internal.cc
│   ├── ./bigint/bigint-internal.h
│   ├── ./bigint/bigint.h
│   ├── ./bigint/bitwise.cc
│   ├── ./bigint/CPPLINT.cfg
│   ├── ./bigint/DEPS
│   ├── ./bigint/digit-arithmetic.h
│   ├── ./bigint/div-barrett.cc
│   ├── ./bigint/div-burnikel.cc
│   ├── ./bigint/div-helpers.cc
│   ├── ./bigint/div-helpers.h
│   ├── ./bigint/div-schoolbook.cc
│   ├── ./bigint/fromstring.cc
│   ├── ./bigint/mul-fft.cc
│   ├── ./bigint/mul-karatsuba.cc
│   ├── ./bigint/mul-schoolbook.cc
│   ├── ./bigint/mul-toom.cc
│   ├── ./bigint/OWNERS
│   ├── ./bigint/tostring.cc
│   ├── ./bigint/util.h
│   ├── ./bigint/vector-arithmetic.cc
│   └── ./bigint/vector-arithmetic.h
├── ./builtins
│   ├── ./builtins/accessors.cc
│   ├── ./builtins/accessors.h
│   ├── ./builtins/aggregate-error.tq
│   ├── ./builtins/arm
│   ├── ./builtins/arm64
│   ├── ./builtins/array-at.tq
│   ├── ./builtins/array-concat.tq
│   ├── ./builtins/array-copywithin.tq
│   ├── ./builtins/array-every.tq
│   ├── ./builtins/array-filter.tq
│   ├── ./builtins/array-find.tq
│   ├── ./builtins/array-findindex.tq
│   ├── ./builtins/array-findlast.tq
│   ├── ./builtins/array-findlastindex.tq
│   ├── ./builtins/array-flat.tq
│   ├── ./builtins/array-foreach.tq
│   ├── ./builtins/array-from-async.tq
│   ├── ./builtins/array-from.tq
│   ├── ./builtins/array-isarray.tq
│   ├── ./builtins/array-join.tq
│   ├── ./builtins/array-lastindexof.tq
│   ├── ./builtins/array-map.tq
│   ├── ./builtins/array-of.tq
│   ├── ./builtins/array-reduce-right.tq
│   ├── ./builtins/array-reduce.tq
│   ├── ./builtins/array-reverse.tq
│   ├── ./builtins/array-shift.tq
│   ├── ./builtins/array-slice.tq
│   ├── ./builtins/array-some.tq
│   ├── ./builtins/array-splice.tq
│   ├── ./builtins/array-to-reversed.tq
│   ├── ./builtins/array-to-sorted.tq
│   ├── ./builtins/array-to-spliced.tq
│   ├── ./builtins/array-unshift.tq
│   ├── ./builtins/array-with.tq
│   ├── ./builtins/array.tq
│   ├── ./builtins/arraybuffer.tq
│   ├── ./builtins/base.tq
│   ├── ./builtins/boolean.tq
│   ├── ./builtins/builtins-abstract-module-source.cc
│   ├── ./builtins/builtins-api.cc
│   ├── ./builtins/builtins-array-gen.cc
│   ├── ./builtins/builtins-array-gen.h
│   ├── ./builtins/builtins-array.cc
│   ├── ./builtins/builtins-arraybuffer.cc
│   ├── ./builtins/builtins-async-disposable-stack.cc
│   ├── ./builtins/builtins-async-function-gen.cc
│   ├── ./builtins/builtins-async-gen.cc
│   ├── ./builtins/builtins-async-gen.h
│   ├── ./builtins/builtins-async-generator-gen.cc
│   ├── ./builtins/builtins-async-iterator-gen.cc
│   ├── ./builtins/builtins-async-module.cc
│   ├── ./builtins/builtins-atomics-synchronization.cc
│   ├── ./builtins/builtins-bigint-gen.cc
│   ├── ./builtins/builtins-bigint-gen.h
│   ├── ./builtins/builtins-bigint.cc
│   ├── ./builtins/builtins-bigint.tq
│   ├── ./builtins/builtins-call-gen.cc
│   ├── ./builtins/builtins-call-gen.h
│   ├── ./builtins/builtins-callsite.cc
│   ├── ./builtins/builtins-collections-gen.cc
│   ├── ./builtins/builtins-collections-gen.h
│   ├── ./builtins/builtins-collections.cc
│   ├── ./builtins/builtins-console.cc
│   ├── ./builtins/builtins-constructor-gen.cc
│   ├── ./builtins/builtins-constructor-gen.h
│   ├── ./builtins/builtins-constructor.h
│   ├── ./builtins/builtins-conversion-gen.cc
│   ├── ./builtins/builtins-data-view-gen.h
│   ├── ./builtins/builtins-dataview.cc
│   ├── ./builtins/builtins-date-gen.cc
│   ├── ./builtins/builtins-date.cc
│   ├── ./builtins/builtins-definitions.h
│   ├── ./builtins/builtins-descriptors.h
│   ├── ./builtins/builtins-disposable-stack.cc
│   ├── ./builtins/builtins-error.cc
│   ├── ./builtins/builtins-function.cc
│   ├── ./builtins/builtins-generator-gen.cc
│   ├── ./builtins/builtins-global-gen.cc
│   ├── ./builtins/builtins-global.cc
│   ├── ./builtins/builtins-handler-gen.cc
│   ├── ./builtins/builtins-ic-gen.cc
│   ├── ./builtins/builtins-inl.h
│   ├── ./builtins/builtins-internal-gen.cc
│   ├── ./builtins/builtins-internal.cc
│   ├── ./builtins/builtins-interpreter-gen.cc
│   ├── ./builtins/builtins-intl-gen.cc
│   ├── ./builtins/builtins-intl.cc
│   ├── ./builtins/builtins-iterator-gen.cc
│   ├── ./builtins/builtins-iterator-gen.h
│   ├── ./builtins/builtins-json.cc
│   ├── ./builtins/builtins-lazy-gen.cc
│   ├── ./builtins/builtins-lazy-gen.h
│   ├── ./builtins/builtins-microtask-queue-gen.cc
│   ├── ./builtins/builtins-number-gen.cc
│   ├── ./builtins/builtins-number-tsa.cc
│   ├── ./builtins/builtins-number.cc
│   ├── ./builtins/builtins-object-gen.cc
│   ├── ./builtins/builtins-object-gen.h
│   ├── ./builtins/builtins-object.cc
│   ├── ./builtins/builtins-promise-gen.cc
│   ├── ./builtins/builtins-promise-gen.h
│   ├── ./builtins/builtins-promise.h
│   ├── ./builtins/builtins-proxy-gen.cc
│   ├── ./builtins/builtins-proxy-gen.h
│   ├── ./builtins/builtins-reflect.cc
│   ├── ./builtins/builtins-regexp-gen.cc
│   ├── ./builtins/builtins-regexp-gen.h
│   ├── ./builtins/builtins-regexp.cc
│   ├── ./builtins/builtins-shadow-realm-gen.cc
│   ├── ./builtins/builtins-shadow-realm.cc
│   ├── ./builtins/builtins-shared-array.cc
│   ├── ./builtins/builtins-sharedarraybuffer-gen.cc
│   ├── ./builtins/builtins-sharedarraybuffer.cc
│   ├── ./builtins/builtins-string-gen.cc
│   ├── ./builtins/builtins-string-gen.h
│   ├── ./builtins/builtins-string-tsa.cc
│   ├── ./builtins/builtins-string.cc
│   ├── ./builtins/builtins-string.tq
│   ├── ./builtins/builtins-struct.cc
│   ├── ./builtins/builtins-symbol.cc
│   ├── ./builtins/builtins-temporal-gen.cc
│   ├── ./builtins/builtins-temporal.cc
│   ├── ./builtins/builtins-trace.cc
│   ├── ./builtins/builtins-typed-array-gen.cc
│   ├── ./builtins/builtins-typed-array-gen.h
│   ├── ./builtins/builtins-typed-array.cc
│   ├── ./builtins/builtins-utils-gen.h
│   ├── ./builtins/builtins-utils-inl.h
│   ├── ./builtins/builtins-utils.h
│   ├── ./builtins/builtins-wasm-gen.cc
│   ├── ./builtins/builtins-wasm-gen.h
│   ├── ./builtins/builtins-weak-refs.cc
│   ├── ./builtins/builtins.cc
│   ├── ./builtins/builtins.h
│   ├── ./builtins/cast.tq
│   ├── ./builtins/collections.tq
│   ├── ./builtins/console.tq
│   ├── ./builtins/constants-table-builder.cc
│   ├── ./builtins/constants-table-builder.h
│   ├── ./builtins/constructor.tq
│   ├── ./builtins/conversion.tq
│   ├── ./builtins/convert.tq
│   ├── ./builtins/data-view-ops.h
│   ├── ./builtins/data-view.tq
│   ├── ./builtins/DEPS
│   ├── ./builtins/DIR_METADATA
│   ├── ./builtins/finalization-registry.tq
│   ├── ./builtins/frame-arguments.tq
│   ├── ./builtins/frames.tq
│   ├── ./builtins/function.tq
│   ├── ./builtins/generate-bytecodes-builtins-list.cc
│   ├── ./builtins/growable-fixed-array-gen.cc
│   ├── ./builtins/growable-fixed-array-gen.h
│   ├── ./builtins/growable-fixed-array.tq
│   ├── ./builtins/ia32
│   ├── ./builtins/ic-callable.tq
│   ├── ./builtins/ic.tq
│   ├── ./builtins/internal-coverage.tq
│   ├── ./builtins/internal.tq
│   ├── ./builtins/iterator-from.tq
│   ├── ./builtins/iterator-helpers.tq
│   ├── ./builtins/iterator.tq
│   ├── ./builtins/js-to-js.tq
│   ├── ./builtins/js-to-wasm.tq
│   ├── ./builtins/loong64
│   ├── ./builtins/map-groupby.tq
│   ├── ./builtins/math.tq
│   ├── ./builtins/mips64
│   ├── ./builtins/number-builtins-reducer-inl.h
│   ├── ./builtins/number.tq
│   ├── ./builtins/object-fromentries.tq
│   ├── ./builtins/object-groupby.tq
│   ├── ./builtins/object.tq
│   ├── ./builtins/OWNERS
│   ├── ./builtins/ppc
│   ├── ./builtins/profile-data-reader.cc
│   ├── ./builtins/profile-data-reader.h
│   ├── ./builtins/promise-abstract-operations.tq
│   ├── ./builtins/promise-all-element-closure.tq
│   ├── ./builtins/promise-all.tq
│   ├── ./builtins/promise-any.tq
│   ├── ./builtins/promise-constructor.tq
│   ├── ./builtins/promise-finally.tq
│   ├── ./builtins/promise-jobs.tq
│   ├── ./builtins/promise-misc.tq
│   ├── ./builtins/promise-race.tq
│   ├── ./builtins/promise-reaction-job.tq
│   ├── ./builtins/promise-resolve.tq
│   ├── ./builtins/promise-then.tq
│   ├── ./builtins/promise-try.tq
│   ├── ./builtins/promise-withresolvers.tq
│   ├── ./builtins/proxy-constructor.tq
│   ├── ./builtins/proxy-delete-property.tq
│   ├── ./builtins/proxy-get-property.tq
│   ├── ./builtins/proxy-get-prototype-of.tq
│   ├── ./builtins/proxy-has-property.tq
│   ├── ./builtins/proxy-is-extensible.tq
│   ├── ./builtins/proxy-prevent-extensions.tq
│   ├── ./builtins/proxy-revocable.tq
│   ├── ./builtins/proxy-revoke.tq
│   ├── ./builtins/proxy-set-property.tq
│   ├── ./builtins/proxy-set-prototype-of.tq
│   ├── ./builtins/proxy.tq
│   ├── ./builtins/reflect.tq
│   ├── ./builtins/regexp-exec.tq
│   ├── ./builtins/regexp-match-all.tq
│   ├── ./builtins/regexp-match.tq
│   ├── ./builtins/regexp-replace.tq
│   ├── ./builtins/regexp-search.tq
│   ├── ./builtins/regexp-source.tq
│   ├── ./builtins/regexp-split.tq
│   ├── ./builtins/regexp-test.tq
│   ├── ./builtins/regexp.tq
│   ├── ./builtins/riscv
│   ├── ./builtins/s390
│   ├── ./builtins/set-difference.tq
│   ├── ./builtins/set-intersection.tq
│   ├── ./builtins/set-is-disjoint-from.tq
│   ├── ./builtins/set-is-subset-of.tq
│   ├── ./builtins/set-is-superset-of.tq
│   ├── ./builtins/set-symmetric-difference.tq
│   ├── ./builtins/set-union.tq
│   ├── ./builtins/setup-builtins-internal.cc
│   ├── ./builtins/string-at.tq
│   ├── ./builtins/string-endswith.tq
│   ├── ./builtins/string-html.tq
│   ├── ./builtins/string-includes.tq
│   ├── ./builtins/string-indexof.tq
│   ├── ./builtins/string-iswellformed.tq
│   ├── ./builtins/string-iterator.tq
│   ├── ./builtins/string-match-search.tq
│   ├── ./builtins/string-pad.tq
│   ├── ./builtins/string-repeat.tq
│   ├── ./builtins/string-replaceall.tq
│   ├── ./builtins/string-slice.tq
│   ├── ./builtins/string-startswith.tq
│   ├── ./builtins/string-substr.tq
│   ├── ./builtins/string-substring.tq
│   ├── ./builtins/string-towellformed.tq
│   ├── ./builtins/string-trim.tq
│   ├── ./builtins/suppressed-error.tq
│   ├── ./builtins/symbol.tq
│   ├── ./builtins/torque-csa-header-includes.h
│   ├── ./builtins/torque-internal.tq
│   ├── ./builtins/typed-array-at.tq
│   ├── ./builtins/typed-array-createtypedarray.tq
│   ├── ./builtins/typed-array-entries.tq
│   ├── ./builtins/typed-array-every.tq
│   ├── ./builtins/typed-array-filter.tq
│   ├── ./builtins/typed-array-find.tq
│   ├── ./builtins/typed-array-findindex.tq
│   ├── ./builtins/typed-array-findlast.tq
│   ├── ./builtins/typed-array-findlastindex.tq
│   ├── ./builtins/typed-array-foreach.tq
│   ├── ./builtins/typed-array-from.tq
│   ├── ./builtins/typed-array-keys.tq
│   ├── ./builtins/typed-array-of.tq
│   ├── ./builtins/typed-array-reduce.tq
│   ├── ./builtins/typed-array-reduceright.tq
│   ├── ./builtins/typed-array-set.tq
│   ├── ./builtins/typed-array-slice.tq
│   ├── ./builtins/typed-array-some.tq
│   ├── ./builtins/typed-array-sort.tq
│   ├── ./builtins/typed-array-subarray.tq
│   ├── ./builtins/typed-array-to-reversed.tq
│   ├── ./builtins/typed-array-to-sorted.tq
│   ├── ./builtins/typed-array-values.tq
│   ├── ./builtins/typed-array-with.tq
│   ├── ./builtins/typed-array.tq
│   ├── ./builtins/wasm-strings.tq
│   ├── ./builtins/wasm-to-js.tq
│   ├── ./builtins/wasm.tq
│   ├── ./builtins/weak-ref.tq
│   └── ./builtins/x64
├── ./codegen
│   ├── ./codegen/aligned-slot-allocator.cc
│   ├── ./codegen/aligned-slot-allocator.h
│   ├── ./codegen/arm
│   ├── ./codegen/arm64
│   ├── ./codegen/assembler-arch.h
│   ├── ./codegen/assembler-inl.h
│   ├── ./codegen/assembler.cc
│   ├── ./codegen/assembler.h
│   ├── ./codegen/atomic-memory-order.h
│   ├── ./codegen/background-merge-task.h
│   ├── ./codegen/bailout-reason.cc
│   ├── ./codegen/bailout-reason.h
│   ├── ./codegen/callable.h
│   ├── ./codegen/code-comments.cc
│   ├── ./codegen/code-comments.h
│   ├── ./codegen/code-desc.cc
│   ├── ./codegen/code-desc.h
│   ├── ./codegen/code-factory.cc
│   ├── ./codegen/code-factory.h
│   ├── ./codegen/code-reference.cc
│   ├── ./codegen/code-reference.h
│   ├── ./codegen/code-stub-assembler-inl.h
│   ├── ./codegen/code-stub-assembler.cc
│   ├── ./codegen/code-stub-assembler.h
│   ├── ./codegen/compilation-cache.cc
│   ├── ./codegen/compilation-cache.h
│   ├── ./codegen/compiler.cc
│   ├── ./codegen/compiler.h
│   ├── ./codegen/constant-pool.cc
│   ├── ./codegen/constant-pool.h
│   ├── ./codegen/constants-arch.h
│   ├── ./codegen/cpu-features.h
│   ├── ./codegen/define-code-stub-assembler-macros.inc
│   ├── ./codegen/DEPS
│   ├── ./codegen/DIR_METADATA
│   ├── ./codegen/external-reference-encoder.cc
│   ├── ./codegen/external-reference-encoder.h
│   ├── ./codegen/external-reference-table.cc
│   ├── ./codegen/external-reference-table.h
│   ├── ./codegen/external-reference.cc
│   ├── ./codegen/external-reference.h
│   ├── ./codegen/flush-instruction-cache.cc
│   ├── ./codegen/flush-instruction-cache.h
│   ├── ./codegen/handler-table.cc
│   ├── ./codegen/handler-table.h
│   ├── ./codegen/heap-object-list.h
│   ├── ./codegen/ia32
│   ├── ./codegen/interface-descriptors-inl.h
│   ├── ./codegen/interface-descriptors.cc
│   ├── ./codegen/interface-descriptors.h
│   ├── ./codegen/label.h
│   ├── ./codegen/linkage-location.h
│   ├── ./codegen/loong64
│   ├── ./codegen/machine-type.cc
│   ├── ./codegen/machine-type.h
│   ├── ./codegen/macro-assembler-base.cc
│   ├── ./codegen/macro-assembler-base.h
│   ├── ./codegen/macro-assembler-inl.h
│   ├── ./codegen/macro-assembler.h
│   ├── ./codegen/maglev-safepoint-table.cc
│   ├── ./codegen/maglev-safepoint-table.h
│   ├── ./codegen/mips64
│   ├── ./codegen/optimized-compilation-info.cc
│   ├── ./codegen/optimized-compilation-info.h
│   ├── ./codegen/OWNERS
│   ├── ./codegen/pending-optimization-table.cc
│   ├── ./codegen/pending-optimization-table.h
│   ├── ./codegen/ppc
│   ├── ./codegen/register-arch.h
│   ├── ./codegen/register-base.h
│   ├── ./codegen/register-configuration.cc
│   ├── ./codegen/register-configuration.h
│   ├── ./codegen/register.h
│   ├── ./codegen/reglist-base.h
│   ├── ./codegen/reglist.h
│   ├── ./codegen/reloc-info-inl.h
│   ├── ./codegen/reloc-info.cc
│   ├── ./codegen/reloc-info.h
│   ├── ./codegen/riscv
│   ├── ./codegen/s390
│   ├── ./codegen/safepoint-table-base.h
│   ├── ./codegen/safepoint-table.cc
│   ├── ./codegen/safepoint-table.h
│   ├── ./codegen/script-details.h
│   ├── ./codegen/shared-ia32-x64
│   ├── ./codegen/signature.h
│   ├── ./codegen/source-position-table.cc
│   ├── ./codegen/source-position-table.h
│   ├── ./codegen/source-position.cc
│   ├── ./codegen/source-position.h
│   ├── ./codegen/tick-counter.cc
│   ├── ./codegen/tick-counter.h
│   ├── ./codegen/tnode.cc
│   ├── ./codegen/tnode.h
│   ├── ./codegen/turboshaft-builtins-assembler-inl.h
│   ├── ./codegen/undef-code-stub-assembler-macros.inc
│   ├── ./codegen/unoptimized-compilation-info.cc
│   ├── ./codegen/unoptimized-compilation-info.h
│   └── ./codegen/x64
├── ./common
│   ├── ./common/assert-scope.cc
│   ├── ./common/assert-scope.h
│   ├── ./common/checks.h
│   ├── ./common/code-memory-access-inl.h
│   ├── ./common/code-memory-access.cc
│   ├── ./common/code-memory-access.h
│   ├── ./common/DIR_METADATA
│   ├── ./common/globals.h
│   ├── ./common/high-allocation-throughput-scope.h
│   ├── ./common/message-template.h
│   ├── ./common/operation.h
│   ├── ./common/OWNERS
│   ├── ./common/ptr-compr-inl.h
│   ├── ./common/ptr-compr.cc
│   ├── ./common/ptr-compr.h
│   ├── ./common/segmented-table-inl.h
│   ├── ./common/segmented-table.h
│   ├── ./common/simd128.h
│   └── ./common/thread-local-storage.h
├── ./compiler
│   ├── ./compiler/access-builder.cc
│   ├── ./compiler/access-builder.h
│   ├── ./compiler/access-info.cc
│   ├── ./compiler/access-info.h
│   ├── ./compiler/add-type-assertions-reducer.cc
│   ├── ./compiler/add-type-assertions-reducer.h
│   ├── ./compiler/all-nodes.cc
│   ├── ./compiler/all-nodes.h
│   ├── ./compiler/allocation-builder-inl.h
│   ├── ./compiler/allocation-builder.h
│   ├── ./compiler/backend
│   ├── ./compiler/basic-block-instrumentor.cc
│   ├── ./compiler/basic-block-instrumentor.h
│   ├── ./compiler/branch-condition-duplicator.cc
│   ├── ./compiler/branch-condition-duplicator.h
│   ├── ./compiler/branch-elimination.cc
│   ├── ./compiler/branch-elimination.h
│   ├── ./compiler/bytecode-analysis.cc
│   ├── ./compiler/bytecode-analysis.h
│   ├── ./compiler/bytecode-graph-builder.cc
│   ├── ./compiler/bytecode-graph-builder.h
│   ├── ./compiler/bytecode-liveness-map.cc
│   ├── ./compiler/bytecode-liveness-map.h
│   ├── ./compiler/c-linkage.cc
│   ├── ./compiler/checkpoint-elimination.cc
│   ├── ./compiler/checkpoint-elimination.h
│   ├── ./compiler/code-assembler-compilation-job.h
│   ├── ./compiler/code-assembler.cc
│   ├── ./compiler/code-assembler.h
│   ├── ./compiler/common-node-cache.cc
│   ├── ./compiler/common-node-cache.h
│   ├── ./compiler/common-operator-reducer.cc
│   ├── ./compiler/common-operator-reducer.h
│   ├── ./compiler/common-operator.cc
│   ├── ./compiler/common-operator.h
│   ├── ./compiler/compilation-dependencies.cc
│   ├── ./compiler/compilation-dependencies.h
│   ├── ./compiler/compiler-source-position-table.cc
│   ├── ./compiler/compiler-source-position-table.h
│   ├── ./compiler/constant-folding-reducer.cc
│   ├── ./compiler/constant-folding-reducer.h
│   ├── ./compiler/control-equivalence.cc
│   ├── ./compiler/control-equivalence.h
│   ├── ./compiler/control-path-state.h
│   ├── ./compiler/csa-load-elimination.cc
│   ├── ./compiler/csa-load-elimination.h
│   ├── ./compiler/dead-code-elimination.cc
│   ├── ./compiler/dead-code-elimination.h
│   ├── ./compiler/decompression-optimizer.cc
│   ├── ./compiler/decompression-optimizer.h
│   ├── ./compiler/DEPS
│   ├── ./compiler/diamond.h
│   ├── ./compiler/DIR_METADATA
│   ├── ./compiler/escape-analysis-reducer.cc
│   ├── ./compiler/escape-analysis-reducer.h
│   ├── ./compiler/escape-analysis.cc
│   ├── ./compiler/escape-analysis.h
│   ├── ./compiler/fast-api-calls.cc
│   ├── ./compiler/fast-api-calls.h
│   ├── ./compiler/feedback-source.cc
│   ├── ./compiler/feedback-source.h
│   ├── ./compiler/frame-states.cc
│   ├── ./compiler/frame-states.h
│   ├── ./compiler/frame.cc
│   ├── ./compiler/frame.h
│   ├── ./compiler/functional-list.h
│   ├── ./compiler/globals.h
│   ├── ./compiler/graph-assembler.cc
│   ├── ./compiler/graph-assembler.h
│   ├── ./compiler/graph-reducer.cc
│   ├── ./compiler/graph-reducer.h
│   ├── ./compiler/graph-trimmer.cc
│   ├── ./compiler/graph-trimmer.h
│   ├── ./compiler/graph-zone-traits.h
│   ├── ./compiler/heap-refs.cc
│   ├── ./compiler/heap-refs.h
│   ├── ./compiler/int64-lowering.cc
│   ├── ./compiler/int64-lowering.h
│   ├── ./compiler/js-call-reducer.cc
│   ├── ./compiler/js-call-reducer.h
│   ├── ./compiler/js-context-specialization.cc
│   ├── ./compiler/js-context-specialization.h
│   ├── ./compiler/js-create-lowering.cc
│   ├── ./compiler/js-create-lowering.h
│   ├── ./compiler/js-generic-lowering.cc
│   ├── ./compiler/js-generic-lowering.h
│   ├── ./compiler/js-graph.cc
│   ├── ./compiler/js-graph.h
│   ├── ./compiler/js-heap-broker-inl.h
│   ├── ./compiler/js-heap-broker.cc
│   ├── ./compiler/js-heap-broker.h
│   ├── ./compiler/js-inlining-heuristic.cc
│   ├── ./compiler/js-inlining-heuristic.h
│   ├── ./compiler/js-inlining.cc
│   ├── ./compiler/js-inlining.h
│   ├── ./compiler/js-intrinsic-lowering.cc
│   ├── ./compiler/js-intrinsic-lowering.h
│   ├── ./compiler/js-native-context-specialization.cc
│   ├── ./compiler/js-native-context-specialization.h
│   ├── ./compiler/js-operator.cc
│   ├── ./compiler/js-operator.h
│   ├── ./compiler/js-type-hint-lowering.cc
│   ├── ./compiler/js-type-hint-lowering.h
│   ├── ./compiler/js-typed-lowering.cc
│   ├── ./compiler/js-typed-lowering.h
│   ├── ./compiler/late-escape-analysis.cc
│   ├── ./compiler/late-escape-analysis.h
│   ├── ./compiler/linear-scheduler.cc
│   ├── ./compiler/linear-scheduler.h
│   ├── ./compiler/linkage.cc
│   ├── ./compiler/linkage.h
│   ├── ./compiler/load-elimination.cc
│   ├── ./compiler/load-elimination.h
│   ├── ./compiler/loop-analysis.cc
│   ├── ./compiler/loop-analysis.h
│   ├── ./compiler/loop-peeling.cc
│   ├── ./compiler/loop-peeling.h
│   ├── ./compiler/loop-unrolling.cc
│   ├── ./compiler/loop-unrolling.h
│   ├── ./compiler/loop-variable-optimizer.cc
│   ├── ./compiler/loop-variable-optimizer.h
│   ├── ./compiler/machine-graph-verifier.cc
│   ├── ./compiler/machine-graph-verifier.h
│   ├── ./compiler/machine-graph.cc
│   ├── ./compiler/machine-graph.h
│   ├── ./compiler/machine-operator-reducer.cc
│   ├── ./compiler/machine-operator-reducer.h
│   ├── ./compiler/machine-operator.cc
│   ├── ./compiler/machine-operator.h
│   ├── ./compiler/map-inference.cc
│   ├── ./compiler/map-inference.h
│   ├── ./compiler/memory-lowering.cc
│   ├── ./compiler/memory-lowering.h
│   ├── ./compiler/memory-optimizer.cc
│   ├── ./compiler/memory-optimizer.h
│   ├── ./compiler/node-aux-data.h
│   ├── ./compiler/node-cache.h
│   ├── ./compiler/node-marker.cc
│   ├── ./compiler/node-marker.h
│   ├── ./compiler/node-matchers.cc
│   ├── ./compiler/node-matchers.h
│   ├── ./compiler/node-observer.cc
│   ├── ./compiler/node-observer.h
│   ├── ./compiler/node-origin-table.cc
│   ├── ./compiler/node-origin-table.h
│   ├── ./compiler/node-properties.cc
│   ├── ./compiler/node-properties.h
│   ├── ./compiler/node.cc
│   ├── ./compiler/node.h
│   ├── ./compiler/opcodes.cc
│   ├── ./compiler/opcodes.h
│   ├── ./compiler/operation-typer.cc
│   ├── ./compiler/operation-typer.h
│   ├── ./compiler/operator-properties.cc
│   ├── ./compiler/operator-properties.h
│   ├── ./compiler/operator.cc
│   ├── ./compiler/operator.h
│   ├── ./compiler/osr.cc
│   ├── ./compiler/osr.h
│   ├── ./compiler/OWNERS
│   ├── ./compiler/pair-load-store-reducer.cc
│   ├── ./compiler/pair-load-store-reducer.h
│   ├── ./compiler/per-isolate-compiler-cache.h
│   ├── ./compiler/persistent-map.h
│   ├── ./compiler/phase.h
│   ├── ./compiler/pipeline-data-inl.h
│   ├── ./compiler/pipeline-statistics.cc
│   ├── ./compiler/pipeline-statistics.h
│   ├── ./compiler/pipeline.cc
│   ├── ./compiler/pipeline.h
│   ├── ./compiler/processed-feedback.h
│   ├── ./compiler/property-access-builder.cc
│   ├── ./compiler/property-access-builder.h
│   ├── ./compiler/raw-machine-assembler.cc
│   ├── ./compiler/raw-machine-assembler.h
│   ├── ./compiler/redundancy-elimination.cc
│   ├── ./compiler/redundancy-elimination.h
│   ├── ./compiler/refs-map.cc
│   ├── ./compiler/refs-map.h
│   ├── ./compiler/representation-change.cc
│   ├── ./compiler/representation-change.h
│   ├── ./compiler/revectorizer.cc
│   ├── ./compiler/revectorizer.h
│   ├── ./compiler/schedule.cc
│   ├── ./compiler/schedule.h
│   ├── ./compiler/scheduler.cc
│   ├── ./compiler/scheduler.h
│   ├── ./compiler/select-lowering.cc
│   ├── ./compiler/select-lowering.h
│   ├── ./compiler/simplified-lowering-verifier.cc
│   ├── ./compiler/simplified-lowering-verifier.h
│   ├── ./compiler/simplified-lowering.cc
│   ├── ./compiler/simplified-lowering.h
│   ├── ./compiler/simplified-operator-reducer.cc
│   ├── ./compiler/simplified-operator-reducer.h
│   ├── ./compiler/simplified-operator.cc
│   ├── ./compiler/simplified-operator.h
│   ├── ./compiler/state-values-utils.cc
│   ├── ./compiler/state-values-utils.h
│   ├── ./compiler/string-builder-optimizer.cc
│   ├── ./compiler/string-builder-optimizer.h
│   ├── ./compiler/turbofan-disabled.cc
│   ├── ./compiler/turbofan-enabled.cc
│   ├── ./compiler/turbofan-graph-visualizer.cc
│   ├── ./compiler/turbofan-graph-visualizer.h
│   ├── ./compiler/turbofan-graph.cc
│   ├── ./compiler/turbofan-graph.h
│   ├── ./compiler/turbofan-typer.cc
│   ├── ./compiler/turbofan-typer.h
│   ├── ./compiler/turbofan-types.cc
│   ├── ./compiler/turbofan-types.h
│   ├── ./compiler/turbofan.h
│   ├── ./compiler/turboshaft
│   ├── ./compiler/type-cache.cc
│   ├── ./compiler/type-cache.h
│   ├── ./compiler/type-narrowing-reducer.cc
│   ├── ./compiler/type-narrowing-reducer.h
│   ├── ./compiler/typed-optimization.cc
│   ├── ./compiler/typed-optimization.h
│   ├── ./compiler/use-info.h
│   ├── ./compiler/value-numbering-reducer.cc
│   ├── ./compiler/value-numbering-reducer.h
│   ├── ./compiler/verifier.cc
│   ├── ./compiler/verifier.h
│   ├── ./compiler/wasm-address-reassociation.cc
│   ├── ./compiler/wasm-address-reassociation.h
│   ├── ./compiler/wasm-call-descriptors.cc
│   ├── ./compiler/wasm-call-descriptors.h
│   ├── ./compiler/wasm-compiler-definitions.cc
│   ├── ./compiler/wasm-compiler-definitions.h
│   ├── ./compiler/wasm-compiler.cc
│   ├── ./compiler/wasm-compiler.h
│   ├── ./compiler/wasm-escape-analysis.cc
│   ├── ./compiler/wasm-escape-analysis.h
│   ├── ./compiler/wasm-gc-lowering.cc
│   ├── ./compiler/wasm-gc-lowering.h
│   ├── ./compiler/wasm-gc-operator-reducer.cc
│   ├── ./compiler/wasm-gc-operator-reducer.h
│   ├── ./compiler/wasm-graph-assembler.cc
│   ├── ./compiler/wasm-graph-assembler.h
│   ├── ./compiler/wasm-inlining-into-js.cc
│   ├── ./compiler/wasm-inlining-into-js.h
│   ├── ./compiler/wasm-inlining.cc
│   ├── ./compiler/wasm-inlining.h
│   ├── ./compiler/wasm-js-lowering.cc
│   ├── ./compiler/wasm-js-lowering.h
│   ├── ./compiler/wasm-load-elimination.cc
│   ├── ./compiler/wasm-load-elimination.h
│   ├── ./compiler/wasm-loop-peeling.cc
│   ├── ./compiler/wasm-loop-peeling.h
│   ├── ./compiler/wasm-typer.cc
│   ├── ./compiler/wasm-typer.h
│   ├── ./compiler/write-barrier-kind.h
│   ├── ./compiler/zone-stats.cc
│   └── ./compiler/zone-stats.h
├── ./compiler-dispatcher
│   ├── ./compiler-dispatcher/DIR_METADATA
│   ├── ./compiler-dispatcher/lazy-compile-dispatcher.cc
│   ├── ./compiler-dispatcher/lazy-compile-dispatcher.h
│   ├── ./compiler-dispatcher/optimizing-compile-dispatcher.cc
│   ├── ./compiler-dispatcher/optimizing-compile-dispatcher.h
│   └── ./compiler-dispatcher/OWNERS
├── ./d8
│   ├── ./d8/async-hooks-wrapper.cc
│   ├── ./d8/async-hooks-wrapper.h
│   ├── ./d8/d8-console.cc
│   ├── ./d8/d8-console.h
│   ├── ./d8/d8-js.cc
│   ├── ./d8/d8-platforms.cc
│   ├── ./d8/d8-platforms.h
│   ├── ./d8/d8-posix.cc
│   ├── ./d8/d8-test.cc
│   ├── ./d8/d8-windows.cc
│   ├── ./d8/d8.cc
│   ├── ./d8/d8.h
│   └── ./d8/OWNERS
├── ./date
│   ├── ./date/date.cc
│   ├── ./date/date.h
│   ├── ./date/dateparser-inl.h
│   ├── ./date/dateparser.cc
│   ├── ./date/dateparser.h
│   ├── ./date/DIR_METADATA
│   └── ./date/OWNERS
├── ./debug
│   ├── ./debug/debug-coverage.cc
│   ├── ./debug/debug-coverage.h
│   ├── ./debug/debug-evaluate.cc
│   ├── ./debug/debug-evaluate.h
│   ├── ./debug/debug-frames.cc
│   ├── ./debug/debug-frames.h
│   ├── ./debug/debug-interface.cc
│   ├── ./debug/debug-interface.h
│   ├── ./debug/debug-property-iterator.cc
│   ├── ./debug/debug-property-iterator.h
│   ├── ./debug/debug-scope-iterator.cc
│   ├── ./debug/debug-scope-iterator.h
│   ├── ./debug/debug-scopes.cc
│   ├── ./debug/debug-scopes.h
│   ├── ./debug/debug-stack-trace-iterator.cc
│   ├── ./debug/debug-stack-trace-iterator.h
│   ├── ./debug/debug-wasm-objects-inl.h
│   ├── ./debug/debug-wasm-objects.cc
│   ├── ./debug/debug-wasm-objects.h
│   ├── ./debug/debug-wasm-objects.tq
│   ├── ./debug/debug.cc
│   ├── ./debug/debug.h
│   ├── ./debug/DIR_METADATA
│   ├── ./debug/interface-types.h
│   ├── ./debug/liveedit-diff.cc
│   ├── ./debug/liveedit-diff.h
│   ├── ./debug/liveedit.cc
│   ├── ./debug/liveedit.h
│   ├── ./debug/OWNERS
│   └── ./debug/wasm
├── ./deoptimizer
│   ├── ./deoptimizer/arm
│   ├── ./deoptimizer/arm64
│   ├── ./deoptimizer/deoptimize-reason.cc
│   ├── ./deoptimizer/deoptimize-reason.h
│   ├── ./deoptimizer/deoptimized-frame-info.cc
│   ├── ./deoptimizer/deoptimized-frame-info.h
│   ├── ./deoptimizer/deoptimizer.cc
│   ├── ./deoptimizer/deoptimizer.h
│   ├── ./deoptimizer/DEPS
│   ├── ./deoptimizer/DIR_METADATA
│   ├── ./deoptimizer/frame-description.h
│   ├── ./deoptimizer/frame-translation-builder.cc
│   ├── ./deoptimizer/frame-translation-builder.h
│   ├── ./deoptimizer/ia32
│   ├── ./deoptimizer/loong64
│   ├── ./deoptimizer/materialized-object-store.cc
│   ├── ./deoptimizer/materialized-object-store.h
│   ├── ./deoptimizer/mips64
│   ├── ./deoptimizer/OWNERS
│   ├── ./deoptimizer/ppc
│   ├── ./deoptimizer/riscv
│   ├── ./deoptimizer/s390
│   ├── ./deoptimizer/translated-state.cc
│   ├── ./deoptimizer/translated-state.h
│   ├── ./deoptimizer/translation-opcode.h
│   └── ./deoptimizer/x64
├── ./DEPS
├── ./diagnostics
│   ├── ./diagnostics/arm
│   ├── ./diagnostics/arm64
│   ├── ./diagnostics/basic-block-profiler.cc
│   ├── ./diagnostics/basic-block-profiler.h
│   ├── ./diagnostics/code-tracer.h
│   ├── ./diagnostics/compilation-statistics.cc
│   ├── ./diagnostics/compilation-statistics.h
│   ├── ./diagnostics/DEPS
│   ├── ./diagnostics/disasm.h
│   ├── ./diagnostics/disassembler.cc
│   ├── ./diagnostics/disassembler.h
│   ├── ./diagnostics/eh-frame.cc
│   ├── ./diagnostics/eh-frame.h
│   ├── ./diagnostics/etw-debug-win.cc
│   ├── ./diagnostics/etw-debug-win.h
│   ├── ./diagnostics/etw-isolate-capture-state-monitor-win.cc
│   ├── ./diagnostics/etw-isolate-capture-state-monitor-win.h
│   ├── ./diagnostics/etw-isolate-load-script-data-win.cc
│   ├── ./diagnostics/etw-isolate-load-script-data-win.h
│   ├── ./diagnostics/etw-isolate-operations-win.cc
│   ├── ./diagnostics/etw-isolate-operations-win.h
│   ├── ./diagnostics/etw-jit-metadata-win.cc
│   ├── ./diagnostics/etw-jit-metadata-win.h
│   ├── ./diagnostics/etw-jit-win.cc
│   ├── ./diagnostics/etw-jit-win.h
│   ├── ./diagnostics/gdb-jit.cc
│   ├── ./diagnostics/gdb-jit.h
│   ├── ./diagnostics/ia32
│   ├── ./diagnostics/loong64
│   ├── ./diagnostics/mips64
│   ├── ./diagnostics/objects-debug.cc
│   ├── ./diagnostics/objects-printer.cc
│   ├── ./diagnostics/OWNERS
│   ├── ./diagnostics/perf-jit.cc
│   ├── ./diagnostics/perf-jit.h
│   ├── ./diagnostics/ppc
│   ├── ./diagnostics/riscv
│   ├── ./diagnostics/s390
│   ├── ./diagnostics/unwinder.cc
│   ├── ./diagnostics/unwinder.h
│   ├── ./diagnostics/unwinding-info-win64.cc
│   ├── ./diagnostics/unwinding-info-win64.h
│   └── ./diagnostics/x64
├── ./DIR_METADATA
├── ./execution
│   ├── ./execution/arguments-inl.h
│   ├── ./execution/arguments.cc
│   ├── ./execution/arguments.h
│   ├── ./execution/arm
│   ├── ./execution/arm64
│   ├── ./execution/clobber-registers.cc
│   ├── ./execution/clobber-registers.h
│   ├── ./execution/DEPS
│   ├── ./execution/DIR_METADATA
│   ├── ./execution/embedder-state.cc
│   ├── ./execution/embedder-state.h
│   ├── ./execution/encoded-c-signature.cc
│   ├── ./execution/encoded-c-signature.h
│   ├── ./execution/execution.cc
│   ├── ./execution/execution.h
│   ├── ./execution/frame-constants.h
│   ├── ./execution/frames-inl.h
│   ├── ./execution/frames.cc
│   ├── ./execution/frames.h
│   ├── ./execution/futex-emulation.cc
│   ├── ./execution/futex-emulation.h
│   ├── ./execution/ia32
│   ├── ./execution/interrupts-scope.cc
│   ├── ./execution/interrupts-scope.h
│   ├── ./execution/isolate-data.h
│   ├── ./execution/isolate-inl.h
│   ├── ./execution/isolate-utils-inl.h
│   ├── ./execution/isolate-utils.h
│   ├── ./execution/isolate.cc
│   ├── ./execution/isolate.h
│   ├── ./execution/local-isolate-inl.h
│   ├── ./execution/local-isolate.cc
│   ├── ./execution/local-isolate.h
[Step 4: Duration 3.55 seconds| Input tokens: 12,525 | Output tokens: 630]
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ Step 5 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'ripgrep' with arguments: {'pattern': 'EnsureCapacity|GrowElementsCapacity|CopyElements|SetLength\\(|SetLength\\b', 'options': ''}                                       │
╰────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
Command: cd /Users/tarun/v8/v8/src && rg 'EnsureCapacity|GrowElementsCapacity|CopyElements|SetLength\(|SetLength\b' | head -n 1000
Observations: debug/debug.cc:  RegExpMatchInfo::CopyElements(isolate_, *regexp_match_info_, 0,
regexp/regexp-macro-assembler.cc:  Address new_stack_base = regexp_stack->EnsureCapacity(old_size * 2);
init/bootstrapper.cc:  FixedArray::CopyElements(isolate, *new_array, 0, cache_, 0, cache_->length());
api/api.cc:  data = i::EmbedderDataArray::EnsureCapacity(i_isolate, data, index);
api/api.cc:void FunctionTemplate::SetLength(int length) {
api/api.cc:  EnsureNotPublished(info, "v8::FunctionTemplate::SetLength");
base/numbers/bignum.h:  void EnsureCapacity(int size) {
regexp/regexp-stack.h:  Address EnsureCapacity(size_t size);
regexp/regexp-stack.cc:    EnsureCapacity(thread_local_.memory_size_ + 1);
regexp/regexp-stack.cc:Address RegExpStack::EnsureCapacity(size_t size) {
base/numbers/bignum.cc:  EnsureCapacity(1);
base/numbers/bignum.cc:  EnsureCapacity(needed_bigits);
base/numbers/bignum.cc:  EnsureCapacity(needed_bigits);
base/numbers/bignum.cc:  EnsureCapacity(1 + std::max(BigitLength(), other.BigitLength()) - exponent_);
base/numbers/bignum.cc:  EnsureCapacity(used_digits_ + 1);
base/numbers/bignum.cc:    EnsureCapacity(used_digits_ + 1);
base/numbers/bignum.cc:    EnsureCapacity(used_digits_ + 1);
base/numbers/bignum.cc:  EnsureCapacity(product_length);
base/numbers/bignum.cc:  EnsureCapacity(final_size / kBigitSize + 2);
base/numbers/bignum.cc:    EnsureCapacity(used_digits_ + zero_digits);
strings/string-builder-inl.h:  EnsureCapacity(2);  // Subject slices are encoded with up to two smis.
strings/string-builder.cc:void FixedArrayBuilder::EnsureCapacity(Isolate* isolate, int elements) {
strings/string-builder.cc:    FixedArray::CopyElements(isolate, *extended_array, 0, *array_, 0, length_);
strings/string-builder.cc:void ReplacementStringBuilder::EnsureCapacity(int elements) {
strings/string-builder.cc:  array_builder_.EnsureCapacity(Isolate::FromHeap(heap_), elements);
strings/string-builder.cc:  EnsureCapacity(1);
strings/string-builder.h:  // EnsureCapacity is called.
strings/string-builder.h:  void EnsureCapacity(Isolate* isolate, int elements);
strings/string-builder.h:  void EnsureCapacity(int elements);
builtins/accessors.cc:  if (JSArray::SetLength(array, length).IsNothing()) {
compiler/js-call-reducer.cc:          jsgraph()->ConstantNoHole(JSArray::kMaxCopyElements));
compiler/js-call-reducer.cc:            jsgraph()->ConstantNoHole(JSArray::kMaxCopyElements - 1), loop);
compiler/js-call-reducer.cc:          // is in |1, kMaxCopyElements-1], and will break in representing
compiler/js-call-reducer.cc:          static_assert(JSArray::kMaxCopyElements < kSmiMaxValue);
wasm/canonical-types.cc:  WeakFixedArray::CopyElements(isolate, *new_rtts, 0, *old_rtts, 0, old_length);
wasm/canonical-types.cc:  WeakFixedArray::CopyElements(isolate, *new_wrappers, 0, *old_wrappers, 0,
zone/zone-containers.h:    EnsureCapacity(ilist.size());
zone/zone-containers.h:    EnsureCapacity(new_size);
zone/zone-containers.h:    EnsureCapacity(new_size);
zone/zone-containers.h:      EnsureCapacity(new_size);
zone/zone-containers.h:  void reserve(size_t new_cap) { EnsureCapacity(new_cap); }
zone/zone-containers.h:  V8_INLINE void EnsureCapacity(size_t minimum) {
builtins/builtins-internal-gen.cc:  elements = TryGrowElementsCapacity(object, elements, PACKED_DOUBLE_ELEMENTS,
builtins/builtins-internal-gen.cc:      TryGrowElementsCapacity(object, elements, PACKED_ELEMENTS, key, &runtime);
builtins/array-to-spliced.tq:    CopyElements(kind, copy, 0, array.elements, 0, actualStart);
builtins/array-to-spliced.tq:    CopyElements(kind, copy, secondPartStart, array.elements, r, secondPartLen);
snapshot/context-deserializer.cc:  void EnsureCapacity(size_t new_capacity) {
snapshot/context-deserializer.cc:    buffer.EnsureCapacity(size);
snapshot/context-deserializer.cc:    buffer.EnsureCapacity(size);
builtins/typed-array-from.tq:        // TypedArrayCopyElements which uses the same ordering as the default
builtins/typed-array-from.tq:            // in TypedArrayCopyElements
builtins/typed-array-from.tq:            // in TypedArrayCopyElements
builtins/typed-array-from.tq:            // code in TypedArrayCopyElements
builtins/typed-array-from.tq:        TypedArrayCopyElements(context, targetObj, finalSource, finalLengthNum);
builtins/typed-array-filter.tq:    // TypedArrayCopyElements() to avoid JSArray materialization. Or collect
builtins/typed-array-filter.tq:    TypedArrayCopyElements(context, typedArray, kept.ToJSArray(), lengthNumber);
builtins/array-splice.tq:macro DoCopyElements<FixedArrayType : type extends FixedArrayBase>(
builtins/array-splice.tq:  TorqueCopyElements(
builtins/array-splice.tq:          DoCopyElements(
codegen/code-stub-assembler.h:  void CopyElements(ElementsKind kind, TNode<FixedArrayBase> dst_elements,
codegen/code-stub-assembler.h:  void ArrayListSetLength(TNode<ArrayList> array, TNode<Smi> length);
codegen/code-stub-assembler.h:  TNode<FixedArrayBase> TryGrowElementsCapacity(TNode<HeapObject> object,
codegen/code-stub-assembler.h:  TNode<FixedArrayBase> TryGrowElementsCapacity(TNode<HeapObject> object,
codegen/code-stub-assembler.h:  TNode<FixedArrayBase> GrowElementsCapacity(
codegen/code-stub-assembler.h:  void PossiblyGrowElementsCapacity(ElementsKind kind, TNode<HeapObject> array,
codegen/code-stub-assembler.h:  TNode<FixedArrayBase> CopyElementsOnWrite(TNode<HeapObject> object,
builtins/typed-array.tq:extern runtime TypedArrayCopyElements(Context, JSTypedArray, Object, Number):
builtins/array-shift.tq:  if (newLength > kMaxCopyElements) goto Runtime;
builtins/array-slice.tq:  CopyElements(
builtins/array-slice.tq:  CopyElements(
builtins/builtins-collections-gen.cc:        ArrayListSetLength(array, SmiConstant(1));
builtins/builtins-collections-gen.cc:    // TODO(pwong): Port HashTable's Rehash() and EnsureCapacity() to CSA.
builtins/builtins-array.cc:          JSArray::SetLength(array, static_cast<uint32_t>(length)));
builtins/builtins-array.cc:    CHECK(accessor->SetLength(array, end).FromJust());
builtins/builtins-array.cc:        isolate, set_len_ok, JSArray::SetLength(array, new_length));
execution/isolate.h:  void UpdateNoElementsProtectorOnSetLength(DirectHandle<JSObject> object) {
builtins/base.tq:const kMaxCopyElements:
builtins/base.tq:    constexpr int31 generates 'JSArray::kMaxCopyElements';
builtins/typed-array-createtypedarray.tq:        TypedArrayCopyElements(
builtins/array-to-sorted.tq:  CopyElements(
builtins/growable-fixed-array.tq:    this.EnsureCapacity();
builtins/growable-fixed-array.tq:  macro EnsureCapacity(): void {
objects/scope-info.cc:void ScopeInfo::CopyElements(Isolate* isolate, int dst_index,
objects/fixed-array.cc:  CopyElements(isolate, *new_array, 0, *array, 0, old_length, mode);
objects/property-array-inl.h:void PropertyArray::CopyElements(Isolate* isolate, Tagged<PropertyArray> dst,
objects/string-table.h:  Data* EnsureCapacity(PtrComprCageBase cage_base, int additional_elements);
objects/objects.cc:    // 2a. Return ArraySetLength(A, Desc).
objects/objects.cc:    return ArraySetLength(isolate, o, desc, should_throw);
objects/objects.cc:// Part of ES6 9.4.2.4 ArraySetLength.
objects/objects.cc:  // Slow path: follow steps in ES6 9.4.2.4 "ArraySetLength".
objects/objects.cc:Maybe<bool> JSArray::ArraySetLength(Isolate* isolate, DirectHandle<JSArray> a,
objects/objects.cc:      // since we later use JSArray::SetLength instead of
objects/objects.cc:  // Most of steps 16 through 19 is implemented by JSArray::SetLength.
objects/objects.cc:  MAYBE_RETURN(JSArray::SetLength(a, new_len), Nothing<bool>());
objects/objects.cc:Maybe<bool> JSArray::SetLength(DirectHandle<JSArray> array,
objects/objects.cc:  return array->GetElementsAccessor()->SetLength(array, new_length);
objects/objects.cc:HandleType<Derived> HashTable<Derived, Shape>::EnsureCapacity(
objects/objects.cc:  // EnsureCapacity will guarantee the hash table is never full.
objects/objects.cc:  // EnsureCapacity will guarantee the hash table is never full.
objects/objects.cc:    stringset = EnsureCapacity(isolate, stringset);
objects/objects.cc:  table = EnsureCapacity(isolate, table);
objects/objects.cc:  dictionary = Derived::EnsureCapacity(isolate, dictionary);
objects/objects.cc:  table = Derived::EnsureCapacity(isolate, table);
objects/objects.cc:  table = Derived::EnsureCapacity(isolate, table);
objects/objects.cc:    set = EnsureCapacity(isolate, set);
objects/objects.cc:  HashTable<DERIVED, SHAPE>::EnsureCapacity(Isolate*, Handle<DERIVED>, int,  \
objects/objects.cc:  HashTable<DERIVED, SHAPE>::EnsureCapacity(LocalIsolate*, Handle<DERIVED>,  \
objects/objects.cc:  HashTable<DERIVED, SHAPE>::EnsureCapacity(Isolate*, DirectHandle<DERIVED>, \
objects/objects.cc:  HashTable<DERIVED, SHAPE>::EnsureCapacity(                                 \
objects/ordered-hash-table.cc:OrderedHashTable<Derived, entrysize>::EnsureCapacityForAdding(
objects/ordered-hash-table.cc:      OrderedHashSet::EnsureCapacityForAdding(isolate, table);
objects/ordered-hash-table.cc:      OrderedHashMap::EnsureCapacityForAdding(isolate, table);
objects/ordered-hash-table.cc:      OrderedNameDictionary::EnsureCapacityForAdding(isolate, table);
objects/ordered-hash-table.cc:OrderedHashTable<OrderedHashSet, 1>::EnsureCapacityForAdding(
objects/ordered-hash-table.cc:OrderedHashTable<OrderedHashMap, 2>::EnsureCapacityForAdding(
objects/ordered-hash-table.cc:OrderedHashTable<OrderedNameDictionary, 3>::EnsureCapacityForAdding(
objects/embedder-data-array.cc:DirectHandle<EmbedderDataArray> EmbedderDataArray::EnsureCapacity(
objects/regexp-match-info.cc:    RegExpMatchInfo::CopyElements(isolate, *new_info, 0, *match_info, 0,
ic/keyed-store-generic.cc:      GrowElementsCapacity(receiver, elements, from_kind, to_kind, capacity,
ic/keyed-store-generic.cc:    // TODO(jkummerow): Use GrowElementsCapacity instead of bailing out.
codegen/code-stub-assembler.cc:void CodeStubAssembler::PossiblyGrowElementsCapacity(
codegen/code-stub-assembler.cc:  *var_elements = GrowElementsCapacity(array, var_elements->value(), kind, kind,
codegen/code-stub-assembler.cc:  // FixedArray. In that case, PossiblyGrowElementsCapacity can fail even if no
codegen/code-stub-assembler.cc:  PossiblyGrowElementsCapacity(kind, array, var_length.value(), &var_elements,
codegen/code-stub-assembler.cc:  PossiblyGrowElementsCapacity(kind, array, var_length.value(), &var_elements,
codegen/code-stub-assembler.cc:      // We can use CopyElements (memcpy) because we don't need to replace or
codegen/code-stub-assembler.cc:      // convert any values. Since {to_elements} is in new-space, CopyElements
codegen/code-stub-assembler.cc:      CopyElements(to_kind, to_elements, IntPtrConstant(0), source,
codegen/code-stub-assembler.cc:      CopyElements(kind, to_elements, IntPtrConstant(0), source,
codegen/code-stub-assembler.cc:void CodeStubAssembler::CopyElements(ElementsKind kind,
codegen/code-stub-assembler.cc:  Comment("TryGrowElementsCapacity");
codegen/code-stub-assembler.cc:TNode<FixedArrayBase> CodeStubAssembler::TryGrowElementsCapacity(
codegen/code-stub-assembler.cc:  return TryGrowElementsCapacity(object, elements, kind,
codegen/code-stub-assembler.cc:TNode<FixedArrayBase> CodeStubAssembler::TryGrowElementsCapacity(
codegen/code-stub-assembler.cc:  Comment("TryGrowElementsCapacity");
codegen/code-stub-assembler.cc:  return GrowElementsCapacity(object, elements, kind, kind, capacity,
codegen/code-stub-assembler.cc:TNode<FixedArrayBase> CodeStubAssembler::GrowElementsCapacity(
codegen/code-stub-assembler.cc:  Comment("| GrowElementsCapacity");
codegen/code-stub-assembler.cc:  Comment("] GrowElementsCapacity");
codegen/code-stub-assembler.cc:template TNode<FixedArrayBase> CodeStubAssembler::GrowElementsCapacity<IntPtrT>(
codegen/code-stub-assembler.cc:    elements = CopyElementsOnWrite(object, elements, elements_kind,
codegen/code-stub-assembler.cc:      TNode<FixedArrayBase> new_elements = TryGrowElementsCapacity(
codegen/code-stub-assembler.cc:TNode<FixedArrayBase> CodeStubAssembler::CopyElementsOnWrite(
codegen/code-stub-assembler.cc:    TNode<FixedArrayBase> new_elements = GrowElementsCapacity(
codegen/code-stub-assembler.cc:    GrowElementsCapacity(object, elements, from_kind, to_kind, array_length,
codegen/code-stub-assembler.cc:  ArrayListSetLength(array_with_space, new_length);
codegen/code-stub-assembler.cc:void CodeStubAssembler::ArrayListSetLength(TNode<ArrayList> array,
objects/hash-table.h:  V8_WARN_UNUSED_RESULT static HandleType<Derived> EnsureCapacity(
objects/hash-table.h:  HashTable<DERIVED, SHAPE>::EnsureCapacity(Isolate*, Handle<DERIVED>, int,  \
objects/hash-table.h:  HashTable<DERIVED, SHAPE>::EnsureCapacity(LocalIsolate*, Handle<DERIVED>,  \
objects/hash-table.h:      HashTable<DERIVED, SHAPE>::EnsureCapacity(                             \
objects/hash-table.h:      HashTable<DERIVED, SHAPE>::EnsureCapacity(                             \
objects/contexts.cc:  names_table = names_table->EnsureCapacity(isolate, names_table, local_count);
objects/contexts.cc:    CopyElements(isolate, *new_table, 0, *table, 0, old_length);
objects/embedder-data-array.h:  static DirectHandle<EmbedderDataArray> EnsureCapacity(
objects/fixed-array.h:  inline static void CopyElements(Isolate* isolate, Tagged<Derived> dst,
objects/fixed-array.h:  using Super::CopyElements;
objects/fixed-array.h:  inline void CopyElements(Isolate* isolate, int dst_index,
objects/fixed-array.h:  inline void CopyElements(Isolate* isolate, int dst_index,
runtime/runtime-collections.cc:      OrderedHashSet::EnsureCapacityForAdding(isolate, table);
runtime/runtime-collections.cc:      OrderedHashSet::EnsureCapacityForAdding(isolate, table);
runtime/runtime-collections.cc:      OrderedHashMap::EnsureCapacityForAdding(isolate, table);
runtime/runtime-collections.cc:      OrderedHashMap::EnsureCapacityForAdding(isolate, table);
runtime/runtime-typedarray.cc:RUNTIME_FUNCTION(Runtime_TypedArrayCopyElements) {
runtime/runtime-typedarray.cc:  return accessor->CopyElements(source, target, length, 0);
runtime/runtime-typedarray.cc:  return accessor->CopyElements(source, target, length, offset);
objects/property-array.h:  // Signature must be in sync with FixedArray::CopyElements().
objects/property-array.h:  inline static void CopyElements(Isolate* isolate, Tagged<PropertyArray> dst,
runtime/runtime.h:  F(TypedArrayCopyElements, 3, 1)              \
runtime/runtime-regexp.cc:    builder.EnsureCapacity(isolate, kMaxBuilderEntriesPerRegExpMatch);
objects/fixed-array-inl.h:void TaggedArrayBase<D, S, P>::CopyElements(Isolate* isolate, Tagged<D> dst,
objects/fixed-array-inl.h:void FixedArray::CopyElements(Isolate* isolate, int dst_index,
objects/fixed-array-inl.h:  CopyElements(isolate, this, dst_index, src, src_index, len, mode);
objects/fixed-array-inl.h:  FixedArray::CopyElements(isolate, *ys, 0, *xs, 0, elements_to_copy, mode);
objects/fixed-array-inl.h:void WeakArrayList::CopyElements(Isolate* isolate, int dst_index,
objects/js-array.tq:extern macro CopyElements(
objects/js-array.tq:macro TorqueCopyElements(
objects/js-array.tq:  CopyElements(
objects/js-array.tq:macro TorqueCopyElements(
objects/js-array.tq:  CopyElements(
objects/js-array.h:  V8_EXPORT_PRIVATE static Maybe<bool> SetLength(DirectHandle<JSArray> array,
objects/js-array.h:  V8_WARN_UNUSED_RESULT static Maybe<bool> ArraySetLength(
objects/js-array.h:  static const int kMaxCopyElements = 100;
objects/elements.h:  V8_WARN_UNUSED_RESULT virtual Maybe<bool> SetLength(
objects/elements.h:  virtual void CopyElements(Isolate* isolate,
objects/elements.h:  virtual Tagged<Object> CopyElements(DirectHandle<JSAny> source,
objects/elements.h:  virtual void CopyElements(Isolate* isolate, Tagged<JSObject> source_holder,
objects/scope-info.h:  void CopyElements(Isolate* isolate, int dst_index, Tagged<ScopeInfo> src,
objects/ordered-hash-table.h:  static MaybeHandle<Derived> EnsureCapacityForAdding(Isolate* isolate,
objects/hash-table-inl.h:  // EnsureCapacity will guarantee the hash table is never full.
objects/hash-table-inl.h:  table = EnsureCapacity(isolate, table);
objects/js-struct.cc:  EnsureCapacity(isolate, 1);
objects/js-struct.cc:void SharedStructTypeRegistry::EnsureCapacity(PtrComprCageBase cage_base,
objects/compilation-cache-table.cc:  return EnsureCapacity(isolate, cache);
objects/compilation-cache-table.cc:  cache = EnsureCapacity(isolate, cache);
objects/compilation-cache-table.cc:  cache = EnsureCapacity(isolate, cache);
heap/new-spaces.h:  bool EnsureCapacity(size_t capacity);
objects/string-forwarding-table.h:  BlockVector* EnsureCapacity(uint32_t block);
objects/keys.cc:    FixedArray::CopyElements(isolate, *combined_keys, 0, *own_keys, 0,
objects/js-struct.h:  void EnsureCapacity(PtrComprCageBase cage_base, int additional_elements);
objects/string-table.cc:    Data* data = EnsureCapacity(isolate, 1);
objects/string-table.cc:StringTable::Data* StringTable::EnsureCapacity(PtrComprCageBase cage_base,
objects/string-table.cc:    Data* const data = EnsureCapacity(isolate, length);
objects/string-table.cc:    Data* const data = EnsureCapacity(isolate, 1);
objects/string-forwarding-table.cc:StringForwardingTable::BlockVector* StringForwardingTable::EnsureCapacity(
objects/string-forwarding-table.cc:  BlockVector* blocks = EnsureCapacity(block_index);
objects/string-forwarding-table.cc:  BlockVector* blocks = EnsureCapacity(block_index);
objects/elements.cc:// CopyElements, it copies all of elements from source after source_start to
objects/elements.cc:  to->CopyElements(isolate, to_start, from, from_start, copy_size,
objects/elements.cc:// See ElementsAccessorBase::CopyElements() for details.
objects/elements.cc:  Maybe<bool> SetLength(DirectHandle<JSArray> array, uint32_t length) final {
objects/elements.cc:    Subclass::CopyElementsImpl(isolate, *old_elements, src_index, *new_elements,
objects/elements.cc:      object->GetIsolate()->UpdateNoElementsProtectorOnSetLength(object);
objects/elements.cc:  static void CopyElementsImpl(Isolate* isolate, Tagged<FixedArrayBase> from,
objects/elements.cc:  void CopyElements(Isolate* isolate, Tagged<JSObject> from_holder,
objects/elements.cc:    // NOTE: the Subclass::CopyElementsImpl() methods
objects/elements.cc:    Subclass::CopyElementsImpl(isolate, from, from_start, *to, from_kind,
objects/elements.cc:  void CopyElements(Isolate* isolate, DirectHandle<FixedArrayBase> source,
objects/elements.cc:    Subclass::CopyElementsImpl(isolate, *source, 0, *destination, source_kind,
objects/elements.cc:  Tagged<Object> CopyElements(DirectHandle<JSAny> source,
objects/elements.cc:    return Subclass::CopyElementsHandleImpl(source, destination, length,
objects/elements.cc:  static Tagged<Object> CopyElementsHandleImpl(
objects/elements.cc:  static void CopyElementsImpl(Isolate* isolate, Tagged<FixedArrayBase> from,
objects/elements.cc:    if (len > JSArray::kMaxCopyElements && dst_index == 0 &&
objects/elements.cc:  // See ElementsAccessor::CopyElements() for details.
objects/elements.cc:  static void CopyElementsImpl(Isolate* isolate, Tagged<FixedArrayBase> from,
objects/elements.cc:  static void CopyElementsImpl(Isolate* isolate, Tagged<FixedArrayBase> from,
objects/elements.cc:  static void CopyElementsFromTypedArray(Tagged<JSTypedArray> source,
objects/elements.cc:  static bool TryCopyElementsFastNumber(Tagged<Context> context,
objects/elements.cc:  static Tagged<Object> CopyElementsHandleSlow(
objects/elements.cc:  static Tagged<Object> CopyElementsHandleImpl(
objects/elements.cc:        CopyElementsFromTypedArray(*source_ta, *destination_ta, length, offset);
objects/elements.cc:        if (TryCopyElementsFastNumber(isolate->context(), *source_array,
objects/elements.cc:    return CopyElementsHandleSlow(source, destination_ta, length, offset);
objects/elements.cc:  static void CopyElementsImpl(Isolate* isolate, Tagged<FixedArrayBase> from,
objects/elements.cc:      object->GetIsolate()->UpdateNoElementsProtectorOnSetLength(object);
objects/elements.cc:  static void CopyElementsImpl(Isolate* isolate, Tagged<FixedArrayBase> from,
objects/elements.cc:      MAYBE_RETURN_NULL(JSArray::SetLength(array, length));
objects/elements.cc:    CHECK(Type##ElementsAccessor::TryCopyElementsFastNumber( \
objects/elements.cc:    Type##ElementsAccessor::CopyElementsFromTypedArray(source, destination, \
objects/elements.cc:    accessor->CopyElements(isolate, array, 0, from_kind, storage,
objects/value-serializer.cc:  MAYBE_RETURN(JSArray::SetLength(array, length), MaybeHandle<JSArray>());
objects/value-serializer.cc:        MAYBE_RETURN_NULL(JSArray::SetLength(js_array, length));
heap/factory.cc:  T::CopyElements(isolate(), result, 0, *src, 0, len, mode);
heap/factory.cc:  T::CopyElements(isolate(), result, 0, *src, 0, old_len, mode);
heap/factory.cc:  raw->CopyElements(isolate(), 0, *src, 0, old_len, mode);
heap/factory.cc:  result->CopyElements(isolate(), 0, *array, 0, new_len, mode);
heap/new-spaces.cc:    EnsureCapacity(target_capacity_);
heap/new-spaces.cc:bool SemiSpace::EnsureCapacity(size_t capacity) {
heap/new-spaces.cc:  if (!EnsureCapacity(target_capacity_)) {
heap/new-spaces.cc:  if (!EnsureCapacity(new_capacity)) {
heap/new-spaces.cc:    EnsureCapacity(new_capacity);
[Step 5: Duration 6.05 seconds| Input tokens: 31,559 | Output tokens: 995]
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ Step 6 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'ripgrep' with arguments: {'pattern': 'KeyedStoreIC|KeyedLoadIC|StoreIC|LoadIC|ICState|FeedbackVector|KeyedStoreMode|KeyedLoad', 'options': ''}                          │
╰────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
Command: cd /Users/tarun/v8/v8/src && rg 'KeyedStoreIC|KeyedLoadIC|StoreIC|LoadIC|ICState|FeedbackVector|KeyedStoreMode|KeyedLoad' | head -n 1000
Observations: builtins/iterator.tq:    maybeFeedbackVector: Undefined|FeedbackVector): JSAny {
builtins/iterator.tq:  // This dcheck ensures correctness of maybeFeedbackVector's type which can
builtins/iterator.tq:      IsUndefined(maybeFeedbackVector) ||
builtins/iterator.tq:      Is<FeedbackVector>(maybeFeedbackVector));
builtins/iterator.tq:  typeswitch (maybeFeedbackVector) {
builtins/iterator.tq:    case (feedback: FeedbackVector): {
builtins/iterator.tq:      iteratorMethod = LoadIC(
builtins/iterator.tq:      context, receiver, iteratorMethod, callSlotSmi, maybeFeedbackVector);
builtins/iterator.tq:extern macro LoadFeedbackVectorFromBaseline(): FeedbackVector;
builtins/iterator.tq:  const feedback: FeedbackVector = LoadFeedbackVectorFromBaseline();
builtins/iterator.tq:      LoadIC(context, receiver, IteratorSymbolConstant(), loadSlot, feedback);
builtins/iterator.tq:    feedback: Undefined|FeedbackVector): JSAny {
builtins/builtins-ic-gen.cc:void Builtins::Generate_LoadIC(compiler::CodeAssemblerState* state) {
builtins/builtins-ic-gen.cc:  assembler.GenerateLoadIC();
builtins/builtins-ic-gen.cc:void Builtins::Generate_LoadIC_Megamorphic(
builtins/builtins-ic-gen.cc:  assembler.GenerateLoadIC_Megamorphic();
builtins/builtins-ic-gen.cc:void Builtins::Generate_LoadIC_Noninlined(compiler::CodeAssemblerState* state) {
builtins/builtins-ic-gen.cc:  assembler.GenerateLoadIC_Noninlined();
builtins/builtins-ic-gen.cc:void Builtins::Generate_LoadIC_NoFeedback(compiler::CodeAssemblerState* state) {
builtins/builtins-ic-gen.cc:  assembler.GenerateLoadIC_NoFeedback();
builtins/builtins-ic-gen.cc:void Builtins::Generate_LoadICTrampoline(compiler::CodeAssemblerState* state) {
builtins/builtins-ic-gen.cc:  assembler.GenerateLoadICTrampoline();
builtins/builtins-ic-gen.cc:void Builtins::Generate_LoadICBaseline(compiler::CodeAssemblerState* state) {
builtins/builtins-ic-gen.cc:  assembler.GenerateLoadICBaseline();
builtins/builtins-ic-gen.cc:void Builtins::Generate_LoadICTrampoline_Megamorphic(
builtins/builtins-ic-gen.cc:  assembler.GenerateLoadICTrampoline_Megamorphic();
builtins/builtins-ic-gen.cc:void Builtins::Generate_KeyedLoadIC(compiler::CodeAssemblerState* state) {
builtins/builtins-ic-gen.cc:  assembler.GenerateKeyedLoadIC();
builtins/builtins-ic-gen.cc:void Builtins::Generate_EnumeratedKeyedLoadIC(
builtins/builtins-ic-gen.cc:  assembler.GenerateEnumeratedKeyedLoadIC();
builtins/builtins-ic-gen.cc:void Builtins::Generate_EnumeratedKeyedLoadICBaseline(
builtins/builtins-ic-gen.cc:  assembler.GenerateEnumeratedKeyedLoadICBaseline();
builtins/builtins-ic-gen.cc:void Builtins::Generate_KeyedLoadIC_Megamorphic(
builtins/builtins-ic-gen.cc:  assembler.GenerateKeyedLoadIC_Megamorphic();
builtins/builtins-ic-gen.cc:void Builtins::Generate_KeyedLoadIC_PolymorphicName(
builtins/builtins-ic-gen.cc:  assembler.GenerateKeyedLoadIC_PolymorphicName();
builtins/builtins-ic-gen.cc:void Builtins::Generate_KeyedLoadICTrampoline(
builtins/builtins-ic-gen.cc:  assembler.GenerateKeyedLoadICTrampoline();
builtins/builtins-ic-gen.cc:void Builtins::Generate_KeyedLoadICBaseline(
builtins/builtins-ic-gen.cc:  assembler.GenerateKeyedLoadICBaseline();
builtins/builtins-ic-gen.cc:void Builtins::Generate_KeyedLoadICTrampoline_Megamorphic(
builtins/builtins-ic-gen.cc:  assembler.GenerateKeyedLoadICTrampoline_Megamorphic();
builtins/builtins-ic-gen.cc:void Builtins::Generate_StoreIC(compiler::CodeAssemblerState* state) {
builtins/builtins-ic-gen.cc:  assembler.GenerateStoreIC();
builtins/builtins-ic-gen.cc:void Builtins::Generate_StoreIC_Megamorphic(
builtins/builtins-ic-gen.cc:  assembler.GenerateStoreIC_Megamorphic();
builtins/builtins-ic-gen.cc:void Builtins::Generate_StoreICTrampoline(compiler::CodeAssemblerState* state) {
builtins/builtins-ic-gen.cc:  assembler.GenerateStoreICTrampoline();
builtins/builtins-ic-gen.cc:void Builtins::Generate_StoreICTrampoline_Megamorphic(
builtins/builtins-ic-gen.cc:  assembler.GenerateStoreICTrampoline_Megamorphic();
builtins/builtins-ic-gen.cc:void Builtins::Generate_StoreICBaseline(compiler::CodeAssemblerState* state) {
builtins/builtins-ic-gen.cc:  assembler.GenerateStoreICBaseline();
builtins/builtins-ic-gen.cc:void Builtins::Generate_KeyedStoreIC(compiler::CodeAssemblerState* state) {
builtins/builtins-ic-gen.cc:  assembler.GenerateKeyedStoreIC();
builtins/builtins-ic-gen.cc:void Builtins::Generate_KeyedStoreICTrampoline(
builtins/builtins-ic-gen.cc:  assembler.GenerateKeyedStoreICTrampoline();
builtins/builtins-ic-gen.cc:void Builtins::Generate_KeyedStoreICTrampoline_Megamorphic(
builtins/builtins-ic-gen.cc:  assembler.GenerateKeyedStoreICTrampoline_Megamorphic();
builtins/builtins-ic-gen.cc:void Builtins::Generate_KeyedStoreICBaseline(
builtins/builtins-ic-gen.cc:  assembler.GenerateKeyedStoreICBaseline();
debug/debug.cc:      if (needs_to_clear_ic && IsFeedbackVector(obj)) {
debug/debug.cc:        Cast<FeedbackVector>(obj)->ClearSlots(isolate_);
roots/static-roots.h:  static constexpr Tagged_t kFeedbackVectorMap = 0x801;
roots/static-roots.h:    StaticReadOnlyRoot::kFeedbackVectorMap,
roots/roots.h:  V(Map, feedback_vector_map, FeedbackVectorMap)                               \
roots/roots.h:    FeedbackVectorsForProfilingTools)                                       \
builtins/builtins-internal-gen.cc:  auto feedback_vector = Parameter<FeedbackVector>(Descriptor::kFeedbackVector);
builtins/builtins-internal-gen.cc:  Register feedback_vector = D::GetRegisterParameter(D::kFeedbackVector);
builtins/builtins-internal-gen.cc:  masm->AssertFeedbackVector(feedback_vector, temporary);
builtins/arm64/builtins-arm64.cc:void ResetFeedbackVectorOsrUrgency(MacroAssembler* masm,
builtins/arm64/builtins-arm64.cc:          FieldMemOperand(feedback_vector, FeedbackVector::kOsrStateOffset));
builtins/arm64/builtins-arm64.cc:  __ And(scratch, scratch, Operand(~FeedbackVector::OsrUrgencyBits::kMask));
builtins/arm64/builtins-arm64.cc:          FieldMemOperand(feedback_vector, FeedbackVector::kOsrStateOffset));
builtins/arm64/builtins-arm64.cc:  __ AssertFeedbackVector(feedback_vector, scratch);
builtins/arm64/builtins-arm64.cc:  __ LoadFeedbackVectorFlagsAndJumpIfNeedsProcessing(
builtins/arm64/builtins-arm64.cc:    ResetFeedbackVectorOsrUrgency(masm, feedback_vector, temps.AcquireW());
builtins/arm64/builtins-arm64.cc:                           FeedbackVector::kInvocationCountOffset));
builtins/arm64/builtins-arm64.cc:                           FeedbackVector::kInvocationCountOffset));
builtins/arm64/builtins-arm64.cc:    __ AssertFeedbackVector(feedback_vector, scratch);
builtins/arm64/builtins-arm64.cc:  __ LoadFeedbackVector(feedback_vector, closure, x7, &push_stack_frame);
builtins/arm64/builtins-arm64.cc:  __ LoadFeedbackVectorFlagsAndJumpIfNeedsProcessing(
builtins/arm64/builtins-arm64.cc:  ResetFeedbackVectorOsrUrgency(masm, feedback_vector, w7);
builtins/arm64/builtins-arm64.cc:                              FeedbackVector::kInvocationCountOffset));
builtins/arm64/builtins-arm64.cc:                              FeedbackVector::kInvocationCountOffset));
builtins/arm64/builtins-arm64.cc:    __ LoadFeedbackVectorFlagsAndJumpIfNeedsProcessing(
builtins/arm64/builtins-arm64.cc:                              WasmTrustedInstanceData::kFeedbackVectorsOffset));
builtins/arm64/builtins-arm64.cc:  __ CallRuntime(Runtime::kWasmAllocateFeedbackVector, 3);
builtins/arm64/builtins-arm64.cc:  static_assert(InterpreterFrameConstants::kFeedbackVectorFromFp ==
builtins/arm64/builtins-arm64.cc:                BaselineFrameConstants::kFeedbackVectorFromFp);
builtins/arm64/builtins-arm64.cc:         MemOperand(fp, InterpreterFrameConstants::kFeedbackVectorFromFp));
debug/liveedit.cc:      JSFunction::EnsureFeedbackVector(isolate, js_function,
debug/liveedit.cc:      JSFunction::EnsureFeedbackVector(isolate, js_function,
debug/debug-coverage.cc:      // a more reliable count than what we get from the FeedbackVector (which
debug/debug-coverage.cc:        Tagged<FeedbackVector> vector = Cast<FeedbackVector>(list->get(i));
debug/debug-coverage.cc:    isolate->SetFeedbackVectorsForProfilingTools(
debug/debug-coverage.cc:      isolate->SetFeedbackVectorsForProfilingTools(
debug/debug-coverage.cc:          } else if (IsFeedbackVector(o)) {
debug/debug-coverage.cc:            Cast<FeedbackVector>(o)->clear_invocation_count(kRelaxedStore);
debug/debug-coverage.cc:        JSFunction::EnsureFeedbackVector(isolate, func, &is_compiled_scope);
flags/flag-definitions.h:DEFINE_BOOL(log_feedback_vector, false, "Log FeedbackVectors on first creation")
builtins/riscv/builtins-riscv.cc:void ResetFeedbackVectorOsrUrgency(MacroAssembler* masm,
builtins/riscv/builtins-riscv.cc:         FieldMemOperand(feedback_vector, FeedbackVector::kOsrStateOffset));
builtins/riscv/builtins-riscv.cc:  __ And(scratch, scratch, Operand(~FeedbackVector::OsrUrgencyBits::kMask));
builtins/riscv/builtins-riscv.cc:        FieldMemOperand(feedback_vector, FeedbackVector::kOsrStateOffset));
builtins/riscv/builtins-riscv.cc:    __ AssertFeedbackVector(feedback_vector, type);
builtins/riscv/builtins-riscv.cc:  __ LoadFeedbackVectorFlagsAndJumpIfNeedsProcessing(
builtins/riscv/builtins-riscv.cc:    ResetFeedbackVectorOsrUrgency(masm, feedback_vector, temps.Acquire());
builtins/riscv/builtins-riscv.cc:                          FeedbackVector::kInvocationCountOffset));
builtins/riscv/builtins-riscv.cc:                          FeedbackVector::kInvocationCountOffset));
builtins/riscv/builtins-riscv.cc:      __ AssertFeedbackVector(feedback_vector, type);
builtins/riscv/builtins-riscv.cc:  __ LoadFeedbackVector(feedback_vector, closure, a4, &push_stack_frame);
builtins/riscv/builtins-riscv.cc:  __ LoadFeedbackVectorFlagsAndJumpIfNeedsProcessing(
builtins/riscv/builtins-riscv.cc:  ResetFeedbackVectorOsrUrgency(masm, feedback_vector, a4);
builtins/riscv/builtins-riscv.cc:                            FeedbackVector::kInvocationCountOffset));
builtins/riscv/builtins-riscv.cc:                            FeedbackVector::kInvocationCountOffset));
builtins/riscv/builtins-riscv.cc:    __ LoadFeedbackVectorFlagsAndJumpIfNeedsProcessing(
builtins/riscv/builtins-riscv.cc:                              WasmTrustedInstanceData::kFeedbackVectorsOffset));
builtins/riscv/builtins-riscv.cc:  __ CallRuntime(Runtime::kWasmAllocateFeedbackVector, 3);
builtins/riscv/builtins-riscv.cc:  static_assert(InterpreterFrameConstants::kFeedbackVectorFromFp ==
builtins/riscv/builtins-riscv.cc:                BaselineFrameConstants::kFeedbackVectorFromFp);
builtins/riscv/builtins-riscv.cc:      MemOperand(fp, InterpreterFrameConstants::kFeedbackVectorFromFp));
builtins/builtins-handler-gen.cc:  void Generate_KeyedStoreIC_SloppyArguments();
builtins/builtins-handler-gen.cc:TF_BUILTIN(LoadIC_StringLength, CodeStubAssembler) {
builtins/builtins-handler-gen.cc:TF_BUILTIN(LoadIC_StringWrapperLength, CodeStubAssembler) {
builtins/builtins-handler-gen.cc:void Builtins::Generate_KeyedStoreIC_Megamorphic(
builtins/builtins-handler-gen.cc:void Builtins::Generate_StoreIC_NoFeedback(
builtins/builtins-handler-gen.cc:  StoreICNoFeedbackGenerator::Generate(state);
builtins/builtins-handler-gen.cc:  auto vector = Parameter<FeedbackVector>(Descriptor::kVector);
builtins/builtins-handler-gen.cc:  TailCallRuntime(Runtime::kElementsTransitionAndStoreIC_Miss, context,
builtins/builtins-handler-gen.cc:  TailCallRuntime(Runtime::kKeyedStoreIC_Miss, context,
builtins/builtins-handler-gen.cc:TF_BUILTIN(LoadIC_FunctionPrototype, CodeStubAssembler) {
builtins/builtins-handler-gen.cc:  auto vector = Parameter<FeedbackVector>(Descriptor::kVector);
builtins/builtins-handler-gen.cc:  TailCallRuntime(Runtime::kLoadIC_Miss, context, receiver, name, slot, vector);
builtins/builtins-handler-gen.cc:  auto vector = Parameter<FeedbackVector>(Descriptor::kVector);
builtins/builtins-handler-gen.cc:TF_BUILTIN(KeyedLoadIC_SloppyArguments, HandlerBuiltinsAssembler) {
builtins/builtins-handler-gen.cc:    TailCallRuntime(Runtime::kKeyedLoadIC_Miss, context, receiver, key, slot,
builtins/builtins-handler-gen.cc:void HandlerBuiltinsAssembler::Generate_KeyedStoreIC_SloppyArguments() {
builtins/builtins-handler-gen.cc:  TailCallRuntime(Runtime::kKeyedStoreIC_Miss, context, value, slot, vector,
builtins/builtins-handler-gen.cc:TF_BUILTIN(KeyedStoreIC_SloppyArguments_InBounds, HandlerBuiltinsAssembler) {
builtins/builtins-handler-gen.cc:  Generate_KeyedStoreIC_SloppyArguments();
builtins/builtins-handler-gen.cc:TF_BUILTIN(KeyedStoreIC_SloppyArguments_NoTransitionGrowAndHandleCOW,
builtins/builtins-handler-gen.cc:  Generate_KeyedStoreIC_SloppyArguments();
builtins/builtins-handler-gen.cc:TF_BUILTIN(KeyedStoreIC_SloppyArguments_NoTransitionIgnoreTypedArrayOOB,
builtins/builtins-handler-gen.cc:  Generate_KeyedStoreIC_SloppyArguments();
builtins/builtins-handler-gen.cc:TF_BUILTIN(KeyedStoreIC_SloppyArguments_NoTransitionHandleCOW,
builtins/builtins-handler-gen.cc:  Generate_KeyedStoreIC_SloppyArguments();
builtins/builtins-handler-gen.cc:  TailCallRuntime(Runtime::kKeyedLoadIC_Miss, context, receiver, key, slot,
wasm/wasm-objects.h:  V(kFeedbackVectorsOffset, kTaggedSize)                                  \
wasm/wasm-objects.h:  V(kFeedbackVectorsOffset, "feedback_vectors")                               \
interpreter/bytecode-array-builder.h:class FeedbackVectorSpec;
interpreter/bytecode-array-builder.h:      FeedbackVectorSpec* feedback_vector_spec = nullptr,
interpreter/bytecode-array-builder.h:  const FeedbackVectorSpec* feedback_vector_spec() const {
interpreter/bytecode-array-builder.h:  FeedbackVectorSpec* feedback_vector_spec_;
builtins/arm/builtins-arm.cc:void ResetFeedbackVectorOsrUrgency(MacroAssembler* masm,
builtins/arm/builtins-arm.cc:          FieldMemOperand(feedback_vector, FeedbackVector::kOsrStateOffset));
builtins/arm/builtins-arm.cc:  __ and_(scratch, scratch, Operand(~FeedbackVector::OsrUrgencyBits::kMask));
builtins/arm/builtins-arm.cc:          FieldMemOperand(feedback_vector, FeedbackVector::kOsrStateOffset));
builtins/arm/builtins-arm.cc:    __ AssertFeedbackVector(feedback_vector, temporary);
builtins/arm/builtins-arm.cc:    __ LoadFeedbackVectorFlagsAndJumpIfNeedsProcessing(
builtins/arm/builtins-arm.cc:    ResetFeedbackVectorOsrUrgency(masm, feedback_vector, temps.Acquire());
builtins/arm/builtins-arm.cc:                           FeedbackVector::kInvocationCountOffset));
builtins/arm/builtins-arm.cc:                           FeedbackVector::kInvocationCountOffset));
builtins/arm/builtins-arm.cc:      __ Assert(eq, AbortReason::kExpectedFeedbackVector);
builtins/arm/builtins-arm.cc:  __ LoadFeedbackVector(feedback_vector, closure, r4, &push_stack_frame);
builtins/arm/builtins-arm.cc:  __ LoadFeedbackVectorFlagsAndJumpIfNeedsProcessing(
builtins/arm/builtins-arm.cc:  ResetFeedbackVectorOsrUrgency(masm, feedback_vector, r4);
builtins/arm/builtins-arm.cc:                             FeedbackVector::kInvocationCountOffset));
builtins/arm/builtins-arm.cc:                             FeedbackVector::kInvocationCountOffset));
builtins/arm/builtins-arm.cc:    __ LoadFeedbackVectorFlagsAndJumpIfNeedsProcessing(
builtins/arm/builtins-arm.cc:                         WasmTrustedInstanceData::kFeedbackVectorsOffset));
builtins/arm/builtins-arm.cc:    __ CallRuntime(Runtime::kWasmAllocateFeedbackVector, 3);
builtins/arm/builtins-arm.cc:  static_assert(InterpreterFrameConstants::kFeedbackVectorFromFp ==
builtins/arm/builtins-arm.cc:                BaselineFrameConstants::kFeedbackVectorFromFp);
builtins/arm/builtins-arm.cc:         MemOperand(fp, InterpreterFrameConstants::kFeedbackVectorFromFp));
deoptimizer/translated-state.h:  Handle<FeedbackVector> feedback_vector_handle_;
deoptimizer/translated-state.h:  Tagged<FeedbackVector> feedback_vector_;
interpreter/interpreter-generator.cc:    TNode<HeapObject> maybe_feedback_vector = LoadFeedbackVector();
interpreter/interpreter-generator.cc:  TNode<HeapObject> maybe_vector = LoadFeedbackVector();
interpreter/interpreter-generator.cc:// Calls the LoadIC at FeedBackVector slot <slot> for <object> and the name at
interpreter/interpreter-generator.cc:  TNode<HeapObject> feedback_vector = LoadFeedbackVector();
interpreter/interpreter-generator.cc:  AccessorAssembler::LazyLoadICParameters params(lazy_context, recv, lazy_name,
interpreter/interpreter-generator.cc:  accessor_asm.LoadIC_BytecodeHandler(&params, &exit_point);
interpreter/interpreter-generator.cc:  TNode<HeapObject> feedback_vector = LoadFeedbackVector();
interpreter/interpreter-generator.cc:// Calls the KeyedLoadIC at FeedBackVector slot <slot> for <object> and the key
interpreter/interpreter-generator.cc:  TNode<HeapObject> feedback_vector = LoadFeedbackVector();
interpreter/interpreter-generator.cc:  var_result = CallBuiltin(Builtin::kKeyedLoadIC, context, object, name, slot,
interpreter/interpreter-generator.cc:// Calls the EnumeratedKeyedLoadIC at FeedBackVector slot <slot> for <object>
interpreter/interpreter-generator.cc:  TNode<HeapObject> feedback_vector = LoadFeedbackVector();
interpreter/interpreter-generator.cc:  var_result = CallBuiltin(Builtin::kEnumeratedKeyedLoadIC, context, object,
interpreter/interpreter-generator.cc:    TNode<HeapObject> maybe_vector = LoadFeedbackVector();
interpreter/interpreter-generator.cc:// Calls the StoreIC at FeedBackVector slot <slot> for <object> and
interpreter/interpreter-generator.cc:  // StoreIC is currently a base class for multiple property store operations
interpreter/interpreter-generator.cc:  // TODO(v8:12548): refactor SetNamedIC as a subclass of StoreIC, which can be
interpreter/interpreter-generator.cc:  SetNamedProperty(Builtin::kStoreIC, NamedPropertyType::kNotOwn);
interpreter/interpreter-generator.cc:// Calls the KeyedStoreIC at FeedbackVector slot <slot> for <object> and
interpreter/interpreter-generator.cc:  TNode<HeapObject> maybe_vector = LoadFeedbackVector();
interpreter/interpreter-generator.cc:  // KeyedStoreIC is currently a base class for multiple keyed property store
interpreter/interpreter-generator.cc:  // TODO(v8:12548): refactor SetKeyedIC as a subclass of KeyedStoreIC, which
interpreter/interpreter-generator.cc:  TNode<Object> result = CallBuiltin(Builtin::kKeyedStoreIC, context, object,
interpreter/interpreter-generator.cc:// Calls the DefineKeyedOwnIC at FeedbackVector slot <slot> for <object> and
interpreter/interpreter-generator.cc:  TNode<HeapObject> maybe_vector = LoadFeedbackVector();
interpreter/interpreter-generator.cc:// Calls the StoreInArrayLiteralIC at FeedbackVector slot <slot> for <array> and
interpreter/interpreter-generator.cc:  TNode<HeapObject> feedback_vector = LoadFeedbackVector();
interpreter/interpreter-generator.cc:  TNode<HeapObject> feedback_vector = LoadFeedbackVector();
interpreter/interpreter-generator.cc:        LoadFeedbackVectorOrUndefinedIfJitless();
interpreter/interpreter-generator.cc:        LoadFeedbackVectorOrUndefinedIfJitless();
interpreter/interpreter-generator.cc:        LoadFeedbackVectorOrUndefinedIfJitless();
interpreter/interpreter-generator.cc:        LoadFeedbackVectorOrUndefinedIfJitless();
interpreter/interpreter-generator.cc:      LoadFeedbackVectorOrUndefinedIfJitless();
interpreter/interpreter-generator.cc:      LoadFeedbackVectorOrUndefinedIfJitless();
interpreter/interpreter-generator.cc:      LoadFeedbackVectorOrUndefinedIfJitless();
interpreter/interpreter-generator.cc:      LoadFeedbackVectorOrUndefinedIfJitless();
interpreter/interpreter-generator.cc:  TNode<HeapObject> maybe_feedback_vector = LoadFeedbackVector();
interpreter/interpreter-generator.cc:    TNode<HeapObject> maybe_feedback_vector = LoadFeedbackVector();
interpreter/interpreter-generator.cc:    TNode<HeapObject> maybe_feedback_vector = LoadFeedbackVector();
interpreter/interpreter-generator.cc:  TNode<HeapObject> maybe_feedback_vector = LoadFeedbackVector();
interpreter/interpreter-generator.cc:        LoadFeedbackVectorOrUndefinedIfJitless();
interpreter/interpreter-generator.cc:          LoadFeedbackVectorOrUndefinedIfJitless();
interpreter/interpreter-generator.cc:  TNode<HeapObject> feedback_vector = LoadFeedbackVector();
interpreter/interpreter-generator.cc:  TNode<HeapObject> maybe_feedback_vector = LoadFeedbackVector();
interpreter/interpreter-generator.cc:  // Load FeedbackVector from Cache.
interpreter/interpreter-generator.cc:  maybe_feedback_vector = LoadFeedbackVector();
interpreter/interpreter-generator.cc:      CodeStubAssembler::LoadFeedbackVector(LoadFunctionClosure(), &ok);
interpreter/interpreter-generator.cc:  TNode<FeedbackVector> feedback_vector = CAST(maybe_feedback_vector.value());
interpreter/interpreter-generator.cc:  static_assert(FeedbackVector::MaybeHasMaglevOsrCodeBit::encode(true) >
interpreter/interpreter-generator.cc:                FeedbackVector::kMaxOsrUrgency);
interpreter/interpreter-generator.cc:  static_assert(FeedbackVector::MaybeHasTurbofanOsrCodeBit::encode(true) >
interpreter/interpreter-generator.cc:                FeedbackVector::kMaxOsrUrgency);
interpreter/interpreter-generator.cc:  TNode<HeapObject> feedback_vector = LoadFeedbackVector();
interpreter/interpreter-generator.cc:  TNode<HeapObject> feedback_vector = LoadFeedbackVector();
interpreter/interpreter-generator.cc:  TNode<HeapObject> maybe_feedback_vector = LoadFeedbackVector();
interpreter/interpreter-generator.cc:  TNode<HeapObject> feedback_vector = LoadFeedbackVector();
interpreter/interpreter-generator.cc:  TNode<HeapObject> maybe_feedback_vector = LoadFeedbackVector();
interpreter/interpreter-generator.cc:  TNode<HeapObject> maybe_feedback_vector = LoadFeedbackVector();
interpreter/interpreter-generator.cc:  TNode<HeapObject> maybe_feedback_vector = LoadFeedbackVector();
interpreter/interpreter-generator.cc:  TNode<HeapObject> maybe_feedback_vector = LoadFeedbackVector();
interpreter/interpreter-generator.cc:  TNode<HeapObject> feedback_vector = LoadFeedbackVector();
wasm/baseline/arm64/liftoff-assembler-arm64-inl.h:  return WasmLiftoffFrameConstants::kFeedbackVectorOffset;
interpreter/bytecode-array-iterator.cc:  return FeedbackVector::ToSlot(index);
builtins/builtins-lazy-gen.cc:    TNode<JSFunction> function, TNode<FeedbackVector> feedback_vector) {
builtins/builtins-lazy-gen.cc:      LoadObjectField<Uint16T>(feedback_vector, FeedbackVector::kFlagsOffset);
builtins/builtins-lazy-gen.cc:      FeedbackVector::FlagMaskForNeedsProcessingCheckFrom(
builtins/builtins-lazy-gen.cc:      IsSetWord32(flags, FeedbackVector::kFlagsTieringStateIsAnyRequested),
builtins/builtins-lazy-gen.cc:    GotoIfNot(IsSetWord32(flags, FeedbackVector::kFlagsLogNextExecution),
builtins/builtins-lazy-gen.cc:        feedback_vector, FeedbackVector::kMaybeOptimizedCodeOffset);
builtins/builtins-lazy-gen.cc:  CSA_DCHECK(this, IsFeedbackVector(feedback_cell_value));
builtins/builtins-lazy-gen.cc:      IsFeedbackVector(feedback_cell_value), |=]() { return sfi_code; },
builtins/builtins-constructor-gen.h:      TNode<FeedbackVector> feedback_vector, TNode<TaggedIndex> slot,
builtins/builtins-constructor-gen.h:  TNode<JSArray> CreateEmptyArrayLiteral(TNode<FeedbackVector> feedback_vector,
builtins/builtins-constructor-gen.h:      TNode<FeedbackVector> feedback_vector, TNode<TaggedIndex> slot,
wasm/baseline/riscv/liftoff-assembler-riscv-inl.h:  return WasmLiftoffFrameConstants::kFeedbackVectorOffset;
interpreter/interpreter-generator-tsa.cc:  LoadFeedbackVectorOrUndefinedIfJitless();
interpreter/control-flow-builders.cc:        &loop_header_, std::min(loop_depth, FeedbackVector::kMaxOsrUrgency - 1),
wasm/baseline/arm/liftoff-assembler-arm-inl.h:  return WasmLiftoffFrameConstants::kFeedbackVectorOffset;
builtins/builtins-array-gen.cc:  auto feedback_vector = Parameter<FeedbackVector>(Descriptor::kFeedbackVector);
builtins/builtins-array-gen.cc:      CAST(LoadFeedbackVectorSlot(feedback_vector, slot));
builtins/builtins-array-gen.cc:  auto feedback_vector = Parameter<FeedbackVector>(Descriptor::kFeedbackVector);
builtins/builtins-array-gen.cc:      CAST(LoadFeedbackVectorSlot(feedback_vector, slot));
wasm/baseline/liftoff-compiler.cc:        __ Fill(vector, WasmLiftoffFrameConstants::kFeedbackVectorOffset,
wasm/baseline/liftoff-compiler.cc:        __ Fill(vector.reg(), WasmLiftoffFrameConstants::kFeedbackVectorOffset,
wasm/baseline/liftoff-compiler.cc:      __ Fill(vector, WasmLiftoffFrameConstants::kFeedbackVectorOffset, kRef);
interpreter/bytecodes.h:  /* Property loads (LoadIC) operations */                                     \
interpreter/bytecodes.h:  /* Propery stores (StoreIC) operations */                                    \
interpreter/interpreter-assembler.h:  // Load the FeedbackVector for the current function. The returned node could
interpreter/interpreter-assembler.h:  TNode<HeapObject> LoadFeedbackVector();
interpreter/interpreter-assembler.h:  TNode<HeapObject> LoadFeedbackVectorOrUndefinedIfJitless() {
interpreter/interpreter-assembler.h:    return LoadFeedbackVector();
interpreter/interpreter-assembler.h:  TNode<Int8T> LoadOsrState(TNode<FeedbackVector> feedback_vector);
interpreter/interpreter-assembler.h:                          TNode<FeedbackVector> feedback_vector,
wasm/baseline/mips64/liftoff-assembler-mips64-inl.h:  return WasmLiftoffFrameConstants::kFeedbackVectorOffset;
profiler/heap-profiler.cc:        if (IsFeedbackVector(heap_obj)) {
profiler/heap-profiler.cc:          Cast<FeedbackVector>(heap_obj)->ClearSlots(isolate());
builtins/ic.tq:    maybeFeedbackVector: Undefined|FeedbackVector, slotId: uintptr): void {
builtins/ic.tq:      maybeTarget, maybeReceiver, context, maybeFeedbackVector, slotId);
builtins/ic.tq:    maybeFeedbackVector: Undefined|FeedbackVector, slotId: uintptr): void {
builtins/ic.tq:      maybeTarget, context, maybeFeedbackVector, slotId);
builtins/ic.tq:    maybeFeedbackVector: Undefined|FeedbackVector, slotId: TaggedIndex,
builtins/ic.tq:      target, newTarget, maybeFeedbackVector, slotId, updateFeedbackMode)
builtins/ic.tq:extern macro LoadFeedbackVectorSlot(FeedbackVector, uintptr): MaybeObject;
builtins/ic.tq:extern macro LoadFeedbackVectorSlot(FeedbackVector, uintptr, constexpr int32):
builtins/ic.tq:extern operator '|]' macro LoadFeedbackVectorSlot(FeedbackVector, intptr):
builtins/ic.tq:extern macro StoreFeedbackVectorSlot(FeedbackVector, uintptr, MaybeObject):
builtins/ic.tq:extern macro StoreFeedbackVectorSlot(
builtins/ic.tq:    FeedbackVector, uintptr, MaybeObject, constexpr WriteBarrierMode,
builtins/ic.tq:extern macro StoreWeakReferenceInFeedbackVector(
builtins/ic.tq:    FeedbackVector, uintptr, HeapObject): MaybeObject;
builtins/ic.tq:extern macro ReportFeedbackUpdate(FeedbackVector, uintptr, constexpr string):
builtins/ic.tq:extern operator '.length_intptr' macro LoadFeedbackVectorLength(FeedbackVector):
wasm/baseline/ia32/liftoff-assembler-ia32-inl.h:  return WasmLiftoffFrameConstants::kFeedbackVectorOffset;
interpreter/bytecode-generator.cc:              feedback_index(feedback_spec()->AddLoadICSlot()));
interpreter/bytecode-generator.cc:                  feedback_index(feedback_spec()->AddLoadICSlot()));
interpreter/bytecode-generator.cc:    FeedbackSlot slot = feedback_spec()->AddStoreICSlot(language_mode());
interpreter/bytecode-generator.cc:      feedback_index(feedback_spec()->AddKeyedLoadICSlot()));
interpreter/bytecode-generator.cc:  FeedbackSlot slot = feedback_spec()->AddKeyedStoreICSlot(language_mode());
interpreter/bytecode-generator.cc:  FeedbackSlot slot = feedback_spec()->AddLoadICSlot();
interpreter/bytecode-generator.cc:      feedback_index(feedback_spec()->AddLoadICSlot()));
interpreter/bytecode-generator.cc:      int length_load_slot = feedback_index(feedback_spec()->AddLoadICSlot());
interpreter/bytecode-generator.cc:      feedback_spec(), feedback_spec()->GetStoreICSlot(LanguageMode::kStrict));
interpreter/bytecode-generator.cc:      FeedbackSlot next_value_load_slot = feedback_spec()->AddLoadICSlot();
interpreter/bytecode-generator.cc:      FeedbackSlot next_done_load_slot = feedback_spec()->AddLoadICSlot();
interpreter/bytecode-generator.cc:  FeedbackSlot slot = GetCachedLoadICSlot(object_expr, name);
interpreter/bytecode-generator.cc:  FeedbackSlot slot = GetCachedStoreICSlot(object_expr, name);
interpreter/bytecode-generator.cc:                  feedback_index(feedback_spec()->AddLoadICSlot()))
interpreter/bytecode-generator.cc:        FeedbackSlot next_value_load_slot = feedback_spec()->AddLoadICSlot();
interpreter/bytecode-generator.cc:        FeedbackSlot next_done_load_slot = feedback_spec()->AddLoadICSlot();
interpreter/bytecode-generator.cc:          value, value_name, feedback_index(feedback_spec()->AddLoadICSlot()));
interpreter/bytecode-generator.cc:          value, feedback_index(feedback_spec()->AddKeyedLoadICSlot()));
interpreter/bytecode-generator.cc:      FeedbackSlot slot = feedback_spec()->AddKeyedStoreICSlot(language_mode());
interpreter/bytecode-generator.cc:      FeedbackSlot slot = feedback_spec()->AddKeyedLoadICSlot();
interpreter/bytecode-generator.cc:          feedback_index(feedback_spec()->AddLoadICSlot()));
interpreter/bytecode-generator.cc:            feedback_index(feedback_spec()->AddLoadICSlot()));
interpreter/bytecode-generator.cc:                          feedback_index(feedback_spec()->AddLoadICSlot()))
interpreter/bytecode-generator.cc:      BuildLoadKeyedProperty(obj, feedback_spec()->AddKeyedLoadICSlot());
interpreter/bytecode-generator.cc:        object, feedback_index(feedback_spec()->AddKeyedLoadICSlot()));
interpreter/bytecode-generator.cc:          feedback_index(feedback_spec()->AddKeyedLoadICSlot());
interpreter/bytecode-generator.cc:          feedback_index(GetCachedLoadICSlot(property->obj(), name)));
interpreter/bytecode-generator.cc:          object, feedback_index(feedback_spec()->AddKeyedLoadICSlot()));
interpreter/bytecode-generator.cc:      FeedbackSlot slot = GetCachedStoreICSlot(property->obj(), name);
interpreter/bytecode-generator.cc:      FeedbackSlot slot = feedback_spec()->AddKeyedStoreICSlot(language_mode());
interpreter/bytecode-generator.cc:        obj, feedback_index(feedback_spec()->AddLoadICSlot()));
interpreter/bytecode-generator.cc:                               feedback_index(feedback_spec()->AddLoadICSlot()))
interpreter/bytecode-generator.cc:          feedback_index(feedback_spec()->AddLoadICSlot());
interpreter/bytecode-generator.cc:                         feedback_index(feedback_spec()->AddLoadICSlot()))
interpreter/bytecode-generator.cc:  FeedbackSlot slot = feedback_spec()->AddLoadICSlot();
interpreter/bytecode-generator.cc:FeedbackVectorSpec* BytecodeGenerator::feedback_spec() {
interpreter/bytecode-generator.cc:  return FeedbackVector::GetIndex(slot);
interpreter/bytecode-generator.cc:FeedbackSlot BytecodeGenerator::GetCachedLoadICSlot(const Expression* expr,
interpreter/bytecode-generator.cc:    return feedback_spec()->AddLoadICSlot();
interpreter/bytecode-generator.cc:    return feedback_spec()->AddLoadICSlot();
interpreter/bytecode-generator.cc:  slot = feedback_spec()->AddLoadICSlot();
interpreter/bytecode-generator.cc:    return feedback_spec()->AddLoadICSlot();
interpreter/bytecode-generator.cc:  slot = feedback_spec()->AddLoadICSlot();
interpreter/bytecode-generator.cc:FeedbackSlot BytecodeGenerator::GetCachedStoreICSlot(const Expression* expr,
interpreter/bytecode-generator.cc:    return feedback_spec()->AddStoreICSlot(language_mode());
interpreter/bytecode-generator.cc:    return feedback_spec()->AddStoreICSlot(language_mode());
interpreter/bytecode-generator.cc:  slot = feedback_spec()->AddStoreICSlot(language_mode());
wasm/baseline/s390/liftoff-assembler-s390-inl.h:  return WasmLiftoffFrameConstants::kFeedbackVectorOffset;
deoptimizer/deoptimizer.h:  void QueueFeedbackVectorForMaterialization(
interpreter/bytecode-register.h:  static constexpr int kFeedbackVectorRegisterIndex =
interpreter/bytecode-register.h:          InterpreterFrameConstants::kFeedbackVectorFromFp);
interpreter/bytecode-register.h:  return Register(kFeedbackVectorRegisterIndex);
interpreter/bytecode-register.h:  return index() == kFeedbackVectorRegisterIndex;
builtins/builtins-number-tsa.cc:  V<FeedbackVector> feedback_vector =
builtins/builtins-number-tsa.cc:      Parameter<FeedbackVector>(Descriptor::kFeedbackVector);
builtins/builtins-number-tsa.cc:  SetFeedbackVector(feedback_vector);
snapshot/startup-serializer.cc:    isolate->SetFeedbackVectorsForProfilingTools(
snapshot/startup-serializer.cc:    isolate_->SetFeedbackVectorsForProfilingTools(
interpreter/control-flow-builders.h:              FeedbackVectorSpec* feedback_vector_spec)
interpreter/control-flow-builders.h:  FeedbackVectorSpec* const feedback_vector_spec_;
builtins/loong64/builtins-loong64.cc:void ResetFeedbackVectorOsrUrgency(MacroAssembler* masm,
builtins/loong64/builtins-loong64.cc:           FieldMemOperand(feedback_vector, FeedbackVector::kOsrStateOffset));
builtins/loong64/builtins-loong64.cc:  __ And(scratch, scratch, Operand(~FeedbackVector::OsrUrgencyBits::kMask));
builtins/loong64/builtins-loong64.cc:          FieldMemOperand(feedback_vector, FeedbackVector::kOsrStateOffset));
builtins/loong64/builtins-loong64.cc:    __ AssertFeedbackVector(feedback_vector, scratch);
builtins/loong64/builtins-loong64.cc:    __ LoadFeedbackVectorFlagsAndJumpIfNeedsProcessing(
builtins/loong64/builtins-loong64.cc:    ResetFeedbackVectorOsrUrgency(masm, feedback_vector, temps.Acquire());
builtins/loong64/builtins-loong64.cc:                            FeedbackVector::kInvocationCountOffset));
builtins/loong64/builtins-loong64.cc:                            FeedbackVector::kInvocationCountOffset));
builtins/loong64/builtins-loong64.cc:      __ AssertFeedbackVector(feedback_vector, invocation_count);
builtins/loong64/builtins-loong64.cc:  __ LoadFeedbackVector(feedback_vector, closure, a5, &push_stack_frame);
builtins/loong64/builtins-loong64.cc:  __ LoadFeedbackVectorFlagsAndJumpIfNeedsProcessing(
builtins/loong64/builtins-loong64.cc:  ResetFeedbackVectorOsrUrgency(masm, feedback_vector, a5);
builtins/loong64/builtins-loong64.cc:                              FeedbackVector::kInvocationCountOffset));
builtins/loong64/builtins-loong64.cc:                              FeedbackVector::kInvocationCountOffset));
builtins/loong64/builtins-loong64.cc:    __ LoadFeedbackVectorFlagsAndJumpIfNeedsProcessing(
builtins/loong64/builtins-loong64.cc:                              WasmTrustedInstanceData::kFeedbackVectorsOffset));
builtins/loong64/builtins-loong64.cc:  __ CallRuntime(Runtime::kWasmAllocateFeedbackVector, 3);
builtins/loong64/builtins-loong64.cc:  static_assert(InterpreterFrameConstants::kFeedbackVectorFromFp ==
builtins/loong64/builtins-loong64.cc:                BaselineFrameConstants::kFeedbackVectorFromFp);
builtins/loong64/builtins-loong64.cc:          MemOperand(fp, InterpreterFrameConstants::kFeedbackVectorFromFp));
profiler/heap-snapshot-generator.h:  void ExtractFeedbackVectorReferences(HeapEntry* entry,
profiler/heap-snapshot-generator.h:                                       Tagged<FeedbackVector> feedback_vector);
snapshot/context-serializer.cc:  if (InstanceTypeChecker::IsFeedbackVector(instance_type)) {
snapshot/context-serializer.cc:    Cast<FeedbackVector>(obj)->ClearSlots(isolate());
interpreter/bytecode-generator.h:  FeedbackSlot GetCachedLoadICSlot(const Expression* expr,
interpreter/bytecode-generator.h:  FeedbackSlot GetCachedStoreICSlot(const Expression* expr,
interpreter/bytecode-generator.h:  inline FeedbackVectorSpec* feedback_spec();
profiler/heap-snapshot-generator.cc:      InstanceTypeChecker::IsFeedbackVector(type) ||
profiler/heap-snapshot-generator.cc:  } else if (IsFeedbackVector(obj)) {
profiler/heap-snapshot-generator.cc:    ExtractFeedbackVectorReferences(entry, Cast<FeedbackVector>(obj));
profiler/heap-snapshot-generator.cc:void V8HeapExplorer::ExtractFeedbackVectorReferences(
profiler/heap-snapshot-generator.cc:    HeapEntry* entry, Tagged<FeedbackVector> feedback_vector) {
profiler/heap-snapshot-generator.cc:                     FeedbackVector::kMaybeOptimizedCodeOffset);
deoptimizer/deoptimizer.cc:  void PushFeedbackVectorForMaterialization(
deoptimizer/deoptimizer.cc:    deoptimizer_->QueueFeedbackVectorForMaterialization(
deoptimizer/deoptimizer.cc:      base_offset - WasmLiftoffFrameConstants::kFeedbackVectorOffset;
deoptimizer/deoptimizer.cc:  frame_writer.PushFeedbackVectorForMaterialization(function_iterator);
deoptimizer/deoptimizer.cc:    CHECK(IsFeedbackVector(feedback_vector));
deoptimizer/deoptimizer.cc:void Deoptimizer::QueueFeedbackVectorForMaterialization(
interpreter/bytecode-array-builder.cc:    FeedbackVectorSpec* feedback_vector_spec,
interpreter/bytecode-array-builder.cc:                FeedbackVector::ToSlot(feedback_slot))),
interpreter/bytecode-array-builder.cc:                FeedbackVector::ToSlot(feedback_slot))),
interpreter/bytecode-array-builder.cc:      feedback_vector_spec()->GetKind(FeedbackVector::ToSlot(feedback_slot)));
interpreter/bytecode-array-builder.cc:                FeedbackVector::ToSlot(feedback_slot))),
interpreter/bytecode-array-builder.cc:                FeedbackVector::ToSlot(feedback_slot))),
interpreter/interpreter-assembler.cc:TNode<HeapObject> InterpreterAssembler::LoadFeedbackVector() {
interpreter/interpreter-assembler.cc:  TNode<HeapObject> maybe_feedback_vector = LoadFeedbackVector();
interpreter/interpreter-assembler.cc:  TNode<HeapObject> maybe_feedback_vector = LoadFeedbackVector();
interpreter/interpreter-assembler.cc:  TNode<FeedbackVector> feedback_vector = CAST(maybe_feedback_vector);
interpreter/interpreter-assembler.cc:      CAST(LoadFeedbackVectorSlot(feedback_vector, slot_id));
interpreter/interpreter-assembler.cc:        HeapConstantNoHole(FeedbackVector::MegamorphicSentinel(isolate())));
interpreter/interpreter-assembler.cc:      StoreWeakReferenceInFeedbackVector(feedback_vector, slot_id,
interpreter/interpreter-assembler.cc:      StoreFeedbackVectorSlot(
interpreter/interpreter-assembler.cc:          HeapConstantNoHole(FeedbackVector::MegamorphicSentinel(isolate())),
interpreter/interpreter-assembler.cc:  TNode<HeapObject> maybe_feedback_vector = LoadFeedbackVector();
interpreter/interpreter-assembler.cc:    TNode<FeedbackVector> feedback_vector) {
interpreter/interpreter-assembler.cc:      LoadObjectField<Int8T>(feedback_vector, FeedbackVector::kOsrStateOffset),
interpreter/interpreter-assembler.cc:    TNode<Context> context, TNode<FeedbackVector> feedback_vector,
interpreter/interpreter-assembler.cc:        LoadFeedbackVectorSlot(feedback_vector, feedback_slot);
interpreter/interpreter-assembler.cc:    StoreFeedbackVectorSlot(feedback_vector, Unsigned(feedback_slot),
interpreter/interpreter-assembler.cc:      static_assert(FeedbackVector::OsrUrgencyBits::kShift == 0);
interpreter/interpreter-assembler.cc:          osr_state, Int32Constant(FeedbackVector::OsrUrgencyBits::kMask));
interpreter/interpreter-assembler.cc:  TNode<HeapObject> maybe_feedback_vector = LoadFeedbackVector();
deoptimizer/translated-state.cc:    feedback_vector_ = FeedbackVector();
deoptimizer/translated-state.cc:      Cast<FeedbackVector>(literal_array->get(iterator->NextOperand()));
deoptimizer/translated-state.cc:    PrintF(trace_file, "  reading FeedbackVector (slot %d)\n",
builtins/builtins-definitions.h:  TFH(KeyedLoadIC_PolymorphicName, LoadWithVector)                             \
builtins/builtins-definitions.h:  TFH(KeyedStoreIC_Megamorphic, StoreWithVector)                               \
builtins/builtins-definitions.h:  TFH(LoadIC_FunctionPrototype, LoadWithVector)                                \
builtins/builtins-definitions.h:  TFH(LoadIC_StringLength, LoadWithVector)                                     \
builtins/builtins-definitions.h:  TFH(LoadIC_StringWrapperLength, LoadWithVector)                              \
builtins/builtins-definitions.h:  TFH(LoadIC_NoFeedback, LoadNoFeedback)                                       \
builtins/builtins-definitions.h:  TFH(StoreIC_NoFeedback, StoreNoFeedback)                                     \
builtins/builtins-definitions.h:  TFH(KeyedLoadIC_SloppyArguments, LoadWithVector)                             \
builtins/builtins-definitions.h:  TFH(KeyedStoreIC_SloppyArguments_InBounds, StoreWithVector)                  \
builtins/builtins-definitions.h:  TFH(KeyedStoreIC_SloppyArguments_NoTransitionGrowAndHandleCOW,               \
builtins/builtins-definitions.h:  TFH(KeyedStoreIC_SloppyArguments_NoTransitionIgnoreTypedArrayOOB,            \
builtins/builtins-definitions.h:  TFH(KeyedStoreIC_SloppyArguments_NoTransitionHandleCOW, StoreWithVector)     \
builtins/builtins-definitions.h:  TFS(CreateArrayFromSlowBoilerplate, NeedsContext::kYes, kFeedbackVector,     \
builtins/builtins-definitions.h:  TFS(CreateObjectFromSlowBoilerplate, NeedsContext::kYes, kFeedbackVector,    \
builtins/builtins-definitions.h:  TFH(LoadIC, LoadWithVector)                                                  \
builtins/builtins-definitions.h:  TFH(LoadIC_Megamorphic, LoadWithVector)                                      \
builtins/builtins-definitions.h:  TFH(LoadIC_Noninlined, LoadWithVector)                                       \
builtins/builtins-definitions.h:  TFH(LoadICTrampoline, Load)                                                  \
builtins/builtins-definitions.h:  TFH(LoadICBaseline, LoadBaseline)                                            \
builtins/builtins-definitions.h:  TFH(LoadICTrampoline_Megamorphic, Load)                                      \
builtins/builtins-definitions.h:  TFH(KeyedLoadIC, KeyedLoadWithVector)                                        \
builtins/builtins-definitions.h:  TFH(EnumeratedKeyedLoadIC, EnumeratedKeyedLoad)                              \
builtins/builtins-definitions.h:  TFH(KeyedLoadIC_Megamorphic, KeyedLoadWithVector)                            \
builtins/builtins-definitions.h:  TFH(KeyedLoadICTrampoline, KeyedLoad)                                        \
builtins/builtins-definitions.h:  TFH(KeyedLoadICBaseline, KeyedLoadBaseline)                                  \
builtins/builtins-definitions.h:  TFH(EnumeratedKeyedLoadICBaseline, EnumeratedKeyedLoadBaseline)              \
builtins/builtins-definitions.h:  TFH(KeyedLoadICTrampoline_Megamorphic, KeyedLoad)                            \
builtins/builtins-definitions.h:  TFH(StoreIC, StoreWithVector)                                                \
builtins/builtins-definitions.h:  TFH(StoreIC_Megamorphic, StoreWithVector)                                    \
builtins/builtins-definitions.h:  TFH(StoreICTrampoline, Store)                                                \
builtins/builtins-definitions.h:  TFH(StoreICTrampoline_Megamorphic, Store)                                    \
builtins/builtins-definitions.h:  TFH(StoreICBaseline, StoreBaseline)                                          \
builtins/builtins-definitions.h:  TFH(KeyedStoreIC, StoreWithVector)                                           \
builtins/builtins-definitions.h:  TFH(KeyedStoreICTrampoline, Store)                                           \
builtins/builtins-definitions.h:  TFH(KeyedStoreICTrampoline_Megamorphic, Store)                               \
builtins/builtins-definitions.h:  TFH(KeyedStoreICBaseline, StoreBaseline)                                     \
builtins/x64/builtins-x64.cc:void ResetFeedbackVectorOsrUrgency(MacroAssembler* masm,
builtins/x64/builtins-x64.cc:          FieldOperand(feedback_vector, FeedbackVector::kOsrStateOffset));
builtins/x64/builtins-x64.cc:  __ andb(scratch, Immediate(~FeedbackVector::OsrUrgencyBits::kMask));
builtins/x64/builtins-x64.cc:  __ movb(FieldOperand(feedback_vector, FeedbackVector::kOsrStateOffset),
builtins/x64/builtins-x64.cc:  __ LoadFeedbackVector(feedback_vector, closure, &push_stack_frame,
builtins/x64/builtins-x64.cc:  __ CheckFeedbackVectorFlagsAndJumpIfNeedsProcessing(
builtins/x64/builtins-x64.cc:  ResetFeedbackVectorOsrUrgency(masm, feedback_vector, kScratchRegister);
builtins/x64/builtins-x64.cc:      FieldOperand(feedback_vector, FeedbackVector::kInvocationCountOffset));
builtins/x64/builtins-x64.cc:    __ CheckFeedbackVectorFlagsAndJumpIfNeedsProcessing(
builtins/x64/builtins-x64.cc:  __ AssertFeedbackVector(feedback_vector, kScratchRegister);
builtins/x64/builtins-x64.cc:  __ CheckFeedbackVectorFlagsAndJumpIfNeedsProcessing(
builtins/x64/builtins-x64.cc:  ResetFeedbackVectorOsrUrgency(masm, feedback_vector, kScratchRegister);
builtins/x64/builtins-x64.cc:      FieldOperand(feedback_vector, FeedbackVector::kInvocationCountOffset));
builtins/x64/builtins-x64.cc:                           WasmTrustedInstanceData::kFeedbackVectorsOffset));
builtins/x64/builtins-x64.cc:  __ CallRuntime(Runtime::kWasmAllocateFeedbackVector, 3);
builtins/x64/builtins-x64.cc:  static_assert(InterpreterFrameConstants::kFeedbackVectorFromFp ==
builtins/x64/builtins-x64.cc:                BaselineFrameConstants::kFeedbackVectorFromFp);
builtins/x64/builtins-x64.cc:  __ movq(MemOperand(rbp, InterpreterFrameConstants::kFeedbackVectorFromFp),
builtins/ppc/builtins-ppc.cc:void ResetFeedbackVectorOsrUrgency(MacroAssembler* masm,
builtins/ppc/builtins-ppc.cc:            FieldMemOperand(feedback_vector, FeedbackVector::kOsrStateOffset),
builtins/ppc/builtins-ppc.cc:      Operand(static_cast<uint8_t>(~FeedbackVector::OsrUrgencyBits::kMask)));
builtins/ppc/builtins-ppc.cc:             FieldMemOperand(feedback_vector, FeedbackVector::kOsrStateOffset),
builtins/ppc/builtins-ppc.cc:  static_assert(InterpreterFrameConstants::kFeedbackVectorFromFp ==
builtins/ppc/builtins-ppc.cc:                BaselineFrameConstants::kFeedbackVectorFromFp);
builtins/ppc/builtins-ppc.cc:              MemOperand(fp, InterpreterFrameConstants::kFeedbackVectorFromFp));
builtins/ppc/builtins-ppc.cc:  __ AssertFeedbackVector(feedback_vector, r11);
builtins/ppc/builtins-ppc.cc:    __ LoadFeedbackVectorFlagsAndJumpIfNeedsProcessing(
builtins/ppc/builtins-ppc.cc:  { ResetFeedbackVectorOsrUrgency(masm, feedback_vector, r11, r0); }
builtins/ppc/builtins-ppc.cc:                               FeedbackVector::kInvocationCountOffset),
builtins/ppc/builtins-ppc.cc:                                FeedbackVector::kInvocationCountOffset),
builtins/ppc/builtins-ppc.cc:      __ Assert(eq, AbortReason::kExpectedFeedbackVector);
builtins/ppc/builtins-ppc.cc:  __ LoadFeedbackVector(feedback_vector, closure, r7, &push_stack_frame);
builtins/ppc/builtins-ppc.cc:  __ LoadFeedbackVectorFlagsAndJumpIfNeedsProcessing(
builtins/ppc/builtins-ppc.cc:  ResetFeedbackVectorOsrUrgency(masm, feedback_vector, ip, r0);
builtins/ppc/builtins-ppc.cc:      FieldMemOperand(feedback_vector, FeedbackVector::kInvocationCountOffset),
builtins/ppc/builtins-ppc.cc:      FieldMemOperand(feedback_vector, FeedbackVector::kInvocationCountOffset),
builtins/ppc/builtins-ppc.cc:    __ LoadFeedbackVectorFlagsAndJumpIfNeedsProcessing(
builtins/ppc/builtins-ppc.cc:                      WasmTrustedInstanceData::kFeedbackVectorsOffset),
builtins/ppc/builtins-ppc.cc:    __ CallRuntime(Runtime::kWasmAllocateFeedbackVector, 3);
wasm/wasm-objects-inl.h:          kFeedbackVectorsOffset)
builtins/builtins-lazy-gen.h:                                      TNode<FeedbackVector> feedback_vector);
wasm/baseline/ppc/liftoff-assembler-ppc-inl.h:  return WasmLiftoffFrameConstants::kFeedbackVectorOffset;
wasm/baseline/loong64/liftoff-assembler-loong64-inl.h:  return WasmLiftoffFrameConstants::kFeedbackVectorOffset;
ic/accessor-assembler.cc:    TNode<TaggedIndex> slot, TNode<FeedbackVector> vector,
ic/accessor-assembler.cc:      FeedbackVector::kRawFeedbackSlotsOffset - kHeapObjectTag;
ic/accessor-assembler.cc:  CSA_DCHECK(this, TaggedEqual(LoadFeedbackVectorSlot(CAST(vector), slot),
ic/accessor-assembler.cc:        LoadFeedbackVectorSlot(CAST(vector), slot, kTaggedSize);
ic/accessor-assembler.cc:void AccessorAssembler::TryEnumeratedKeyedLoad(
ic/accessor-assembler.cc:    const LoadICParameters* p, TNode<Map> lookup_start_object_map,
ic/accessor-assembler.cc:  if (!p->IsEnumeratedKeyedLoad()) return;
ic/accessor-assembler.cc:void AccessorAssembler::HandleLoadICHandlerCase(
ic/accessor-assembler.cc:    const LazyLoadICParameters* p, TNode<MaybeObject> handler, Label* miss,
ic/accessor-assembler.cc:    HandleLoadICProtoHandler(p, CAST(handler), &var_holder, &var_smi_handler,
ic/accessor-assembler.cc:    HandleLoadICSmiHandlerCase(
ic/accessor-assembler.cc:              // LoadIC case: the receiver is definitely not null or undefined.
ic/accessor-assembler.cc:    const LazyLoadICParameters* p, TNode<JSObject> holder,
ic/accessor-assembler.cc:    const LazyLoadICParameters* p,
ic/accessor-assembler.cc:void AccessorAssembler::HandleLoadICSmiHandlerCase(
ic/accessor-assembler.cc:    const LazyLoadICParameters* p, TNode<Object> holder, TNode<Smi> smi_handler,
ic/accessor-assembler.cc:    HandleLoadICSmiHandlerHasNamedCase(p, holder, handler_kind, miss,
ic/accessor-assembler.cc:    HandleLoadICSmiHandlerLoadNamedCase(
ic/accessor-assembler.cc:void AccessorAssembler::HandleLoadICSmiHandlerLoadNamedCase(
ic/accessor-assembler.cc:    const LazyLoadICParameters* p, TNode<Object> holder,
ic/accessor-assembler.cc:void AccessorAssembler::HandleLoadICSmiHandlerHasNamedCase(
ic/accessor-assembler.cc:    const LazyLoadICParameters* p, TNode<Object> holder,
ic/accessor-assembler.cc:void AccessorAssembler::HandleLoadICProtoHandler(
ic/accessor-assembler.cc:    const LazyLoadICParameters* p, TNode<DataHandler> handler,
ic/accessor-assembler.cc:      // Code sub-handlers are not expected in LoadICs, so no |on_code_handler|.
ic/accessor-assembler.cc:void AccessorAssembler::HandleStoreICNativeDataProperty(
ic/accessor-assembler.cc:    const StoreICParameters* p, TNode<HeapObject> holder,
ic/accessor-assembler.cc:void AccessorAssembler::HandleStoreICSmiHandlerJSSharedStructFieldCase(
ic/accessor-assembler.cc:void AccessorAssembler::HandleStoreICHandlerCase(
ic/accessor-assembler.cc:    const StoreICParameters* p, TNode<MaybeObject> handler, Label* miss,
ic/accessor-assembler.cc:      HandleStoreICNativeDataProperty(p, CAST(holder), handler_word);
ic/accessor-assembler.cc:      HandleStoreICSmiHandlerJSSharedStructFieldCase(p->context(), handler_word,
ic/accessor-assembler.cc:      HandleStoreICSmiHandlerCase(handler_word, CAST(holder), p->value(), miss);
ic/accessor-assembler.cc:          id = Runtime::kKeyedStoreIC_Slow;
ic/accessor-assembler.cc:      HandleStoreICProtoHandler(p, CAST(strong_handler), &if_slow, miss,
ic/accessor-assembler.cc:      HandleStoreICTransitionMapHandlerCase(p, map, miss,
ic/accessor-assembler.cc:void AccessorAssembler::HandleStoreICTransitionMapHandlerCase(
ic/accessor-assembler.cc:    const StoreICParameters* p, TNode<Map> transition_map, Label* miss,
ic/accessor-assembler.cc:void AccessorAssembler::HandleStoreICProtoHandler(
ic/accessor-assembler.cc:    const StoreICParameters* p, TNode<StoreHandler> handler, Label* slow,
ic/accessor-assembler.cc:  Comment("HandleStoreICProtoHandler");
ic/accessor-assembler.cc:    // Code sub-handlers are expected only in KeyedStoreICs.
ic/accessor-assembler.cc:    HandleStoreICNativeDataProperty(p, holder, handler_word);
ic/accessor-assembler.cc:void AccessorAssembler::HandleStoreToProxy(const StoreICParameters* p,
ic/accessor-assembler.cc:void AccessorAssembler::HandleStoreICSmiHandlerCase(TNode<Word32T> handler_word,
ic/accessor-assembler.cc:    TNode<Int32T> lookup_start_object_instance_type, const LoadICParameters* p,
ic/accessor-assembler.cc:        LazyLoadICParameters lazy_p(p);
ic/accessor-assembler.cc:        HandleLoadICHandlerCase(&lazy_p, var_handler.value(), &stub_cache_miss,
ic/accessor-assembler.cc:        Comment("KeyedLoadGeneric_miss");
ic/accessor-assembler.cc:        TailCallRuntime(Runtime::kKeyedLoadIC_Miss, p->context(),
ic/accessor-assembler.cc:void AccessorAssembler::LoadIC_BytecodeHandler(const LazyLoadICParameters* p,
ic/accessor-assembler.cc:  // Must be kept in sync with LoadIC.
ic/accessor-assembler.cc:    Comment("LoadIC_BytecodeHandler_fast");
ic/accessor-assembler.cc:    HandleLoadICHandlerCase(p, var_handler.value(), &miss, exit_point);
ic/accessor-assembler.cc:    Comment("LoadIC_BytecodeHandler_noninlined");
ic/accessor-assembler.cc:    // Call into the stub that implements the non-inlined parts of LoadIC.
ic/accessor-assembler.cc:    exit_point->ReturnCallBuiltin(Builtin::kLoadIC_Noninlined, p->context(),
ic/accessor-assembler.cc:    Comment("LoadIC_BytecodeHandler_nofeedback");
ic/accessor-assembler.cc:    // Call into the stub that implements the non-inlined parts of LoadIC.
ic/accessor-assembler.cc:    exit_point->ReturnCallBuiltin(Builtin::kLoadIC_NoFeedback, p->context(),
ic/accessor-assembler.cc:    Comment("LoadIC_BytecodeHandler_miss");
ic/accessor-assembler.cc:    exit_point->ReturnCallRuntime(Runtime::kLoadIC_Miss, p->context(),
ic/accessor-assembler.cc:void AccessorAssembler::LoadIC(const LoadICParameters* p) {
ic/accessor-assembler.cc:  // Must be kept in sync with LoadIC_BytecodeHandler.
ic/accessor-assembler.cc:    LazyLoadICParameters lazy_p(p);
ic/accessor-assembler.cc:    HandleLoadICHandlerCase(&lazy_p, var_handler.value(), &miss, &direct_exit);
ic/accessor-assembler.cc:    Comment("LoadIC_try_polymorphic");
ic/accessor-assembler.cc:    LoadIC_Noninlined(p, lookup_start_object_map, strong_feedback, &var_handler,
ic/accessor-assembler.cc:    Comment("LoadIC_nofeedback");
ic/accessor-assembler.cc:    // Call into the stub that implements the non-inlined parts of LoadIC.
ic/accessor-assembler.cc:    direct_exit.ReturnCallBuiltin(Builtin::kLoadIC_NoFeedback, p->context(),
ic/accessor-assembler.cc:  direct_exit.ReturnCallRuntime(Runtime::kLoadIC_Miss, p->context(),
ic/accessor-assembler.cc:void AccessorAssembler::LoadSuperIC(const LoadICParameters* p) {
ic/accessor-assembler.cc:    LazyLoadICParameters lazy_p(p);
ic/accessor-assembler.cc:    HandleLoadICHandlerCase(&lazy_p, var_handler.value(), &miss, &direct_exit);
ic/accessor-assembler.cc:    // LoadIC_Noninlined can be used here, since it handles the
ic/accessor-assembler.cc:    LoadIC_Noninlined(p, lookup_start_object_map, strong_feedback, &var_handler,
ic/accessor-assembler.cc:void AccessorAssembler::LoadIC_Noninlined(const LoadICParameters* p,
ic/accessor-assembler.cc:void AccessorAssembler::LoadIC_NoFeedback(const LoadICParameters* p,
ic/accessor-assembler.cc:void AccessorAssembler::LoadSuperIC_NoFeedback(const LoadICParameters* p) {
ic/accessor-assembler.cc:      TNode<FeedbackVector> vector = CAST(maybe_feedback_vector);
ic/accessor-assembler.cc:    TNode<FeedbackVector> vector, TNode<TaggedIndex> slot,
ic/accessor-assembler.cc:  TNode<MaybeObject> maybe_weak_ref = LoadFeedbackVectorSlot(vector, slot);
ic/accessor-assembler.cc:    TNode<FeedbackVector> vector, TNode<TaggedIndex> slot,
ic/accessor-assembler.cc:      LoadFeedbackVectorSlot(vector, slot, kTaggedSize);
ic/accessor-assembler.cc:  LazyLoadICParameters p(|=] { return context; }, receiver, lazy_name,
ic/accessor-assembler.cc:  HandleLoadICHandlerCase(&p, handler, miss, exit_point, ICMode::kGlobalIC,
ic/accessor-assembler.cc:  TailCallBuiltin(Builtin::kLoadIC_NoFeedback, context, global_object, name,
ic/accessor-assembler.cc:void AccessorAssembler::KeyedLoadIC(const LoadICParameters* p,
ic/accessor-assembler.cc:  TryEnumeratedKeyedLoad(p, lookup_start_object_map, &direct_exit);
ic/accessor-assembler.cc:    LazyLoadICParameters lazy_p(p);
ic/accessor-assembler.cc:    HandleLoadICHandlerCase(
ic/accessor-assembler.cc:    Comment("KeyedLoadIC_try_polymorphic");
ic/accessor-assembler.cc:    Comment("KeyedLoadIC_try_megamorphic");
ic/accessor-assembler.cc:        access_mode == LoadAccessMode::kLoad ? Builtin::kKeyedLoadIC_Megamorphic
ic/accessor-assembler.cc:    Comment("KeyedLoadIC_try_uninitialized");
ic/accessor-assembler.cc:    Comment("KeyedLoadIC_try_polymorphic_name");
ic/accessor-assembler.cc:                          ? Builtin::kKeyedLoadIC_PolymorphicName
ic/accessor-assembler.cc:    Comment("KeyedLoadIC_miss");
ic/accessor-assembler.cc:        access_mode == LoadAccessMode::kLoad ? Runtime::kKeyedLoadIC_Miss
ic/accessor-assembler.cc:void AccessorAssembler::KeyedLoadICGeneric(const LoadICParameters* p) {
ic/accessor-assembler.cc:      LoadICParameters pp(p, var_unique.value());
ic/accessor-assembler.cc:          LoadICParameters pp(p, var_unique.value());
ic/accessor-assembler.cc:    Comment("KeyedLoadGeneric_slow");
ic/accessor-assembler.cc:void AccessorAssembler::KeyedLoadICPolymorphicName(const LoadICParameters* p,
ic/accessor-assembler.cc:  TNode<FeedbackVector> vector = CAST(p->vector());
ic/accessor-assembler.cc:  // LoadIC handler logic below.
ic/accessor-assembler.cc:  CSA_DCHECK(this, TaggedEqual(name, LoadFeedbackVectorSlot(vector, slot)),
ic/accessor-assembler.cc:      LoadFeedbackVectorSlot(vector, slot, kTaggedSize);
ic/accessor-assembler.cc:    LazyLoadICParameters lazy_p(p);
ic/accessor-assembler.cc:    HandleLoadICHandlerCase(
ic/accessor-assembler.cc:    Comment("KeyedLoadIC_miss");
ic/accessor-assembler.cc:        access_mode == LoadAccessMode::kLoad ? Runtime::kKeyedLoadIC_Miss
ic/accessor-assembler.cc:void AccessorAssembler::StoreIC(const StoreICParameters* p) {
ic/accessor-assembler.cc:    Comment("StoreIC_if_handler");
ic/accessor-assembler.cc:    HandleStoreICHandlerCase(p, var_handler.value(), &miss,
ic/accessor-assembler.cc:    Comment("StoreIC_try_polymorphic");
ic/accessor-assembler.cc:    // TODO(v8:12548): refactor SetNamedIC as a subclass of StoreIC, which can
ic/accessor-assembler.cc:                                         : Builtin::kStoreIC_NoFeedback;
ic/accessor-assembler.cc:                                         : Runtime::kStoreIC_Miss;
ic/accessor-assembler.cc:void AccessorAssembler::StoreGlobalIC(const StoreICParameters* pp) {
ic/accessor-assembler.cc:      LoadFeedbackVectorSlot(CAST(pp->vector()), pp->slot());
ic/accessor-assembler.cc:          LoadFeedbackVectorSlot(CAST(pp->vector()), pp->slot(), kTaggedSize);
ic/accessor-assembler.cc:      StoreICParameters p(
ic/accessor-assembler.cc:          StoreICMode::kDefault);
ic/accessor-assembler.cc:      HandleStoreICHandlerCase(&p, handler, &miss, ICMode::kGlobalIC);
ic/accessor-assembler.cc:void AccessorAssembler::KeyedStoreIC(const StoreICParameters* p) {
ic/accessor-assembler.cc:      Comment("KeyedStoreIC_if_handler");
ic/accessor-assembler.cc:      HandleStoreICHandlerCase(p, var_handler.value(), &miss,
ic/accessor-assembler.cc:      Comment("KeyedStoreIC_try_polymorphic");
ic/accessor-assembler.cc:      Comment("KeyedStoreIC_try_megamorphic");
ic/accessor-assembler.cc:      TailCallBuiltin(Builtin::kKeyedStoreIC_Megamorphic, p->context(),
ic/accessor-assembler.cc:      Comment("KeyedStoreIC_try_polymorphic_name");
ic/accessor-assembler.cc:          LoadFeedbackVectorSlot(CAST(p->vector()), p->slot(), kTaggedSize);
ic/accessor-assembler.cc:    Comment("KeyedStoreIC_miss");
ic/accessor-assembler.cc:    TailCallRuntime(Runtime::kKeyedStoreIC_Miss, p->context(), p->value(),
ic/accessor-assembler.cc:void AccessorAssembler::DefineKeyedOwnIC(const StoreICParameters* p) {
ic/accessor-assembler.cc:      // StoreICParameters flags and have builtins:kDefineKeyedOwnIC reusing
ic/accessor-assembler.cc:      HandleStoreICHandlerCase(p, var_handler.value(), &miss,
ic/accessor-assembler.cc:          LoadFeedbackVectorSlot(CAST(p->vector()), p->slot(), kTaggedSize);
ic/accessor-assembler.cc:void AccessorAssembler::StoreInArrayLiteralIC(const StoreICParameters* p) {
ic/accessor-assembler.cc:      // This is a stripped-down version of HandleStoreICHandlerCase.
ic/accessor-assembler.cc:void AccessorAssembler::GenerateLoadIC() {
ic/accessor-assembler.cc:  LoadICParameters p(context, receiver, name, slot, vector);
ic/accessor-assembler.cc:  LoadIC(&p);
ic/accessor-assembler.cc:void AccessorAssembler::GenerateLoadIC_Megamorphic() {
ic/accessor-assembler.cc:  CSA_DCHECK(this, TaggedEqual(LoadFeedbackVectorSlot(CAST(vector), slot),
ic/accessor-assembler.cc:  LazyLoadICParameters p(
ic/accessor-assembler.cc:  HandleLoadICHandlerCase(&p, var_handler.value(), &miss, &direct_exit);
ic/accessor-assembler.cc:  direct_exit.ReturnCallRuntime(Runtime::kLoadIC_Miss, context, receiver, name,
ic/accessor-assembler.cc:void AccessorAssembler::GenerateLoadIC_Noninlined() {
ic/accessor-assembler.cc:  auto vector = Parameter<FeedbackVector>(Descriptor::kVector);
ic/accessor-assembler.cc:  TNode<MaybeObject> feedback_element = LoadFeedbackVectorSlot(vector, slot);
ic/accessor-assembler.cc:  LoadICParameters p(context, receiver, name, slot, vector);
ic/accessor-assembler.cc:  LoadIC_Noninlined(&p, lookup_start_object_map, feedback, &var_handler,
ic/accessor-assembler.cc:    LazyLoadICParameters lazy_p(&p);
ic/accessor-assembler.cc:    HandleLoadICHandlerCase(&lazy_p, var_handler.value(), &miss, &direct_exit);
ic/accessor-assembler.cc:  direct_exit.ReturnCallRuntime(Runtime::kLoadIC_Miss, context, receiver, name,
ic/accessor-assembler.cc:void AccessorAssembler::GenerateLoadIC_NoFeedback() {
ic/accessor-assembler.cc:  LoadICParameters p(context, receiver, name,
ic/accessor-assembler.cc:  LoadIC_NoFeedback(&p, ic_kind);
ic/accessor-assembler.cc:void AccessorAssembler::GenerateLoadICTrampoline() {
ic/accessor-assembler.cc:  TNode<FeedbackVector> vector = LoadFeedbackVectorForStub();
ic/accessor-assembler.cc:  TailCallBuiltin(Builtin::kLoadIC, context, receiver, name, slot, vector);
ic/accessor-assembler.cc:void AccessorAssembler::GenerateLoadICBaseline() {
ic/accessor-assembler.cc:  TNode<FeedbackVector> vector = LoadFeedbackVectorFromBaseline();
ic/accessor-assembler.cc:  TailCallBuiltin(Builtin::kLoadIC, context, receiver, name, slot, vector);
ic/accessor-assembler.cc:void AccessorAssembler::GenerateLoadICTrampoline_Megamorphic() {
ic/accessor-assembler.cc:  TNode<FeedbackVector> vector = LoadFeedbackVectorForStub();
ic/accessor-assembler.cc:  TailCallBuiltin(Builtin::kLoadIC_Megamorphic, context, receiver, name, slot,
ic/accessor-assembler.cc:  LoadICParameters p(context, receiver, name, slot, vector,
ic/accessor-assembler.cc:  TNode<FeedbackVector> vector = LoadFeedbackVectorFromBaseline();
ic/accessor-assembler.cc:  TNode<FeedbackVector> vector = LoadFeedbackVectorForStub();
ic/accessor-assembler.cc:  TNode<FeedbackVector> vector = LoadFeedbackVectorFromBaseline();
ic/accessor-assembler.cc:    LazyNode<FeedbackVector> lazy_feedback_vector, TypeofMode typeof_mode) {
ic/accessor-assembler.cc:                 |&] { return Parameter<FeedbackVector>(Descriptor::kVector); },
ic/accessor-assembler.cc:                 |&] { return LoadFeedbackVectorForStub(); }, typeof_mode);
ic/accessor-assembler.cc:                 |&] { return LoadFeedbackVectorFromBaseline(); }, typeof_mode);
ic/accessor-assembler.cc:void AccessorAssembler::GenerateKeyedLoadIC() {
ic/accessor-assembler.cc:  using Descriptor = KeyedLoadWithVectorDescriptor;
ic/accessor-assembler.cc:  LoadICParameters p(context, receiver, name, slot, vector);
ic/accessor-assembler.cc:  KeyedLoadIC(&p, LoadAccessMode::kLoad);
ic/accessor-assembler.cc:void AccessorAssembler::GenerateEnumeratedKeyedLoadIC() {
ic/accessor-assembler.cc:  using Descriptor = EnumeratedKeyedLoadDescriptor;
ic/accessor-assembler.cc:  LoadICParameters p(context, receiver, name, slot, vector, lookup_start_object,
ic/accessor-assembler.cc:  KeyedLoadIC(&p, LoadAccessMode::kLoad);
ic/accessor-assembler.cc:void AccessorAssembler::GenerateKeyedLoadIC_Megamorphic() {
ic/accessor-assembler.cc:  using Descriptor = KeyedLoadWithVectorDescriptor;
ic/accessor-assembler.cc:  LoadICParameters p(context, receiver, name, slot, vector);
ic/accessor-assembler.cc:  KeyedLoadICGeneric(&p);
ic/accessor-assembler.cc:void AccessorAssembler::GenerateKeyedLoadICTrampoline() {
ic/accessor-assembler.cc:  using Descriptor = KeyedLoadDescriptor;
ic/accessor-assembler.cc:  TNode<FeedbackVector> vector = LoadFeedbackVectorForStub();
ic/accessor-assembler.cc:  TailCallBuiltin(Builtin::kKeyedLoadIC, context, receiver, name, slot, vector);
ic/accessor-assembler.cc:void AccessorAssembler::GenerateKeyedLoadICBaseline() {
ic/accessor-assembler.cc:  using Descriptor = KeyedLoadBaselineDescriptor;
ic/accessor-assembler.cc:  TNode<FeedbackVector> vector = LoadFeedbackVectorFromBaseline();
ic/accessor-assembler.cc:  TailCallBuiltin(Builtin::kKeyedLoadIC, context, receiver, name, slot, vector);
ic/accessor-assembler.cc:void AccessorAssembler::GenerateEnumeratedKeyedLoadICBaseline() {
ic/accessor-assembler.cc:  using Descriptor = EnumeratedKeyedLoadBaselineDescriptor;
ic/accessor-assembler.cc:  TNode<FeedbackVector> vector = LoadFeedbackVectorFromBaseline();
ic/accessor-assembler.cc:  TailCallBuiltin(Builtin::kEnumeratedKeyedLoadIC, context, receiver, name,
ic/accessor-assembler.cc:void AccessorAssembler::GenerateKeyedLoadICTrampoline_Megamorphic() {
ic/accessor-assembler.cc:  using Descriptor = KeyedLoadDescriptor;
ic/accessor-assembler.cc:  TNode<FeedbackVector> vector = LoadFeedbackVectorForStub();
ic/accessor-assembler.cc:  TailCallBuiltin(Builtin::kKeyedLoadIC_Megamorphic, context, receiver, name,
ic/accessor-assembler.cc:void AccessorAssembler::GenerateKeyedLoadIC_PolymorphicName() {
ic/accessor-assembler.cc:  auto vector = Parameter<FeedbackVector>(Descriptor::kVector);
ic/accessor-assembler.cc:  LoadICParameters p(context, receiver, name, slot, vector);
ic/accessor-assembler.cc:  KeyedLoadICPolymorphicName(&p, LoadAccessMode::kLoad);
ic/accessor-assembler.cc:  StoreICParameters p(context, std::nullopt, name, value, flags, slot, vector,
ic/accessor-assembler.cc:                      StoreICMode::kDefault);
ic/accessor-assembler.cc:  TNode<FeedbackVector> vector = LoadFeedbackVectorForStub();
ic/accessor-assembler.cc:  TNode<FeedbackVector> vector = LoadFeedbackVectorFromBaseline();
ic/accessor-assembler.cc:void AccessorAssembler::GenerateStoreIC() {
ic/accessor-assembler.cc:  StoreICParameters p(context, receiver, name, value, flags, slot, vector,
ic/accessor-assembler.cc:                      StoreICMode::kDefault);
ic/accessor-assembler.cc:  StoreIC(&p);
ic/accessor-assembler.cc:void AccessorAssembler::GenerateStoreIC_Megamorphic() {
ic/accessor-assembler.cc:  CSA_DCHECK(this, TaggedEqual(LoadFeedbackVectorSlot(CAST(vector), slot),
ic/accessor-assembler.cc:    StoreICParameters p(context, receiver, name, value, flags, slot, vector,
ic/accessor-assembler.cc:                        StoreICMode::kDefault);
ic/accessor-assembler.cc:    HandleStoreICHandlerCase(&p, var_handler.value(), &miss,
ic/accessor-assembler.cc:    direct_exit.ReturnCallRuntime(Runtime::kStoreIC_Miss, context, value, slot,
ic/accessor-assembler.cc:void AccessorAssembler::GenerateStoreICTrampoline() {
ic/accessor-assembler.cc:  TNode<FeedbackVector> vector = LoadFeedbackVectorForStub();
ic/accessor-assembler.cc:  TailCallBuiltin(Builtin::kStoreIC, context, receiver, name, value, slot,
ic/accessor-assembler.cc:void AccessorAssembler::GenerateStoreICTrampoline_Megamorphic() {
ic/accessor-assembler.cc:  TNode<FeedbackVector> vector = LoadFeedbackVectorForStub();
ic/accessor-assembler.cc:  TailCallBuiltin(Builtin::kStoreIC_Megamorphic, context, receiver, name, value,
ic/accessor-assembler.cc:void AccessorAssembler::GenerateStoreICBaseline() {
ic/accessor-assembler.cc:  TNode<FeedbackVector> vector = LoadFeedbackVectorFromBaseline();
ic/accessor-assembler.cc:  TailCallBuiltin(Builtin::kStoreIC, context, receiver, name, value, slot,
ic/accessor-assembler.cc:  StoreICParameters p(context, receiver, name, value, flags, slot, vector,
ic/accessor-assembler.cc:                      StoreICMode::kDefineNamedOwn);
ic/accessor-assembler.cc:  // StoreIC is a generic helper than handle both set and define own
ic/accessor-assembler.cc:  StoreIC(&p);
ic/accessor-assembler.cc:  TNode<FeedbackVector> vector = LoadFeedbackVectorForStub();
ic/accessor-assembler.cc:  TNode<FeedbackVector> vector = LoadFeedbackVectorFromBaseline();
ic/accessor-assembler.cc:void AccessorAssembler::GenerateKeyedStoreIC() {
ic/accessor-assembler.cc:  StoreICParameters p(context, receiver, name, value, flags, slot, vector,
ic/accessor-assembler.cc:                      StoreICMode::kDefault);
ic/accessor-assembler.cc:  KeyedStoreIC(&p);
ic/accessor-assembler.cc:void AccessorAssembler::GenerateKeyedStoreICTrampoline() {
ic/accessor-assembler.cc:  TNode<FeedbackVector> vector = LoadFeedbackVectorForStub();
ic/accessor-assembler.cc:  TailCallBuiltin(Builtin::kKeyedStoreIC, context, receiver, name, value, slot,
ic/accessor-assembler.cc:void AccessorAssembler::GenerateKeyedStoreICTrampoline_Megamorphic() {
ic/accessor-assembler.cc:  TNode<FeedbackVector> vector = LoadFeedbackVectorForStub();
ic/accessor-assembler.cc:  TailCallBuiltin(Builtin::kKeyedStoreIC_Megamorphic, context, receiver, name,
ic/accessor-assembler.cc:void AccessorAssembler::GenerateKeyedStoreICBaseline() {
ic/accessor-assembler.cc:  TNode<FeedbackVector> vector = LoadFeedbackVectorFromBaseline();
ic/accessor-assembler.cc:  TailCallBuiltin(Builtin::kKeyedStoreIC, context, receiver, name, value, slot,
ic/accessor-assembler.cc:  StoreICParameters p(context, receiver, name, value, flags, slot, vector,
ic/accessor-assembler.cc:                      StoreICMode::kDefineKeyedOwn);
ic/accessor-assembler.cc:  TNode<FeedbackVector> vector = LoadFeedbackVectorForStub();
ic/accessor-assembler.cc:  TNode<FeedbackVector> vector = LoadFeedbackVectorFromBaseline();
ic/accessor-assembler.cc:  StoreICParameters p(context, array, index, value, flags, slot, vector,
ic/accessor-assembler.cc:                      StoreICMode::kDefault);
ic/accessor-assembler.cc:  TNode<FeedbackVector> vector = LoadFeedbackVectorFromBaseline();
ic/accessor-assembler.cc:  TNode<FeedbackVector> vector = LoadFeedbackVectorFromBaseline();
ic/accessor-assembler.cc:  LoadICParameters p(context, receiver, name, slot, vector);
ic/accessor-assembler.cc:  KeyedLoadIC(&p, LoadAccessMode::kHas);
ic/accessor-assembler.cc:  TNode<FeedbackVector> vector = LoadFeedbackVectorFromBaseline();
ic/accessor-assembler.cc:  // TODO(magardn): implement HasProperty handling in KeyedLoadICGeneric
ic/accessor-assembler.cc:  LoadICParameters p(context, receiver, name, slot, vector);
ic/accessor-assembler.cc:  KeyedLoadICPolymorphicName(&p, LoadAccessMode::kHas);
builtins/builtins-object-gen.cc:  auto feedback_vector = Parameter<HeapObject>(Descriptor::kFeedbackVector);
builtins/builtins-object-gen.cc:  auto feedback_vector = LoadFeedbackVectorFromBaseline();
ic/handler-configuration-inl.h:      return BUILTIN_CODE(isolate, KeyedStoreIC_SloppyArguments_InBounds);
ic/handler-configuration-inl.h:          isolate, KeyedStoreIC_SloppyArguments_NoTransitionGrowAndHandleCOW);
ic/handler-configuration-inl.h:          KeyedStoreIC_SloppyArguments_NoTransitionIgnoreTypedArrayOOB);
ic/handler-configuration-inl.h:                          KeyedStoreIC_SloppyArguments_NoTransitionHandleCOW);
ic/accessor-assembler.h:  void GenerateLoadIC();
ic/accessor-assembler.h:  void GenerateLoadIC_Megamorphic();
ic/accessor-assembler.h:  void GenerateLoadIC_Noninlined();
ic/accessor-assembler.h:  void GenerateLoadIC_NoFeedback();
ic/accessor-assembler.h:  void GenerateLoadICTrampoline();
ic/accessor-assembler.h:  void GenerateLoadICBaseline();
ic/accessor-assembler.h:  void GenerateLoadICTrampoline_Megamorphic();
ic/accessor-assembler.h:  void GenerateKeyedLoadIC();
ic/accessor-assembler.h:  void GenerateEnumeratedKeyedLoadIC();
ic/accessor-assembler.h:  void GenerateKeyedLoadIC_Megamorphic();
ic/accessor-assembler.h:  void GenerateKeyedLoadIC_PolymorphicName();
ic/accessor-assembler.h:  void GenerateKeyedLoadICTrampoline();
ic/accessor-assembler.h:  void GenerateKeyedLoadICBaseline();
ic/accessor-assembler.h:  void GenerateEnumeratedKeyedLoadICBaseline();
ic/accessor-assembler.h:  void GenerateKeyedLoadICTrampoline_Megamorphic();
ic/accessor-assembler.h:  void GenerateStoreIC();
ic/accessor-assembler.h:  void GenerateStoreIC_Megamorphic();
ic/accessor-assembler.h:  void GenerateStoreICTrampoline();
ic/accessor-assembler.h:  void GenerateStoreICTrampoline_Megamorphic();
ic/accessor-assembler.h:  void GenerateStoreICBaseline();
ic/accessor-assembler.h:  void GenerateKeyedStoreIC();
ic/accessor-assembler.h:  void GenerateKeyedStoreICTrampoline();
ic/accessor-assembler.h:  void GenerateKeyedStoreICTrampoline_Megamorphic();
ic/accessor-assembler.h:  void GenerateKeyedStoreICBaseline();
ic/accessor-assembler.h:  struct LoadICParameters {
ic/accessor-assembler.h:    LoadICParameters(
ic/accessor-assembler.h:    LoadICParameters(const LoadICParameters* p, TNode<Object> unique_name)
ic/accessor-assembler.h:    bool IsEnumeratedKeyedLoad() const { return enum_index_ != std::nullopt; }
ic/accessor-assembler.h:  struct LazyLoadICParameters {
ic/accessor-assembler.h:    LazyLoadICParameters(
ic/accessor-assembler.h:    explicit LazyLoadICParameters(const LoadICParameters* p)
ic/accessor-assembler.h:  // Specialized LoadIC for inlined bytecode handler, hand-tuned to omit frame
ic/accessor-assembler.h:  void LoadIC_BytecodeHandler(const LazyLoadICParameters* p,
ic/accessor-assembler.h:  enum class StoreICMode {
ic/accessor-assembler.h:  struct StoreICParameters {
ic/accessor-assembler.h:    StoreICParameters(TNode<Context> context,
ic/accessor-assembler.h:                      StoreICMode mode)
ic/accessor-assembler.h:      return mode_ == StoreICMode::kDefineNamedOwn;
ic/accessor-assembler.h:      return mode_ == StoreICMode::kDefineKeyedOwn;
ic/accessor-assembler.h:    StoreICMode mode_;
ic/accessor-assembler.h:  void HandleStoreICHandlerCase(
ic/accessor-assembler.h:      const StoreICParameters* p, TNode<MaybeObject> handler, Label* miss,
ic/accessor-assembler.h:  void HandleStoreICTransitionMapHandlerCase(const StoreICParameters* p,
ic/accessor-assembler.h:  // LoadIC contains the full LoadIC logic, while LoadIC_Noninlined contains
ic/accessor-assembler.h:  void LoadIC(const LoadICParameters* p);
ic/accessor-assembler.h:  void LoadIC_Noninlined(const LoadICParameters* p,
ic/accessor-assembler.h:  void LoadSuperIC(const LoadICParameters* p);
ic/accessor-assembler.h:  void LoadIC_NoFeedback(const LoadICParameters* p, TNode<Smi> smi_typeof_mode);
ic/accessor-assembler.h:  void LoadSuperIC_NoFeedback(const LoadICParameters* p);
ic/accessor-assembler.h:  void KeyedLoadIC(const LoadICParameters* p, LoadAccessMode access_mode);
ic/accessor-assembler.h:  void KeyedLoadICGeneric(const LoadICParameters* p);
ic/accessor-assembler.h:  void KeyedLoadICPolymorphicName(const LoadICParameters* p,
ic/accessor-assembler.h:  void StoreIC(const StoreICParameters* p);
ic/accessor-assembler.h:  void StoreGlobalIC(const StoreICParameters* p);
ic/accessor-assembler.h:  void KeyedStoreIC(const StoreICParameters* p);
ic/accessor-assembler.h:  void DefineKeyedOwnIC(const StoreICParameters* p);
ic/accessor-assembler.h:  void StoreInArrayLiteralIC(const StoreICParameters* p);
ic/accessor-assembler.h:                      LazyNode<FeedbackVector> lazy_feedback_vector,
ic/accessor-assembler.h:      TNode<TaggedIndex> slot, TNode<FeedbackVector> vector,
ic/accessor-assembler.h:  void TryEnumeratedKeyedLoad(const LoadICParameters* p,
ic/accessor-assembler.h:  // LoadIC implementation.
ic/accessor-assembler.h:  void HandleLoadICHandlerCase(
ic/accessor-assembler.h:      const LazyLoadICParameters* p, TNode<MaybeObject> handler, Label* miss,
ic/accessor-assembler.h:  void HandleLoadICSmiHandlerCase(const LazyLoadICParameters* p,
ic/accessor-assembler.h:  void HandleLoadICProtoHandler(const LazyLoadICParameters* p,
ic/accessor-assembler.h:  void HandleLoadCallbackProperty(const LazyLoadICParameters* p,
ic/accessor-assembler.h:  void HandleLoadAccessor(const LazyLoadICParameters* p,
ic/accessor-assembler.h:  void HandleLoadICSmiHandlerLoadNamedCase(
ic/accessor-assembler.h:      const LazyLoadICParameters* p, TNode<Object> holder,
ic/accessor-assembler.h:  void HandleLoadICSmiHandlerHasNamedCase(const LazyLoadICParameters* p,
ic/accessor-assembler.h:  void LoadGlobalIC_TryPropertyCellCase(TNode<FeedbackVector> vector,
ic/accessor-assembler.h:  void LoadGlobalIC_TryHandlerCase(TNode<FeedbackVector> vector,
ic/accessor-assembler.h:  // StoreIC implementation.
ic/accessor-assembler.h:  void HandleStoreICProtoHandler(const StoreICParameters* p,
ic/accessor-assembler.h:  void HandleStoreICSmiHandlerCase(TNode<Word32T> handler_word,
ic/accessor-assembler.h:  void HandleStoreICSmiHandlerJSSharedStructFieldCase(
ic/accessor-assembler.h:  void HandleStoreICNativeDataProperty(const StoreICParameters* p,
ic/accessor-assembler.h:  void HandleStoreToProxy(const StoreICParameters* p, TNode<JSProxy> proxy,
ic/accessor-assembler.h:  // KeyedLoadIC_Generic implementation.
ic/accessor-assembler.h:                           const LoadICParameters* p, Label* slow,
ic/keyed-store-generic.cc:  // chain to invoke setters. it's used by KeyedStoreIC and StoreIC to
ic/keyed-store-generic.cc:  void StoreIC_NoFeedback();
ic/keyed-store-generic.cc:                                const StoreICParameters* p,
ic/keyed-store-generic.cc:                                const StoreICParameters* p, Label* slow) {
ic/keyed-store-generic.cc:  TNode<Map> FindCandidateStoreICTransitionMapHandler(TNode<Map> map,
ic/keyed-store-generic.cc:void StoreICNoFeedbackGenerator::Generate(compiler::CodeAssemblerState* state) {
ic/keyed-store-generic.cc:  assembler.StoreIC_NoFeedback();
ic/keyed-store-generic.cc:  assembler.StoreIC_NoFeedback();
ic/keyed-store-generic.cc:TNode<Map> KeyedStoreGenericAssembler::FindCandidateStoreICTransitionMapHandler(
ic/keyed-store-generic.cc:    TNode<Uint16T> instance_type, const StoreICParameters* p,
ic/keyed-store-generic.cc:      TNode<Map> transition_map = FindCandidateStoreICTransitionMapHandler(
ic/keyed-store-generic.cc:      HandleStoreICTransitionMapHandlerCase(p, transition_map, slow, flags);
ic/keyed-store-generic.cc:      HandleStoreICHandlerCase(p, var_handler.value(), &stub_cache_miss,
ic/keyed-store-generic.cc:      TailCallRuntime(Runtime::kKeyedStoreIC_Miss, p->context(), p->value(),
ic/keyed-store-generic.cc:    StoreICParameters p(context, receiver, var_unique.value(), value,
ic/keyed-store-generic.cc:                        StoreICMode::kDefault);
ic/keyed-store-generic.cc:void KeyedStoreGenericAssembler::StoreIC_NoFeedback() {
ic/keyed-store-generic.cc:      StoreICParameters p(context, receiver, name, value, std::nullopt, {},
ic/keyed-store-generic.cc:                          IsDefineNamedOwn() ? StoreICMode::kDefineNamedOwn
ic/keyed-store-generic.cc:                                             : StoreICMode::kDefault);
ic/keyed-store-generic.cc:                                      : Runtime::kStoreIC_Miss;
ic/keyed-store-generic.cc:  StoreICParameters p(context, receiver, unique_name, value, std::nullopt, {},
ic/keyed-store-generic.cc:                      UndefinedConstant(), StoreICMode::kDefault);
builtins/cast.tq:macro IsFeedbackVector(o: HeapObject): bool {
builtins/cast.tq:  return Is<FeedbackVector>(o);
ic/ic.h:// IC is the base class for LoadIC, StoreIC, KeyedLoadIC, and KeyedStoreIC.
ic/ic.h:  IC(Isolate* isolate, Handle<FeedbackVector> vector, FeedbackSlot slot,
ic/ic.h:    return IsLoadIC() || IsLoadGlobalIC() || IsKeyedLoadIC();
ic/ic.h:           IsKeyedStoreIC() || IsStoreInArrayLiteralICKind(kind()) ||
ic/ic.h:  static void OnFeedbackChanged(Isolate* isolate, Tagged<FeedbackVector> vector,
ic/ic.h:  bool IsLoadIC() const { return IsLoadICKind(kind_); }
ic/ic.h:  bool IsKeyedLoadIC() const { return IsKeyedLoadICKind(kind_); }
ic/ic.h:  bool IsKeyedStoreIC() const { return IsKeyedStoreICKind(kind_); }
ic/ic.h:    return IsKeyedLoadIC() || IsKeyedStoreIC() || IsStoreInArrayLiteralIC() ||
ic/ic.h:class LoadIC : public IC {
ic/ic.h:  LoadIC(Isolate* isolate, Handle<FeedbackVector> vector, FeedbackSlot slot,
ic/ic.h:class LoadGlobalIC : public LoadIC {
ic/ic.h:  LoadGlobalIC(Isolate* isolate, Handle<FeedbackVector> vector,
ic/ic.h:      : LoadIC(isolate, vector, slot, kind) {}
ic/ic.h:class KeyedLoadIC : public LoadIC {
ic/ic.h:  KeyedLoadIC(Isolate* isolate, Handle<FeedbackVector> vector,
ic/ic.h:      : LoadIC(isolate, vector, slot, kind) {}
ic/ic.h:class StoreIC : public IC {
ic/ic.h:  StoreIC(Isolate* isolate, Handle<FeedbackVector> vector, FeedbackSlot slot,
ic/ic.h:class StoreGlobalIC : public StoreIC {
ic/ic.h:  StoreGlobalIC(Isolate* isolate, Handle<FeedbackVector> vector,
ic/ic.h:      : StoreIC(isolate, vector, slot, kind) {}
ic/ic.h:class KeyedStoreIC : public StoreIC {
ic/ic.h:  KeyedStoreIC(Isolate* isolate, Handle<FeedbackVector> vector,
ic/ic.h:      : StoreIC(isolate, vector, slot, kind) {}
ic/ic.h:class StoreInArrayLiteralIC : public KeyedStoreIC {
ic/ic.h:  StoreInArrayLiteralIC(Isolate* isolate, Handle<FeedbackVector> vector,
ic/ic.h:      : KeyedStoreIC(isolate, vector, slot,
heap/factory.h:  Handle<FeedbackVector> NewFeedbackVector(
common/globals.h:class FeedbackVector;
diagnostics/objects-debug.cc:  CHECK(IsUndefined(v) || IsClosureFeedbackCellArray(v) || IsFeedbackVector(v));
ic/keyed-store-generic.h:class StoreICNoFeedbackGenerator {
builtins/constructor.tq:    Context, Undefined|FeedbackVector, TaggedIndex, ArrayBoilerplateDescription,
builtins/constructor.tq:    Context, Undefined|FeedbackVector, TaggedIndex,
builtins/constructor.tq:    FeedbackVector, TaggedIndex, Context,
builtins/constructor.tq:    FeedbackVector, TaggedIndex, Context): HeapObject;
builtins/constructor.tq:    FeedbackVector, TaggedIndex): HeapObject labels CallRuntime;
builtins/constructor.tq:    implicit context: Context)(maybeFeedbackVector: HeapObject,
builtins/constructor.tq:      maybeFeedbackVector, slot, pattern, flags, context);
builtins/constructor.tq:    implicit context: Context)(maybeFeedbackVector: Undefined|FeedbackVector,
builtins/constructor.tq:    const vector = Cast<FeedbackVector>(maybeFeedbackVector)
builtins/constructor.tq:        context, maybeFeedbackVector, slot, constantElements, flags);
builtins/constructor.tq:    implicit context: Context)(feedbackVector: FeedbackVector,
builtins/constructor.tq:    implicit context: Context)(maybeFeedbackVector: Undefined|FeedbackVector,
builtins/constructor.tq:    const feedbackVector = Cast<FeedbackVector>(maybeFeedbackVector)
builtins/constructor.tq:        context, maybeFeedbackVector, slot, desc, flags);
ic/ic.cc:  } else if (IsKeyedLoadIC()) {
ic/ic.cc:  } else if (IsKeyedStoreIC() || IsStoreInArrayLiteralIC() ||
ic/ic.cc:IC::IC(Isolate* isolate, Handle<FeedbackVector> vector, FeedbackSlot slot,
ic/ic.cc:  Tagged<FeedbackVector> vector = nexus()->vector();
ic/ic.cc:void IC::OnFeedbackChanged(Isolate* isolate, Tagged<FeedbackVector> vector,
ic/ic.cc:    FeedbackVector::TraceFeedbackChange(isolate, vector, slot, reason);
ic/ic.cc:MaybeHandle<Object> LoadIC::Load(Handle<JSAny> object, Handle<Name> name,
ic/ic.cc:      TRACE_HANDLER_STATS(isolate(), LoadIC_NonReceiver);
ic/ic.cc:      TraceIC("LoadIC", name);
ic/ic.cc:                       : TraceIC("LoadIC", name);
ic/ic.cc:  return LoadIC::Load(global, name, update_feedback);
ic/ic.cc:  // TODO(gsathya): Support KeyedLoadIC, StoreIC and KeyedStoreIC.
ic/ic.cc:  if (!IsLoadIC()) return false;
ic/ic.cc:void LoadIC::UpdateCaches(LookupIterator* lookup) {
ic/ic.cc:      TRACE_HANDLER_STATS(isolate(), LoadIC_LoadNonexistentDH);
ic/ic.cc:  TraceIC("LoadIC", lookup->GetName());
ic/ic.cc:MaybeObjectHandle LoadIC::ComputeHandler(LookupIterator* lookup) {
ic/ic.cc:      TRACE_HANDLER_STATS(isolate(), LoadIC_StringLength);
ic/ic.cc:      return MaybeObjectHandle(BUILTIN_CODE(isolate(), LoadIC_StringLength));
ic/ic.cc:      TRACE_HANDLER_STATS(isolate(), LoadIC_StringWrapperLength);
ic/ic.cc:          BUILTIN_CODE(isolate(), LoadIC_StringWrapperLength));
ic/ic.cc:      TRACE_HANDLER_STATS(isolate(), LoadIC_FunctionPrototypeStub);
ic/ic.cc:          BUILTIN_CODE(isolate(), LoadIC_FunctionPrototype));
ic/ic.cc:        TRACE_HANDLER_STATS(isolate(), LoadIC_LoadNonMaskingInterceptorDH);
ic/ic.cc:        TRACE_HANDLER_STATS(isolate(), LoadIC_LoadInterceptorDH);
ic/ic.cc:      TRACE_HANDLER_STATS(isolate(), LoadIC_LoadInterceptorFromPrototypeDH);
ic/ic.cc:        TRACE_HANDLER_STATS(isolate(), LoadIC_LoadFieldDH);
ic/ic.cc:          TRACE_HANDLER_STATS(isolate(), LoadIC_SlowStub);
ic/ic.cc:          TRACE_HANDLER_STATS(isolate(), LoadIC_SlowStub);
ic/ic.cc:            TRACE_HANDLER_STATS(isolate(), LoadIC_SlowStub);
ic/ic.cc:          TRACE_HANDLER_STATS(isolate(), LoadIC_LoadApiGetterFromPrototypeDH);
ic/ic.cc:            TRACE_HANDLER_STATS(isolate(), LoadIC_LoadAccessorDH);
ic/ic.cc:          TRACE_HANDLER_STATS(isolate(), LoadIC_LoadAccessorFromPrototypeDH);
ic/ic.cc:          TRACE_HANDLER_STATS(isolate(), LoadIC_LoadGlobalFromPrototypeDH);
ic/ic.cc:          TRACE_HANDLER_STATS(isolate(), LoadIC_LoadNormalDH);
ic/ic.cc:          TRACE_HANDLER_STATS(isolate(), LoadIC_LoadNormalFromPrototypeDH);
ic/ic.cc:        TRACE_HANDLER_STATS(isolate(), LoadIC_SlowStub);
ic/ic.cc:        TRACE_HANDLER_STATS(isolate(), LoadIC_SlowStub);
ic/ic.cc:      TRACE_HANDLER_STATS(isolate(), LoadIC_LoadNativeDataPropertyDH);
ic/ic.cc:                          LoadIC_LoadNativeDataPropertyFromPrototypeDH);
ic/ic.cc:          TRACE_HANDLER_STATS(isolate(), LoadIC_LoadGlobalDH);
ic/ic.cc:        TRACE_HANDLER_STATS(isolate(), LoadIC_LoadNormalDH);
ic/ic.cc:        TRACE_HANDLER_STATS(isolate(), LoadIC_LoadNormalFromPrototypeDH);
ic/ic.cc:        TRACE_HANDLER_STATS(isolate(), LoadIC_SlowStub);
ic/ic.cc:        TRACE_HANDLER_STATS(isolate(), LoadIC_LoadFieldDH);
ic/ic.cc:        TRACE_HANDLER_STATS(isolate(), LoadIC_LoadFieldFromPrototypeDH);
ic/ic.cc:          TRACE_HANDLER_STATS(isolate(), LoadIC_LoadConstantFromPrototypeDH);
ic/ic.cc:      TRACE_HANDLER_STATS(isolate(), LoadIC_LoadIntegerIndexedExoticDH);
ic/ic.cc:KeyedAccessLoadMode KeyedLoadIC::GetKeyedAccessLoadModeFor(
ic/ic.cc:void KeyedLoadIC::UpdateLoadElement(DirectHandle<HeapObject> receiver,
ic/ic.cc:KeyedAccessLoadMode GetNewKeyedLoadMode(Isolate* isolate,
ic/ic.cc:Handle<Object> KeyedLoadIC::LoadElementHandler(
ic/ic.cc:    TRACE_HANDLER_STATS(isolate(), KeyedLoadIC_LoadIndexedInterceptorStub);
ic/ic.cc:    TRACE_HANDLER_STATS(isolate(), KeyedLoadIC_LoadIndexedStringDH);
ic/ic.cc:    TRACE_HANDLER_STATS(isolate(), KeyedLoadIC_SlowStub);
ic/ic.cc:    TRACE_HANDLER_STATS(isolate(), KeyedLoadIC_SlowStub);
ic/ic.cc:    TRACE_HANDLER_STATS(isolate(), KeyedLoadIC_KeyedLoadSloppyArgumentsStub);
ic/ic.cc:                      : BUILTIN_CODE(isolate(), KeyedLoadIC_SloppyArguments);
ic/ic.cc:    TRACE_HANDLER_STATS(isolate(), KeyedLoadIC_LoadElementDH);
ic/ic.cc:  TRACE_HANDLER_STATS(isolate(), KeyedLoadIC_LoadElementDH);
ic/ic.cc:void KeyedLoadIC::LoadElementPolymorphicHandlers(
ic/ic.cc:MaybeHandle<Object> KeyedLoadIC::RuntimeLoad(DirectHandle<JSAny> object,
ic/ic.cc:  if (IsKeyedLoadIC()) {
ic/ic.cc:MaybeHandle<Object> KeyedLoadIC::LoadName(Handle<JSAny> object,
ic/ic.cc:                             LoadIC::Load(object, name));
ic/ic.cc:    TraceIC("LoadIC", key);
ic/ic.cc:MaybeHandle<Object> KeyedLoadIC::Load(Handle<JSAny> object,
ic/ic.cc:        GetNewKeyedLoadMode(isolate(), receiver, index, is_found);
ic/ic.cc:      TraceIC("LoadIC", key);
ic/ic.cc:    TraceIC("LoadIC", key);
ic/ic.cc:bool StoreIC::LookupForWrite(LookupIterator* it, DirectHandle<Object> value,
ic/ic.cc:  return StoreIC::Store(global, name, value);
ic/ic.cc:MaybeHandle<Object> StoreIC::Store(Handle<JSAny> object, Handle<Name> name,
ic/ic.cc:    // KeyedStoreIC should handle DefineKeyedOwnIC with deprecated maps directly
ic/ic.cc:      TRACE_HANDLER_STATS(isolate(), StoreIC_NonReceiver);
ic/ic.cc:      TraceIC("StoreIC", name);
ic/ic.cc:                      : TraceIC("StoreIC", name);
ic/ic.cc:  // of StoreIC so their logic doesn't get mixed here.
ic/ic.cc:  // IsAnyDefineOwn() can be true when this method is reused by KeyedStoreIC.
ic/ic.cc:void StoreIC::UpdateCaches(LookupIterator* lookup, DirectHandle<Object> value,
ic/ic.cc:  TraceIC("StoreIC", lookup->GetName());
ic/ic.cc:MaybeObjectHandle StoreIC::ComputeHandler(LookupIterator* lookup) {
[Step 6: Duration 4.51 seconds| Input tokens: 56,003 | Output tokens: 1,180]
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ Step 7 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'fuzzy_finder' with arguments: {'pattern': 'elements', 'options': '--filter'}                                                                                            │
╰────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
Command: cd /Users/tarun/v8/v8/src && rg --hidden --no-follow --no-ignore-vcs --files 2>/dev/null | fzf --filter 'elements' | head -n 1000
Observations: objects/elements.h
objects/elements.cc
objects/elements-inl.h
objects/elements-kind.h
objects/elements-kind.cc
builtins/promise-all-element-closure.tq
torque/implementation-visitor.h
torque/implementation-visitor.cc
[Step 7: Duration 5.30 seconds| Input tokens: 102,651 | Output tokens: 1,338]
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ Step 8 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'ripgrep' with arguments: {'pattern':                                                                                                                                    │
│ 'JSArray::SetLength|ElementsAccessor|ElementsKind|TransitionElementsKind|GrowElementsCapacity|TryGrowElementsCapacity|CopyElements', 'options': ''}                                    │
╰────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
Command: cd /Users/tarun/v8/v8/src && rg 'JSArray::SetLength|ElementsAccessor|ElementsKind|TransitionElementsKind|GrowElementsCapacity|TryGrowElementsCapacity|CopyElements' | head -n 1000
Observations: debug/debug-evaluate.cc:  V(TransitionElementsKind)              \
roots/roots.h:enum ElementsKind : uint8_t;
debug/debug.cc:  RegExpMatchInfo::CopyElements(isolate_, *regexp_match_info_, 0,
init/bootstrapper.cc:  FixedArray::CopyElements(isolate, *new_array, 0, cache_, 0, cache_->length());
init/bootstrapper.cc:                                       ElementsKind elements_kind,
init/bootstrapper.cc:  ElementsKind elements_kind;
init/bootstrapper.cc:  ElementsKind kind = current_map->elements_kind();
init/bootstrapper.cc:  DCHECK_EQ(GetInitialFastElementsKind(), kind);
init/bootstrapper.cc:  for (int i = GetSequenceIndexFromFastElementsKind(kind) + 1;
init/bootstrapper.cc:       i < kFastElementsKindCount; ++i) {
init/bootstrapper.cc:    ElementsKind next_kind = GetFastElementsKindFromSequenceIndex(i);
init/bootstrapper.cc:      new_map = Map::CopyAsElementsKind(isolate, current_map, next_kind,
init/bootstrapper.cc:  DCHECK_EQ(global_object_from_snapshot->GetElementsKind(),
init/bootstrapper.cc:            global_object->GetElementsKind());
init/bootstrapper.cc:    DCHECK(initial_map->elements_kind() == GetInitialFastElementsKind());
init/bootstrapper.cc:    DCHECK(IsObjectElementsKind(map->elements_kind()));
init/bootstrapper.cc:    DCHECK(IsObjectElementsKind(map->elements_kind()));
init/bootstrapper.cc:                                              ElementsKind elements_kind,
init/bootstrapper.cc:      Smi::FromInt(1 << ElementsKindToShiftSize(elements_kind)), isolate());
init/bootstrapper.cc:          GetCorrespondingRabGsabElementsKind(elements_kind), 0);
init/bootstrapper.cc:    template_map = Map::CopyAsElementsKind(isolate_, template_map,
init/v8.cc:  ElementsAccessor::InitializeOncePerProcess();
init/v8.cc:  ElementsAccessor::TearDown();
builtins/typed-array-from.tq:        // TypedArrayCopyElements which uses the same ordering as the default
builtins/typed-array-from.tq:            // in TypedArrayCopyElements
builtins/typed-array-from.tq:            // in TypedArrayCopyElements
builtins/typed-array-from.tq:            // code in TypedArrayCopyElements
builtins/typed-array-from.tq:        TypedArrayCopyElements(context, targetObj, finalSource, finalLengthNum);
builtins/wasm.tq:      ElementsKind::PACKED_ELEMENTS, size, AllocationFlag::kNone));
builtins/wasm.tq:  FillEntireFixedArrayWithSmiZero(ElementsKind::PACKED_ELEMENTS, result, size);
builtins/wasm.tq:      ElementsKind::PACKED_ELEMENTS, size, AllocationFlag::kNone));
builtins/wasm.tq:  return AllocateJSArray(ElementsKind::PACKED_ELEMENTS, map, size, size);
builtins/wasm.tq:          ElementsKind::PACKED_ELEMENTS, entries.length_intptr + 2,
builtins/wasm.tq:        ElementsKind::PACKED_ELEMENTS, 4, AllocationFlag::kNone));
builtins/accessors.cc:  if (JSArray::SetLength(array, length).IsNothing()) {
builtins/builtins-string.tq:  const kind = ElementsKind::PACKED_ELEMENTS;
builtins/builtins-internal-gen.cc:  elements = TryGrowElementsCapacity(object, elements, PACKED_DOUBLE_ELEMENTS,
builtins/builtins-internal-gen.cc:      TryGrowElementsCapacity(object, elements, PACKED_ELEMENTS, key, &runtime);
builtins/builtins-typed-array-gen.h:  TNode<BoolT> IsUint8ElementsKind(TNode<Int32T> kind);
builtins/builtins-typed-array-gen.h:  TNode<BoolT> IsBigInt64ElementsKind(TNode<Int32T> kind);
builtins/builtins-typed-array-gen.h:  using TypedArraySwitchCase = std::function<void(ElementsKind, int, int)>;
builtins/builtins-typed-array-gen.h:  void DispatchTypedArrayByElementsKind(
builtins/builtins-typed-array-gen.h:                                           ElementsKind elements_kind);
builtins/builtins-typed-array-gen.h:                                          ElementsKind elements_kind,
builtins/builtins-typed-array-gen.h:      ElementsKind elements_kind, Label* if_detached_or_out_of_bounds);
builtins/array-to-spliced.tq:    implicit context: Context)(kind: constexpr ElementsKind, array: JSArray,
builtins/array-to-spliced.tq:    CopyElements(kind, copy, 0, array.elements, 0, actualStart);
builtins/array-to-spliced.tq:  // it could transition the ElementsKind.
builtins/array-to-spliced.tq:    if constexpr (kind == ElementsKind::PACKED_DOUBLE_ELEMENTS) {
builtins/array-to-spliced.tq:    CopyElements(kind, copy, secondPartStart, array.elements, r, secondPartLen);
builtins/array-to-spliced.tq:  let elementsKind: ElementsKind = array.map.elements_kind;
builtins/array-to-spliced.tq:  if (!IsFastPackedElementsKind(elementsKind)) goto Slow;
builtins/array-to-spliced.tq:  // ElementsKind.
builtins/array-to-spliced.tq:  if (elementsKind == ElementsKind::PACKED_SMI_ELEMENTS) {
builtins/array-to-spliced.tq:        ElementsKind::PACKED_SMI_ELEMENTS, array, newLen, actualStart,
builtins/array-to-spliced.tq:  } else if (elementsKind == ElementsKind::PACKED_ELEMENTS) {
builtins/array-to-spliced.tq:        ElementsKind::PACKED_ELEMENTS, array, newLen, actualStart, insertCount,
builtins/array-to-spliced.tq:    dcheck(elementsKind == ElementsKind::PACKED_DOUBLE_ELEMENTS);
builtins/array-to-spliced.tq:        ElementsKind::PACKED_DOUBLE_ELEMENTS, array, newLen, actualStart,
builtins/array-to-spliced.tq:  elementsKind = TransitionElementsKindForInsertionIfNeeded(
builtins/array-to-spliced.tq:  dcheck(IsFastPackedElementsKind(elementsKind));
builtins/array-to-spliced.tq:  if (IsFastSmiOrTaggedElementsKind(elementsKind)) {
builtins/builtins-regexp-gen.cc:  const ElementsKind elements_kind = PACKED_ELEMENTS;
builtins/builtins-regexp-gen.cc:  const ElementsKind kind = (encoding == String::ONE_BYTE_ENCODING)
builtins/builtins-regexp-gen.cc:  const ElementsKind elements_kind = PACKED_ELEMENTS;
builtins/builtins-object-gen.cc:    CSA_DCHECK(this, Word32BinaryNot(IsElementsKindInRange(
builtins/builtins-object-gen.cc:                         LoadElementsKind(to_map),
builtins/builtins-collections-gen.cc:  TNode<Int32T> elements_kind = LoadElementsKind(fast_jsarray);
builtins/builtins-collections-gen.cc:  Branch(IsFastSmiOrTaggedElementsKind(elements_kind), &if_smiorobjects,
builtins/builtins-collections-gen.cc:  const ElementsKind kind = PACKED_ELEMENTS;
builtins/builtins-collections-gen.cc:  const ElementsKind kind = PACKED_ELEMENTS;
builtins/array-filter.tq:// This method creates a 0-length array with the ElementsKind of the
builtins/array-filter.tq:  return AllocateJSArray(ElementsKind::PACKED_SMI_ELEMENTS, newMap, len, len);
builtins/builtins-array.cc:         !current->GetElementsAccessor()->HasAccessors(current);
builtins/builtins-array.cc:void MatchArrayElementsKindToArguments(Isolate* isolate,
builtins/builtins-array.cc:  ElementsKind origin_kind = array->GetElementsKind();
builtins/builtins-array.cc:  if (IsObjectElementsKind(origin_kind)) return;
builtins/builtins-array.cc:  ElementsKind target_kind = origin_kind;
builtins/builtins-array.cc:    JSObject::TransitionElementsKind(array, target_kind);
builtins/builtins-array.cc:  ElementsKind origin_kind = array->GetElementsKind();
builtins/builtins-array.cc:  if (IsDictionaryElementsKind(origin_kind)) return false;
builtins/builtins-array.cc:  MatchArrayElementsKindToArguments(isolate, array, args, first_arg_index,
builtins/builtins-array.cc:          JSArray::SetLength(array, static_cast<uint32_t>(length)));
builtins/builtins-array.cc:  if (args->length() == 1 && array->GetElementsKind() != PACKED_ELEMENTS) {
builtins/builtins-array.cc:    JSObject::TransitionElementsKind(array, PACKED_ELEMENTS);
builtins/builtins-array.cc:  ElementsAccessor* accessor = array->GetElementsAccessor();
builtins/builtins-array.cc:  ElementsAccessor* accessor = array->GetElementsAccessor();
builtins/builtins-array.cc:        isolate, result, array->GetElementsAccessor()->Pop(array));
builtins/builtins-array.cc:        isolate, set_len_ok, JSArray::SetLength(array, new_length));
builtins/builtins-array.cc:// Returns true, iff we can use ElementsAccessor for shifting.
builtins/builtins-array.cc:                             array->GetElementsAccessor()->Shift(array));
builtins/builtins-array.cc:  DCHECK(!IsDictionaryElementsKind(array->GetElementsKind()));
builtins/builtins-array.cc:  MatchArrayElementsKindToArguments(isolate, array, &args, 1,
builtins/builtins-array.cc:  ElementsAccessor* accessor = array->GetElementsAccessor();
builtins/builtins-array.cc:  switch (array->GetElementsKind()) {
builtins/builtins-array.cc:  ElementsKind kind = object->GetElementsKind();
builtins/builtins-array.cc:      ElementsAccessor* accessor = object->GetElementsAccessor();
builtins/builtins-array.cc:      ElementsAccessor* accessor = object->GetElementsAccessor();
builtins/builtins-array.cc:        SLOW_DCHECK(object->GetElementsAccessor()->HasElement(
builtins/builtins-array.cc:  switch (array->GetElementsKind()) {
builtins/builtins-array.cc:  ElementsKind kind = PACKED_SMI_ELEMENTS;
builtins/builtins-array.cc:        ElementsKind array_kind =
builtins/builtins-array.cc:            GetPackedElementsKind(array->GetElementsKind());
builtins/builtins-array.cc:        if (IsAnyNonextensibleElementsKind(array_kind)) {
builtins/builtins-array.cc:        kind = GetMoreGeneralElementsKind(kind, array_kind);
builtins/builtins-array.cc:        kind = GetMoreGeneralElementsKind(
builtins/builtins-array.cc:          switch (array->GetElementsKind()) {
builtins/builtins-array.cc:  return ElementsAccessor::Concat(isolate, args, n_arguments, result_len);
builtins/array-lastindexof.tq:  const kind: ElementsKind = array.map.elements_kind;
builtins/array-lastindexof.tq:  if (IsFastSmiOrTaggedElementsKind(kind)) {
builtins/array-lastindexof.tq:  dcheck(IsDoubleElementsKind(kind));
builtins/builtins-constructor-gen.cc:  TNode<Int32T> kind = LoadElementsKind(allocation_site.value());
builtins/builtins-constructor-gen.cc:  TNode<JSArray> result = AllocateJSArray(GetInitialFastElementsKind(),
builtins/builtins-string-gen.cc:    const ElementsKind kind = PACKED_ELEMENTS;
builtins/builtins-string-gen.cc:    const ElementsKind kind = PACKED_ELEMENTS;
builtins/builtins-string-gen.cc:  ElementsKind from_kind = from_one_byte ? UINT8_ELEMENTS : UINT16_ELEMENTS;
builtins/builtins-string-gen.cc:  ElementsKind to_kind = to_one_byte ? UINT8_ELEMENTS : UINT16_ELEMENTS;
builtins/builtins-string-gen.cc:  int from_increment = 1 << ElementsKindToShiftSize(from_kind);
builtins/builtins-string-gen.cc:  int to_increment = 1 << ElementsKindToShiftSize(to_kind);
builtins/builtins-sharedarraybuffer-gen.cc:      GetNonRabGsabElementsKind(LoadMapElementsKind(map));
builtins/builtins-typed-array.cc:  ElementsKind kind = array->GetElementsKind();
builtins/builtins-typed-array.cc:  if (IsBigIntTypedArrayElementsKind(kind)) {
builtins/builtins-typed-array.cc:  RETURN_RESULT_OR_FAILURE(isolate, ElementsAccessor::ForKind(kind)->Fill(
builtins/builtins-typed-array.cc:  ElementsAccessor* elements = array->GetElementsAccessor();
builtins/builtins-typed-array.cc:  ElementsAccessor* elements = array->GetElementsAccessor();
builtins/builtins-typed-array.cc:  ElementsAccessor* elements = array->GetElementsAccessor();
builtins/builtins-typed-array.cc:  ElementsAccessor* elements = array->GetElementsAccessor();
builtins/typed-array-slice.tq:  const srcKind: ElementsKind = src.elements_kind;
builtins/typed-array-slice.tq:  if (typed_array::IsBigInt64ElementsKind(src.elements_kind) !=
builtins/typed-array-slice.tq:      typed_array::IsBigInt64ElementsKind(dest.elements_kind))
builtins/builtins-data-view-gen.h:  int32_t DataViewElementSize(ElementsKind elements_kind) {
builtins/builtins-data-view-gen.h:    return ElementsKindToByteSize(elements_kind);
interpreter/interpreter-generator.cc:    TNode<Map> array_map = LoadJSArrayElementsMap(GetInitialFastElementsKind(),
interpreter/interpreter-generator.cc:    result = AllocateJSArray(GetInitialFastElementsKind(), array_map, capacity,
builtins/cast.tq:  const elementsKind: ElementsKind = LoadMapElementsKind(map);
builtins/cast.tq:  if (!IsFastElementsKind(elementsKind)) goto CastError;
builtins/cast.tq:  const elementsKind: ElementsKind = LoadMapElementsKind(map);
builtins/cast.tq:  if (!IsElementsKindLessThanOrEqual(
builtins/cast.tq:          elementsKind, ElementsKind::LAST_ANY_NONEXTENSIBLE_ELEMENTS_KIND))
builtins/array-slice.tq:      LoadJSArrayElementsMap(ElementsKind::HOLEY_ELEMENTS, context);
builtins/array-slice.tq:      AllocateJSArray(ElementsKind::HOLEY_ELEMENTS, arrayMap, count, count);
builtins/array-slice.tq:  CopyElements(
builtins/array-slice.tq:      ElementsKind::PACKED_ELEMENTS, newElements, 0, sourceElements,
builtins/array-slice.tq:      LoadJSArrayElementsMap(ElementsKind::HOLEY_ELEMENTS, context);
builtins/array-slice.tq:      AllocateJSArray(ElementsKind::HOLEY_ELEMENTS, arrayMap, count, count);
builtins/array-slice.tq:  CopyElements(
builtins/array-slice.tq:      ElementsKind::PACKED_ELEMENTS, resultElements, Convert<intptr>(indexOut),
builtins/array-from.tq:          ElementsKind::PACKED_SMI_ELEMENTS, map, capacity, smiLen);
builtins/array-to-reversed.tq:          ElementsKind::PACKED_DOUBLE_ELEMENTS, SmiUntag(length)));
builtins/array-to-reversed.tq:      ElementsKind::PACKED_DOUBLE_ELEMENTS, LoadNativeContext(context));
builtins/array-to-reversed.tq:    implicit context: Context)(kind: constexpr ElementsKind,
builtins/array-to-reversed.tq:  const kind: ElementsKind = array.map.elements_kind;
builtins/array-to-reversed.tq:  if (kind == ElementsKind::PACKED_SMI_ELEMENTS) {
builtins/array-to-reversed.tq:        ElementsKind::PACKED_SMI_ELEMENTS,
builtins/array-to-reversed.tq:  } else if (kind == ElementsKind::PACKED_ELEMENTS) {
builtins/array-to-reversed.tq:        ElementsKind::PACKED_ELEMENTS, UnsafeCast<FixedArray>(array.elements),
builtins/array-to-reversed.tq:  } else if (kind == ElementsKind::PACKED_DOUBLE_ELEMENTS) {
builtins/array-to-reversed.tq:    if (kind == ElementsKind::HOLEY_SMI_ELEMENTS ||
builtins/array-to-reversed.tq:        kind == ElementsKind::HOLEY_ELEMENTS) {
builtins/array-to-reversed.tq:          ElementsKind::PACKED_ELEMENTS, UnsafeCast<FixedArray>(array.elements),
builtins/array-to-reversed.tq:    } else if (kind == ElementsKind::HOLEY_DOUBLE_ELEMENTS) {
builtins/array-to-reversed.tq:          ElementsKind::PACKED_ELEMENTS,
builtins/typed-array.tq:type Uint8Elements extends ElementsKind;
builtins/typed-array.tq:type Int8Elements extends ElementsKind;
builtins/typed-array.tq:type Uint16Elements extends ElementsKind;
builtins/typed-array.tq:type Int16Elements extends ElementsKind;
builtins/typed-array.tq:type Uint32Elements extends ElementsKind;
builtins/typed-array.tq:type Int32Elements extends ElementsKind;
builtins/typed-array.tq:type Float16Elements extends ElementsKind;
builtins/typed-array.tq:type Float32Elements extends ElementsKind;
builtins/typed-array.tq:type Float64Elements extends ElementsKind;
builtins/typed-array.tq:type Uint8ClampedElements extends ElementsKind;
builtins/typed-array.tq:type BigUint64Elements extends ElementsKind;
builtins/typed-array.tq:type BigInt64Elements extends ElementsKind;
builtins/typed-array.tq:type RabGsabUint8Elements extends ElementsKind;
builtins/typed-array.tq:    // ElementsKindToShiftSize).
builtins/typed-array.tq:  kind: ElementsKind;
builtins/typed-array.tq:extern runtime TypedArrayCopyElements(Context, JSTypedArray, Object, Number):
builtins/typed-array.tq:extern macro TypedArrayBuiltinsAssembler::IsUint8ElementsKind(ElementsKind):
builtins/typed-array.tq:extern macro TypedArrayBuiltinsAssembler::IsBigInt64ElementsKind(ElementsKind):
builtins/typed-array.tq:    RawPtr, uintptr, constexpr ElementsKind): Numeric;
builtins/typed-array.tq:    Context, JSTypedArray, uintptr, Numeric, constexpr ElementsKind): void;
builtins/typed-array.tq:    constexpr ElementsKind): void labels IfDetached;
builtins/typed-array.tq:macro GetTypedArrayAccessor<T : type extends ElementsKind>():
builtins/typed-array.tq:macro GetTypedArrayAccessor(elementsKindParam: ElementsKind):
builtins/typed-array.tq:  if (IsElementsKindGreaterThanOrEqual(
builtins/typed-array.tq:          elementsKind, kFirstRabGsabFixedTypedArrayElementsKind)) {
builtins/typed-array.tq:    elementsKind = %RawDownCast<ElementsKind>(
builtins/typed-array.tq:        elementsKind - kFirstRabGsabFixedTypedArrayElementsKind +
builtins/typed-array.tq:        kFirstFixedTypedArrayElementsKind);
builtins/typed-array.tq:  if (IsElementsKindGreaterThan(elementsKind, ElementsKind::UINT32_ELEMENTS)) {
builtins/typed-array.tq:    if (elementsKind == ElementsKind::INT32_ELEMENTS) {
builtins/typed-array.tq:    } else if (elementsKind == ElementsKind::FLOAT16_ELEMENTS) {
builtins/typed-array.tq:    } else if (elementsKind == ElementsKind::FLOAT32_ELEMENTS) {
builtins/typed-array.tq:    } else if (elementsKind == ElementsKind::FLOAT64_ELEMENTS) {
builtins/typed-array.tq:    } else if (elementsKind == ElementsKind::UINT8_CLAMPED_ELEMENTS) {
builtins/typed-array.tq:    } else if (elementsKind == ElementsKind::BIGUINT64_ELEMENTS) {
builtins/typed-array.tq:    } else if (elementsKind == ElementsKind::BIGINT64_ELEMENTS) {
builtins/typed-array.tq:    if (elementsKind == ElementsKind::UINT8_ELEMENTS) {
builtins/typed-array.tq:    } else if (elementsKind == ElementsKind::INT8_ELEMENTS) {
builtins/typed-array.tq:    } else if (elementsKind == ElementsKind::UINT16_ELEMENTS) {
builtins/typed-array.tq:    } else if (elementsKind == ElementsKind::INT16_ELEMENTS) {
builtins/typed-array.tq:    } else if (elementsKind == ElementsKind::UINT32_ELEMENTS) {
builtins/typed-array.tq:macro KindForArrayType<T : type extends ElementsKind>():
builtins/typed-array.tq:    constexpr ElementsKind;
builtins/typed-array.tq:KindForArrayType<Uint8Elements>(): constexpr ElementsKind {
builtins/typed-array.tq:  return ElementsKind::UINT8_ELEMENTS;
builtins/typed-array.tq:KindForArrayType<Int8Elements>(): constexpr ElementsKind {
builtins/typed-array.tq:  return ElementsKind::INT8_ELEMENTS;
builtins/typed-array.tq:KindForArrayType<Uint16Elements>(): constexpr ElementsKind {
builtins/typed-array.tq:  return ElementsKind::UINT16_ELEMENTS;
builtins/typed-array.tq:KindForArrayType<Int16Elements>(): constexpr ElementsKind {
builtins/typed-array.tq:  return ElementsKind::INT16_ELEMENTS;
builtins/typed-array.tq:KindForArrayType<Uint32Elements>(): constexpr ElementsKind {
builtins/typed-array.tq:  return ElementsKind::UINT32_ELEMENTS;
builtins/typed-array.tq:KindForArrayType<Int32Elements>(): constexpr ElementsKind {
builtins/typed-array.tq:  return ElementsKind::INT32_ELEMENTS;
builtins/typed-array.tq:KindForArrayType<Float16Elements>(): constexpr ElementsKind {
builtins/typed-array.tq:  return ElementsKind::FLOAT16_ELEMENTS;
builtins/typed-array.tq:KindForArrayType<Float32Elements>(): constexpr ElementsKind {
builtins/typed-array.tq:  return ElementsKind::FLOAT32_ELEMENTS;
builtins/typed-array.tq:KindForArrayType<Float64Elements>(): constexpr ElementsKind {
builtins/typed-array.tq:  return ElementsKind::FLOAT64_ELEMENTS;
builtins/typed-array.tq:KindForArrayType<Uint8ClampedElements>(): constexpr ElementsKind {
builtins/typed-array.tq:  return ElementsKind::UINT8_CLAMPED_ELEMENTS;
builtins/typed-array.tq:KindForArrayType<BigUint64Elements>(): constexpr ElementsKind {
builtins/typed-array.tq:  return ElementsKind::BIGUINT64_ELEMENTS;
builtins/typed-array.tq:KindForArrayType<BigInt64Elements>(): constexpr ElementsKind {
builtins/typed-array.tq:  return ElementsKind::BIGINT64_ELEMENTS;
builtins/typed-array.tq:builtin LoadTypedElement<T : type extends ElementsKind>(
builtins/typed-array.tq:builtin StoreTypedElementNumeric<T : type extends ElementsKind>(
builtins/typed-array.tq:builtin StoreTypedElementJSAny<T : type extends ElementsKind>(
builtins/array-splice.tq:macro DoCopyElements<FixedArrayType : type extends FixedArrayBase>(
builtins/array-splice.tq:  TorqueCopyElements(
builtins/array-splice.tq:          DoCopyElements(
builtins/array-splice.tq:transitioning macro TransitionElementsKindForInsertionIfNeeded(
builtins/array-splice.tq:    context: Context, a: JSArray, originalElementsKind: ElementsKind,
builtins/array-splice.tq:    args: Arguments, argsStart: constexpr IntegerLiteral): ElementsKind {
builtins/array-splice.tq:  dcheck(a.map.elements_kind == originalElementsKind);
builtins/array-splice.tq:  let elementsKind = originalElementsKind;
builtins/array-splice.tq:    if (IsFastSmiElementsKind(elementsKind)) {
builtins/array-splice.tq:    } else if (IsDoubleElementsKind(elementsKind)) {
builtins/array-splice.tq:  if (elementsKind != originalElementsKind) {
builtins/array-splice.tq:    const smiElementsKind: Smi = Convert<Smi>(Convert<int32>(elementsKind));
builtins/array-splice.tq:    TransitionElementsKindWithKind(context, a, smiElementsKind);
builtins/array-splice.tq:  let elementsKind: ElementsKind = EnsureArrayPushable(map) otherwise Bailout;
builtins/array-splice.tq:  if (!IsFastElementsKind(elementsKind)) goto Bailout;
builtins/array-splice.tq:  elementsKind = TransitionElementsKindForInsertionIfNeeded(
builtins/array-splice.tq:  if (IsFastSmiOrTaggedElementsKind(elementsKind)) {
builtins/data-view.tq:macro MakeDataViewGetterNameString(kind: constexpr ElementsKind): String {
builtins/data-view.tq:  if constexpr (kind == ElementsKind::UINT8_ELEMENTS) {
builtins/data-view.tq:  } else if constexpr (kind == ElementsKind::INT8_ELEMENTS) {
builtins/data-view.tq:  } else if constexpr (kind == ElementsKind::UINT16_ELEMENTS) {
builtins/data-view.tq:  } else if constexpr (kind == ElementsKind::INT16_ELEMENTS) {
builtins/data-view.tq:  } else if constexpr (kind == ElementsKind::UINT32_ELEMENTS) {
builtins/data-view.tq:  } else if constexpr (kind == ElementsKind::INT32_ELEMENTS) {
builtins/data-view.tq:  } else if constexpr (kind == ElementsKind::FLOAT16_ELEMENTS) {
builtins/data-view.tq:  } else if constexpr (kind == ElementsKind::FLOAT32_ELEMENTS) {
builtins/data-view.tq:  } else if constexpr (kind == ElementsKind::FLOAT64_ELEMENTS) {
builtins/data-view.tq:  } else if constexpr (kind == ElementsKind::BIGINT64_ELEMENTS) {
builtins/data-view.tq:  } else if constexpr (kind == ElementsKind::BIGUINT64_ELEMENTS) {
builtins/data-view.tq:macro MakeDataViewSetterNameString(kind: constexpr ElementsKind): String {
builtins/data-view.tq:  if constexpr (kind == ElementsKind::UINT8_ELEMENTS) {
builtins/data-view.tq:  } else if constexpr (kind == ElementsKind::INT8_ELEMENTS) {
builtins/data-view.tq:  } else if constexpr (kind == ElementsKind::UINT16_ELEMENTS) {
builtins/data-view.tq:  } else if constexpr (kind == ElementsKind::INT16_ELEMENTS) {
builtins/data-view.tq:  } else if constexpr (kind == ElementsKind::UINT32_ELEMENTS) {
builtins/data-view.tq:  } else if constexpr (kind == ElementsKind::INT32_ELEMENTS) {
builtins/data-view.tq:  } else if constexpr (kind == ElementsKind::FLOAT16_ELEMENTS) {
builtins/data-view.tq:  } else if constexpr (kind == ElementsKind::FLOAT32_ELEMENTS) {
builtins/data-view.tq:  } else if constexpr (kind == ElementsKind::FLOAT64_ELEMENTS) {
builtins/data-view.tq:  } else if constexpr (kind == ElementsKind::BIGINT64_ELEMENTS) {
builtins/data-view.tq:  } else if constexpr (kind == ElementsKind::BIGUINT64_ELEMENTS) {
builtins/data-view.tq:    kind: constexpr ElementsKind): Number {
builtins/data-view.tq:  if constexpr (kind == ElementsKind::INT32_ELEMENTS) {
builtins/data-view.tq:  } else if constexpr (kind == ElementsKind::UINT32_ELEMENTS) {
builtins/data-view.tq:  } else if constexpr (kind == ElementsKind::FLOAT32_ELEMENTS) {
builtins/data-view.tq:    constexpr ElementsKind): constexpr int31;
builtins/data-view.tq:    requestedLittleEndian: JSAny, kind: constexpr ElementsKind): Numeric {
builtins/data-view.tq:    if constexpr (kind == ElementsKind::UINT8_ELEMENTS) {
builtins/data-view.tq:    } else if constexpr (kind == ElementsKind::INT8_ELEMENTS) {
builtins/data-view.tq:    } else if constexpr (kind == ElementsKind::UINT16_ELEMENTS) {
builtins/data-view.tq:    } else if constexpr (kind == ElementsKind::INT16_ELEMENTS) {
builtins/data-view.tq:    } else if constexpr (kind == ElementsKind::UINT32_ELEMENTS) {
builtins/data-view.tq:    } else if constexpr (kind == ElementsKind::INT32_ELEMENTS) {
builtins/data-view.tq:    } else if constexpr (kind == ElementsKind::FLOAT16_ELEMENTS) {
builtins/data-view.tq:    } else if constexpr (kind == ElementsKind::FLOAT32_ELEMENTS) {
builtins/data-view.tq:    } else if constexpr (kind == ElementsKind::FLOAT64_ELEMENTS) {
builtins/data-view.tq:    } else if constexpr (kind == ElementsKind::BIGUINT64_ELEMENTS) {
builtins/data-view.tq:    } else if constexpr (kind == ElementsKind::BIGINT64_ELEMENTS) {
builtins/data-view.tq:      context, receiver, offset, Undefined, ElementsKind::UINT8_ELEMENTS);
builtins/data-view.tq:      context, receiver, offset, Undefined, ElementsKind::INT8_ELEMENTS);
builtins/data-view.tq:      context, receiver, offset, isLittleEndian, ElementsKind::UINT16_ELEMENTS);
builtins/data-view.tq:      context, receiver, offset, isLittleEndian, ElementsKind::INT16_ELEMENTS);
builtins/data-view.tq:      context, receiver, offset, isLittleEndian, ElementsKind::UINT32_ELEMENTS);
builtins/data-view.tq:      context, receiver, offset, isLittleEndian, ElementsKind::INT32_ELEMENTS);
builtins/data-view.tq:      ElementsKind::FLOAT16_ELEMENTS);
builtins/data-view.tq:      ElementsKind::FLOAT32_ELEMENTS);
builtins/data-view.tq:      ElementsKind::FLOAT64_ELEMENTS);
builtins/data-view.tq:      ElementsKind::BIGUINT64_ELEMENTS);
builtins/data-view.tq:      ElementsKind::BIGINT64_ELEMENTS);
builtins/data-view.tq:    requestedLittleEndian: JSAny, kind: constexpr ElementsKind): JSAny {
builtins/data-view.tq:        kind == ElementsKind::BIGUINT64_ELEMENTS ||
builtins/data-view.tq:        kind == ElementsKind::BIGINT64_ELEMENTS) {
builtins/data-view.tq:        kind == ElementsKind::BIGUINT64_ELEMENTS ||
builtins/data-view.tq:        kind == ElementsKind::BIGINT64_ELEMENTS) {
builtins/data-view.tq:          kind == ElementsKind::UINT8_ELEMENTS ||
builtins/data-view.tq:          kind == ElementsKind::INT8_ELEMENTS) {
builtins/data-view.tq:          kind == ElementsKind::UINT16_ELEMENTS ||
builtins/data-view.tq:          kind == ElementsKind::INT16_ELEMENTS) {
builtins/data-view.tq:      } else if constexpr (kind == ElementsKind::FLOAT16_ELEMENTS) {
builtins/data-view.tq:          kind == ElementsKind::UINT32_ELEMENTS ||
builtins/data-view.tq:          kind == ElementsKind::INT32_ELEMENTS) {
builtins/data-view.tq:      } else if constexpr (kind == ElementsKind::FLOAT32_ELEMENTS) {
builtins/data-view.tq:      } else if constexpr (kind == ElementsKind::FLOAT64_ELEMENTS) {
builtins/data-view.tq:      ElementsKind::UINT8_ELEMENTS);
builtins/data-view.tq:      context, receiver, offset, value, Undefined, ElementsKind::INT8_ELEMENTS);
builtins/data-view.tq:      ElementsKind::UINT16_ELEMENTS);
builtins/data-view.tq:      ElementsKind::INT16_ELEMENTS);
builtins/data-view.tq:      ElementsKind::UINT32_ELEMENTS);
builtins/data-view.tq:      ElementsKind::INT32_ELEMENTS);
builtins/data-view.tq:      ElementsKind::FLOAT16_ELEMENTS);
builtins/data-view.tq:      ElementsKind::FLOAT32_ELEMENTS);
builtins/data-view.tq:      ElementsKind::FLOAT64_ELEMENTS);
builtins/data-view.tq:      ElementsKind::BIGUINT64_ELEMENTS);
builtins/data-view.tq:      ElementsKind::BIGINT64_ELEMENTS);
builtins/builtins-handler-gen.cc:  using ElementsKindSwitchCase = std::function<void(ElementsKind)>;
builtins/builtins-handler-gen.cc:  void DispatchByElementsKind(TNode<Int32T> elements_kind,
builtins/builtins-handler-gen.cc:                              const ElementsKindSwitchCase& case_function,
builtins/builtins-handler-gen.cc:  using ElementsKindTransitionSwitchCase =
builtins/builtins-handler-gen.cc:      std::function<void(ElementsKind, ElementsKind)>;
builtins/builtins-handler-gen.cc:  void DispatchForElementsKindTransition(
builtins/builtins-handler-gen.cc:      const ElementsKindTransitionSwitchCase& case_function);
builtins/builtins-handler-gen.cc:void HandlerBuiltinsAssembler::DispatchForElementsKindTransition(
builtins/builtins-handler-gen.cc:    const ElementsKindTransitionSwitchCase& case_function) {
builtins/builtins-handler-gen.cc:  static_assert(sizeof(ElementsKind) == sizeof(uint8_t));
builtins/builtins-handler-gen.cc:    DispatchForElementsKindTransition(
builtins/builtins-handler-gen.cc:        LoadElementsKind(receiver), LoadMapElementsKind(map),
builtins/builtins-handler-gen.cc:        |=, this, &miss](ElementsKind from_kind, ElementsKind to_kind) {
builtins/builtins-handler-gen.cc:          TransitionElementsKind(receiver, map, from_kind, to_kind, &miss);
builtins/builtins-handler-gen.cc:void HandlerBuiltinsAssembler::DispatchByElementsKind(
builtins/builtins-handler-gen.cc:    TNode<Int32T> elements_kind, const ElementsKindSwitchCase& case_function,
builtins/builtins-handler-gen.cc:        IsAnyNonextensibleElementsKindUnchecked(KIND)) {            \
builtins/builtins-handler-gen.cc:               IsTypedArrayOrRabGsabTypedArrayElementsKind(KIND)) { \
builtins/builtins-handler-gen.cc:  DispatchByElementsKind(
builtins/builtins-handler-gen.cc:      LoadElementsKind(receiver),
builtins/builtins-handler-gen.cc:      |=, this, &miss, &maybe_converted_value](ElementsKind elements_kind) {
builtins/builtins-call-gen.cc:    TNode<Int32T> kind = LoadMapElementsKind(arguments_list_map);
builtins/builtins-call-gen.cc:        IsElementsKindGreaterThan(kind, LAST_ANY_NONEXTENSIBLE_ELEMENTS_KIND),
builtins/builtins-call-gen.cc:  const ElementsKind new_kind = PACKED_ELEMENTS;
builtins/builtins-call-gen.cc:    TNode<Int32T> spread_kind = LoadMapElementsKind(spread_map);
builtins/builtins-call-gen.cc:    GotoIf(IsElementsKindLessThanOrEqual(spread_kind, HOLEY_ELEMENTS),
builtins/builtins-call-gen.cc:    GotoIf(IsElementsKindLessThanOrEqual(spread_kind, LAST_FAST_ELEMENTS_KIND),
builtins/builtins-call-gen.cc:    Branch(IsElementsKindLessThanOrEqual(spread_kind,
builtins/builtins-call-gen.cc:    var_elements_kind = LoadElementsKind(list);
builtins/typed-array-filter.tq:    // TypedArrayCopyElements() to avoid JSArray materialization. Or collect
builtins/typed-array-filter.tq:    TypedArrayCopyElements(context, typedArray, kept.ToJSArray(), lengthNumber);
builtins/array-reverse.tq:  const kind: ElementsKind = array.map.elements_kind;
builtins/array-reverse.tq:  if (kind == ElementsKind::PACKED_SMI_ELEMENTS ||
builtins/array-reverse.tq:      kind == ElementsKind::PACKED_ELEMENTS) {
builtins/array-reverse.tq:  } else if (kind == ElementsKind::PACKED_DOUBLE_ELEMENTS) {
builtins/array-reverse.tq:    if (kind == ElementsKind::HOLEY_SMI_ELEMENTS ||
builtins/array-reverse.tq:        kind == ElementsKind::HOLEY_ELEMENTS) {
builtins/array-reverse.tq:    } else if (kind == ElementsKind::HOLEY_DOUBLE_ELEMENTS) {
builtins/growable-fixed-array.tq:        LoadJSArrayElementsMap(ElementsKind::PACKED_ELEMENTS, nativeContext);
builtins/builtins-array-gen.h:                           ElementsKind elements_kind, AllocationSiteMode mode);
builtins/builtins-array-gen.h:  void GenerateArrayNoArgumentConstructor(ElementsKind kind,
builtins/builtins-array-gen.h:  void GenerateArraySingleArgumentConstructor(ElementsKind kind,
builtins/builtins-array-gen.h:  ElementsKind source_elements_kind_ = ElementsKind::NO_ELEMENTS;
builtins/typed-array-with.tq:    if (IsBigInt64ElementsKind(array.elements_kind)) {
builtins/typed-array-createtypedarray.tq:        goto IfElementsKindMismatch(src.elements_kind);
builtins/typed-array-createtypedarray.tq:    } label IfElementsKindMismatch(srcKind: ElementsKind) deferred {
builtins/typed-array-createtypedarray.tq:      if (IsBigInt64ElementsKind(srcKind) !=
builtins/typed-array-createtypedarray.tq:          IsBigInt64ElementsKind(elementsInfo.kind)) {
builtins/typed-array-createtypedarray.tq:        TypedArrayCopyElements(
builtins/typed-array-createtypedarray.tq:  // ElementsKind). GSAB-backed non-length-tracking TypedArrays behave just like
builtins/typed-array-createtypedarray.tq:      GetNonRabGsabElementsKind(exemplar.elements_kind) ==
builtins/growable-fixed-array-gen.cc:  const ElementsKind kind = PACKED_ELEMENTS;
builtins/typed-array-set.tq:    if (IsBigInt64ElementsKind(target.elements_kind)) goto IfSlow;
builtins/typed-array-set.tq:    const srcKind: ElementsKind = fastSrc.map.elements_kind;
builtins/typed-array-set.tq:    if (IsElementsKindInRange(
builtins/typed-array-set.tq:            srcKind, ElementsKind::PACKED_SMI_ELEMENTS,
builtins/typed-array-set.tq:            ElementsKind::HOLEY_SMI_ELEMENTS) ||
builtins/typed-array-set.tq:        IsElementsKindInRange(
builtins/typed-array-set.tq:            srcKind, ElementsKind::PACKED_DOUBLE_ELEMENTS,
builtins/typed-array-set.tq:            ElementsKind::HOLEY_DOUBLE_ELEMENTS)) {
builtins/typed-array-set.tq:  const srcKind: ElementsKind = source.elements_kind;
builtins/typed-array-set.tq:      if (!IsUint8ElementsKind(srcKind) ||
builtins/typed-array-set.tq:          !IsUint8ElementsKind(targetElementsInfo.kind)) {
builtins/typed-array-set.tq:    if (IsBigInt64ElementsKind(srcKind) !=
builtins/typed-array-set.tq:        IsBigInt64ElementsKind(targetElementsInfo.kind))
builtins/builtins-typed-array-gen.cc:TNode<BoolT> TypedArrayBuiltinsAssembler::IsUint8ElementsKind(
builtins/builtins-typed-array-gen.cc:TNode<BoolT> TypedArrayBuiltinsAssembler::IsBigInt64ElementsKind(
builtins/builtins-typed-array-gen.cc:      IsElementsKindInRange(kind, BIGUINT64_ELEMENTS, BIGINT64_ELEMENTS),
builtins/builtins-typed-array-gen.cc:      IsElementsKindInRange(kind, RAB_GSAB_BIGUINT64_ELEMENTS,
builtins/builtins-typed-array-gen.cc:  DispatchTypedArrayByElementsKind(
builtins/builtins-typed-array-gen.cc:      |&](ElementsKind el_kind, int size, int typed_array_fun_index) {
builtins/builtins-typed-array-gen.cc:  TNode<Int32T> elements_kind = LoadMapElementsKind(map);
builtins/builtins-typed-array-gen.cc:  DispatchTypedArrayByElementsKind(
builtins/builtins-typed-array-gen.cc:      |&](ElementsKind kind, int size, int typed_array_fun_index) {
builtins/builtins-typed-array-gen.cc:        var_size_log2 = UintPtrConstant(ElementsKindToShiftSize(kind));
builtins/builtins-typed-array-gen.cc:  TNode<Int32T> elements_kind = LoadElementsKind(exemplar);
builtins/builtins-typed-array-gen.cc:  DispatchTypedArrayByElementsKind(
builtins/builtins-typed-array-gen.cc:      |&](ElementsKind el_kind, int size, int typed_array_function_index) {
builtins/builtins-typed-array-gen.cc:             Word32BinaryNot(IsBigInt64ElementsKind(LoadElementsKind(dest))));
builtins/builtins-typed-array-gen.cc:void TypedArrayBuiltinsAssembler::DispatchTypedArrayByElementsKind(
builtins/builtins-typed-array-gen.cc:    TNode<UintPtrT> index, TNode<Numeric> value, ElementsKind elements_kind) {
builtins/builtins-typed-array-gen.cc:    ElementsKind elements_kind, Label* if_detached_or_out_of_bounds) {
builtins/builtins-typed-array-gen.cc:    TNode<UintPtrT> index, TNode<Object> value, ElementsKind elements_kind,
builtins/builtins-typed-array-gen.cc:  size_t const kTypedElementsKindCount =
builtins/builtins-typed-array-gen.cc:  Label* elements_kind_labels|kTypedElementsKindCount] = {
builtins/builtins-typed-array-gen.cc:  // TAs have distinct ElementsKinds internally, they have the same "class"
builtins/builtins-typed-array-gen.cc:  int32_t elements_kinds|kTypedElementsKindCount] = {
builtins/builtins-typed-array-gen.cc:  // ElementsKind values are contiguous.
builtins/builtins-typed-array-gen.cc:      Int32Sub(LoadElementsKind(receiver_heap_object),
builtins/builtins-typed-array-gen.cc:         kTypedElementsKindCount);
builtins/base.tq:extern enum ElementsKind extends int32 {
builtins/base.tq:const kFirstFixedTypedArrayElementsKind: constexpr ElementsKind =
builtins/base.tq:    ElementsKind::UINT8_ELEMENTS;
builtins/base.tq:const kFirstRabGsabFixedTypedArrayElementsKind: constexpr ElementsKind =
builtins/base.tq:    ElementsKind::RAB_GSAB_UINT8_ELEMENTS;
builtins/base.tq:const kMaxCopyElements:
builtins/base.tq:    constexpr int31 generates 'JSArray::kMaxCopyElements';
builtins/base.tq:    constexpr ElementsKind, FastJSArray, JSAny): void labels Bailout;
builtins/base.tq:extern macro EnsureArrayPushable(implicit context: Context)(Map): ElementsKind
builtins/base.tq:extern transitioning runtime TransitionElementsKindWithKind(
builtins/base.tq:extern operator '==' macro ElementsKindEqual(
builtins/base.tq:    constexpr ElementsKind, constexpr ElementsKind): constexpr bool;
builtins/base.tq:extern operator '==' macro ElementsKindEqual(ElementsKind, ElementsKind): bool;
builtins/base.tq:operator '!=' macro ElementsKindNotEqual(
builtins/base.tq:    k1: ElementsKind, k2: ElementsKind): bool {
builtins/base.tq:  return !ElementsKindEqual(k1, k2);
builtins/base.tq:extern macro IsElementsKindLessThanOrEqual(
builtins/base.tq:    ElementsKind, constexpr ElementsKind): bool;
builtins/base.tq:extern macro IsElementsKindGreaterThan(
builtins/base.tq:    ElementsKind, constexpr ElementsKind): bool;
builtins/base.tq:extern macro IsElementsKindGreaterThanOrEqual(
builtins/base.tq:    ElementsKind, constexpr ElementsKind): bool;
builtins/base.tq:extern macro IsElementsKindInRange(
builtins/base.tq:    ElementsKind, constexpr ElementsKind, constexpr ElementsKind): bool;
builtins/base.tq:extern macro IsFastElementsKind(constexpr ElementsKind): constexpr bool;
builtins/base.tq:extern macro IsFastPackedElementsKind(constexpr ElementsKind): constexpr bool;
builtins/base.tq:extern macro IsDoubleElementsKind(constexpr ElementsKind): constexpr bool;
builtins/base.tq:extern macro GetNonRabGsabElementsKind(ElementsKind): ElementsKind;
builtins/base.tq:    constexpr ElementsKind, NativeContext): Map;
builtins/base.tq:extern macro LoadJSArrayElementsMap(ElementsKind, NativeContext): Map;
builtins/base.tq:extern operator '.elements_kind' macro LoadMapElementsKind(Map): ElementsKind;
builtins/base.tq:extern operator '.elements_kind' macro LoadElementsKind(JSTypedArray):
builtins/base.tq:    ElementsKind;
builtins/base.tq:extern macro IsFastElementsKind(ElementsKind): bool;
builtins/base.tq:extern macro IsFastPackedElementsKind(ElementsKind): bool;
builtins/base.tq:extern macro IsDoubleElementsKind(ElementsKind): bool;
builtins/base.tq:extern macro IsFastSmiOrTaggedElementsKind(ElementsKind): bool;
builtins/base.tq:extern macro IsFastSmiElementsKind(ElementsKind): bool;
builtins/base.tq:extern macro IsHoleyFastElementsKind(ElementsKind): bool;
builtins/base.tq:macro FastHoleyElementsKind(kind: ElementsKind): ElementsKind {
builtins/base.tq:  if (kind == ElementsKind::PACKED_SMI_ELEMENTS) {
builtins/base.tq:    return ElementsKind::HOLEY_SMI_ELEMENTS;
builtins/base.tq:  } else if (kind == ElementsKind::PACKED_DOUBLE_ELEMENTS) {
builtins/base.tq:    return ElementsKind::HOLEY_DOUBLE_ELEMENTS;
builtins/base.tq:  dcheck(kind == ElementsKind::PACKED_ELEMENTS);
builtins/base.tq:  return ElementsKind::HOLEY_ELEMENTS;
builtins/base.tq:macro AllowDoubleElements(kind: ElementsKind): ElementsKind {
builtins/base.tq:  if (kind == ElementsKind::PACKED_SMI_ELEMENTS) {
builtins/base.tq:    return ElementsKind::PACKED_DOUBLE_ELEMENTS;
builtins/base.tq:  } else if (kind == ElementsKind::HOLEY_SMI_ELEMENTS) {
builtins/base.tq:    return ElementsKind::HOLEY_DOUBLE_ELEMENTS;
builtins/base.tq:macro AllowNonNumberElements(kind: ElementsKind): ElementsKind {
builtins/base.tq:  if (kind == ElementsKind::PACKED_SMI_ELEMENTS) {
builtins/base.tq:    return ElementsKind::PACKED_ELEMENTS;
builtins/base.tq:  } else if (kind == ElementsKind::HOLEY_SMI_ELEMENTS) {
builtins/base.tq:    return ElementsKind::HOLEY_ELEMENTS;
builtins/base.tq:  } else if (kind == ElementsKind::PACKED_DOUBLE_ELEMENTS) {
builtins/base.tq:    return ElementsKind::PACKED_ELEMENTS;
builtins/base.tq:  } else if (kind == ElementsKind::HOLEY_DOUBLE_ELEMENTS) {
builtins/base.tq:    return ElementsKind::HOLEY_ELEMENTS;
builtins/base.tq:extern macro TransitionElementsKind(
builtins/base.tq:    JSObject, Map, constexpr ElementsKind,
builtins/base.tq:    constexpr ElementsKind): void labels Bailout;
builtins/base.tq:      if (IsFastSmiElementsKind(kind)) {
builtins/base.tq:        BuildAppendJSArray(ElementsKind::HOLEY_SMI_ELEMENTS, array, value)
builtins/base.tq:      } else if (IsDoubleElementsKind(kind)) {
builtins/base.tq:        BuildAppendJSArray(ElementsKind::HOLEY_DOUBLE_ELEMENTS, array, value)
builtins/base.tq:        dcheck(IsFastSmiOrTaggedElementsKind(kind));
builtins/base.tq:        BuildAppendJSArray(ElementsKind::HOLEY_ELEMENTS, array, value)
builtins/base.tq:      if (IsFastSmiElementsKind(kind)) {
builtins/base.tq:      } else if (IsDoubleElementsKind(kind)) {
builtins/base.tq:        dcheck(IsFastSmiOrTaggedElementsKind(kind));
builtins/builtins-array-gen.cc:      Word32Equal(LoadElementsKind(original_array), LoadElementsKind(a));
builtins/builtins-array-gen.cc:  if (IsBigIntTypedArrayElementsKind(source_elements_kind_)) {
builtins/builtins-array-gen.cc:  TNode<Int32T> elements_kind = LoadMapElementsKind(typed_array_map);
builtins/builtins-array-gen.cc:    source_elements_kind_ = static_cast<ElementsKind>(elements_kinds|i]);
builtins/builtins-array-gen.cc:  ElementsKind effective_elements_kind = source_elements_kind_;
builtins/builtins-array-gen.cc:  bool is_rab_gsab = IsRabGsabTypedArrayElementsKind(effective_elements_kind);
builtins/builtins-array-gen.cc:        GetCorrespondingNonRabGsabElementsKind(effective_elements_kind);
builtins/builtins-array-gen.cc:    //    implemented in elements.cc:ElementsAccessorBase::SetLengthImpl.
builtins/builtins-array-gen.cc:    TNode<Int32T> elements_kind = LoadElementsKind(array_receiver);
builtins/builtins-array-gen.cc:    GotoIf(IsElementsKindGreaterThan(kind, HOLEY_SMI_ELEMENTS),
builtins/builtins-array-gen.cc:    TNode<Int32T> elements_kind = LoadElementsKind(array_receiver);
builtins/builtins-array-gen.cc:    Branch(IsElementsKindGreaterThan(kind, HOLEY_ELEMENTS), &double_push,
builtins/builtins-array-gen.cc:    TNode<Int32T> elements_kind = LoadElementsKind(array_receiver);
builtins/builtins-array-gen.cc:             Word32Or(Word32BinaryNot(IsHoleyFastElementsKindForRead(
builtins/builtins-array-gen.cc:                          LoadElementsKind(array))),
builtins/builtins-array-gen.cc:// - If there are no holes in the source, its ElementsKind will be preserved. In
builtins/builtins-array-gen.cc:// - If there are holes in the source, the ElementsKind of the "copy" will be
builtins/builtins-array-gen.cc:             Word32Or(Word32BinaryNot(IsHoleyFastElementsKindForRead(
builtins/builtins-array-gen.cc:                          LoadElementsKind(array))),
builtins/builtins-array-gen.cc:  TNode<Int32T> elements_kind = LoadElementsKind(array);
builtins/builtins-array-gen.cc:  GotoIf(IsElementsKindLessThanOrEqual(elements_kind, HOLEY_SMI_ELEMENTS),
builtins/builtins-array-gen.cc:  GotoIf(IsElementsKindLessThanOrEqual(elements_kind, HOLEY_ELEMENTS),
builtins/builtins-array-gen.cc:      ElementsKindEqual(elements_kind, Int32Constant(PACKED_DOUBLE_ELEMENTS)),
builtins/builtins-array-gen.cc:  GotoIf(ElementsKindEqual(elements_kind, Int32Constant(HOLEY_DOUBLE_ELEMENTS)),
builtins/builtins-array-gen.cc:  GotoIf(IsElementsKindLessThanOrEqual(elements_kind,
builtins/builtins-array-gen.cc:    TNode<Int32T> elements_kind = LoadMapElementsKind(array_map);
builtins/builtins-array-gen.cc:    TNode<Int32T> elements_kind = LoadMapElementsKind(array_map);
builtins/builtins-array-gen.cc:        isolate(), GetInitialFastElementsKind(), mode);
builtins/builtins-array-gen.cc:    TNode<Int32T> elements_kind = LoadElementsKind(*allocation_site);
builtins/builtins-array-gen.cc:        GetSequenceIndexFromFastElementsKind(TERMINAL_FAST_ELEMENTS_KIND);
builtins/builtins-array-gen.cc:      ElementsKind kind = GetFastElementsKindFromSequenceIndex(i);
builtins/builtins-array-gen.cc:    Abort(AbortReason::kUnexpectedElementsKindInArrayConstructor);
builtins/builtins-array-gen.cc:    ElementsKind initial = GetInitialFastElementsKind();
builtins/builtins-array-gen.cc:    ElementsKind holey_initial = GetHoleyElementsKind(initial);
builtins/builtins-array-gen.cc:              Signed(DecodeWord32<AllocationSite::ElementsKindBits>(
builtins/builtins-array-gen.cc:        AllocationSite::ElementsKindBits::encode(static_cast<ElementsKind>(1));
builtins/builtins-array-gen.cc:        GetSequenceIndexFromFastElementsKind(TERMINAL_FAST_ELEMENTS_KIND);
builtins/builtins-array-gen.cc:      ElementsKind kind = GetFastElementsKindFromSequenceIndex(i);
builtins/builtins-array-gen.cc:    Abort(AbortReason::kUnexpectedElementsKindInArrayConstructor);
builtins/builtins-array-gen.cc:    TNode<HeapObject> allocation_site, ElementsKind elements_kind,
builtins/builtins-array-gen.cc:    if (IsFastPackedElementsKind(elements_kind)) {
builtins/builtins-array-gen.cc:    ElementsKind kind, AllocationSiteOverrideMode mode) {
builtins/builtins-array-gen.cc:    ElementsKind kind, AllocationSiteOverrideMode mode) {
builtins/builtins-array-gen.cc:  TNode<Int32T> elements_kind = LoadElementsKind(boilerplate);
builtins/builtins-array-gen.cc:  TNode<Int32T> elements_kind = LoadElementsKind(boilerplate);
builtins/builtins-array-gen.cc:    TNode<Int32T> elements_kind = LoadElementsKind(object);
builtins/array-map.tq:    let kind: ElementsKind = ElementsKind::PACKED_SMI_ELEMENTS;
builtins/array-map.tq:        kind = ElementsKind::PACKED_DOUBLE_ELEMENTS;
builtins/array-map.tq:        kind = ElementsKind::PACKED_ELEMENTS;
builtins/array-map.tq:      kind = FastHoleyElementsKind(kind);
builtins/array-map.tq:    if (IsDoubleElementsKind(kind)) {
builtins/array-join.tq:transitioning builtin LoadJoinElement<T : type extends ElementsKind>(
builtins/array-join.tq:builtin LoadJoinTypedElement<T : type extends ElementsKind>(
builtins/array-join.tq:// (see LoadJoinElement<ElementsAccessor>).
builtins/array-join.tq:  if (loadFn == LoadJoinElement<array::GenericElementsAccessor>) return false;
builtins/array-join.tq:        loadFn = LoadJoinElement<array::GenericElementsAccessor>;
builtins/array-join.tq:  const kind: ElementsKind = map.elements_kind;
builtins/array-join.tq:    if (IsElementsKindLessThanOrEqual(kind, ElementsKind::HOLEY_ELEMENTS)) {
builtins/array-join.tq:    } else if (IsElementsKindLessThanOrEqual(
builtins/array-join.tq:                   kind, ElementsKind::HOLEY_DOUBLE_ELEMENTS)) {
builtins/array-join.tq:    } else if (kind == ElementsKind::DICTIONARY_ELEMENTS)
builtins/array-join.tq:    loadFn = LoadJoinElement<array::GenericElementsAccessor>;
builtins/array-join.tq:  const kind: ElementsKind = map.elements_kind;
builtins/array-join.tq:  if (IsElementsKindGreaterThan(kind, ElementsKind::UINT32_ELEMENTS)) {
builtins/array-join.tq:    if (kind == ElementsKind::INT32_ELEMENTS) {
builtins/array-join.tq:    } else if (kind == ElementsKind::FLOAT16_ELEMENTS) {
builtins/array-join.tq:    } else if (kind == ElementsKind::FLOAT32_ELEMENTS) {
builtins/array-join.tq:    } else if (kind == ElementsKind::FLOAT64_ELEMENTS) {
builtins/array-join.tq:    } else if (kind == ElementsKind::UINT8_CLAMPED_ELEMENTS) {
builtins/array-join.tq:    } else if (kind == ElementsKind::BIGUINT64_ELEMENTS) {
builtins/array-join.tq:    } else if (kind == ElementsKind::BIGINT64_ELEMENTS) {
builtins/array-join.tq:    } else if (kind == ElementsKind::RAB_GSAB_UINT8_ELEMENTS) {
builtins/array-join.tq:    } else if (kind == ElementsKind::RAB_GSAB_INT8_ELEMENTS) {
builtins/array-join.tq:    } else if (kind == ElementsKind::RAB_GSAB_UINT16_ELEMENTS) {
builtins/array-join.tq:    } else if (kind == ElementsKind::RAB_GSAB_INT16_ELEMENTS) {
builtins/array-join.tq:    } else if (kind == ElementsKind::RAB_GSAB_UINT32_ELEMENTS) {
builtins/array-join.tq:    } else if (kind == ElementsKind::RAB_GSAB_INT32_ELEMENTS) {
builtins/array-join.tq:    } else if (kind == ElementsKind::RAB_GSAB_FLOAT16_ELEMENTS) {
builtins/array-join.tq:    } else if (kind == ElementsKind::RAB_GSAB_FLOAT32_ELEMENTS) {
builtins/array-join.tq:    } else if (kind == ElementsKind::RAB_GSAB_FLOAT64_ELEMENTS) {
builtins/array-join.tq:    } else if (kind == ElementsKind::RAB_GSAB_UINT8_CLAMPED_ELEMENTS) {
builtins/array-join.tq:    } else if (kind == ElementsKind::RAB_GSAB_BIGUINT64_ELEMENTS) {
builtins/array-join.tq:    } else if (kind == ElementsKind::RAB_GSAB_BIGINT64_ELEMENTS) {
builtins/array-join.tq:    if (kind == ElementsKind::UINT8_ELEMENTS) {
builtins/array-join.tq:    } else if (kind == ElementsKind::INT8_ELEMENTS) {
builtins/array-join.tq:    } else if (kind == ElementsKind::UINT16_ELEMENTS) {
builtins/array-join.tq:    } else if (kind == ElementsKind::INT16_ELEMENTS) {
builtins/array-join.tq:    } else if (kind == ElementsKind::UINT32_ELEMENTS) {
builtins/array-with.tq:  if (IsFastPackedElementsKind(array.map.elements_kind)) {
builtins/array-to-sorted.tq:    elementsKind: constexpr ElementsKind, numberOfNonUndefined: Smi): JSArray {
builtins/array-to-sorted.tq:      elementsKind == ElementsKind::PACKED_SMI_ELEMENTS ||
builtins/array-to-sorted.tq:      elementsKind == ElementsKind::PACKED_ELEMENTS);
builtins/array-to-sorted.tq:  CopyElements(
builtins/array-to-sorted.tq:      elementsKind == ElementsKind::PACKED_ELEMENTS);
builtins/array-to-sorted.tq:          ElementsKind::PACKED_SMI_ELEMENTS, numberOfNonUndefined);
builtins/array-to-sorted.tq:          ElementsKind::PACKED_ELEMENTS, numberOfNonUndefined);
builtins/array-shift.tq:  // implemented in elements.cc:ElementsAccessorBase::SetLengthImpl.
builtins/array-shift.tq:  // implemented in elements.cc:FastElementsAccessor::MoveElements.
builtins/array-shift.tq:  if (newLength > kMaxCopyElements) goto Runtime;
builtins/array.tq:type GenericElementsAccessor extends ElementsKind;
builtins/array.tq:type FastPackedSmiElements extends ElementsKind;
builtins/array.tq:type FastPackedObjectElements extends ElementsKind;
builtins/array.tq:type FastPackedDoubleElements extends ElementsKind;
builtins/array.tq:type FastSmiOrObjectElements extends ElementsKind;
builtins/array.tq:type FastDoubleElements extends ElementsKind;
builtins/array.tq:type DictionaryElements extends ElementsKind;
builtins/array.tq:  dcheck(IsFastElementsKind(array.map.elements_kind));
builtins/array.tq:  dcheck(IsFastSmiOrTaggedElementsKind(array.map.elements_kind));
builtins/array.tq:      LoadJSArrayElementsMap(ElementsKind::PACKED_ELEMENTS, nativeContext);
objects/fixed-array.cc:int FixedArrayBase::GetMaxLengthForNewSpaceAllocation(ElementsKind kind) {
objects/fixed-array.cc:          ElementsKindToShiftSize(kind));
objects/fixed-array.cc:  CopyElements(isolate, *new_array, 0, *array, 0, old_length, mode);
builtins/builtins-shadow-realm-gen.cc:      CAST(AllocateFixedArray(ElementsKind::PACKED_ELEMENTS, argc_ptr));
builtins/builtins-shadow-realm-gen.cc:  FillFixedArrayWithValue(ElementsKind::PACKED_ELEMENTS, wrapped_args,
api/api-inl.h:  switch (obj->GetElementsKind()) {
heap/factory.h:                     ElementsKind elements_kind = TERMINAL_FAST_ELEMENTS_KIND,
heap/factory.h:      ElementsKind elements_kind = TERMINAL_FAST_ELEMENTS_KIND,
heap/factory.h:      ElementsKind elements_kind = TERMINAL_FAST_ELEMENTS_KIND,
heap/factory.h:      ElementsKind elements_kind = TERMINAL_FAST_ELEMENTS_KIND,
heap/factory.h:      ElementsKind elements_kind = TERMINAL_FAST_ELEMENTS_KIND,
heap/factory.h:      ElementsKind elements_kind = TERMINAL_FAST_ELEMENTS_KIND,
heap/factory.h:                            int instance_size, ElementsKind elements_kind,
heap/factory.h:      ElementsKind elements_kind, int length, int capacity,
heap/factory.h:      int capacity, ElementsKind elements_kind = TERMINAL_FAST_ELEMENTS_KIND,
heap/factory.h:      elements_kind = GetHoleyElementsKind(elements_kind);
heap/factory.h:      DirectHandle<FixedArrayBase> elements, ElementsKind elements_kind,
heap/factory.h:      ElementsKind elements_kind = TERMINAL_FAST_ELEMENTS_KIND,
heap/factory.h:  static void TypeAndSizeForElementsKind(ElementsKind kind,
heap/factory.h:      ElementsKind elements_kind = TERMINAL_FAST_ELEMENTS_KIND,
heap/factory.h:      DirectHandle<FixedArrayBase> elements, ElementsKind elements_kind,
heap/factory.h:      ElementsKind elements_kind, int capacity,
diagnostics/objects-debug.cc:        IsTransitionableFastElementsKind(map()->elements_kind());
diagnostics/objects-debug.cc:      IsJSObjectMap(*this) && !CanHaveFastTransitionableElementsKind(),
diagnostics/objects-debug.cc:      IsDictionaryElementsKind(elements_kind()) ||
diagnostics/objects-debug.cc:          IsTerminalElementsKind(elements_kind()) ||
diagnostics/objects-debug.cc:          IsAnyHoleyNonextensibleElementsKind(elements_kind()) ||
diagnostics/objects-debug.cc:          IsSharedArrayElementsKind(elements_kind()));
diagnostics/objects-debug.cc:  ElementsKind kind = holder->GetElementsKind();
diagnostics/objects-debug.cc:  ElementsAccessor* accessor;
diagnostics/objects-debug.cc:    accessor = ElementsAccessor::ForKind(HOLEY_ELEMENTS);
diagnostics/objects-debug.cc:    accessor = ElementsAccessor::ForKind(DICTIONARY_ELEMENTS);
diagnostics/objects-debug.cc:  if (IsSloppyArgumentsElementsKind(GetElementsKind())) {
diagnostics/objects-debug.cc:  switch (GetElementsKind()) {
heap/factory-inl.h:    DirectHandle<FixedArrayBase> elements, ElementsKind elements_kind,
diagnostics/objects-printer.cc:void PrintSloppyArgumentElements(std::ostream& os, ElementsKind kind,
diagnostics/objects-printer.cc:     << ElementsKindToString(arguments_store->map()->elements_kind()) << " {";
diagnostics/objects-printer.cc:  // Don't call GetElementsKind, its validation code can cause the printer to
diagnostics/objects-printer.cc:  // Don't call GetElementsKind, its validation code can cause the printer to
diagnostics/objects-printer.cc:     << ElementsKindToString(obj->map()->elements_kind());
diagnostics/objects-printer.cc:  os << "\n - elements kind: " << ElementsKindToString(elements_kind());
diagnostics/objects-printer.cc:    ElementsKind kind = GetElementsKind();
diagnostics/objects-printer.cc:    os << "Array allocation with ElementsKind " << ElementsKindToString(kind);
diagnostics/objects-printer.cc:          os << ElementsKindToString(map->elements_kind());
diagnostics/objects-printer.cc:  os << "\n - elements kind: " << ElementsKindToString(elements_kind());
diagnostics/objects-printer.cc:    os << "(transition to " << ElementsKindToString(target->elements_kind())
diagnostics/objects-printer.cc:          os << "to " << ElementsKindToString(target->elements_kind());
api/api.cc:  if (array->GetElementsAccessor()->HasAccessors(*array)) return false;
api/api.cc:  switch (array->GetElementsKind()) {
objects/allocation-site-inl.h:  SetElementsKind(GetInitialFastElementsKind());
objects/allocation-site-inl.h:ElementsKind AllocationSite::GetElementsKind() const {
objects/allocation-site-inl.h:  return ElementsKindBits::decode(transition_info());
objects/allocation-site-inl.h:void AllocationSite::SetElementsKind(ElementsKind kind) {
objects/allocation-site-inl.h:  set_transition_info(ElementsKindBits::update(transition_info(), kind));
objects/allocation-site-inl.h:bool AllocationSite::ShouldTrack(ElementsKind boilerplate_elements_kind) {
objects/allocation-site-inl.h:  return IsSmiElementsKind(boilerplate_elements_kind);
objects/allocation-site-inl.h:                                              ElementsKind to_kind) {
objects/allocation-site-inl.h:    ElementsKind kind = boilerplate->GetElementsKind();
objects/allocation-site-inl.h:    if (IsHoleyElementsKind(kind)) {
objects/allocation-site-inl.h:      to_kind = GetHoleyElementsKind(to_kind);
objects/allocation-site-inl.h:    if (IsMoreGeneralElementsKindTransition(kind, to_kind)) {
objects/allocation-site-inl.h:                 is_nested ? "(nested)" : " ", ElementsKindToString(kind),
objects/allocation-site-inl.h:                 ElementsKindToString(to_kind));
objects/allocation-site-inl.h:        JSObject::TransitionElementsKind(boilerplate, to_kind);
objects/allocation-site-inl.h:    ElementsKind kind = site->GetElementsKind();
objects/allocation-site-inl.h:    if (IsHoleyElementsKind(kind)) {
objects/allocation-site-inl.h:      to_kind = GetHoleyElementsKind(to_kind);
objects/allocation-site-inl.h:    if (IsMoreGeneralElementsKindTransition(kind, to_kind)) {
objects/allocation-site-inl.h:               reinterpret_cast<void*>(site->ptr()), ElementsKindToString(kind),
objects/allocation-site-inl.h:               ElementsKindToString(to_kind));
objects/allocation-site-inl.h:      site->SetElementsKind(to_kind);
objects/js-array-buffer.h:                                        ElementsKind* element_kind);
objects/map-updater.h:  Handle<Map> ReconfigureElementsKind(ElementsKind elements_kind);
objects/map-updater.h:  ElementsKind new_elements_kind_;
objects/objects.cc:      return array->GetElementsAccessor()->CreateListFromArrayLike(
objects/objects.cc:      return array->GetElementsAccessor()->CreateListFromArrayLike(
objects/objects.cc:  ElementsKind array_kind = array->GetElementsKind();
objects/objects.cc:  if (IsFastPackedElementsKind(array_kind)) return false;
objects/objects.cc:  if (IsHoleyElementsKind(array_kind) &&
objects/objects.cc:    ElementsKind elements_kind = Cast<JSObject>(*receiver)->GetElementsKind();
objects/objects.cc:    if (IsBigIntTypedArrayElementsKind(elements_kind)) {
objects/objects.cc:      // since we later use JSArray::SetLength instead of
objects/objects.cc:  // Most of steps 16 through 19 is implemented by JSArray::SetLength.
objects/objects.cc:  MAYBE_RETURN(JSArray::SetLength(a, new_len), Nothing<bool>());
objects/objects.cc:Maybe<bool> JSArray::SetLength(DirectHandle<JSArray> array,
objects/objects.cc:  return array->GetElementsAccessor()->SetLength(array, new_length);
objects/objects.cc:bool JSArray::SetLengthWouldNormalize(uint32_t new_length) {
objects/objects.cc:  return JSArray::SetLengthWouldNormalize(GetHeap(), new_length) &&
objects/objects.cc:bool AllocationSite::ShouldTrack(ElementsKind from, ElementsKind to) {
objects/objects.cc:  return IsMoreGeneralElementsKindTransition(from, to);
objects/scope-info.cc:void ScopeInfo::CopyElements(Isolate* isolate, int dst_index,
ast/ast.h:  ElementsKind boilerplate_descriptor_kind() const {
ast/ast.h:      IsSimpleField::Next<ElementsKind, kFastElementsKindBits>;
ast/ast.h:  void set_boilerplate_descriptor_kind(ElementsKind kind) {
ast/ast.h:    DCHECK(IsFastElementsKind(kind));
objects/literal-objects-inl.h:ElementsKind ArrayBoilerplateDescription::elements_kind() const {
objects/literal-objects-inl.h:  return static_cast<ElementsKind>(flags());
objects/literal-objects-inl.h:void ArrayBoilerplateDescription::set_elements_kind(ElementsKind kind) {
objects/regexp-match-info.cc:    RegExpMatchInfo::CopyElements(isolate, *new_info, 0, *match_info, 0,
ast/ast.cc:  ElementsKind kind = FIRST_FAST_ELEMENTS_KIND;
ast/ast.cc:                      GetMoreGeneralElementsKind(kind, PACKED_DOUBLE_ELEMENTS));
ast/ast.cc:                      GetMoreGeneralElementsKind(kind, PACKED_SMI_ELEMENTS));
ast/ast.cc:    kind = GetHoleyElementsKind(kind);
ast/ast.cc:  ElementsKind kind = boilerplate_descriptor_kind();
ast/ast.cc:  bool use_doubles = IsDoubleElementsKind(kind);
ast/ast.cc:        DCHECK(IsHoleyElementsKind(kind));
ast/ast.cc:        DCHECK(IsHoleyElementsKind(kind));
ast/ast.cc:      DCHECK_EQ(kind, GetMoreGeneralElementsKind(
ast/ast.cc:                          kind, Object::OptimalElementsKind(
ast/ast.cc:      IsSmiOrObjectElementsKind(kind)) {
objects/transitions.h:// and/or handlers as well as prototype and ElementsKind transitions.  Property
compiler/heap-refs.cc:         IsFastElementsKind(map->elements_kind()) &&
compiler/heap-refs.cc:  ElementsKind kind = elements_kind();
compiler/heap-refs.cc:  if (IsFastElementsKind(kind)) return true;
compiler/heap-refs.cc:  if (IsTypedArrayElementsKind(kind) &&
compiler/heap-refs.cc:  if (IsRabGsabTypedArrayElementsKind(kind) &&
compiler/heap-refs.cc:OptionalMapRef MapRef::AsElementsKind(JSHeapBroker* broker,
compiler/heap-refs.cc:                                      ElementsKind kind) const {
compiler/heap-refs.cc:  const ElementsKind current_kind = elements_kind();
compiler/heap-refs.cc:  // If starting from an initial JSArray map, TryAsElementsKind must succeed
compiler/heap-refs.cc:        Map::TryAsElementsKind(broker->isolate(), object(), kind,
compiler/heap-refs.cc:  std::optional<Tagged<Map>> maybe_result = Map::TryAsElementsKind(
compiler/heap-refs.cc:    TRACE_BROKER_MISSING(broker, "MapRef::AsElementsKind " << *this);
compiler/heap-refs.cc:        !IsFastOrNonextensibleOrSealedElementsKind(
compiler/heap-refs.cc:HEAP_ACCESSOR_C(AllocationSite, ElementsKind, GetElementsKind)
compiler/heap-refs.cc:BIMODAL_ACCESSOR_B(Map, bit_field2, elements_kind, Map::Bits2::ElementsKindBits)
compiler/heap-refs.cc:                                              ElementsKind kind) const {
compiler/heap-refs.cc:    ElementsKind elements_kind, uint32_t index) const {
compiler/heap-refs.cc:    // See also ElementsAccessorBase::GetMaxIndex.
compiler/heap-refs.cc:  ElementsKind elements_kind = map(broker).elements_kind();
compiler/heap-refs.cc:  if (!IsSmiOrObjectElementsKind(elements_kind)) return {};
compiler/heap-refs.cc:  DCHECK(IsFastElementsKind(elements_kind));
compiler/js-call-reducer.cc:  TNode<JSArray> AllocateEmptyJSArray(ElementsKind kind,
compiler/js-call-reducer.cc:  TNode<Number> LoadMapElementsKind(TNode<Map> map);
compiler/js-call-reducer.cc:  TNode<Object> ConvertHoleToUndefined(TNode<Object> value, ElementsKind kind) {
compiler/js-call-reducer.cc:    DCHECK(IsHoleyElementsKind(kind));
compiler/js-call-reducer.cc:                                            ElementsKind kind,
compiler/js-call-reducer.cc:                                           ElementsKind kind,
compiler/js-call-reducer.cc:                                         ElementsKind kind,
compiler/js-call-reducer.cc:                                            ElementsKind kind,
compiler/js-call-reducer.cc:                                         ElementsKind kind,
compiler/js-call-reducer.cc:      ElementsKind kind, SharedFunctionInfoRef shared,
compiler/js-call-reducer.cc:      ElementsKind kind, ArrayIndexOfIncludesVariant variant);
compiler/js-call-reducer.cc:  std::pair<TNode<Number>, TNode<Object>> SafeLoadElement(ElementsKind kind,
compiler/js-call-reducer.cc:      TNode<Object> o, ElementsKind kind,
compiler/js-call-reducer.cc:    if (!IsHoleyElementsKind(kind)) return o;
compiler/js-call-reducer.cc:  TNode<Smi> LoadJSArrayLength(TNode<JSArray> array, ElementsKind kind) {
compiler/js-call-reducer.cc:                          ElementsKind kind) {
compiler/js-call-reducer.cc:                                  TNode<Object> v, ElementsKind kind) {
compiler/js-call-reducer.cc:  TNode<Boolean> HoleCheck(ElementsKind kind, TNode<Object> v) {
compiler/js-call-reducer.cc:    return IsDoubleElementsKind(kind)
compiler/js-call-reducer.cc:    ElementsKind kind, NativeContextRef native_context) {
compiler/js-call-reducer.cc:TNode<Number> JSCallReducerAssembler::LoadMapElementsKind(TNode<Map> map) {
compiler/js-call-reducer.cc:                       NumberConstant(Map::Bits2::ElementsKindBits::kMask)),
compiler/js-call-reducer.cc:      NumberConstant(Map::Bits2::ElementsKindBits::kShift));
compiler/js-call-reducer.cc:      LoadMapElementsKind(arguments_list_map);
compiler/js-call-reducer.cc:    if (IsHoleyElementsKind(map.elements_kind())) {
compiler/js-call-reducer.cc:    ElementsKind kind = map.elements_kind();
compiler/js-call-reducer.cc:      if (IsDoubleElementsKind(kind)) {
compiler/js-call-reducer.cc:      } else if (IsSmiElementsKind(kind)) {
compiler/js-call-reducer.cc:      if (IsDoubleElementsKind(kind)) {
compiler/js-call-reducer.cc:      } else if (IsSmiElementsKind(kind)) {
compiler/js-call-reducer.cc:  auto build_array_push = |&](ElementsKind kind,
compiler/js-call-reducer.cc:    ElementsKind kind, SharedFunctionInfoRef shared) {
compiler/js-call-reducer.cc:    ElementsKind kind, ArrayReduceDirection direction,
compiler/js-call-reducer.cc:    ElementsKind kind, SharedFunctionInfoRef shared,
compiler/js-call-reducer.cc:    ElementsKind kind, SharedFunctionInfoRef shared,
compiler/js-call-reducer.cc:  const ElementsKind packed_kind = GetPackedElementsKind(kind);
compiler/js-call-reducer.cc:    ElementsKind kind, SharedFunctionInfoRef shared,
compiler/js-call-reducer.cc:    if (IsHoleyElementsKind(kind)) {
compiler/js-call-reducer.cc:    ElementsKind kind, SharedFunctionInfoRef shared,
compiler/js-call-reducer.cc:                                            ElementsKind elements_kind,
compiler/js-call-reducer.cc:    ElementsKind kind, ArrayIndexOfIncludesVariant variant) {
compiler/js-call-reducer.cc:                                    ElementsKind* kind_return) {
compiler/js-call-reducer.cc:        !UnionElementsKindUptoSize(kind_return, map.elements_kind())) {
compiler/js-call-reducer.cc:                                   std::vector<ElementsKind>* kinds,
compiler/js-call-reducer.cc:    ElementsKind current_kind = map.elements_kind();
compiler/js-call-reducer.cc:      if (UnionElementsKindUptoPackedness(kind_ptr, current_kind)) {
compiler/js-call-reducer.cc:  ElementsKind elements_kind() const { return elements_kind_; }
compiler/js-call-reducer.cc:  ElementsKind elements_kind_;
compiler/js-call-reducer.cc:Node* JSCallReducer::ConvertHoleToUndefined(Node* value, ElementsKind kind) {
compiler/js-call-reducer.cc:  DCHECK(IsHoleyElementsKind(kind));
compiler/js-call-reducer.cc:Node* JSCallReducer::CheckArrayLength(Node* array, ElementsKind elements_kind,
compiler/js-call-reducer.cc:  ElementsKind elements_kind = array_map.elements_kind();
compiler/js-call-reducer.cc:    if (IsHoleyElementsKind(elements_kind)) {
compiler/js-call-reducer.cc:    // counter-productive at least for Object ElementsKinds. Disable it until
compiler/js-call-reducer.cc:Node* JSCallReducer::LoadReceiverElementsKind(Node* receiver, Effect* effect,
compiler/js-call-reducer.cc:          jsgraph()->ConstantNoHole(Map::Bits2::ElementsKindBits::kMask)),
compiler/js-call-reducer.cc:      jsgraph()->ConstantNoHole(Map::Bits2::ElementsKindBits::kShift));
compiler/js-call-reducer.cc:void JSCallReducer::CheckIfElementsKind(Node* receiver_elements_kind,
compiler/js-call-reducer.cc:                                        ElementsKind kind, Node* control,
compiler/js-call-reducer.cc:                       jsgraph()->ConstantNoHole(GetPackedElementsKind(kind)));
compiler/js-call-reducer.cc:  if (IsHoleyElementsKind(kind)) {
compiler/js-call-reducer.cc:                         jsgraph()->ConstantNoHole(GetHoleyElementsKind(kind)));
compiler/js-call-reducer.cc:  std::vector<ElementsKind> kinds;
compiler/js-call-reducer.cc:  std::vector<ElementsKind> kinds;
compiler/js-call-reducer.cc:      LoadReceiverElementsKind(receiver, &effect, control);
compiler/js-call-reducer.cc:    ElementsKind kind = kinds|i];
compiler/js-call-reducer.cc:      CheckIfElementsKind(receiver_elements_kind, kind, control_node,
compiler/js-call-reducer.cc:      // big, as implemented in elements.cc:ElementsAccessorBase::SetLengthImpl.
compiler/js-call-reducer.cc:      if (IsSmiOrObjectElementsKind(kind)) {
compiler/js-call-reducer.cc:              AccessBuilder::ForFixedArrayElement(GetHoleyElementsKind(kind))),
compiler/js-call-reducer.cc:    if (IsHoleyElementsKind(kind)) {
compiler/js-call-reducer.cc:  std::vector<ElementsKind> kinds;
compiler/js-call-reducer.cc:      LoadReceiverElementsKind(receiver, &effect, control);
compiler/js-call-reducer.cc:    ElementsKind kind = kinds|i];
compiler/js-call-reducer.cc:      CheckIfElementsKind(receiver_elements_kind, kind, control_node,
compiler/js-call-reducer.cc:          jsgraph()->ConstantNoHole(JSArray::kMaxCopyElements));
compiler/js-call-reducer.cc:        if (IsSmiOrObjectElementsKind(kind)) {
compiler/js-call-reducer.cc:            jsgraph()->ConstantNoHole(JSArray::kMaxCopyElements - 1), loop);
compiler/js-call-reducer.cc:          // is in |1, kMaxCopyElements-1], and will break in representing
compiler/js-call-reducer.cc:          static_assert(JSArray::kMaxCopyElements < kSmiMaxValue);
compiler/js-call-reducer.cc:                GetHoleyElementsKind(kind))),
compiler/js-call-reducer.cc:    if (IsHoleyElementsKind(kind)) {
compiler/js-call-reducer.cc:    if (IsHoleyElementsKind(receiver_map.elements_kind())) {
compiler/js-call-reducer.cc:      std::set<ElementsKind> elements_kinds;
compiler/js-call-reducer.cc:  ElementsKind elements_kind = iterated_object_maps|0].elements_kind();
compiler/js-call-reducer.cc:  if (IsTypedArrayElementsKind(elements_kind)) {
compiler/js-call-reducer.cc:  if (IsHoleyElementsKind(elements_kind) &&
compiler/js-call-reducer.cc:  if (IsFloat16TypedArrayElementsKind(elements_kind)) {
compiler/js-call-reducer.cc:  if (IsTypedArrayElementsKind(elements_kind)) {
compiler/js-call-reducer.cc:  if (IsTypedArrayElementsKind(elements_kind)) {
compiler/js-call-reducer.cc:  if (IsTypedArrayElementsKind(elements_kind)) {
compiler/js-call-reducer.cc:        jsgraph()->UintPtrConstant(ElementsKindToShiftSize(elements_kind)));
compiler/js-call-reducer.cc:      if (IsTypedArrayElementsKind(elements_kind)) {
compiler/js-call-reducer.cc:        if (IsHoleyElementsKind(elements_kind)) {
compiler/js-call-reducer.cc:    if (!IsTypedArrayElementsKind(elements_kind)) {
compiler/js-call-reducer.cc:          jsgraph()->ConstantNoHole(Map::Bits2::ElementsKindBits::kMask)),
compiler/js-call-reducer.cc:      jsgraph()->ConstantNoHole(Map::Bits2::ElementsKindBits::kShift));
compiler/js-call-reducer.cc:  std::set<ElementsKind> elements_kinds;
compiler/js-call-reducer.cc:      ElementsKind kind = map.elements_kind();
compiler/js-call-reducer.cc:      if (IsRabGsabTypedArrayElementsKind(kind)) maybe_rab_gsab = true;
compiler/js-call-reducer.cc:  std::set<ElementsKind> elements_kinds;
compiler/js-call-reducer.cc:      ElementsKind kind = map.elements_kind();
compiler/js-call-reducer.cc:      if (IsRabGsabTypedArrayElementsKind(kind)) maybe_rab_gsab = true;
compiler/js-call-reducer.cc:  std::set<ElementsKind> elements_kinds;
compiler/js-call-reducer.cc:    ElementsKind kind = map.elements_kind();
compiler/js-call-reducer.cc:    if (IsRabGsabTypedArrayElementsKind(kind)) maybe_rab_gsab = true;
compiler/js-call-reducer.cc:                   return IsRabGsabTypedArrayElementsKind(map.elements_kind());
compiler/js-call-reducer.cc:    TNode<Uint32T> elements_kind = a.LoadElementsKind(map);
compiler/js-call-reducer.cc:    TNode<Uint32T> shift = a.LookupByteShiftForElementsKind(elements_kind);
objects/js-objects-inl.h:  ElementsKind elements_kind = object->map()->elements_kind();
objects/js-objects-inl.h:  if (!IsObjectElementsKind(elements_kind)) {
objects/js-objects-inl.h:    if (IsHoleyElementsKind(elements_kind)) {
objects/js-objects-inl.h:      TransitionElementsKind(object, HOLEY_ELEMENTS);
objects/js-objects-inl.h:      TransitionElementsKind(object, PACKED_ELEMENTS);
objects/js-objects-inl.h:  ElementsKind current_kind = object->GetElementsKind();
objects/js-objects-inl.h:  ElementsKind target_kind = current_kind;
objects/js-objects-inl.h:    bool is_holey = IsHoleyElementsKind(current_kind);
objects/js-objects-inl.h:        target_kind = GetHoleyElementsKind(target_kind);
objects/js-objects-inl.h:          if (IsSmiElementsKind(target_kind)) {
objects/js-objects-inl.h:    TransitionElementsKind(object, target_kind);
objects/js-objects-inl.h:  if (object->GetElementsKind() == HOLEY_SMI_ELEMENTS) {
objects/js-objects-inl.h:    TransitionElementsKind(object, HOLEY_DOUBLE_ELEMENTS);
objects/js-objects-inl.h:  } else if (object->GetElementsKind() == PACKED_SMI_ELEMENTS) {
objects/js-objects-inl.h:        TransitionElementsKind(object, HOLEY_DOUBLE_ELEMENTS);
objects/js-objects-inl.h:    TransitionElementsKind(object, PACKED_DOUBLE_ELEMENTS);
objects/js-objects-inl.h:DEF_GETTER(JSObject, GetElementsKind, ElementsKind) {
objects/js-objects-inl.h:  ElementsKind kind = map(cage_base)->elements_kind();
objects/js-objects-inl.h:    if (IsSmiOrObjectElementsKind(kind)) {
objects/js-objects-inl.h:    } else if (IsDoubleElementsKind(kind)) {
objects/js-objects-inl.h:      CHECK(kind > DICTIONARY_ELEMENTS || IsAnyNonextensibleElementsKind(kind));
objects/js-objects-inl.h:    CHECK_IMPLIES(IsSloppyArgumentsElementsKind(kind),
objects/js-objects-inl.h:DEF_GETTER(JSObject, GetElementsAccessor, ElementsAccessor*) {
objects/js-objects-inl.h:  return ElementsAccessor::ForKind(GetElementsKind(cage_base));
objects/js-objects-inl.h:  return IsObjectElementsKind(GetElementsKind(cage_base));
objects/js-objects-inl.h:  return IsSmiElementsKind(GetElementsKind(cage_base));
objects/js-objects-inl.h:  return IsSmiOrObjectElementsKind(GetElementsKind(cage_base));
objects/js-objects-inl.h:  return IsDoubleElementsKind(GetElementsKind(cage_base));
objects/js-objects-inl.h:  return IsHoleyElementsKind(GetElementsKind(cage_base));
objects/js-objects-inl.h:  return IsFastElementsKind(GetElementsKind(cage_base));
objects/js-objects-inl.h:  return IsFastPackedElementsKind(GetElementsKind(cage_base));
objects/js-objects-inl.h:  return IsDictionaryElementsKind(GetElementsKind(cage_base));
objects/js-objects-inl.h:  return GetElementsKind(cage_base) == PACKED_ELEMENTS;
objects/js-objects-inl.h:  return IsAnyNonextensibleElementsKind(GetElementsKind(cage_base));
objects/js-objects-inl.h:  return IsSealedElementsKind(GetElementsKind(cage_base));
objects/js-objects-inl.h:  return GetElementsKind(cage_base) == SHARED_ARRAY_ELEMENTS;
objects/js-objects-inl.h:  return IsNonextensibleElementsKind(GetElementsKind(cage_base));
objects/js-objects-inl.h:  return IsFastArgumentsElementsKind(GetElementsKind(cage_base));
objects/js-objects-inl.h:  return IsSlowArgumentsElementsKind(GetElementsKind(cage_base));
objects/js-objects-inl.h:  return IsSloppyArgumentsElementsKind(GetElementsKind(cage_base));
objects/js-objects-inl.h:  return IsStringWrapperElementsKind(GetElementsKind(cage_base));
objects/js-objects-inl.h:  return GetElementsKind(cage_base) == FAST_STRING_WRAPPER_ELEMENTS;
objects/js-objects-inl.h:  return GetElementsKind(cage_base) == SLOW_STRING_WRAPPER_ELEMENTS;
objects/contexts.cc:    CopyElements(isolate, *new_table, 0, *table, 0, old_length);
objects/map.tq:  elements_kind: ElementsKind: 6 bit;
objects/objects-inl.h:ElementsKind Object::OptimalElementsKind(Tagged<Object> obj,
maglev/arm64/maglev-ir-arm64.cc:  int shift_size = ElementsKindToShiftSize(elements_kind_);
objects/fixed-array.h:  inline static void CopyElements(Isolate* isolate, Tagged<Derived> dst,
objects/fixed-array.h:  using Super::CopyElements;
objects/fixed-array.h:  inline void CopyElements(Isolate* isolate, int dst_index,
objects/fixed-array.h:  static int GetMaxLengthForNewSpaceAllocation(ElementsKind kind);
objects/fixed-array.h:  inline void CopyElements(Isolate* isolate, int dst_index,
objects/property-array.h:  // Signature must be in sync with FixedArray::CopyElements().
objects/property-array.h:  inline static void CopyElements(Isolate* isolate, Tagged<PropertyArray> dst,
strings/string-builder.cc:    FixedArray::CopyElements(isolate, *extended_array, 0, *array_, 0, length_);
maglev/riscv/maglev-ir-riscv.cc:  int shift_size = ElementsKindToShiftSize(elements_kind_);
maglev/arm/maglev-ir-arm.cc:  int shift_size = ElementsKindToShiftSize(elements_kind_);
objects/contexts.h:  static int ArrayMapIndex(ElementsKind elements_kind) {
objects/contexts.h:    DCHECK(IsFastElementsKind(elements_kind));
objects/contexts.h:  inline Tagged<Map> GetInitialJSArrayMap(ElementsKind kind) const;
objects/contexts.h:  inline Tagged<Map> TypedArrayElementsKindToCtorMap(
objects/contexts.h:      ElementsKind element_kind) const;
objects/contexts.h:  inline Tagged<Map> TypedArrayElementsKindToRabGsabCtorMap(
objects/contexts.h:      ElementsKind element_kind) const;
codegen/arm64/macro-assembler-arm64.h:  void LoadElementsKindFromMap(Register result, Register map);
objects/property-array-inl.h:void PropertyArray::CopyElements(Isolate* isolate, Tagged<PropertyArray> dst,
runtime/runtime-object.cc:      ElementsKind elements_kind = lookup_start_object->GetElementsKind();
runtime/runtime-object.cc:      if (IsDoubleElementsKind(elements_kind)) {
runtime/runtime-object.cc:          elements_kind = IsHoleyElementsKind(elements_kind) ? HOLEY_ELEMENTS
runtime/runtime-object.cc:          JSObject::TransitionElementsKind(lookup_start_object, elements_kind);
runtime/runtime-object.cc:        DCHECK(IsSmiOrObjectElementsKind(elements_kind) ||
runtime/runtime-object.cc:               !IsFastElementsKind(elements_kind));
runtime/runtime-object.cc:      IsFastPackedElementsKind(obj->map()->elements_kind()));
objects/js-array-buffer.cc:  DCHECK(IsTypedArrayOrRabGsabTypedArrayElementsKind(self->GetElementsKind()));
objects/js-array-buffer.cc:  auto element_byte_size = ElementsKindToByteSize(array->GetElementsKind());
runtime/runtime-literals.cc:  switch (copy->GetElementsKind(isolate)) {
runtime/runtime-literals.cc:  ElementsKind constant_elements_kind =
runtime/runtime-literals.cc:  if (IsDoubleElementsKind(constant_elements_kind)) {
runtime/runtime-literals.cc:    DCHECK(IsSmiOrObjectElementsKind(constant_elements_kind));
objects/fixed-array-inl.h:void TaggedArrayBase<D, S, P>::CopyElements(Isolate* isolate, Tagged<D> dst,
objects/fixed-array-inl.h:void FixedArray::CopyElements(Isolate* isolate, int dst_index,
objects/fixed-array-inl.h:  CopyElements(isolate, this, dst_index, src, src_index, len, mode);
objects/fixed-array-inl.h:  FixedArray::CopyElements(isolate, *ys, 0, *xs, 0, elements_to_copy, mode);
objects/fixed-array-inl.h:void WeakArrayList::CopyElements(Isolate* isolate, int dst_index,
objects/allocation-site.h:  using ElementsKindBits = base::BitField<ElementsKind, 0, 6>;
objects/allocation-site.h:  inline ElementsKind GetElementsKind() const;
objects/allocation-site.h:  inline void SetElementsKind(ElementsKind kind);
objects/allocation-site.h:                                       ElementsKind to_kind);
objects/allocation-site.h:  static inline bool ShouldTrack(ElementsKind boilerplate_elements_kind);
objects/allocation-site.h:  static bool ShouldTrack(ElementsKind from, ElementsKind to);
objects/allocation-site-scopes-inl.h:        AllocationSite::ShouldTrack(object->GetElementsKind())) {
objects/js-objects.cc:      object->GetElementsAccessor()->GetCapacity(*object, object->elements());
objects/js-objects.cc:    MAYBE_RETURN(object->GetElementsAccessor()->CollectValuesOrEntries(
objects/js-objects.cc:  DCHECK_EQ(object->GetElementsKind(), DICTIONARY_ELEMENTS);
objects/js-objects.cc:    FILE* file, DirectHandle<JSObject> object, ElementsKind from_kind,
objects/js-objects.cc:    DirectHandle<FixedArrayBase> from_elements, ElementsKind to_kind,
objects/js-objects.cc:    os << "elements transition |" << ElementsKindToString(from_kind) << " -> "
objects/js-objects.cc:       << ElementsKindToString(to_kind) << "] in ";
objects/js-objects.cc:                                               ElementsKind to_kind) {
objects/js-objects.cc:  ElementsKind obj_kind = object->map()->elements_kind();
objects/js-objects.cc:  ElementsKind map_kind = map->elements_kind();
objects/js-objects.cc:    ElementsKind to_kind = GetMoreGeneralElementsKind(map_kind, obj_kind);
objects/js-objects.cc:    if (IsDictionaryElementsKind(obj_kind)) {
objects/js-objects.cc:    if (IsDictionaryElementsKind(to_kind)) {
objects/js-objects.cc:      TransitionElementsKind(object, to_kind);
objects/js-objects.cc:    map = MapUpdater{isolate, map}.ReconfigureElementsKind(to_kind);
objects/js-objects.cc:      IsTransitionableFastElementsKind(old_map->elements_kind());
objects/js-objects.cc:      object->GetElementsAccessor()->Normalize(object);
objects/js-objects.cc:  ElementsKind target_kind =
objects/js-objects.cc:  ElementsKind kind = object->GetElementsKind();
objects/js-objects.cc:  if (IsDictionaryElementsKind(kind)) {
objects/js-objects.cc:  if (IsTypedArrayOrRabGsabTypedArrayElementsKind(kind)) {
objects/js-objects.cc:  if (IsFrozenElementsKind(kind)) return true;
objects/js-objects.cc:  if (IsSealedElementsKind(kind) && level != FROZEN) return true;
objects/js-objects.cc:  if (IsNonextensibleElementsKind(kind) && level == NONE) return true;
objects/js-objects.cc:  ElementsAccessor* accessor = ElementsAccessor::ForKind(kind);
objects/js-objects.cc:                    : object->GetElementsAccessor()->Normalize(object);
objects/js-objects.cc:    ElementsKind old_elements_kind = object->map()->elements_kind();
objects/js-objects.cc:    if (IsFrozenElementsKind(old_elements_kind)) return Just(true);
objects/js-objects.cc:    if (attrs != FROZEN && IsSealedElementsKind(old_elements_kind)) {
objects/js-objects.cc:        JSObject::TransitionElementsKind(object, PACKED_ELEMENTS);
objects/js-objects.cc:        JSObject::TransitionElementsKind(object, HOLEY_ELEMENTS);
objects/js-objects.cc:      ElementsKind new_kind =
objects/js-objects.cc:          IsStringWrapperElementsKind(old_map->elements_kind())
objects/js-objects.cc:  switch (object->GetElementsKind()) {
objects/js-objects.cc:    object->GetElementsAccessor()->Validate(object);
objects/js-objects.cc:static ElementsKind BestFittingFastElementsKind(Tagged<JSObject> object) {
objects/js-objects.cc:  if (!object->map()->CanHaveFastTransitionableElementsKind()) {
objects/js-objects.cc:  ElementsKind kind = HOLEY_SMI_ELEMENTS;
objects/js-objects.cc:  ElementsKind kind = object->GetElementsKind(isolate);
objects/js-objects.cc:  ElementsKind dictionary_kind = DICTIONARY_ELEMENTS;
objects/js-objects.cc:  if (IsSloppyArgumentsElementsKind(kind)) {
objects/js-objects.cc:  } else if (IsStringWrapperElementsKind(kind)) {
objects/js-objects.cc:               ? BestFittingFastElementsKind(*object)
objects/js-objects.cc:  ElementsKind to = Object::OptimalElementsKind(*value, isolate);
objects/js-objects.cc:  if (IsHoleyElementsKind(kind) || !IsJSArray(*object, isolate) ||
objects/js-objects.cc:    to = GetHoleyElementsKind(to);
objects/js-objects.cc:    kind = GetHoleyElementsKind(kind);
objects/js-objects.cc:  to = GetMoreGeneralElementsKind(kind, to);
objects/js-objects.cc:  ElementsAccessor* accessor = ElementsAccessor::ForKind(to);
objects/js-objects.cc:                                    ElementsKind to_kind) {
objects/js-objects.cc:    DirectHandle<JSObject> object, ElementsKind to_kind);
objects/js-objects.cc:    DirectHandle<JSObject> object, ElementsKind to_kind);
objects/js-objects.cc:void JSObject::TransitionElementsKind(DirectHandle<JSObject> object,
objects/js-objects.cc:                                      ElementsKind to_kind) {
objects/js-objects.cc:  ElementsKind from_kind = object->GetElementsKind();
objects/js-objects.cc:  if (IsHoleyElementsKind(from_kind)) {
objects/js-objects.cc:    to_kind = GetHoleyElementsKind(to_kind);
objects/js-objects.cc:  DCHECK(IsFastElementsKind(from_kind) ||
objects/js-objects.cc:         IsNonextensibleElementsKind(from_kind));
objects/js-objects.cc:  DCHECK(IsFastElementsKind(to_kind) || IsNonextensibleElementsKind(to_kind));
objects/js-objects.cc:      IsDoubleElementsKind(from_kind) == IsDoubleElementsKind(to_kind)) {
objects/js-objects.cc:    DCHECK((IsSmiElementsKind(from_kind) && IsDoubleElementsKind(to_kind)) ||
objects/js-objects.cc:           (IsDoubleElementsKind(from_kind) && IsObjectElementsKind(to_kind)));
objects/js-objects.cc:    if (ElementsAccessor::ForKind(to_kind)
objects/js-objects.cc:      // overflow, until all users of TransitionElementsKind can handle
objects/js-objects.cc:  switch (GetElementsKind()) {
objects/elements-kind.cc:constexpr uint8_t kTypedArrayAndRabGsabTypedArrayElementsKindShifts|] = {
objects/elements-kind.cc:constexpr uint8_t kTypedArrayAndRabGsabTypedArrayElementsKindSizes|] = {
objects/elements-kind.cc:      kTypedArrayAndRabGsabTypedArrayElementsKindShifts                \
objects/elements-kind.cc:              |ElementsKind::TYPE##_ELEMENTS -                         \
objects/elements-kind.cc:               ElementsKind::FIRST_FIXED_TYPED_ARRAY_ELEMENTS_KIND] == \
[Step 8: Duration 7.99 seconds| Input tokens: 149,391 | Output tokens: 1,776]
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ Step 9 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'fuzzy_finder' with arguments: {'pattern': 'ElementsAccessor', 'options': '--filter'}                                                                                    │
╰────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
Command: cd /Users/tarun/v8/v8/src && rg --hidden --no-follow --no-ignore-vcs --files 2>/dev/null | fzf --filter 'ElementsAccessor' | head -n 1000
Observations: None
[Step 9: Duration 5.72 seconds| Input tokens: 217,216 | Output tokens: 1,999]
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ Step 10 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'fuzzy_finder' with arguments: {'pattern': 'elements.cc', 'options': '--filter'}                                                                                         │
╰────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
Command: cd /Users/tarun/v8/v8/src && rg --hidden --no-follow --no-ignore-vcs --files 2>/dev/null | fzf --filter 'elements.cc' | head -n 1000
Observations: objects/elements.cc
objects/elements-kind.cc
torque/implementation-visitor.cc
[Step 10: Duration 8.40 seconds| Input tokens: 285,080 | Output tokens: 2,414]
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ Step 11 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'read_file' with arguments: {'file_path': 'objects/elements.cc'}                                                                                                         │
╰────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
Command: cd /Users/tarun/v8/v8/src && wc -l '/Users/tarun/v8/v8/src/objects/elements.cc'
Observations: File 'objects/elements.cc' has 5779 lines and is divided into 2 sections (each section is 3000 lines).
To read this file, please specify a section number between 1 and 2 using the 'section' argument.
[Step 11: Duration 2.01 seconds| Input tokens: 353,000 | Output tokens: 2,435]
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ Step 12 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'read_file' with arguments: {'file_path': 'objects/elements.cc', 'section': 1}                                                                                           │
╰────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
Command: cd /Users/tarun/v8/v8/src && wc -l '/Users/tarun/v8/v8/src/objects/elements.cc'
Command: cd /Users/tarun/v8/v8/src && sed -n '1,3000p' '/Users/tarun/v8/v8/src/objects/elements.cc'
Observations: Showing section 1/2 (lines 1-3000) of 'objects/elements.cc':
// Copyright 2012 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "src/objects/elements.h"

#include "src/base/atomicops.h"
#include "src/base/safe_conversions.h"
#include "src/common/message-template.h"
#include "src/execution/arguments.h"
#include "src/execution/frames.h"
#include "src/execution/isolate-inl.h"
#include "src/execution/protectors-inl.h"
#include "src/heap/factory.h"
#include "src/heap/heap-inl.h"  // For MaxNumberToStringCacheSize.
#include "src/heap/heap-write-barrier-inl.h"
#include "src/numbers/conversions.h"
#include "src/objects/arguments-inl.h"
#include "src/objects/hash-table-inl.h"
#include "src/objects/js-array-buffer-inl.h"
#include "src/objects/js-array-inl.h"
#include "src/objects/js-shared-array-inl.h"
#include "src/objects/keys.h"
#include "src/objects/objects-inl.h"
#include "src/objects/slots-atomic-inl.h"
#include "src/objects/slots.h"
#include "src/utils/utils.h"
#include "third_party/fp16/src/include/fp16.h"

// Each concrete ElementsAccessor can handle exactly one ElementsKind,
// several abstract ElementsAccessor classes are used to allow sharing
// common code.
//
// Inheritance hierarchy:
// - ElementsAccessorBase                        (abstract)
//   - FastElementsAccessor                      (abstract)
//     - FastSmiOrObjectElementsAccessor
//       - FastPackedSmiElementsAccessor
//       - FastHoleySmiElementsAccessor
//       - FastPackedObjectElementsAccessor
//       - FastNonextensibleObjectElementsAccessor: template
//         - FastPackedNonextensibleObjectElementsAccessor
//         - FastHoleyNonextensibleObjectElementsAccessor
//       - FastSealedObjectElementsAccessor: template
//         - FastPackedSealedObjectElementsAccessor
//         - FastHoleySealedObjectElementsAccessor
//       - FastFrozenObjectElementsAccessor: template
//         - FastPackedFrozenObjectElementsAccessor
//         - FastHoleyFrozenObjectElementsAccessor
//       - FastHoleyObjectElementsAccessor
//     - FastDoubleElementsAccessor
//       - FastPackedDoubleElementsAccessor
//       - FastHoleyDoubleElementsAccessor
//   - TypedElementsAccessor: template, with instantiations:
//     - Uint8ElementsAccessor
//     - Int8ElementsAccessor
//     - Uint16ElementsAccessor
//     - Int16ElementsAccessor
//     - Uint32ElementsAccessor
//     - Int32ElementsAccessor
//     - Float32ElementsAccessor
//     - Float64ElementsAccessor
//     - Uint8ClampedElementsAccessor
//     - BigUint64ElementsAccessor
//     - BigInt64ElementsAccessor
//     - RabGsabUint8ElementsAccessor
//     - RabGsabInt8ElementsAccessor
//     - RabGsabUint16ElementsAccessor
//     - RabGsabInt16ElementsAccessor
//     - RabGsabUint32ElementsAccessor
//     - RabGsabInt32ElementsAccessor
//     - RabGsabFloat32ElementsAccessor
//     - RabGsabFloat64ElementsAccessor
//     - RabGsabUint8ClampedElementsAccessor
//     - RabGsabBigUint64ElementsAccessor
//     - RabGsabBigInt64ElementsAccessor
//   - DictionaryElementsAccessor
//   - SloppyArgumentsElementsAccessor
//     - FastSloppyArgumentsElementsAccessor
//     - SlowSloppyArgumentsElementsAccessor
//   - StringWrapperElementsAccessor
//     - FastStringWrapperElementsAccessor
//     - SlowStringWrapperElementsAccessor

namespace v8 {
namespace internal {

namespace {

#define RETURN_NOTHING_IF_NOT_SUCCESSFUL(call) \
  do {                                         \
    if (!(call)) return Nothing<bool>();       \
  } while (false)

#define RETURN_FAILURE_IF_NOT_SUCCESSFUL(call)          \
  do {                                                  \
    ExceptionStatus status_enum_result = (call);        \
    if (!status_enum_result) return status_enum_result; \
  } while (false)

static const int kPackedSizeNotKnown = -1;

enum Where { AT_START, AT_END };

// First argument in list is the accessor class, the second argument is the
// accessor ElementsKind, and the third is the backing store class.  Use the
// fast element handler for smi-only arrays.  The implementation is currently
// identical.  Note that the order must match that of the ElementsKind enum for
// the |accessor_array|]| below to work.
#define ELEMENTS_LIST(V)                                                      \
  V(FastPackedSmiElementsAccessor, PACKED_SMI_ELEMENTS, FixedArray)           \
  V(FastHoleySmiElementsAccessor, HOLEY_SMI_ELEMENTS, FixedArray)             \
  V(FastPackedObjectElementsAccessor, PACKED_ELEMENTS, FixedArray)            \
  V(FastHoleyObjectElementsAccessor, HOLEY_ELEMENTS, FixedArray)              \
  V(FastPackedDoubleElementsAccessor, PACKED_DOUBLE_ELEMENTS,                 \
    FixedDoubleArray)                                                         \
  V(FastHoleyDoubleElementsAccessor, HOLEY_DOUBLE_ELEMENTS, FixedDoubleArray) \
  V(FastPackedNonextensibleObjectElementsAccessor,                            \
    PACKED_NONEXTENSIBLE_ELEMENTS, FixedArray)                                \
  V(FastHoleyNonextensibleObjectElementsAccessor,                             \
    HOLEY_NONEXTENSIBLE_ELEMENTS, FixedArray)                                 \
  V(FastPackedSealedObjectElementsAccessor, PACKED_SEALED_ELEMENTS,           \
    FixedArray)                                                               \
  V(FastHoleySealedObjectElementsAccessor, HOLEY_SEALED_ELEMENTS, FixedArray) \
  V(FastPackedFrozenObjectElementsAccessor, PACKED_FROZEN_ELEMENTS,           \
    FixedArray)                                                               \
  V(FastHoleyFrozenObjectElementsAccessor, HOLEY_FROZEN_ELEMENTS, FixedArray) \
  V(SharedArrayElementsAccessor, SHARED_ARRAY_ELEMENTS, FixedArray)           \
  V(DictionaryElementsAccessor, DICTIONARY_ELEMENTS, NumberDictionary)        \
  V(FastSloppyArgumentsElementsAccessor, FAST_SLOPPY_ARGUMENTS_ELEMENTS,      \
    FixedArray)                                                               \
  V(SlowSloppyArgumentsElementsAccessor, SLOW_SLOPPY_ARGUMENTS_ELEMENTS,      \
    FixedArray)                                                               \
  V(FastStringWrapperElementsAccessor, FAST_STRING_WRAPPER_ELEMENTS,          \
    FixedArray)                                                               \
  V(SlowStringWrapperElementsAccessor, SLOW_STRING_WRAPPER_ELEMENTS,          \
    FixedArray)                                                               \
  V(Uint8ElementsAccessor, UINT8_ELEMENTS, ByteArray)                         \
  V(Int8ElementsAccessor, INT8_ELEMENTS, ByteArray)                           \
  V(Uint16ElementsAccessor, UINT16_ELEMENTS, ByteArray)                       \
  V(Int16ElementsAccessor, INT16_ELEMENTS, ByteArray)                         \
  V(Uint32ElementsAccessor, UINT32_ELEMENTS, ByteArray)                       \
  V(Int32ElementsAccessor, INT32_ELEMENTS, ByteArray)                         \
  V(BigUint64ElementsAccessor, BIGUINT64_ELEMENTS, ByteArray)                 \
  V(BigInt64ElementsAccessor, BIGINT64_ELEMENTS, ByteArray)                   \
  V(Uint8ClampedElementsAccessor, UINT8_CLAMPED_ELEMENTS, ByteArray)          \
  V(Float32ElementsAccessor, FLOAT32_ELEMENTS, ByteArray)                     \
  V(Float64ElementsAccessor, FLOAT64_ELEMENTS, ByteArray)                     \
  V(Float16ElementsAccessor, FLOAT16_ELEMENTS, ByteArray)                     \
  V(RabGsabUint8ElementsAccessor, RAB_GSAB_UINT8_ELEMENTS, ByteArray)         \
  V(RabGsabInt8ElementsAccessor, RAB_GSAB_INT8_ELEMENTS, ByteArray)           \
  V(RabGsabUint16ElementsAccessor, RAB_GSAB_UINT16_ELEMENTS, ByteArray)       \
  V(RabGsabInt16ElementsAccessor, RAB_GSAB_INT16_ELEMENTS, ByteArray)         \
  V(RabGsabUint32ElementsAccessor, RAB_GSAB_UINT32_ELEMENTS, ByteArray)       \
  V(RabGsabInt32ElementsAccessor, RAB_GSAB_INT32_ELEMENTS, ByteArray)         \
  V(RabGsabBigUint64ElementsAccessor, RAB_GSAB_BIGUINT64_ELEMENTS, ByteArray) \
  V(RabGsabBigInt64ElementsAccessor, RAB_GSAB_BIGINT64_ELEMENTS, ByteArray)   \
  V(RabGsabUint8ClampedElementsAccessor, RAB_GSAB_UINT8_CLAMPED_ELEMENTS,     \
    ByteArray)                                                                \
  V(RabGsabFloat32ElementsAccessor, RAB_GSAB_FLOAT32_ELEMENTS, ByteArray)     \
  V(RabGsabFloat64ElementsAccessor, RAB_GSAB_FLOAT64_ELEMENTS, ByteArray)     \
  V(RabGsabFloat16ElementsAccessor, RAB_GSAB_FLOAT16_ELEMENTS, ByteArray)

template <ElementsKind Kind>
class ElementsKindTraits {
 public:
  using BackingStore = FixedArrayBase;
};

#define ELEMENTS_TRAITS(Class, KindParam, Store)    \
  template <>                                       \
  class ElementsKindTraits<KindParam> {             \
   public: /* NOLINT */                             \
    static constexpr ElementsKind Kind = KindParam; \
    using BackingStore = Store;                     \
  };                                                \
  constexpr ElementsKind ElementsKindTraits<KindParam>::Kind;
ELEMENTS_LIST(ELEMENTS_TRAITS)
#undef ELEMENTS_TRAITS

V8_WARN_UNUSED_RESULT
MaybeDirectHandle<Object> ThrowArrayLengthRangeError(Isolate* isolate) {
  THROW_NEW_ERROR(isolate, NewRangeError(MessageTemplate::kInvalidArrayLength));
}

WriteBarrierMode GetWriteBarrierMode(Tagged<FixedArrayBase> elements,
                                     ElementsKind kind,
                                     const DisallowGarbageCollection& promise) {
  if (IsSmiElementsKind(kind)) return SKIP_WRITE_BARRIER;
  if (IsDoubleElementsKind(kind)) return SKIP_WRITE_BARRIER;
  return elements->GetWriteBarrierMode(promise);
}

// If kCopyToEndAndInitializeToHole is specified as the copy_size to
// CopyElements, it copies all of elements from source after source_start to
// destination array, padding any remaining uninitialized elements in the
// destination array with the hole.
constexpr int kCopyToEndAndInitializeToHole = -1;

void CopyObjectToObjectElements(Isolate* isolate,
                                Tagged<FixedArrayBase> from_base,
                                ElementsKind from_kind, uint32_t from_start,
                                Tagged<FixedArrayBase> to_base,
                                ElementsKind to_kind, uint32_t to_start,
                                int raw_copy_size) {
  ReadOnlyRoots roots(isolate);
  DCHECK(to_base->map() != roots.fixed_cow_array_map());
  DisallowGarbageCollection no_gc;
  int copy_size = raw_copy_size;
  if (raw_copy_size < 0) {
    DCHECK_EQ(kCopyToEndAndInitializeToHole, raw_copy_size);
    copy_size = std::min(from_base->length() - from_start,
                         to_base->length() - to_start);
    int start = to_start + copy_size;
    int length = to_base->length() - start;
    if (length > 0) {
      MemsetTagged(Cast<FixedArray>(to_base)->RawFieldOfElementAt(start),
                   roots.the_hole_value(), length);
    }
  }
  DCHECK((copy_size + static_cast<int>(to_start)) <= to_base->length() &&
         (copy_size + static_cast<int>(from_start)) <= from_base->length());
  if (copy_size == 0) return;
  Tagged<FixedArray> from = Cast<FixedArray>(from_base);
  Tagged<FixedArray> to = Cast<FixedArray>(to_base);
  DCHECK(IsSmiOrObjectElementsKind(from_kind));
  DCHECK(IsSmiOrObjectElementsKind(to_kind));

  WriteBarrierMode write_barrier_mode =
      (IsObjectElementsKind(from_kind) && IsObjectElementsKind(to_kind))
          ? UPDATE_WRITE_BARRIER
          : SKIP_WRITE_BARRIER;
  to->CopyElements(isolate, to_start, from, from_start, copy_size,
                   write_barrier_mode);
}

void CopyDictionaryToObjectElements(Isolate* isolate,
                                    Tagged<FixedArrayBase> from_base,
                                    uint32_t from_start,
                                    Tagged<FixedArrayBase> to_base,
                                    ElementsKind to_kind, uint32_t to_start,
                                    int raw_copy_size) {
  DisallowGarbageCollection no_gc;
  Tagged<NumberDictionary> from = Cast<NumberDictionary>(from_base);
  int copy_size = raw_copy_size;
  if (raw_copy_size < 0) {
    DCHECK_EQ(kCopyToEndAndInitializeToHole, raw_copy_size);
    copy_size = from->max_number_key() + 1 - from_start;
    int start = to_start + copy_size;
    int length = to_base->length() - start;
    if (length > 0) {
      MemsetTagged(Cast<FixedArray>(to_base)->RawFieldOfElementAt(start),
                   ReadOnlyRoots(isolate).the_hole_value(), length);
    }
  }
  DCHECK(to_base != from_base);
  DCHECK(IsSmiOrObjectElementsKind(to_kind));
  if (copy_size == 0) return;
  Tagged<FixedArray> to = Cast<FixedArray>(to_base);
  uint32_t to_length = to->length();
  if (to_start + copy_size > to_length) {
    copy_size = to_length - to_start;
  }
  WriteBarrierMode write_barrier_mode = GetWriteBarrierMode(to, to_kind, no_gc);
  for (int i = 0; i < copy_size; i++) {
    InternalIndex entry = from->FindEntry(isolate, i + from_start);
    if (entry.is_found()) {
      Tagged<Object> value = from->ValueAt(entry);
      DCHECK(!IsTheHole(value, isolate));
      to->set(i + to_start, value, write_barrier_mode);
    } else {
      to->set_the_hole(isolate, i + to_start);
    }
  }
}

// NOTE: this method violates the handlified function signature convention:
// raw pointer parameters in the function that allocates.
// See ElementsAccessorBase::CopyElements() for details.
void CopyDoubleToObjectElements(Isolate* isolate,
                                Tagged<FixedArrayBase> from_base,
                                uint32_t from_start,
                                Tagged<FixedArrayBase> to_base,
                                uint32_t to_start, int raw_copy_size) {
  int copy_size = raw_copy_size;
  if (raw_copy_size < 0) {
    DisallowGarbageCollection no_gc;
    DCHECK_EQ(kCopyToEndAndInitializeToHole, raw_copy_size);
    copy_size = std::min(from_base->length() - from_start,
                         to_base->length() - to_start);
    // Also initialize the area that will be copied over since HeapNumber
    // allocation below can cause an incremental marking step, requiring all
    // existing heap objects to be propertly initialized.
    int start = to_start;
    int length = to_base->length() - start;
    if (length > 0) {
      MemsetTagged(Cast<FixedArray>(to_base)->RawFieldOfElementAt(start),
                   ReadOnlyRoots(isolate).the_hole_value(), length);
    }
  }

  DCHECK((copy_size + static_cast<int>(to_start)) <= to_base->length() &&
         (copy_size + static_cast<int>(from_start)) <= from_base->length());
  if (copy_size == 0) return;

  // From here on, the code below could actually allocate. Therefore the raw
  // values are wrapped into handles.
  DirectHandle<FixedDoubleArray> from(Cast<FixedDoubleArray>(from_base),
                                      isolate);
  DirectHandle<FixedArray> to(Cast<FixedArray>(to_base), isolate);

  // Use an outer loop to not waste too much time on creating HandleScopes.
  // On the other hand we might overflow a single handle scope depending on
  // the copy_size.
  int offset = 0;
  while (offset < copy_size) {
    HandleScope scope(isolate);
    offset += 100;
    for (int i = offset - 100; i < offset && i < copy_size; ++i) {
      DirectHandle<Object> value =
          FixedDoubleArray::get(*from, i + from_start, isolate);
      to->set(i + to_start, *value, UPDATE_WRITE_BARRIER);
    }
  }
}

void CopyDoubleToDoubleElements(Tagged<FixedArrayBase> from_base,
                                uint32_t from_start,
                                Tagged<FixedArrayBase> to_base,
                                uint32_t to_start, int raw_copy_size) {
  DisallowGarbageCollection no_gc;
  int copy_size = raw_copy_size;
  if (raw_copy_size < 0) {
    DCHECK_EQ(kCopyToEndAndInitializeToHole, raw_copy_size);
    copy_size = std::min(from_base->length() - from_start,
                         to_base->length() - to_start);
    for (int i = to_start + copy_size; i < to_base->length(); ++i) {
      Cast<FixedDoubleArray>(to_base)->set_the_hole(i);
    }
  }
  DCHECK((copy_size + static_cast<int>(to_start)) <= to_base->length() &&
         (copy_size + static_cast<int>(from_start)) <= from_base->length());
  if (copy_size == 0) return;
  Tagged<FixedDoubleArray> from = Cast<FixedDoubleArray>(from_base);
  Tagged<FixedDoubleArray> to = Cast<FixedDoubleArray>(to_base);
  Address to_address = reinterpret_cast<Address>(to->begin());
  Address from_address = reinterpret_cast<Address>(from->begin());
  to_address += kDoubleSize * to_start;
  from_address += kDoubleSize * from_start;
#ifdef V8_COMPRESS_POINTERS
  // TODO(ishell, v8:8875): we use CopyTagged() in order to avoid unaligned
  // access to double values in the arrays. This will no longed be necessary
  // once the allocations alignment issue is fixed.
  int words_per_double = (kDoubleSize / kTaggedSize);
  CopyTagged(to_address, from_address,
             static_cast<size_t>(words_per_double * copy_size));
#else
  int words_per_double = (kDoubleSize / kSystemPointerSize);
  CopyWords(to_address, from_address,
            static_cast<size_t>(words_per_double * copy_size));
#endif
}

void CopySmiToDoubleElements(Tagged<FixedArrayBase> from_base,
                             uint32_t from_start,
                             Tagged<FixedArrayBase> to_base, uint32_t to_start,
                             int raw_copy_size) {
  DisallowGarbageCollection no_gc;
  int copy_size = raw_copy_size;
  if (raw_copy_size < 0) {
    DCHECK_EQ(kCopyToEndAndInitializeToHole, raw_copy_size);
    copy_size = from_base->length() - from_start;
    for (int i = to_start + copy_size; i < to_base->length(); ++i) {
      Cast<FixedDoubleArray>(to_base)->set_the_hole(i);
    }
  }
  DCHECK((copy_size + static_cast<int>(to_start)) <= to_base->length() &&
         (copy_size + static_cast<int>(from_start)) <= from_base->length());
  if (copy_size == 0) return;
  Tagged<FixedArray> from = Cast<FixedArray>(from_base);
  Tagged<FixedDoubleArray> to = Cast<FixedDoubleArray>(to_base);
  Tagged<Object> the_hole = GetReadOnlyRoots().the_hole_value();
  for (uint32_t from_end = from_start + static_cast<uint32_t>(copy_size);
       from_start < from_end; from_start++, to_start++) {
    Tagged<Object> hole_or_smi = from->get(from_start);
    if (hole_or_smi == the_hole) {
      to->set_the_hole(to_start);
    } else {
      to->set(to_start, Smi::ToInt(hole_or_smi));
    }
  }
}

void CopyPackedSmiToDoubleElements(Tagged<FixedArrayBase> from_base,
                                   uint32_t from_start,
                                   Tagged<FixedArrayBase> to_base,
                                   uint32_t to_start, int packed_size,
                                   int raw_copy_size) {
  DisallowGarbageCollection no_gc;
  int copy_size = raw_copy_size;
  uint32_t to_end;
  if (raw_copy_size < 0) {
    DCHECK_EQ(kCopyToEndAndInitializeToHole, raw_copy_size);
    copy_size = packed_size - from_start;
    to_end = to_base->length();
    for (uint32_t i = to_start + copy_size; i < to_end; ++i) {
      Cast<FixedDoubleArray>(to_base)->set_the_hole(i);
    }
  } else {
    to_end = to_start + static_cast<uint32_t>(copy_size);
  }
  DCHECK(static_cast<int>(to_end) <= to_base->length());
  DCHECK(packed_size >= 0 && packed_size <= copy_size);
  DCHECK((copy_size + static_cast<int>(to_start)) <= to_base->length() &&
         (copy_size + static_cast<int>(from_start)) <= from_base->length());
  if (copy_size == 0) return;
  Tagged<FixedArray> from = Cast<FixedArray>(from_base);
  Tagged<FixedDoubleArray> to = Cast<FixedDoubleArray>(to_base);
  for (uint32_t from_end = from_start + static_cast<uint32_t>(packed_size);
       from_start < from_end; from_start++, to_start++) {
    Tagged<Object> smi = from->get(from_start);
    DCHECK(!IsTheHole(smi));
    to->set(to_start, Smi::ToInt(smi));
  }
}

void CopyObjectToDoubleElements(Tagged<FixedArrayBase> from_base,
                                uint32_t from_start,
                                Tagged<FixedArrayBase> to_base,
                                uint32_t to_start, int raw_copy_size) {
  DisallowGarbageCollection no_gc;
  int copy_size = raw_copy_size;
  if (raw_copy_size < 0) {
    DCHECK_EQ(kCopyToEndAndInitializeToHole, raw_copy_size);
    copy_size = from_base->length() - from_start;
    for (int i = to_start + copy_size; i < to_base->length(); ++i) {
      Cast<FixedDoubleArray>(to_base)->set_the_hole(i);
    }
  }
  DCHECK((copy_size + static_cast<int>(to_start)) <= to_base->length() &&
         (copy_size + static_cast<int>(from_start)) <= from_base->length());
  if (copy_size == 0) return;
  Tagged<FixedArray> from = Cast<FixedArray>(from_base);
  Tagged<FixedDoubleArray> to = Cast<FixedDoubleArray>(to_base);
  Tagged<Hole> the_hole = GetReadOnlyRoots().the_hole_value();
  for (uint32_t from_end = from_start + copy_size; from_start < from_end;
       from_start++, to_start++) {
    Tagged<Object> hole_or_object = from->get(from_start);
    if (hole_or_object == the_hole) {
      to->set_the_hole(to_start);
    } else {
      to->set(to_start, Object::NumberValue(Cast<Number>(hole_or_object)));
    }
  }
}

void CopyDictionaryToDoubleElements(Isolate* isolate,
                                    Tagged<FixedArrayBase> from_base,
                                    uint32_t from_start,
                                    Tagged<FixedArrayBase> to_base,
                                    uint32_t to_start, int raw_copy_size) {
  DisallowGarbageCollection no_gc;
  Tagged<NumberDictionary> from = Cast<NumberDictionary>(from_base);
  int copy_size = raw_copy_size;
  if (copy_size < 0) {
    DCHECK_EQ(kCopyToEndAndInitializeToHole, copy_size);
    copy_size = from->max_number_key() + 1 - from_start;
    for (int i = to_start + copy_size; i < to_base->length(); ++i) {
      Cast<FixedDoubleArray>(to_base)->set_the_hole(i);
    }
  }
  if (copy_size == 0) return;
  Tagged<FixedDoubleArray> to = Cast<FixedDoubleArray>(to_base);
  uint32_t to_length = to->length();
  if (to_start + copy_size > to_length) {
    copy_size = to_length - to_start;
  }
  for (int i = 0; i < copy_size; i++) {
    InternalIndex entry = from->FindEntry(isolate, i + from_start);
    if (entry.is_found()) {
      to->set(i + to_start,
              Object::NumberValue(Cast<Number>(from->ValueAt(entry))));
    } else {
      to->set_the_hole(i + to_start);
    }
  }
}

void SortIndices(Isolate* isolate, DirectHandle<FixedArray> indices,
                 uint32_t sort_size) {
  if (sort_size == 0) return;

  // Use AtomicSlot wrapper to ensure that std::sort uses atomic load and
  // store operations that are safe for concurrent marking.
  AtomicSlot start(indices->RawFieldOfFirstElement());
  AtomicSlot end(start + sort_size);
  std::sort(start, end, |isolate](Tagged_t elementA, Tagged_t elementB) {
#ifdef V8_COMPRESS_POINTERS
    Tagged<Object> a(
        V8HeapCompressionScheme::DecompressTagged(isolate, elementA));
    Tagged<Object> b(
        V8HeapCompressionScheme::DecompressTagged(isolate, elementB));
#else
    Tagged<Object> a(elementA);
    Tagged<Object> b(elementB);
#endif
    if (IsSmi(a) || !IsUndefined(a, isolate)) {
      if (!IsSmi(b) && IsUndefined(b, isolate)) {
        return true;
      }
      return Object::NumberValue(Cast<Number>(a)) <
             Object::NumberValue(Cast<Number>(b));
    }
    return !IsSmi(b) && IsUndefined(b, isolate);
  });
  WriteBarrier::ForRange(isolate->heap(), *indices, ObjectSlot(start),
                         ObjectSlot(end));
}

Maybe<bool> IncludesValueSlowPath(Isolate* isolate,
                                  DirectHandle<JSObject> receiver,
                                  DirectHandle<Object> value, size_t start_from,
                                  size_t length) {
  bool search_for_hole = IsUndefined(*value, isolate);
  for (size_t k = start_from; k < length; ++k) {
    LookupIterator it(isolate, receiver, k);
    if (!it.IsFound()) {
      if (search_for_hole) return Just(true);
      continue;
    }
    DirectHandle<Object> element_k;
    ASSIGN_RETURN_ON_EXCEPTION_VALUE(isolate, element_k,
                                     Object::GetProperty(&it), Nothing<bool>());

    if (Object::SameValueZero(*value, *element_k)) return Just(true);
  }

  return Just(false);
}

Maybe<int64_t> IndexOfValueSlowPath(Isolate* isolate,
                                    DirectHandle<JSObject> receiver,
                                    DirectHandle<Object> value,
                                    size_t start_from, size_t length) {
  for (size_t k = start_from; k < length; ++k) {
    LookupIterator it(isolate, receiver, k);
    if (!it.IsFound()) {
      continue;
    }
    DirectHandle<Object> element_k;
    ASSIGN_RETURN_ON_EXCEPTION_VALUE(
        isolate, element_k, Object::GetProperty(&it), Nothing<int64_t>());

    if (Object::StrictEquals(*value, *element_k)) return Just<int64_t>(k);
  }

  return Just<int64_t>(-1);
}

// The InternalElementsAccessor is a helper class to expose otherwise protected
// methods to its subclasses. Namely, we don't want to publicly expose methods
// that take an entry (instead of an index) as an argument.
class InternalElementsAccessor : public ElementsAccessor {
 public:
  InternalIndex GetEntryForIndex(Isolate* isolate, Tagged<JSObject> holder,
                                 Tagged<FixedArrayBase> backing_store,
                                 size_t index) override = 0;

  PropertyDetails GetDetails(Tagged<JSObject> holder,
                             InternalIndex entry) override = 0;
};

// Base class for element handler implementations. Contains the
// the common logic for objects with different ElementsKinds.
// Subclasses must specialize method for which the element
// implementation differs from the base class implementation.
//
// This class is intended to be used in the following way:
//
//   class SomeElementsAccessor :
//       public ElementsAccessorBase<SomeElementsAccessor,
//                                   BackingStoreClass> {
//     ...
//   }
//
// This is an example of the Curiously Recurring Template Pattern (see
// http://en.wikipedia.org/wiki/Curiously_recurring_template_pattern).  We use
// CRTP to guarantee aggressive compile time optimizations (i.e.  inlining and
// specialization of SomeElementsAccessor methods).
template <typename Subclass, typename ElementsTraitsParam>
class ElementsAccessorBase : public InternalElementsAccessor {
 public:
  ElementsAccessorBase() = default;
  ElementsAccessorBase(const ElementsAccessorBase&) = delete;
  ElementsAccessorBase& operator=(const ElementsAccessorBase&) = delete;

  using ElementsTraits = ElementsTraitsParam;
  using BackingStore = typename ElementsTraitsParam::BackingStore;

  static ElementsKind kind() { return ElementsTraits::Kind; }

  static void ValidateContents(Tagged<JSObject> holder, size_t length) {}

  static void ValidateImpl(Tagged<JSObject> holder) {
    Tagged<FixedArrayBase> fixed_array_base = holder->elements();
    if (!IsHeapObject(fixed_array_base)) return;
    // Arrays that have been shifted in place can't be verified.
    if (IsFreeSpaceOrFiller(fixed_array_base)) return;
    size_t length = 0;
    if (IsJSArray(holder)) {
      Tagged<Object> length_obj = Cast<JSArray>(holder)->length();
      if (IsSmi(length_obj)) {
        length = Smi::ToInt(length_obj);
      }
    } else if (IsJSTypedArray(holder)) {
      length = Cast<JSTypedArray>(holder)->GetLength();
    } else {
      length = fixed_array_base->length();
    }
    Subclass::ValidateContents(holder, length);
  }

  void Validate(Tagged<JSObject> holder) final {
    DisallowGarbageCollection no_gc;
    Subclass::ValidateImpl(holder);
  }

  bool HasElement(Tagged<JSObject> holder, uint32_t index,
                  Tagged<FixedArrayBase> backing_store,
                  PropertyFilter filter) final {
    return Subclass::HasElementImpl(holder->GetIsolate(), holder, index,
                                    backing_store, filter);
  }

  static bool HasElementImpl(Isolate* isolate, Tagged<JSObject> holder,
                             size_t index, Tagged<FixedArrayBase> backing_store,
                             PropertyFilter filter = ALL_PROPERTIES) {
    return Subclass::GetEntryForIndexImpl(isolate, holder, backing_store, index,
                                          filter)
        .is_found();
  }

  bool HasEntry(Tagged<JSObject> holder, InternalIndex entry) final {
    return Subclass::HasEntryImpl(holder->GetIsolate(), holder->elements(),
                                  entry);
  }

  static bool HasEntryImpl(Isolate* isolate,
                           Tagged<FixedArrayBase> backing_store,
                           InternalIndex entry) {
    UNIMPLEMENTED();
  }

  bool HasAccessors(Tagged<JSObject> holder) final {
    return Subclass::HasAccessorsImpl(holder, holder->elements());
  }

  static bool HasAccessorsImpl(Tagged<JSObject> holder,
                               Tagged<FixedArrayBase> backing_store) {
    return false;
  }

  Handle<Object> Get(Isolate* isolate, DirectHandle<JSObject> holder,
                     InternalIndex entry) final {
    return Subclass::GetInternalImpl(isolate, holder, entry);
  }

  static Handle<Object> GetInternalImpl(Isolate* isolate,
                                        DirectHandle<JSObject> holder,
                                        InternalIndex entry) {
    return Subclass::GetImpl(isolate, holder->elements(), entry);
  }

  static Handle<Object> GetImpl(Isolate* isolate,
                                Tagged<FixedArrayBase> backing_store,
                                InternalIndex entry) {
    return handle(Cast<BackingStore>(backing_store)->get(entry.as_int()),
                  isolate);
  }

  Handle<Object> GetAtomic(Isolate* isolate, DirectHandle<JSObject> holder,
                           InternalIndex entry, SeqCstAccessTag tag) final {
    return Subclass::GetAtomicInternalImpl(isolate, holder->elements(), entry,
                                           tag);
  }

  static Handle<Object> GetAtomicInternalImpl(
      Isolate* isolate, Tagged<FixedArrayBase> backing_store,
      InternalIndex entry, SeqCstAccessTag tag) {
    UNREACHABLE();
  }

  void SetAtomic(DirectHandle<JSObject> holder, InternalIndex entry,
                 Tagged<Object> value, SeqCstAccessTag tag) final {
    Subclass::SetAtomicInternalImpl(holder->elements(), entry, value, tag);
  }

  static void SetAtomicInternalImpl(Tagged<FixedArrayBase> backing_store,
                                    InternalIndex entry, Tagged<Object> value,
                                    SeqCstAccessTag tag) {
    UNREACHABLE();
  }

  Handle<Object> SwapAtomic(Isolate* isolate, DirectHandle<JSObject> holder,
                            InternalIndex entry, Tagged<Object> value,
                            SeqCstAccessTag tag) final {
    return Subclass::SwapAtomicInternalImpl(isolate, holder->elements(), entry,
                                            value, tag);
  }

  static Handle<Object> SwapAtomicInternalImpl(
      Isolate* isolate, Tagged<FixedArrayBase> backing_store,
      InternalIndex entry, Tagged<Object> value, SeqCstAccessTag tag) {
    UNREACHABLE();
  }

  Handle<Object> CompareAndSwapAtomic(Isolate* isolate,
                                      DirectHandle<JSObject> holder,
                                      InternalIndex entry,
                                      Tagged<Object> expected,
                                      Tagged<Object> value,
                                      SeqCstAccessTag tag) final {
    return handle(HeapObject::SeqCst_CompareAndSwapField(
                      expected, value,
                      |=](Tagged<Object> expected_value,
                          Tagged<Object> new_value) {
                        return Subclass::CompareAndSwapAtomicInternalImpl(
                            holder->elements(), entry, expected_value,
                            new_value, tag);
                      }),
                  isolate);
  }

  static Tagged<Object> CompareAndSwapAtomicInternalImpl(
      Tagged<FixedArrayBase> backing_store, InternalIndex entry,
      Tagged<Object> expected, Tagged<Object> value, SeqCstAccessTag tag) {
    UNREACHABLE();
  }

  void Set(DirectHandle<JSObject> holder, InternalIndex entry,
           Tagged<Object> value) final {
    Subclass::SetImpl(holder, entry, value);
  }

  void Reconfigure(DirectHandle<JSObject> object,
                   DirectHandle<FixedArrayBase> store, InternalIndex entry,
                   DirectHandle<Object> value,
                   PropertyAttributes attributes) final {
    Subclass::ReconfigureImpl(object, store, entry, value, attributes);
  }

  static void ReconfigureImpl(DirectHandle<JSObject> object,
                              DirectHandle<FixedArrayBase> store,
                              InternalIndex entry, DirectHandle<Object> value,
                              PropertyAttributes attributes) {
    UNREACHABLE();
  }

  Maybe<bool> Add(DirectHandle<JSObject> object, uint32_t index,
                  DirectHandle<Object> value, PropertyAttributes attributes,
                  uint32_t new_capacity) final {
    return Subclass::AddImpl(object, index, value, attributes, new_capacity);
  }

  static Maybe<bool> AddImpl(DirectHandle<JSObject> object, uint32_t index,
                             DirectHandle<Object> value,
                             PropertyAttributes attributes,
                             uint32_t new_capacity) {
    UNREACHABLE();
  }

  Maybe<uint32_t> Push(DirectHandle<JSArray> receiver, BuiltinArguments* args,
                       uint32_t push_size) final {
    return Subclass::PushImpl(receiver, args, push_size);
  }

  static Maybe<uint32_t> PushImpl(DirectHandle<JSArray> receiver,
                                  BuiltinArguments* args, uint32_t push_sized) {
    UNREACHABLE();
  }

  Maybe<uint32_t> Unshift(DirectHandle<JSArray> receiver,
                          BuiltinArguments* args, uint32_t unshift_size) final {
    return Subclass::UnshiftImpl(receiver, args, unshift_size);
  }

  static Maybe<uint32_t> UnshiftImpl(DirectHandle<JSArray> receiver,
                                     BuiltinArguments* args,
                                     uint32_t unshift_size) {
    UNREACHABLE();
  }

  MaybeDirectHandle<Object> Pop(DirectHandle<JSArray> receiver) final {
    return Subclass::PopImpl(receiver);
  }

  static MaybeDirectHandle<Object> PopImpl(DirectHandle<JSArray> receiver) {
    UNREACHABLE();
  }

  MaybeDirectHandle<Object> Shift(DirectHandle<JSArray> receiver) final {
    return Subclass::ShiftImpl(receiver);
  }

  static MaybeDirectHandle<Object> ShiftImpl(DirectHandle<JSArray> receiver) {
    UNREACHABLE();
  }

  Maybe<bool> SetLength(DirectHandle<JSArray> array, uint32_t length) final {
    return Subclass::SetLengthImpl(
        array->GetIsolate(), array, length,
        direct_handle(array->elements(), array->GetIsolate()));
  }

  static Maybe<bool> SetLengthImpl(Isolate* isolate,
                                   DirectHandle<JSArray> array, uint32_t length,
                                   DirectHandle<FixedArrayBase> backing_store) {
    DCHECK(!array->SetLengthWouldNormalize(length));
    DCHECK(IsFastElementsKind(array->GetElementsKind()));
    uint32_t old_length = 0;
    CHECK(Object::ToArrayIndex(array->length(), &old_length));

    if (old_length < length) {
      ElementsKind kind = array->GetElementsKind();
      if (!IsHoleyElementsKind(kind)) {
        kind = GetHoleyElementsKind(kind);
        JSObject::TransitionElementsKind(array, kind);
      }
    }

    // Check whether the backing store should be shrunk.
    uint32_t capacity = backing_store->length();
    old_length = std::min(old_length, capacity);
    if (length == 0) {
      array->initialize_elements();
    } else if (length <= capacity) {
      if (IsSmiOrObjectElementsKind(kind())) {
        JSObject::EnsureWritableFastElements(array);
        if (array->elements() != *backing_store) {
          backing_store = direct_handle(array->elements(), isolate);
        }
      }
      if (2 * length + JSObject::kMinAddedElementsCapacity <= capacity) {
        // If more than half the elements won't be used, trim the array.
        // Do not trim from short arrays to prevent frequent trimming on
        // repeated pop operations.
        // Leave some space to allow for subsequent push operations.
        uint32_t new_capacity =
            length + 1 == old_length ? (capacity + length) / 2 : length;
        DCHECK_LT(new_capacity, capacity);
        isolate->heap()->RightTrimArray(Cast<BackingStore>(*backing_store),
                                        new_capacity, capacity);
        // Fill the non-trimmed elements with holes.
        Cast<BackingStore>(*backing_store)
            ->FillWithHoles(length, std::min(old_length, new_capacity));
      } else {
        // Otherwise, fill the unused tail with holes.
        Cast<BackingStore>(*backing_store)->FillWithHoles(length, old_length);
      }
    } else {
      // Check whether the backing store should be expanded.
      capacity = std::max(length, JSObject::NewElementsCapacity(capacity));
      MAYBE_RETURN(Subclass::GrowCapacityAndConvertImpl(array, capacity),
                   Nothing<bool>());
    }

    array->set_length(Smi::FromInt(length));
    JSObject::ValidateElements(*array);
    return Just(true);
  }

  size_t NumberOfElements(Isolate* isolate, Tagged<JSObject> receiver) final {
    return Subclass::NumberOfElementsImpl(isolate, receiver,
                                          receiver->elements());
  }

  static uint32_t NumberOfElementsImpl(Isolate* isolate,
                                       Tagged<JSObject> receiver,
                                       Tagged<FixedArrayBase> backing_store) {
    UNREACHABLE();
  }

  static size_t GetMaxIndex(Tagged<JSObject> receiver,
                            Tagged<FixedArrayBase> elements) {
    if (IsJSArray(receiver)) {
      DCHECK(IsSmi(Cast<JSArray>(receiver)->length()));
      return static_cast<uint32_t>(
          Smi::ToInt(Cast<JSArray>(receiver)->length()));
    }
    return Subclass::GetCapacityImpl(receiver, elements);
  }

  static size_t GetMaxNumberOfEntries(Isolate* isolate,
                                      Tagged<JSObject> receiver,
                                      Tagged<FixedArrayBase> elements) {
    return Subclass::GetMaxIndex(receiver, elements);
  }

  static MaybeDirectHandle<FixedArrayBase> ConvertElementsWithCapacity(
      DirectHandle<JSObject> object, DirectHandle<FixedArrayBase> old_elements,
      ElementsKind from_kind, uint32_t capacity) {
    return ConvertElementsWithCapacity(object, old_elements, from_kind,
                                       capacity, 0, 0);
  }

  static MaybeDirectHandle<FixedArrayBase> ConvertElementsWithCapacity(
      DirectHandle<JSObject> object, DirectHandle<FixedArrayBase> old_elements,
      ElementsKind from_kind, uint32_t capacity, uint32_t src_index,
      uint32_t dst_index) {
    Isolate* isolate = object->GetIsolate();
    DirectHandle<FixedArrayBase> new_elements;
    // TODO(victorgomes): Retrieve native context in optimized code
    // and remove the check isolate->context().is_null().
    if (IsDoubleElementsKind(kind())) {
      if (!isolate->context().is_null() &&
          !base::IsInRange(capacity, 0, FixedDoubleArray::kMaxLength)) {
        THROW_NEW_ERROR(isolate,
                        NewRangeError(MessageTemplate::kInvalidArrayLength));
      }
      new_elements = isolate->factory()->NewFixedDoubleArray(capacity);
    } else {
      if (!isolate->context().is_null() &&
          !base::IsInRange(capacity, 0, FixedArray::kMaxLength)) {
        THROW_NEW_ERROR(isolate,
                        NewRangeError(MessageTemplate::kInvalidArrayLength));
      }
      new_elements = isolate->factory()->NewFixedArray(capacity);
    }

    int packed_size = kPackedSizeNotKnown;
    if (IsFastPackedElementsKind(from_kind) && IsJSArray(*object)) {
      packed_size = Smi::ToInt(Cast<JSArray>(*object)->length());
    }

    Subclass::CopyElementsImpl(isolate, *old_elements, src_index, *new_elements,
                               from_kind, dst_index, packed_size,
                               kCopyToEndAndInitializeToHole);

    return MaybeDirectHandle<FixedArrayBase>(new_elements);
  }

  static Maybe<bool> TransitionElementsKindImpl(DirectHandle<JSObject> object,
                                                DirectHandle<Map> to_map) {
    Isolate* isolate = object->GetIsolate();
    DirectHandle<Map> from_map(object->map(), isolate);
    ElementsKind from_kind = from_map->elements_kind();
    ElementsKind to_kind = to_map->elements_kind();
    if (IsHoleyElementsKind(from_kind)) {
      to_kind = GetHoleyElementsKind(to_kind);
    }
    if (from_kind != to_kind) {
      // This method should never be called for any other case.
      DCHECK(IsFastElementsKind(from_kind));
      DCHECK(IsFastElementsKind(to_kind));
      DCHECK_NE(TERMINAL_FAST_ELEMENTS_KIND, from_kind);

      DirectHandle<FixedArrayBase> from_elements(object->elements(), isolate);
      if (object->elements() == ReadOnlyRoots(isolate).empty_fixed_array() ||
          IsDoubleElementsKind(from_kind) == IsDoubleElementsKind(to_kind)) {
        // No change is needed to the elements() buffer, the transition
        // only requires a map change.
        JSObject::MigrateToMap(isolate, object, to_map);
      } else {
        DCHECK(
            (IsSmiElementsKind(from_kind) && IsDoubleElementsKind(to_kind)) ||
            (IsDoubleElementsKind(from_kind) && IsObjectElementsKind(to_kind)));
        uint32_t capacity = static_cast<uint32_t>(object->elements()->length());
        DirectHandle<FixedArrayBase> elements;
        ASSIGN_RETURN_ON_EXCEPTION_VALUE(
            object->GetIsolate(), elements,
            ConvertElementsWithCapacity(object, from_elements, from_kind,
                                        capacity),
            Nothing<bool>());
        JSObject::SetMapAndElements(object, to_map, elements);
      }
      if (v8_flags.trace_elements_transitions) {
        JSObject::PrintElementsTransition(
            stdout, object, from_kind, from_elements, to_kind,
            direct_handle(object->elements(), isolate));
      }
    }
    return Just(true);
  }

  static Maybe<bool> GrowCapacityAndConvertImpl(DirectHandle<JSObject> object,
                                                uint32_t capacity) {
    ElementsKind from_kind = object->GetElementsKind();
    if (IsSmiOrObjectElementsKind(from_kind)) {
      // Array optimizations rely on the prototype lookups of Array objects
      // always returning undefined. If there is a store to the initial
      // prototype object, make sure all of these optimizations are invalidated.
      object->GetIsolate()->UpdateNoElementsProtectorOnSetLength(object);
    }
    DirectHandle<FixedArrayBase> old_elements(object->elements(),
                                              object->GetIsolate());
    // This method should only be called if there's a reason to update the
    // elements.
    DCHECK(IsDoubleElementsKind(from_kind) != IsDoubleElementsKind(kind()) ||
           IsDictionaryElementsKind(from_kind) ||
           static_cast<uint32_t>(old_elements->length()) < capacity);
    return Subclass::BasicGrowCapacityAndConvertImpl(
        object, old_elements, from_kind, kind(), capacity);
  }

  static Maybe<bool> BasicGrowCapacityAndConvertImpl(
      DirectHandle<JSObject> object, DirectHandle<FixedArrayBase> old_elements,
      ElementsKind from_kind, ElementsKind to_kind, uint32_t capacity) {
    DirectHandle<FixedArrayBase> elements;
    ASSIGN_RETURN_ON_EXCEPTION_VALUE(
        object->GetIsolate(), elements,
        ConvertElementsWithCapacity(object, old_elements, from_kind, capacity),
        Nothing<bool>());

    if (IsHoleyElementsKind(from_kind)) {
      to_kind = GetHoleyElementsKind(to_kind);
    }
    DirectHandle<Map> new_map =
        JSObject::GetElementsTransitionMap(object, to_kind);
    JSObject::SetMapAndElements(object, new_map, elements);

    // Transition through the allocation site as well if present.
    JSObject::UpdateAllocationSite(object, to_kind);

    if (v8_flags.trace_elements_transitions) {
      JSObject::PrintElementsTransition(stdout, object, from_kind, old_elements,
                                        to_kind, elements);
    }
    return Just(true);
  }

  Maybe<bool> TransitionElementsKind(DirectHandle<JSObject> object,
                                     DirectHandle<Map> map) final {
    return Subclass::TransitionElementsKindImpl(object, map);
  }

  Maybe<bool> GrowCapacityAndConvert(DirectHandle<JSObject> object,
                                     uint32_t capacity) final {
    return Subclass::GrowCapacityAndConvertImpl(object, capacity);
  }

  Maybe<bool> GrowCapacity(DirectHandle<JSObject> object,
                           uint32_t index) final {
    // This function is intended to be called from optimized code. We don't
    // want to trigger lazy deopts there, so refuse to handle cases that would.
    if (object->map()->is_prototype_map() ||
        object->WouldConvertToSlowElements(index)) {
      return Just(false);
    }
    DirectHandle<FixedArrayBase> old_elements(object->elements(),
                                              object->GetIsolate());
    uint32_t new_capacity = JSObject::NewElementsCapacity(index + 1);
    DCHECK(static_cast<uint32_t>(old_elements->length()) < new_capacity);
    const uint32_t kMaxLength = IsDoubleElementsKind(kind())
                                    ? FixedDoubleArray::kMaxLength
                                    : FixedArray::kMaxLength;
    if (new_capacity > kMaxLength) {
      return Just(false);
    }
    DirectHandle<FixedArrayBase> elements;
    ASSIGN_RETURN_ON_EXCEPTION_VALUE(
        object->GetIsolate(), elements,
        ConvertElementsWithCapacity(object, old_elements, kind(), new_capacity),
        Nothing<bool>());

    DCHECK_EQ(object->GetElementsKind(), kind());
    // Transition through the allocation site as well if present.
    if (JSObject::UpdateAllocationSite<AllocationSiteUpdateMode::kCheckOnly>(
            object, kind())) {
      return Just(false);
    }

    object->set_elements(*elements);
    return Just(true);
  }

  void Delete(DirectHandle<JSObject> obj, InternalIndex entry) final {
    Subclass::DeleteImpl(obj, entry);
  }

  static void CopyElementsImpl(Isolate* isolate, Tagged<FixedArrayBase> from,
                               uint32_t from_start, Tagged<FixedArrayBase> to,
                               ElementsKind from_kind, uint32_t to_start,
                               int packed_size, int copy_size) {
    UNREACHABLE();
  }

  void CopyElements(Isolate* isolate, Tagged<JSObject> from_holder,
                    uint32_t from_start, ElementsKind from_kind,
                    DirectHandle<FixedArrayBase> to, uint32_t to_start,
                    int copy_size) final {
    int packed_size = kPackedSizeNotKnown;
    bool is_packed =
        IsFastPackedElementsKind(from_kind) && IsJSArray(from_holder);
    if (is_packed) {
      packed_size = Smi::ToInt(Cast<JSArray>(from_holder)->length());
      if (copy_size >= 0 && packed_size > copy_size) {
        packed_size = copy_size;
      }
    }
    Tagged<FixedArrayBase> from = from_holder->elements();
    // NOTE: the Subclass::CopyElementsImpl() methods
    // violate the handlified function signature convention:
    // raw pointer parameters in the function that allocates. This is done
    // intentionally to avoid ArrayConcat() builtin performance degradation.
    //
    // Details: The idea is that allocations actually happen only in case of
    // copying from object with fast double elements to object with object
    // elements. In all the other cases there are no allocations performed and
    // handle creation causes noticeable performance degradation of the builtin.
    Subclass::CopyElementsImpl(isolate, from, from_start, *to, from_kind,
                               to_start, packed_size, copy_size);
  }

  void CopyElements(Isolate* isolate, DirectHandle<FixedArrayBase> source,
                    ElementsKind source_kind,
                    DirectHandle<FixedArrayBase> destination,
                    int size) override {
    Subclass::CopyElementsImpl(isolate, *source, 0, *destination, source_kind,
                               0, kPackedSizeNotKnown, size);
  }

  void CopyTypedArrayElementsSlice(Tagged<JSTypedArray> source,
                                   Tagged<JSTypedArray> destination,
                                   size_t start, size_t end) override {
    Subclass::CopyTypedArrayElementsSliceImpl(source, destination, start, end);
  }

  static void CopyTypedArrayElementsSliceImpl(Tagged<JSTypedArray> source,
                                              Tagged<JSTypedArray> destination,
                                              size_t start, size_t end) {
    UNREACHABLE();
  }

  Tagged<Object> CopyElements(DirectHandle<JSAny> source,
                              DirectHandle<JSObject> destination, size_t length,
                              size_t offset) final {
    return Subclass::CopyElementsHandleImpl(source, destination, length,
                                            offset);
  }

  static Tagged<Object> CopyElementsHandleImpl(
      DirectHandle<Object> source, DirectHandle<JSObject> destination,
      size_t length, size_t offset) {
    UNREACHABLE();
  }

  DirectHandle<NumberDictionary> Normalize(
      DirectHandle<JSObject> object) final {
    return Subclass::NormalizeImpl(
        object, direct_handle(object->elements(), object->GetIsolate()));
  }

  static DirectHandle<NumberDictionary> NormalizeImpl(
      DirectHandle<JSObject> object, DirectHandle<FixedArrayBase> elements) {
    UNREACHABLE();
  }

  Maybe<bool> CollectValuesOrEntries(Isolate* isolate,
                                     DirectHandle<JSObject> object,
                                     DirectHandle<FixedArray> values_or_entries,
                                     bool get_entries, int* nof_items,
                                     PropertyFilter filter) override {
    return Subclass::CollectValuesOrEntriesImpl(
        isolate, object, values_or_entries, get_entries, nof_items, filter);
  }

  static Maybe<bool> CollectValuesOrEntriesImpl(
      Isolate* isolate, DirectHandle<JSObject> object,
      DirectHandle<FixedArray> values_or_entries, bool get_entries,
      int* nof_items, PropertyFilter filter) {
    DCHECK_EQ(*nof_items, 0);
    KeyAccumulator accumulator(isolate, KeyCollectionMode::kOwnOnly,
                               ALL_PROPERTIES);
    RETURN_NOTHING_IF_NOT_SUCCESSFUL(Subclass::CollectElementIndicesImpl(
        object, direct_handle(object->elements(), isolate), &accumulator));
    DirectHandle<FixedArray> keys = accumulator.GetKeys();

    int count = 0;
    int i = 0;
    ElementsKind original_elements_kind = object->GetElementsKind();

    for (; i < keys->length(); ++i) {
      DirectHandle<Object> key(keys->get(i), isolate);
      uint32_t index;
      if (!Object::ToUint32(*key, &index)) continue;

      DCHECK_EQ(object->GetElementsKind(), original_elements_kind);
      InternalIndex entry = Subclass::GetEntryForIndexImpl(
          isolate, *object, object->elements(), index, filter);
      if (entry.is_not_found()) continue;
      PropertyDetails details = Subclass::GetDetailsImpl(*object, entry);

      DirectHandle<Object> value;
      if (details.kind() == PropertyKind::kData) {
        value = Subclass::GetInternalImpl(isolate, object, entry);
      } else {
        // This might modify the elements and/or change the elements kind.
        LookupIterator it(isolate, object, index, LookupIterator::OWN);
        ASSIGN_RETURN_ON_EXCEPTION_VALUE(
            isolate, value, Object::GetProperty(&it), Nothing<bool>());
      }
      if (get_entries) value = MakeEntryPair(isolate, index, value);
      values_or_entries->set(count++, *value);
      if (object->GetElementsKind() != original_elements_kind) break;
    }

    // Slow path caused by changes in elements kind during iteration.
    for (; i < keys->length(); i++) {
      DirectHandle<Object> key(keys->get(i), isolate);
      uint32_t index;
      if (!Object::ToUint32(*key, &index)) continue;

      if (filter & ONLY_ENUMERABLE) {
        InternalElementsAccessor* accessor =
            reinterpret_cast<InternalElementsAccessor*>(
                object->GetElementsAccessor());
        InternalIndex entry = accessor->GetEntryForIndex(
            isolate, *object, object->elements(), index);
        if (entry.is_not_found()) continue;
        PropertyDetails details = accessor->GetDetails(*object, entry);
        if (!details.IsEnumerable()) continue;
      }

      DirectHandle<Object> value;
      LookupIterator it(isolate, object, index, LookupIterator::OWN);
      ASSIGN_RETURN_ON_EXCEPTION_VALUE(isolate, value, Object::GetProperty(&it),
                                       Nothing<bool>());

      if (get_entries) value = MakeEntryPair(isolate, index, value);
      values_or_entries->set(count++, *value);
    }

    *nof_items = count;
    return Just(true);
  }

  V8_WARN_UNUSED_RESULT ExceptionStatus CollectElementIndices(
      DirectHandle<JSObject> object, DirectHandle<FixedArrayBase> backing_store,
      KeyAccumulator* keys) final {
    return Subclass::CollectElementIndicesImpl(object, backing_store, keys);
  }

  V8_WARN_UNUSED_RESULT static ExceptionStatus CollectElementIndicesImpl(
      DirectHandle<JSObject> object, DirectHandle<FixedArrayBase> backing_store,
      KeyAccumulator* keys) {
    DCHECK_NE(DICTIONARY_ELEMENTS, kind());
    // Non-dictionary elements can't have all-can-read accessors.
    size_t length = Subclass::GetMaxIndex(*object, *backing_store);
    PropertyFilter filter = keys->filter();
    Isolate* isolate = keys->isolate();
    Factory* factory = isolate->factory();
    for (size_t i = 0; i < length; i++) {
      if (Subclass::HasElementImpl(isolate, *object, i, *backing_store,
                                   filter)) {
        RETURN_FAILURE_IF_NOT_SUCCESSFUL(
            keys->AddKey(factory->NewNumberFromSize(i)));
      }
    }
    return ExceptionStatus::kSuccess;
  }

  static Handle<FixedArray> DirectCollectElementIndicesImpl(
      Isolate* isolate, DirectHandle<JSObject> object,
      DirectHandle<FixedArrayBase> backing_store, GetKeysConversion convert,
      PropertyFilter filter, Handle<FixedArray> list, uint32_t* nof_indices,
      uint32_t insertion_index = 0) {
    size_t length = Subclass::GetMaxIndex(*object, *backing_store);
    uint32_t const kMaxStringTableEntries =
        isolate->heap()->MaxNumberToStringCacheSize();
    for (size_t i = 0; i < length; i++) {
      if (Subclass::HasElementImpl(isolate, *object, i, *backing_store,
                                   filter)) {
        if (convert == GetKeysConversion::kConvertToString) {
          bool use_cache = i < kMaxStringTableEntries;
          DirectHandle<String> index_string =
              isolate->factory()->SizeToString(i, use_cache);
          list->set(insertion_index, *index_string);
        } else {
          DirectHandle<Object> number =
              isolate->factory()->NewNumberFromSize(i);
          list->set(insertion_index, *number);
        }
        insertion_index++;
      }
    }
    *nof_indices = insertion_index;
    return list;
  }

  MaybeHandle<FixedArray> PrependElementIndices(
      Isolate* isolate, DirectHandle<JSObject> object,
      DirectHandle<FixedArrayBase> backing_store, DirectHandle<FixedArray> keys,
      GetKeysConversion convert, PropertyFilter filter) final {
    return Subclass::PrependElementIndicesImpl(isolate, object, backing_store,
                                               keys, convert, filter);
  }

  static MaybeHandle<FixedArray> PrependElementIndicesImpl(
      Isolate* isolate, DirectHandle<JSObject> object,
      DirectHandle<FixedArrayBase> backing_store, DirectHandle<FixedArray> keys,
      GetKeysConversion convert, PropertyFilter filter) {
    uint32_t nof_property_keys = keys->length();
    size_t initial_list_length =
        Subclass::GetMaxNumberOfEntries(isolate, *object, *backing_store);

    if (initial_list_length > FixedArray::kMaxLength - nof_property_keys) {
      THROW_NEW_ERROR(isolate,
                      NewRangeError(MessageTemplate::kInvalidArrayLength));
    }
    initial_list_length += nof_property_keys;

    // Collect the element indices into a new list.
    DCHECK_LE(initial_list_length, std::numeric_limits<int>::max());
    MaybeHandle<FixedArray> raw_array = isolate->factory()->TryNewFixedArray(
        static_cast<int>(initial_list_length));
    Handle<FixedArray> combined_keys;

    // If we have a holey backing store try to precisely estimate the backing
    // store size as a last emergency measure if we cannot allocate the big
    // array.
    if (!raw_array.ToHandle(&combined_keys)) {
      if (IsHoleyOrDictionaryElementsKind(kind())) {
        // If we overestimate the result list size we might end up in the
        // large-object space which doesn't free memory on shrinking the list.
        // Hence we try to estimate the final size for holey backing stores more
        // precisely here.
        initial_list_length =
            Subclass::NumberOfElementsImpl(isolate, *object, *backing_store);
        initial_list_length += nof_property_keys;
      }
      DCHECK_LE(initial_list_length, std::numeric_limits<int>::max());
      combined_keys = isolate->factory()->NewFixedArray(
          static_cast<int>(initial_list_length));
    }

    uint32_t nof_indices = 0;
    bool needs_sorting = IsDictionaryElementsKind(kind()) ||
                         IsSloppyArgumentsElementsKind(kind());
    combined_keys = Subclass::DirectCollectElementIndicesImpl(
        isolate, object, backing_store,
        needs_sorting ? GetKeysConversion::kKeepNumbers : convert, filter,
        combined_keys, &nof_indices);

    if (needs_sorting) {
      SortIndices(isolate, combined_keys, nof_indices);
      // Indices from dictionary elements should only be converted after
      // sorting.
      if (convert == GetKeysConversion::kConvertToString) {
        for (uint32_t i = 0; i < nof_indices; i++) {
          DirectHandle<Object> index_string =
              isolate->factory()->Uint32ToString(
                  Object::NumberValue(combined_keys->get(i)));
          combined_keys->set(i, *index_string);
        }
      }
    }

    // Copy over the passed-in property keys.
    CopyObjectToObjectElements(isolate, *keys, PACKED_ELEMENTS, 0,
                               *combined_keys, PACKED_ELEMENTS, nof_indices,
                               nof_property_keys);

    // For holey elements and arguments we might have to shrink the collected
    // keys since the estimates might be off.
    if (IsHoleyOrDictionaryElementsKind(kind()) ||
        IsSloppyArgumentsElementsKind(kind())) {
      // Shrink combined_keys to the final size.
      int final_size = nof_indices + nof_property_keys;
      DCHECK_LE(final_size, combined_keys->length());
      return FixedArray::RightTrimOrEmpty(isolate, combined_keys, final_size);
    }

    return combined_keys;
  }

  V8_WARN_UNUSED_RESULT ExceptionStatus AddElementsToKeyAccumulator(
      DirectHandle<JSObject> receiver, KeyAccumulator* accumulator,
      AddKeyConversion convert) final {
    return Subclass::AddElementsToKeyAccumulatorImpl(receiver, accumulator,
                                                     convert);
  }

  static uint32_t GetCapacityImpl(Tagged<JSObject> holder,
                                  Tagged<FixedArrayBase> backing_store) {
    return backing_store->length();
  }

  size_t GetCapacity(Tagged<JSObject> holder,
                     Tagged<FixedArrayBase> backing_store) final {
    return Subclass::GetCapacityImpl(holder, backing_store);
  }

  static MaybeDirectHandle<Object> FillImpl(DirectHandle<JSObject> receiver,
                                            DirectHandle<Object> obj_value,
                                            size_t start, size_t end) {
    UNREACHABLE();
  }

  MaybeDirectHandle<Object> Fill(DirectHandle<JSObject> receiver,
                                 DirectHandle<Object> obj_value, size_t start,
                                 size_t end) override {
    return Subclass::FillImpl(receiver, obj_value, start, end);
  }

  static Maybe<bool> IncludesValueImpl(Isolate* isolate,
                                       DirectHandle<JSObject> receiver,
                                       DirectHandle<Object> value,
                                       size_t start_from, size_t length) {
    return IncludesValueSlowPath(isolate, receiver, value, start_from, length);
  }

  Maybe<bool> IncludesValue(Isolate* isolate, DirectHandle<JSObject> receiver,
                            DirectHandle<Object> value, size_t start_from,
                            size_t length) final {
    return Subclass::IncludesValueImpl(isolate, receiver, value, start_from,
                                       length);
  }

  static Maybe<int64_t> IndexOfValueImpl(Isolate* isolate,
                                         DirectHandle<JSObject> receiver,
                                         DirectHandle<Object> value,
                                         size_t start_from, size_t length) {
    return IndexOfValueSlowPath(isolate, receiver, value, start_from, length);
  }

  Maybe<int64_t> IndexOfValue(Isolate* isolate, DirectHandle<JSObject> receiver,
                              DirectHandle<Object> value, size_t start_from,
                              size_t length) final {
    return Subclass::IndexOfValueImpl(isolate, receiver, value, start_from,
                                      length);
  }

  static Maybe<int64_t> LastIndexOfValueImpl(DirectHandle<JSObject> receiver,
                                             DirectHandle<Object> value,
                                             size_t start_from) {
    UNREACHABLE();
  }

  Maybe<int64_t> LastIndexOfValue(DirectHandle<JSObject> receiver,
                                  DirectHandle<Object> value,
                                  size_t start_from) final {
    return Subclass::LastIndexOfValueImpl(receiver, value, start_from);
  }

  static void ReverseImpl(Tagged<JSObject> receiver) { UNREACHABLE(); }

  void Reverse(Tagged<JSObject> receiver) final {
    Subclass::ReverseImpl(receiver);
  }

  static InternalIndex GetEntryForIndexImpl(
      Isolate* isolate, Tagged<JSObject> holder,
      Tagged<FixedArrayBase> backing_store, size_t index,
      PropertyFilter filter) {
    DCHECK(IsFastElementsKind(kind()) ||
           IsAnyNonextensibleElementsKind(kind()));
    size_t length = Subclass::GetMaxIndex(holder, backing_store);
    if (IsHoleyElementsKindForRead(kind())) {
      DCHECK_IMPLIES(
          index < length,
          index <= static_cast<size_t>(std::numeric_limits<int>::max()));
      return index < length &&
                     !Cast<BackingStore>(backing_store)
                          ->is_the_hole(isolate, static_cast<int>(index))
                 ? InternalIndex(index)
                 : InternalIndex::NotFound();
    } else {
      return index < length ? InternalIndex(index) : InternalIndex::NotFound();
    }
  }

  InternalIndex GetEntryForIndex(Isolate* isolate, Tagged<JSObject> holder,
                                 Tagged<FixedArrayBase> backing_store,
                                 size_t index) final {
    return Subclass::GetEntryForIndexImpl(isolate, holder, backing_store, index,
                                          ALL_PROPERTIES);
  }

  static PropertyDetails GetDetailsImpl(Tagged<FixedArrayBase> backing_store,
                                        InternalIndex entry) {
    return PropertyDetails(PropertyKind::kData, NONE,
                           PropertyCellType::kNoCell);
  }

  static PropertyDetails GetDetailsImpl(Tagged<JSObject> holder,
                                        InternalIndex entry) {
    return PropertyDetails(PropertyKind::kData, NONE,
                           PropertyCellType::kNoCell);
  }

  PropertyDetails GetDetails(Tagged<JSObject> holder,
                             InternalIndex entry) final {
    return Subclass::GetDetailsImpl(holder, entry);
  }

  Handle<FixedArray> CreateListFromArrayLike(Isolate* isolate,
                                             DirectHandle<JSObject> object,
                                             uint32_t length) final {
    return Subclass::CreateListFromArrayLikeImpl(isolate, object, length);
  }

  static Handle<FixedArray> CreateListFromArrayLikeImpl(
      Isolate* isolate, DirectHandle<JSObject> object, uint32_t length) {
    UNREACHABLE();
  }
};

class DictionaryElementsAccessor
    : public ElementsAccessorBase<DictionaryElementsAccessor,
                                  ElementsKindTraits<DICTIONARY_ELEMENTS>> {
 public:
  static uint32_t GetMaxIndex(Tagged<JSObject> receiver,
                              Tagged<FixedArrayBase> elements) {
    // We cannot properly estimate this for dictionaries.
    UNREACHABLE();
  }

  static uint32_t GetMaxNumberOfEntries(Isolate* isolate,
                                        Tagged<JSObject> receiver,
                                        Tagged<FixedArrayBase> backing_store) {
    return NumberOfElementsImpl(isolate, receiver, backing_store);
  }

  static uint32_t NumberOfElementsImpl(Isolate* isolate,
                                       Tagged<JSObject> receiver,
                                       Tagged<FixedArrayBase> backing_store) {
    Tagged<NumberDictionary> dict = Cast<NumberDictionary>(backing_store);
    return dict->NumberOfElements();
  }

  static Maybe<bool> SetLengthImpl(Isolate* isolate,
                                   DirectHandle<JSArray> array, uint32_t length,
                                   DirectHandle<FixedArrayBase> backing_store) {
    auto dict = Cast<NumberDictionary>(backing_store);
    uint32_t old_length = 0;
    CHECK(Object::ToArrayLength(array->length(), &old_length));
    {
      DisallowGarbageCollection no_gc;
      ReadOnlyRoots roots(isolate);
      if (length < old_length) {
        if (dict->requires_slow_elements()) {
          // Find last non-deletable element in range of elements to be
          // deleted and adjust range accordingly.
          for (InternalIndex entry : dict->IterateEntries()) {
            Tagged<Object> index = dict->KeyAt(isolate, entry);
            if (dict->IsKey(roots, index)) {
              uint32_t number =
                  static_cast<uint32_t>(Object::NumberValue(index));
              if (length <= number && number < old_length) {
                PropertyDetails details = dict->DetailsAt(entry);
                if (!details.IsConfigurable()) length = number + 1;
              }
            }
          }
        }

        if (length == 0) {
          // Flush the backing store.
          array->initialize_elements();
        } else {
          // Remove elements that should be deleted.
          int removed_entries = 0;
          for (InternalIndex entry : dict->IterateEntries()) {
            Tagged<Object> index = dict->KeyAt(isolate, entry);
            if (dict->IsKey(roots, index)) {
              uint32_t number =
                  static_cast<uint32_t>(Object::NumberValue(index));
              if (length <= number && number < old_length) {
                dict->ClearEntry(entry);
                removed_entries++;
              }
            }
          }

          if (removed_entries > 0) {
            // Update the number of elements.
            dict->ElementsRemoved(removed_entries);
          }
        }
      }
    }

    DirectHandle<Number> length_obj =
        isolate->factory()->NewNumberFromUint(length);
    array->set_length(*length_obj);
    return Just(true);
  }

  static void CopyElementsImpl(Isolate* isolate, Tagged<FixedArrayBase> from,
                               uint32_t from_start, Tagged<FixedArrayBase> to,
                               ElementsKind from_kind, uint32_t to_start,
                               int packed_size, int copy_size) {
    UNREACHABLE();
  }

  static void DeleteImpl(DirectHandle<JSObject> obj, InternalIndex entry) {
    DirectHandle<NumberDictionary> dict(Cast<NumberDictionary>(obj->elements()),
                                        obj->GetIsolate());
    dict = NumberDictionary::DeleteEntry(obj->GetIsolate(), dict, entry);
    obj->set_elements(*dict);
  }

  static bool HasAccessorsImpl(Tagged<JSObject> holder,
                               Tagged<FixedArrayBase> backing_store) {
    DisallowGarbageCollection no_gc;
    Tagged<NumberDictionary> dict = Cast<NumberDictionary>(backing_store);
    if (!dict->requires_slow_elements()) return false;
    PtrComprCageBase cage_base = GetPtrComprCageBase(holder);
    ReadOnlyRoots roots = GetReadOnlyRoots();
    for (InternalIndex i : dict->IterateEntries()) {
      Tagged<Object> key = dict->KeyAt(cage_base, i);
      if (!dict->IsKey(roots, key)) continue;
      PropertyDetails details = dict->DetailsAt(i);
      if (details.kind() == PropertyKind::kAccessor) return true;
    }
    return false;
  }

  static Tagged<Object> GetRaw(Tagged<FixedArrayBase> store,
                               InternalIndex entry) {
    Tagged<NumberDictionary> backing_store = Cast<NumberDictionary>(store);
    return backing_store->ValueAt(entry);
  }

  static Handle<Object> GetImpl(Isolate* isolate,
                                Tagged<FixedArrayBase> backing_store,
                                InternalIndex entry) {
    return handle(GetRaw(backing_store, entry), isolate);
  }

  static Handle<Object> GetAtomicInternalImpl(
      Isolate* isolate, Tagged<FixedArrayBase> backing_store,
      InternalIndex entry, SeqCstAccessTag tag) {
    return handle(Cast<NumberDictionary>(backing_store)->ValueAt(entry, tag),
                  isolate);
  }

  static inline void SetImpl(DirectHandle<JSObject> holder, InternalIndex entry,
                             Tagged<Object> value) {
    SetImpl(holder->elements(), entry, value);
  }

  static inline void SetImpl(Tagged<FixedArrayBase> backing_store,
                             InternalIndex entry, Tagged<Object> value) {
    Cast<NumberDictionary>(backing_store)->ValueAtPut(entry, value);
  }

  static void SetAtomicInternalImpl(Tagged<FixedArrayBase> backing_store,
                                    InternalIndex entry, Tagged<Object> value,
                                    SeqCstAccessTag tag) {
    Cast<NumberDictionary>(backing_store)->ValueAtPut(entry, value, tag);
  }

  static Handle<Object> SwapAtomicInternalImpl(
      Isolate* isolate, Tagged<FixedArrayBase> backing_store,
      InternalIndex entry, Tagged<Object> value, SeqCstAccessTag tag) {
    return handle(
        Cast<NumberDictionary>(backing_store)->ValueAtSwap(entry, value, tag),
        isolate);
  }

  static Tagged<Object> CompareAndSwapAtomicInternalImpl(
      Tagged<FixedArrayBase> backing_store, InternalIndex entry,
      Tagged<Object> expected, Tagged<Object> value, SeqCstAccessTag tag) {
    return Cast<NumberDictionary>(backing_store)
        ->ValueAtCompareAndSwap(entry, expected, value, tag);
  }

  static void ReconfigureImpl(DirectHandle<JSObject> object,
                              DirectHandle<FixedArrayBase> store,
                              InternalIndex entry, DirectHandle<Object> value,
                              PropertyAttributes attributes) {
    Tagged<NumberDictionary> dictionary = Cast<NumberDictionary>(*store);
    if (attributes != NONE) object->RequireSlowElements(dictionary);
    dictionary->ValueAtPut(entry, *value);
    PropertyDetails details = dictionary->DetailsAt(entry);
    details =
        PropertyDetails(PropertyKind::kData, attributes,
                        PropertyCellType::kNoCell, details.dictionary_index());

    dictionary->DetailsAtPut(entry, details);
  }

  static Maybe<bool> AddImpl(DirectHandle<JSObject> object, uint32_t index,
                             DirectHandle<Object> value,
                             PropertyAttributes attributes,
                             uint32_t new_capacity) {
    PropertyDetails details(PropertyKind::kData, attributes,
                            PropertyCellType::kNoCell);
    DirectHandle<NumberDictionary> dictionary =
        object->HasFastElements() || object->HasFastStringWrapperElements()
            ? JSObject::NormalizeElements(object)
            : direct_handle(Cast<NumberDictionary>(object->elements()),
                            object->GetIsolate());
    DirectHandle<NumberDictionary> new_dictionary = NumberDictionary::Add(
        object->GetIsolate(), dictionary, index, value, details);
    new_dictionary->UpdateMaxNumberKey(index, object);
    if (attributes != NONE) object->RequireSlowElements(*new_dictionary);
    if (dictionary.is_identical_to(new_dictionary)) return Just(true);
    object->set_elements(*new_dictionary);
    return Just(true);
  }

  static bool HasEntryImpl(Isolate* isolate, Tagged<FixedArrayBase> store,
                           InternalIndex entry) {
    DisallowGarbageCollection no_gc;
    Tagged<NumberDictionary> dict = Cast<NumberDictionary>(store);
    Tagged<Object> index = dict->KeyAt(isolate, entry);
    return !IsTheHole(index, isolate);
  }

  static InternalIndex GetEntryForIndexImpl(Isolate* isolate,
                                            Tagged<JSObject> holder,
                                            Tagged<FixedArrayBase> store,
                                            size_t index,
                                            PropertyFilter filter) {
    DisallowGarbageCollection no_gc;
    Tagged<NumberDictionary> dictionary = Cast<NumberDictionary>(store);
    DCHECK_LE(index, std::numeric_limits<uint32_t>::max());
    InternalIndex entry =
        dictionary->FindEntry(isolate, static_cast<uint32_t>(index));
    if (entry.is_not_found()) return entry;

    if (filter != ALL_PROPERTIES) {
      PropertyDetails details = dictionary->DetailsAt(entry);
      PropertyAttributes attr = details.attributes();
      if ((int{attr} & filter) != 0) return InternalIndex::NotFound();
    }
    return entry;
  }

  static PropertyDetails GetDetailsImpl(Tagged<JSObject> holder,
                                        InternalIndex entry) {
    return GetDetailsImpl(holder->elements(), entry);
  }

  static PropertyDetails GetDetailsImpl(Tagged<FixedArrayBase> backing_store,
                                        InternalIndex entry) {
    return Cast<NumberDictionary>(backing_store)->DetailsAt(entry);
  }

  static uint32_t FilterKey(DirectHandle<NumberDictionary> dictionary,
                            InternalIndex entry, Tagged<Object> raw_key,
                            PropertyFilter filter) {
    DCHECK(IsNumber(raw_key));
    DCHECK_LE(Object::NumberValue(raw_key), kMaxUInt32);
    PropertyDetails details = dictionary->DetailsAt(entry);
    PropertyAttributes attr = details.attributes();
    if ((int{attr} & filter) != 0) return kMaxUInt32;
    return static_cast<uint32_t>(Object::NumberValue(raw_key));
  }

  static uint32_t GetKeyForEntryImpl(Isolate* isolate,
                                     DirectHandle<NumberDictionary> dictionary,
                                     InternalIndex entry,
                                     PropertyFilter filter) {
    DisallowGarbageCollection no_gc;
    Tagged<Object> raw_key = dictionary->KeyAt(isolate, entry);
    if (!dictionary->IsKey(ReadOnlyRoots(isolate), raw_key)) return kMaxUInt32;
    return FilterKey(dictionary, entry, raw_key, filter);
  }

  V8_WARN_UNUSED_RESULT static ExceptionStatus CollectElementIndicesImpl(
      DirectHandle<JSObject> object, DirectHandle<FixedArrayBase> backing_store,
      KeyAccumulator* keys) {
    if (keys->filter() & SKIP_STRINGS) return ExceptionStatus::kSuccess;
    Isolate* isolate = keys->isolate();
    auto dictionary = Cast<NumberDictionary>(backing_store);
    DirectHandle<FixedArray> elements = isolate->factory()->NewFixedArray(
        GetMaxNumberOfEntries(isolate, *object, *backing_store));
    int insertion_index = 0;
    PropertyFilter filter = keys->filter();
    ReadOnlyRoots roots(isolate);
    for (InternalIndex i : dictionary->IterateEntries()) {
      AllowGarbageCollection allow_gc;
      Tagged<Object> raw_key = dictionary->KeyAt(isolate, i);
      if (!dictionary->IsKey(roots, raw_key)) continue;
      uint32_t key = FilterKey(dictionary, i, raw_key, filter);
      if (key == kMaxUInt32) {
        // This might allocate, but {raw_key} is not used afterwards.
        keys->AddShadowingKey(raw_key, &allow_gc);
        continue;
      }
      elements->set(insertion_index, raw_key);
      insertion_index++;
    }
    SortIndices(isolate, elements, insertion_index);
    for (int i = 0; i < insertion_index; i++) {
      RETURN_FAILURE_IF_NOT_SUCCESSFUL(keys->AddKey(elements->get(i)));
    }
    return ExceptionStatus::kSuccess;
  }

  static Handle<FixedArray> DirectCollectElementIndicesImpl(
      Isolate* isolate, DirectHandle<JSObject> object,
      DirectHandle<FixedArrayBase> backing_store, GetKeysConversion convert,
      PropertyFilter filter, Handle<FixedArray> list, uint32_t* nof_indices,
      uint32_t insertion_index = 0) {
    if (filter & SKIP_STRINGS) return list;

    auto dictionary = Cast<NumberDictionary>(backing_store);
    for (InternalIndex i : dictionary->IterateEntries()) {
      uint32_t key = GetKeyForEntryImpl(isolate, dictionary, i, filter);
      if (key == kMaxUInt32) continue;
      DirectHandle<Object> index = isolate->factory()->NewNumberFromUint(key);
      list->set(insertion_index, *index);
      insertion_index++;
    }
    *nof_indices = insertion_index;
    return list;
  }

  V8_WARN_UNUSED_RESULT static ExceptionStatus AddElementsToKeyAccumulatorImpl(
      DirectHandle<JSObject> receiver, KeyAccumulator* accumulator,
      AddKeyConversion convert) {
    Isolate* isolate = accumulator->isolate();
    DirectHandle<NumberDictionary> dictionary(
        Cast<NumberDictionary>(receiver->elements()), isolate);
    ReadOnlyRoots roots(isolate);
    for (InternalIndex i : dictionary->IterateEntries()) {
      Tagged<Object> k = dictionary->KeyAt(isolate, i);
      if (!dictionary->IsKey(roots, k)) continue;
      Tagged<Object> value = dictionary->ValueAt(isolate, i);
      DCHECK(!IsTheHole(value, isolate));
      DCHECK(!IsAccessorPair(value));
      DCHECK(!IsAccessorInfo(value));
      RETURN_FAILURE_IF_NOT_SUCCESSFUL(accumulator->AddKey(value, convert));
    }
    return ExceptionStatus::kSuccess;
  }

  static bool IncludesValueFastPath(Isolate* isolate,
                                    DirectHandle<JSObject> receiver,
                                    DirectHandle<Object> value,
                                    size_t start_from, size_t length,
                                    Maybe<bool>* result) {
    DisallowGarbageCollection no_gc;
    Tagged<NumberDictionary> dictionary =
        Cast<NumberDictionary>(receiver->elements());
    Tagged<Object> the_hole = ReadOnlyRoots(isolate).the_hole_value();
    Tagged<Object> undefined = ReadOnlyRoots(isolate).undefined_value();

    // Scan for accessor properties. If accessors are present, then elements
    // must be accessed in order via the slow path.
    bool found = false;
    for (InternalIndex i : dictionary->IterateEntries()) {
      Tagged<Object> k = dictionary->KeyAt(isolate, i);
      if (k == the_hole) continue;
      if (k == undefined) continue;

      uint32_t index;
      if (!Object::ToArrayIndex(k, &index) || index < start_from ||
          index >= length) {
        continue;
      }

      if (dictionary->DetailsAt(i).kind() == PropertyKind::kAccessor) {
        // Restart from beginning in slow path, otherwise we may observably
        // access getters out of order
        return false;
      } else if (!found) {
        Tagged<Object> element_k = dictionary->ValueAt(isolate, i);
        if (Object::SameValueZero(*value, element_k)) found = true;
      }
    }

    *result = Just(found);
    return true;
  }

  static Maybe<bool> IncludesValueImpl(Isolate* isolate,
                                       DirectHandle<JSObject> receiver,
                                       DirectHandle<Object> value,
                                       size_t start_from, size_t length) {
    DCHECK(JSObject::PrototypeHasNoElements(isolate, *receiver));
    bool search_for_hole = IsUndefined(*value, isolate);

    if (!search_for_hole) {
      Maybe<bool> result = Nothing<bool>();
      if (DictionaryElementsAccessor::IncludesValueFastPath(
              isolate, receiver, value, start_from, length, &result)) {
        return result;
      }
    }
    ElementsKind original_elements_kind = receiver->GetElementsKind();
    USE(original_elements_kind);
    DirectHandle<NumberDictionary> dictionary(
        Cast<NumberDictionary>(receiver->elements()), isolate);
    // Iterate through the entire range, as accessing elements out of order is
    // observable.
    for (size_t k = start_from; k < length; ++k) {
      DCHECK_EQ(receiver->GetElementsKind(), original_elements_kind);
      InternalIndex entry =
          dictionary->FindEntry(isolate, static_cast<uint32_t>(k));
      if (entry.is_not_found()) {
        if (search_for_hole) return Just(true);
        continue;
      }

      PropertyDetails details = GetDetailsImpl(*dictionary, entry);
      switch (details.kind()) {
        case PropertyKind::kData: {
          Tagged<Object> element_k = dictionary->ValueAt(entry);
          if (Object::SameValueZero(*value, element_k)) return Just(true);
          break;
        }
        case PropertyKind::kAccessor: {
          LookupIterator it(isolate, receiver, k,
                            LookupIterator::OWN_SKIP_INTERCEPTOR);
          DCHECK(it.IsFound());
          DCHECK_EQ(it.state(), LookupIterator::ACCESSOR);
          DirectHandle<Object> element_k;

          ASSIGN_RETURN_ON_EXCEPTION_VALUE(isolate, element_k,
                                           Object::GetPropertyWithAccessor(&it),
                                           Nothing<bool>());

          if (Object::SameValueZero(*value, *element_k)) return Just(true);

          // Bailout to slow path if elements on prototype changed
          if (!JSObject::PrototypeHasNoElements(isolate, *receiver)) {
            return IncludesValueSlowPath(isolate, receiver, value, k + 1,
                                         length);
          }

          // Continue if elements unchanged
          if (*dictionary == receiver->elements()) continue;

          // Otherwise, bailout or update elements

          // If switched to initial elements, return true if searching for
          // undefined, and false otherwise.
          if (receiver->map()->GetInitialElements() == receiver->elements()) {
            return Just(search_for_hole);
          }

          // If switched to fast elements, continue with the correct accessor.
          if (receiver->GetElementsKind() != DICTIONARY_ELEMENTS) {
            ElementsAccessor* accessor = receiver->GetElementsAccessor();
            return accessor->IncludesValue(isolate, receiver, value, k + 1,
                                           length);
          }
          dictionary = direct_handle(
              Cast<NumberDictionary>(receiver->elements()), isolate);
          break;
        }
      }
    }
    return Just(false);
  }

  static Maybe<int64_t> IndexOfValueImpl(Isolate* isolate,
                                         DirectHandle<JSObject> receiver,
                                         DirectHandle<Object> value,
                                         size_t start_from, size_t length) {
    DCHECK(JSObject::PrototypeHasNoElements(isolate, *receiver));

    ElementsKind original_elements_kind = receiver->GetElementsKind();
    USE(original_elements_kind);
    DirectHandle<NumberDictionary> dictionary(
        Cast<NumberDictionary>(receiver->elements()), isolate);
    // Iterate through entire range, as accessing elements out of order is
    // observable.
    for (size_t k = start_from; k < length; ++k) {
      DCHECK_EQ(receiver->GetElementsKind(), original_elements_kind);
      DCHECK_LE(k, std::numeric_limits<uint32_t>::max());
      InternalIndex entry =
          dictionary->FindEntry(isolate, static_cast<uint32_t>(k));
      if (entry.is_not_found()) continue;

      PropertyDetails details =
          GetDetailsImpl(*dictionary, InternalIndex(entry));
      switch (details.kind()) {
        case PropertyKind::kData: {
          Tagged<Object> element_k = dictionary->ValueAt(entry);
          if (Object::StrictEquals(*value, element_k)) {
            return Just<int64_t>(k);
          }
          break;
        }
        case PropertyKind::kAccessor: {
          LookupIterator it(isolate, receiver, k,
                            LookupIterator::OWN_SKIP_INTERCEPTOR);
          DCHECK(it.IsFound());
          DCHECK_EQ(it.state(), LookupIterator::ACCESSOR);
          DirectHandle<Object> element_k;

          ASSIGN_RETURN_ON_EXCEPTION_VALUE(isolate, element_k,
                                           Object::GetPropertyWithAccessor(&it),
                                           Nothing<int64_t>());

          if (Object::StrictEquals(*value, *element_k)) return Just<int64_t>(k);

          // Bailout to slow path if elements on prototype changed.
          if (!JSObject::PrototypeHasNoElements(isolate, *receiver)) {
            return IndexOfValueSlowPath(isolate, receiver, value, k + 1,
                                        length);
          }

          // Continue if elements unchanged.
          if (*dictionary == receiver->elements()) continue;

          // Otherwise, bailout or update elements.
          if (receiver->GetElementsKind() != DICTIONARY_ELEMENTS) {
            // Otherwise, switch to slow path.
            return IndexOfValueSlowPath(isolate, receiver, value, k + 1,
                                        length);
          }
          dictionary = direct_handle(
              Cast<NumberDictionary>(receiver->elements()), isolate);
          break;
        }
      }
    }
    return Just<int64_t>(-1);
  }

  static void ValidateContents(Tagged<JSObject> holder, size_t length) {
    DisallowGarbageCollection no_gc;
#if DEBUG
    DCHECK_EQ(holder->map()->elements_kind(), DICTIONARY_ELEMENTS);
    if (!v8_flags.enable_slow_asserts) return;
    ReadOnlyRoots roots = GetReadOnlyRoots();
    Tagged<NumberDictionary> dictionary =
        Cast<NumberDictionary>(holder->elements());
    // Validate the requires_slow_elements and max_number_key values.
    bool requires_slow_elements = false;
    int max_key = 0;
    for (InternalIndex i : dictionary->IterateEntries()) {
      Tagged<Object> k;
      if (!dictionary->ToKey(roots, i, &k)) continue;
      DCHECK_LE(0.0, Object::NumberValue(k));
      if (Object::NumberValue(k) >
          NumberDictionary::kRequiresSlowElementsLimit) {
        requires_slow_elements = true;
      } else {
        max_key = std::max(max_key, Smi::ToInt(k));
      }
    }
    if (requires_slow_elements) {
      DCHECK(dictionary->requires_slow_elements());
    } else if (!dictionary->requires_slow_elements()) {
      DCHECK_LE(max_key, dictionary->max_number_key());
    }
#endif
  }
};

// Super class for all fast element arrays.
template <typename Subclass, typename KindTraits>
class FastElementsAccessor : public ElementsAccessorBase<Subclass, KindTraits> {
 public:
  using BackingStore = typename KindTraits::BackingStore;

  static DirectHandle<NumberDictionary> NormalizeImpl(
      DirectHandle<JSObject> object, DirectHandle<FixedArrayBase> store) {
    Isolate* isolate = object->GetIsolate();
    ElementsKind kind = Subclass::kind();

    // Ensure that notifications fire if the array or object prototypes are
    // normalizing.
    if (IsSmiOrObjectElementsKind(kind) ||
        kind == FAST_STRING_WRAPPER_ELEMENTS) {
      isolate->UpdateNoElementsProtectorOnNormalizeElements(object);
    }

    int capacity = object->GetFastElementsUsage();
    DirectHandle<NumberDictionary> dictionary =
        NumberDictionary::New(isolate, capacity);

    PropertyDetails details = PropertyDetails::Empty();
    int j = 0;
    int max_number_key = -1;
    for (int i = 0; j < capacity; i++) {
      if (IsHoleyElementsKindForRead(kind)) {
        if (Cast<BackingStore>(*store)->is_the_hole(isolate, i)) continue;
      }
      max_number_key = i;
      DirectHandle<Object> value =
          Subclass::GetImpl(isolate, *store, InternalIndex(i));
      dictionary =
          NumberDictionary::Add(isolate, dictionary, i, value, details);
      j++;
    }

    if (max_number_key > 0) {
      dictionary->UpdateMaxNumberKey(static_cast<uint32_t>(max_number_key),
                                     object);
    }
    return dictionary;
  }

  static void DeleteAtEnd(DirectHandle<JSObject> obj,
                          DirectHandle<BackingStore> backing_store,
                          uint32_t entry) {
    uint32_t length = static_cast<uint32_t>(backing_store->length());
    DCHECK_LT(entry, length);
    Isolate* isolate = obj->GetIsolate();
    for (; entry > 0; entry--) {
      if (!backing_store->is_the_hole(isolate, entry - 1)) break;
    }
    if (entry == 0) {
      Tagged<FixedArray> empty = ReadOnlyRoots(isolate).empty_fixed_array();
      // Dynamically ask for the elements kind here since we manually redirect
      // the operations for argument backing stores.
      if (obj->GetElementsKind() == FAST_SLOPPY_ARGUMENTS_ELEMENTS) {
        Cast<SloppyArgumentsElements>(obj->elements())->set_arguments(empty);
      } else {
        obj->set_elements(empty);
      }
      return;
    }

    isolate->heap()->RightTrimArray(*backing_store, entry, length);
  }

  static void DeleteCommon(DirectHandle<JSObject> obj, uint32_t entry,
                           DirectHandle<FixedArrayBase> store) {
    DCHECK(obj->HasSmiOrObjectElements() || obj->HasDoubleElements() ||
           obj->HasNonextensibleElements() || obj->HasFastArgumentsElements() ||
           obj->HasFastStringWrapperElements());
    DirectHandle<BackingStore> backing_store = Cast<BackingStore>(store);
    if (!IsJSArray(*obj) &&
        entry == static_cast<uint32_t>(store->length()) - 1) {
      DeleteAtEnd(obj, backing_store, entry);
      return;
    }

    Isolate* isolate = obj->GetIsolate();
    backing_store->set_the_hole(isolate, entry);

    // TODO(verwaest): Move this out of elements.cc.
    // If the backing store is larger than a certain size and
    // has too few used values, normalize it.
    const int kMinLengthForSparsenessCheck = 64;
    if (backing_store->length() < kMinLengthForSparsenessCheck) return;
    uint32_t length = 0;
    if (IsJSArray(*obj)) {
      Object::ToArrayLength(Cast<JSArray>(*obj)->length(), &length);
    } else {
      length = static_cast<uint32_t>(store->length());
    }

    // To avoid doing the check on every delete, use a counter-based heuristic.
    const int kLengthFraction = 16;
    // The above constant must be large enough to ensure that we check for
    // normalization frequently enough. At a minimum, it should be large
    // enough to reliably hit the "window" of remaining elements count where
    // normalization would be beneficial.
    static_assert(kLengthFraction >=
                  NumberDictionary::kEntrySize *
                      NumberDictionary::kPreferFastElementsSizeFactor);
    size_t current_counter = isolate->elements_deletion_counter();
    if (current_counter < length / kLengthFraction) {
      isolate->set_elements_deletion_counter(current_counter + 1);
      return;
    }
    // Reset the counter whenever the full check is performed.
    isolate->set_elements_deletion_counter(0);

    if (!IsJSArray(*obj)) {
      uint32_t i;
      for (i = entry + 1; i < length; i++) {
        if (!backing_store->is_the_hole(isolate, i)) break;
      }
      if (i == length) {
        DeleteAtEnd(obj, backing_store, entry);
        return;
      }
    }
    int num_used = 0;
    for (int i = 0; i < backing_store->length(); ++i) {
      if (!backing_store->is_the_hole(isolate, i)) {
        ++num_used;
        // Bail out if a number dictionary wouldn't be able to save much space.
        if (NumberDictionary::kPreferFastElementsSizeFactor *
                NumberDictionary::ComputeCapacity(num_used) *
                NumberDictionary::kEntrySize >
            static_cast<uint32_t>(backing_store->length())) {
          return;
        }
      }
    }
    JSObject::NormalizeElements(obj);
  }

  static void ReconfigureImpl(DirectHandle<JSObject> object,
                              DirectHandle<FixedArrayBase> store,
                              InternalIndex entry, DirectHandle<Object> value,
                              PropertyAttributes attributes) {
    DirectHandle<NumberDictionary> dictionary =
        JSObject::NormalizeElements(object);
    entry = InternalIndex(
        dictionary->FindEntry(object->GetIsolate(), entry.as_uint32()));
    DictionaryElementsAccessor::ReconfigureImpl(
        object, Cast<FixedArrayBase>(dictionary), entry, value, attributes);
  }

  static Maybe<bool> AddImpl(DirectHandle<JSObject> object, uint32_t index,
                             DirectHandle<Object> value,
                             PropertyAttributes attributes,
                             uint32_t new_capacity) {
    DCHECK_EQ(NONE, attributes);
    ElementsKind from_kind = object->GetElementsKind();
    ElementsKind to_kind = Subclass::kind();
    if (IsDictionaryElementsKind(from_kind) ||
        IsDoubleElementsKind(from_kind) != IsDoubleElementsKind(to_kind) ||
        Subclass::GetCapacityImpl(*object, object->elements()) !=
            new_capacity) {
      MAYBE_RETURN(Subclass::GrowCapacityAndConvertImpl(object, new_capacity),
                   Nothing<bool>());
    } else {
      if (IsFastElementsKind(from_kind) && from_kind != to_kind) {
        JSObject::TransitionElementsKind(object, to_kind);
      }
      if (IsSmiOrObjectElementsKind(from_kind)) {
        DCHECK(IsSmiOrObjectElementsKind(to_kind));
        JSObject::EnsureWritableFastElements(object);
      }
    }
    Subclass::SetImpl(object, InternalIndex(index), *value);
    return Just(true);
  }

  static void DeleteImpl(DirectHandle<JSObject> obj, InternalIndex entry) {
    ElementsKind kind = KindTraits::Kind;
    if (IsFastPackedElementsKind(kind) ||
        kind == PACKED_NONEXTENSIBLE_ELEMENTS) {
      JSObject::TransitionElementsKind(obj, GetHoleyElementsKind(kind));
    }
    if (IsSmiOrObjectElementsKind(KindTraits::Kind) ||
        IsNonextensibleElementsKind(kind)) {
      JSObject::EnsureWritableFastElements(obj);
    }
    DeleteCommon(obj, entry.as_uint32(),
                 direct_handle(obj->elements(), obj->GetIsolate()));
  }

  static bool HasEntryImpl(Isolate* isolate,
                           Tagged<FixedArrayBase> backing_store,
                           InternalIndex entry) {
    return !Cast<BackingStore>(backing_store)
                ->is_the_hole(isolate, entry.as_int());
  }

  static uint32_t NumberOfElementsImpl(Isolate* isolate,
                                       Tagged<JSObject> receiver,
                                       Tagged<FixedArrayBase> backing_store) {
    size_t max_index = Subclass::GetMaxIndex(receiver, backing_store);
    DCHECK_LE(max_index, std::numeric_limits<uint32_t>::max());
    if (IsFastPackedElementsKind(Subclass::kind())) {
      return static_cast<uint32_t>(max_index);
    }
    uint32_t count = 0;
    for (size_t i = 0; i < max_index; i++) {
      if (Subclass::HasEntryImpl(isolate, backing_store, InternalIndex(i))) {
        count++;
      }
    }
    return count;
  }

  V8_WARN_UNUSED_RESULT static ExceptionStatus AddElementsToKeyAccumulatorImpl(
      DirectHandle<JSObject> receiver, KeyAccumulator* accumulator,
      AddKeyConversion convert) {
    Isolate* isolate = accumulator->isolate();
    DirectHandle<FixedArrayBase> elements(receiver->elements(), isolate);
    size_t length =
        Subclass::GetMaxNumberOfEntries(isolate, *receiver, *elements);
    for (size_t i = 0; i < length; i++) {
      if (IsFastPackedElementsKind(KindTraits::Kind) ||
          HasEntryImpl(isolate, *elements, InternalIndex(i))) {
        RETURN_FAILURE_IF_NOT_SUCCESSFUL(accumulator->AddKey(
            Subclass::GetImpl(isolate, *elements, InternalIndex(i)), convert));
      }
    }
    return ExceptionStatus::kSuccess;
  }

  static void ValidateContents(Tagged<JSObject> holder, size_t length) {
#if DEBUG
    Isolate* isolate = holder->GetIsolate();
    Heap* heap = isolate->heap();
    Tagged<FixedArrayBase> elements = holder->elements();
    Tagged<Map> map = elements->map();
    if (IsSmiOrObjectElementsKind(KindTraits::Kind)) {
      DCHECK_NE(map, ReadOnlyRoots(heap).fixed_double_array_map());
    } else if (IsDoubleElementsKind(KindTraits::Kind)) {
      DCHECK_NE(map, ReadOnlyRoots(heap).fixed_cow_array_map());
      if (map == ReadOnlyRoots(heap).fixed_array_map()) DCHECK_EQ(0u, length);
    } else {
      UNREACHABLE();
    }
    if (length == 0u) return;  // nothing to do!
#if ENABLE_SLOW_DCHECKS
    DisallowGarbageCollection no_gc;
    Tagged<BackingStore> backing_store = Cast<BackingStore>(elements);
    DCHECK(length <= std::numeric_limits<int>::max());
    int length_int = static_cast<int>(length);
    if (IsSmiElementsKind(KindTraits::Kind)) {
      HandleScope scope(isolate);
      for (int i = 0; i < length_int; i++) {
        Tagged<Object> element = Cast<FixedArray>(backing_store)->get(i);
        DCHECK(IsSmi(element) || (IsHoleyElementsKind(KindTraits::Kind) &&
                                  IsTheHole(element, isolate)));
      }
    } else if (KindTraits::Kind == PACKED_ELEMENTS ||
               KindTraits::Kind == PACKED_DOUBLE_ELEMENTS) {
      for (int i = 0; i < length_int; i++) {
        DCHECK(!backing_store->is_the_hole(isolate, i));
      }
    } else {
      DCHECK(IsHoleyElementsKind(KindTraits::Kind));
    }
#endif
#endif
  }

  static MaybeDirectHandle<Object> PopImpl(DirectHandle<JSArray> receiver) {
    return Subclass::RemoveElement(receiver, AT_END);
  }

  static MaybeDirectHandle<Object> ShiftImpl(DirectHandle<JSArray> receiver) {
    return Subclass::RemoveElement(receiver, AT_START);
  }

  static Maybe<uint32_t> PushImpl(DirectHandle<JSArray> receiver,
                                  BuiltinArguments* args, uint32_t push_size) {
    DirectHandle<FixedArrayBase> backing_store(receiver->elements(),
                                               receiver->GetIsolate());
    return Subclass::AddArguments(receiver, backing_store, args, push_size,
                                  AT_END);
  }

  static Maybe<uint32_t> UnshiftImpl(DirectHandle<JSArray> receiver,
                                     BuiltinArguments* args,
                                     uint32_t unshift_size) {
    DirectHandle<FixedArrayBase> backing_store(receiver->elements(),
                                               receiver->GetIsolate());
    return Subclass::AddArguments(receiver, backing_store, args, unshift_size,
                                  AT_START);
  }

  static DirectHandle<FixedArrayBase> MoveElements(
      Isolate* isolate, DirectHandle<JSArray> receiver,
      DirectHandle<FixedArrayBase> backing_store, int dst_index, int src_index,
      int len, int hole_start, int hole_end) {
    DisallowGarbageCollection no_gc;
    Tagged<BackingStore> dst_elms = Cast<BackingStore>(*backing_store);
    if (len > JSArray::kMaxCopyElements && dst_index == 0 &&
        isolate->heap()->CanMoveObjectStart(dst_elms)) {
      dst_elms = Cast<BackingStore>(
          isolate->heap()->LeftTrimFixedArray(dst_elms, src_index));
      // Updates this backing_store handle.
      backing_store.SetValue(dst_elms);
      receiver->set_elements(dst_elms);
      // Adjust the hole offset as the array has been shrunk.
      hole_end -= src_index;
      DCHECK_LE(hole_start, backing_store->length());
      DCHECK_LE(hole_end, backing_store->length());
    } else if (len != 0) {
      WriteBarrierMode mode =
          GetWriteBarrierMode(dst_elms, KindTraits::Kind, no_gc);
      dst_elms->MoveElements(isolate, dst_index, src_index, len, mode);
    }
    if (hole_start != hole_end) {
      dst_elms->FillWithHoles(hole_start, hole_end);
    }
    return backing_store;
  }

  static MaybeDirectHandle<Object> FillImpl(DirectHandle<JSObject> receiver,
                                            DirectHandle<Object> obj_value,
                                            size_t start, size_t end) {
    // Ensure indexes are within array bounds
    DCHECK_LE(0, start);
    DCHECK_LE(start, end);

    // Make sure COW arrays are copied.
    if (IsSmiOrObjectElementsKind(Subclass::kind())) {
      JSObject::EnsureWritableFastElements(receiver);
    }

    // Make sure we have enough space.
    DCHECK_LE(end, std::numeric_limits<uint32_t>::max());
    if (end > Subclass::GetCapacityImpl(*receiver, receiver->elements())) {
      MAYBE_RETURN_NULL(Subclass::GrowCapacityAndConvertImpl(
          receiver, static_cast<uint32_t>(end)));
      CHECK_EQ(Subclass::kind(), receiver->GetElementsKind());
    }
    DCHECK_LE(end, Subclass::GetCapacityImpl(*receiver, receiver->elements()));

    for (size_t index = start; index < end; ++index) {
      Subclass::SetImpl(receiver, InternalIndex(index), *obj_value);
    }
    return MaybeDirectHandle<Object>(receiver);
  }

  static Maybe<bool> IncludesValueImpl(Isolate* isolate,
                                       DirectHandle<JSObject> receiver,
                                       DirectHandle<Object> search_value,
                                       size_t start_from, size_t length) {
    DCHECK(JSObject::PrototypeHasNoElements(isolate, *receiver));
    DisallowGarbageCollection no_gc;
    Tagged<FixedArrayBase> elements_base = receiver->elements();
    Tagged<Object> the_hole = ReadOnlyRoots(isolate).the_hole_value();
    Tagged<Object> undefined = ReadOnlyRoots(isolate).undefined_value();
    Tagged<Object> value = *search_value;

    if (start_from >= length) return Just(false);

    // Elements beyond the capacity of the backing store treated as undefined.
    size_t elements_length = static_cast<size_t>(elements_base->length());
    if (value == undefined && elements_length < length) return Just(true);
    if (elements_length == 0) {
      DCHECK_NE(value, undefined);
      return Just(false);
    }

    length = std::min(elements_length, length);
    DCHECK_LE(length, std::numeric_limits<int>::max());

    if (!IsNumber(value)) {
      if (value == undefined) {
        // Search for `undefined` or The Hole. Even in the case of
        // PACKED_DOUBLE_ELEMENTS or PACKED_SMI_ELEMENTS, we might encounter The
        // Hole here, since the {length} used here can be larger than
        // JSArray::length.
        if (IsSmiOrObjectElementsKind(Subclass::kind()) ||
            IsAnyNonextensibleElementsKind(Subclass::kind())) {
          Tagged<FixedArray> elements = Cast<FixedArray>(receiver->elements());

          for (size_t k = start_from; k < length; ++k) {
            Tagged<Object> element_k = elements->get(static_cast<int>(k));

            if (element_k == the_hole || element_k == undefined) {
              return Just(true);
            }
          }
          return Just(false);
        } else {
          // Search for The Hole in HOLEY_DOUBLE_ELEMENTS or
          // PACKED_DOUBLE_ELEMENTS.
          DCHECK(IsDoubleElementsKind(Subclass::kind()));
          Tagged<FixedDoubleArray> elements =
              Cast<FixedDoubleArray>(receiver->elements());

          for (size_t k = start_from; k < length; ++k) {
            if (elements->is_the_hole(static_cast<int>(k))) return Just(true);
          }
          return Just(false);
        }
      } else if (!IsObjectElementsKind(Subclass::kind()) &&
                 !IsAnyNonextensibleElementsKind(Subclass::kind())) {
        // Search for non-number, non-Undefined value, with either
        // PACKED_SMI_ELEMENTS, PACKED_DOUBLE_ELEMENTS, HOLEY_SMI_ELEMENTS or
        // HOLEY_DOUBLE_ELEMENTS. Guaranteed to return false, since these
        // elements kinds can only contain Number values or undefined.
        return Just(false);
      } else {
        // Search for non-number, non-Undefined value with either
        // PACKED_ELEMENTS or HOLEY_ELEMENTS.
        DCHECK(IsObjectElementsKind(Subclass::kind()) ||
               IsAnyNonextensibleElementsKind(Subclass::kind()));
        Tagged<FixedArray> elements = Cast<FixedArray>(receiver->elements());

        for (size_t k = start_from; k < length; ++k) {
          Tagged<Object> element_k = elements->get(static_cast<int>(k));
          if (element_k == the_hole) continue;
          if (Object::SameValueZero(value, element_k)) return Just(true);
        }
        return Just(false);
      }
    } else {
      if (!IsNaN(value)) {
        double search_number = Object::NumberValue(value);
        if (IsDoubleElementsKind(Subclass::kind())) {
          // Search for non-NaN Number in PACKED_DOUBLE_ELEMENTS or
          // HOLEY_DOUBLE_ELEMENTS --- Skip TheHole, and trust UCOMISD or
          // similar operation for result.
          Tagged<FixedDoubleArray> elements =
              Cast<FixedDoubleArray>(receiver->elements());

          for (size_t k = start_from; k < length; ++k) {
            if (elements->is_the_hole(static_cast<int>(k))) continue;
            if (elements->get_scalar(static_cast<int>(k)) == search_number) {
              return Just(true);
            }
          }
          return Just(false);
        } else {
          // Search for non-NaN Number in PACKED_ELEMENTS, HOLEY_ELEMENTS,
          // PACKED_SMI_ELEMENTS or HOLEY_SMI_ELEMENTS --- Skip non-Numbers,
          // and trust UCOMISD or similar operation for result
          Tagged<FixedArray> elements = Cast<FixedArray>(receiver->elements());

          for (size_t k = start_from; k < length; ++k) {
            Tagged<Object> element_k = elements->get(static_cast<int>(k));
            if (IsNumber(element_k) &&
                Object::NumberValue(element_k) == search_number) {
              return Just(true);
            }
          }
          return Just(false);
        }
      } else {
        // Search for NaN --- NaN cannot be represented with Smi elements, so
        // abort if ElementsKind is PACKED_SMI_ELEMENTS or HOLEY_SMI_ELEMENTS
        if (IsSmiElementsKind(Subclass::kind())) return Just(false);

        if (IsDoubleElementsKind(Subclass::kind())) {
          // Search for NaN in PACKED_DOUBLE_ELEMENTS or
          // HOLEY_DOUBLE_ELEMENTS --- Skip The Hole and trust
          // std::isnan(elementK) for result
          Tagged<FixedDoubleArray> elements =
              Cast<FixedDoubleArray>(receiver->elements());

          for (size_t k = start_from; k < length; ++k) {
            if (elements->is_the_hole(static_cast<int>(k))) continue;
            if (std::isnan(elements->get_scalar(static_cast<int>(k)))) {
              return Just(true);
            }
          }
          return Just(false);
        } else {
          // Search for NaN in PACKED_ELEMENTS or HOLEY_ELEMENTS. Return true
          // if elementK->IsHeapNumber() && std::isnan(elementK->Number())
          DCHECK(IsObjectElementsKind(Subclass::kind()) ||
                 IsAnyNonextensibleElementsKind(Subclass::kind()));
          Tagged<FixedArray> elements = Cast<FixedArray>(receiver->elements());

          for (size_t k = start_from; k < length; ++k) {
            if (IsNaN(elements->get(static_cast<int>(k)))) return Just(true);
          }
          return Just(false);
        }
      }
    }
  }

  static Handle<FixedArray> CreateListFromArrayLikeImpl(
      Isolate* isolate, DirectHandle<JSObject> object, uint32_t length) {
    Handle<FixedArray> result = isolate->factory()->NewFixedArray(length);
    DirectHandle<FixedArrayBase> elements(object->elements(), isolate);
    for (uint32_t i = 0; i < length; i++) {
      InternalIndex entry(i);
      if (!Subclass::HasEntryImpl(isolate, *elements, entry)) continue;
      DirectHandle<Object> value;
      value = Subclass::GetImpl(isolate, *elements, entry);
      if (IsName(*value)) {
        value = isolate->factory()->InternalizeName(Cast<Name>(value));
      }
      result->set(i, *value);
    }
    return result;
  }

  static MaybeDirectHandle<Object> RemoveElement(DirectHandle<JSArray> receiver,
                                                 Where remove_position) {
    Isolate* isolate = receiver->GetIsolate();
    ElementsKind kind = KindTraits::Kind;
    if (IsSmiOrObjectElementsKind(kind)) {
      HandleScope scope(isolate);
      JSObject::EnsureWritableFastElements(receiver);
    }
    DirectHandle<FixedArrayBase> backing_store(receiver->elements(), isolate);
    uint32_t length = static_cast<uint32_t>(Smi::ToInt(receiver->length()));
    DCHECK_GT(length, 0);
    int new_length = length - 1;
    int remove_index = remove_position == AT_START ? 0 : new_length;
    DirectHandle<Object> result =
        Subclass::GetImpl(isolate, *backing_store, InternalIndex(remove_index));
    if (remove_position == AT_START) {
      backing_store = Subclass::MoveElements(isolate, receiver, backing_store,
                                             0, 1, new_length, 0, 0);
    }
    MAYBE_RETURN_NULL(
        Subclass::SetLengthImpl(isolate, receiver, new_length, backing_store));

    if (IsHoleyElementsKind(kind) && IsTheHole(*result, isolate)) {
      return isolate->factory()->undefined_value();
    }
    return MaybeDirectHandle<Object>(result);
  }

  static Maybe<uint32_t> AddArguments(
      DirectHandle<JSArray> receiver,
      DirectHandle<FixedArrayBase> backing_store, BuiltinArguments* args,
      uint32_t add_size, Where add_position) {
    uint32_t length = Smi::ToInt(receiver->length());
    DCHECK_LT(0, add_size);
    uint32_t elms_len = backing_store->length();
    // Check we do not overflow the new_length.
    DCHECK(add_size <= static_cast<uint32_t>(Smi::kMaxValue - length));
    uint32_t new_length = length + add_size;
    Isolate* isolate = receiver->GetIsolate();

    if (new_length > elms_len) {
      // New backing storage is needed.
      uint32_t capacity = JSObject::NewElementsCapacity(new_length);
      // If we add arguments to the start we have to shift the existing objects.
      int copy_dst_index = add_position == AT_START ? add_size : 0;
      // Copy over all objects to a new backing_store.
      ASSIGN_RETURN_ON_EXCEPTION_VALUE(
          isolate, backing_store,
          Subclass::ConvertElementsWithCapacity(receiver, backing_store,
                                                KindTraits::Kind, capacity, 0,
                                                copy_dst_index),
          Nothing<uint32_t>());
      receiver->set_elements(*backing_store);
    } else if (add_position == AT_START) {
      // If the backing store has enough capacity and we add elements to the
      // start we have to shift the existing objects.
      backing_store = Subclass::MoveElements(isolate, receiver, backing_store,
                                             add_size, 0, length, 0, 0);
    }

    int insertion_index = add_position == AT_START ? 0 : length;
    // Copy the arguments to the start.
    Subclass::CopyArguments(args, backing_store, add_size, 1, insertion_index);
    // Set the length.
    receiver->set_length(Smi::FromInt(new_length));
    return Just(new_length);
  }

  static void CopyArguments(BuiltinArguments* args,
                            DirectHandle<FixedArrayBase> dst_store,
                            uint32_t copy_size, uint32_t src_index,
                            uint32_t dst_index) {
    // Add the provided values.
    DisallowGarbageCollection no_gc;
    Tagged<FixedArrayBase> raw_backing_store = *dst_store;
    WriteBarrierMode mode = raw_backing_store->GetWriteBarrierMode(no_gc);
    for (uint32_t i = 0; i < copy_size; i++) {
      Tagged<Object> argument = (*args)|src_index + i];
      DCHECK(!IsTheHole(argument));
      Subclass::SetImpl(raw_backing_store, InternalIndex(dst_index + i),
                        argument, mode);
    }
  }
};

template <typename Subclass, typename KindTraits>
class FastSmiOrObjectElementsAccessor
    : public FastElementsAccessor<Subclass, KindTraits> {
 public:
  static inline void SetImpl(DirectHandle<JSObject> holder, InternalIndex entry,
                             Tagged<Object> value) {
    SetImpl(holder->elements(), entry, value);
  }

  static inline void SetImpl(Tagged<FixedArrayBase> backing_store,
                             InternalIndex entry, Tagged<Object> value) {
    Cast<FixedArray>(backing_store)->set(entry.as_int(), value);
  }

  static inline void SetImpl(Tagged<FixedArrayBase> backing_store,
                             InternalIndex entry, Tagged<Object> value,
                             WriteBarrierMode mode) {
    Cast<FixedArray>(backing_store)->set(entry.as_int(), value, mode);
  }

  static Tagged<Object> GetRaw(Tagged<FixedArray> backing_store,
                               InternalIndex entry) {
    return backing_store->get(entry.as_int());
  }

  // NOTE: this method violates the handlified function signature convention:
  // raw pointer parameters in the function that allocates.
  // See ElementsAccessor::CopyElements() for details.
  // This method could actually allocate if copying from double elements to
  // object elements.
  static void CopyElementsImpl(Isolate* isolate, Tagged<FixedArrayBase> from,
                               uint32_t from_start, Tagged<FixedArrayBase> to,
                               ElementsKind from_kind, uint32_t to_start,
                               int packed_size, int copy_size) {
    DisallowGarbageCollection no_gc;
    ElementsKind to_kind = KindTraits::Kind;
    switch (from_kind) {
      case PACKED_SMI_ELEMENTS:
      case HOLEY_SMI_ELEMENTS:
      case PACKED_ELEMENTS:
      case PACKED_FROZEN_ELEMENTS:
      case PACKED_SEALED_ELEMENTS:
      case PACKED_NONEXTENSIBLE_ELEMENTS:
      case HOLEY_ELEMENTS:
      case HOLEY_FROZEN_ELEMENTS:
      case HOLEY_SEALED_ELEMENTS:
      case HOLEY_NONEXTENSIBLE_ELEMENTS:
      case SHARED_ARRAY_ELEMENTS:
        CopyObjectToObjectElements(isolate, from, from_kind, from_start, to,
                                   to_kind, to_start, copy_size);
        break;
      case PACKED_DOUBLE_ELEMENTS:
      case HOLEY_DOUBLE_ELEMENTS: {
        AllowGarbageCollection allow_allocation;
        DCHECK(IsObjectElementsKind(to_kind));
        CopyDoubleToObjectElements(isolate, from, from_start, to, to_start,
                                   copy_size);
        break;
      }
      case DICTIONARY_ELEMENTS:
        CopyDictionaryToObjectElements(isolate, from, from_start, to, to_kind,
                                       to_start, copy_size);
        break;
      case FAST_SLOPPY_ARGUMENTS_ELEMENTS:
      case SLOW_SLOPPY_ARGUMENTS_ELEMENTS:
      case FAST_STRING_WRAPPER_ELEMENTS:
      case SLOW_STRING_WRAPPER_ELEMENTS:
#define TYPED_ARRAY_CASE(Type, type, TYPE, ctype) case TYPE##_ELEMENTS:
        TYPED_ARRAYS(TYPED_ARRAY_CASE)
        RAB_GSAB_TYPED_ARRAYS(TYPED_ARRAY_CASE)
#undef TYPED_ARRAY_CASE
      case WASM_ARRAY_ELEMENTS:
        // This function is currently only used for JSArrays with non-zero
        // length.
        UNREACHABLE();
      case NO_ELEMENTS:
        break;  // Nothing to do.
    }
  }

  static Maybe<bool> CollectValuesOrEntriesImpl(
      Isolate* isolate, DirectHandle<JSObject> object,
      DirectHandle<FixedArray> values_or_entries, bool get_entries,
      int* nof_items, PropertyFilter filter) {
    int count = 0;
    if (get_entries) {
      // Collecting entries needs to allocate, so this code must be handlified.
      DirectHandle<FixedArray> elements(Cast<FixedArray>(object->elements()),
                                        isolate);
      uint32_t length = elements->length();
      for (uint32_t index = 0; index < length; ++index) {
        InternalIndex entry(index);
        if (!Subclass::HasEntryImpl(isolate, *elements, entry)) continue;
        DirectHandle<Object> value =
            Subclass::GetImpl(isolate, *elements, entry);
        value = MakeEntryPair(isolate, index, value);
        values_or_entries->set(count++, *value);
      }
    } else {
      // No allocations here, so we can avoid handlification overhead.
      DisallowGarbageCollection no_gc;
      Tagged<FixedArray> elements = Cast<FixedArray>(object->elements());
      uint32_t length = elements->length();
      for (uint32_t index = 0; index < length; ++index) {
        InternalIndex entry(index);
        if (!Subclass::HasEntryImpl(isolate, elements, entry)) continue;
        Tagged<Object> value = GetRaw(elements, entry);
        values_or_entries->set(count++, value);
      }
    }
    *nof_items = count;
    return Just(true);
  }

  static Maybe<int64_t> IndexOfValueImpl(Isolate* isolate,
                                         DirectHandle<JSObject> receiver,
                                         DirectHandle<Object> search_value,
                                         size_t start_from, size_t length) {
    DCHECK(JSObject::PrototypeHasNoElements(isolate, *receiver));
    DisallowGarbageCollection no_gc;
    Tagged<FixedArrayBase> elements_base = receiver->elements();
    Tagged<Object> value = *search_value;

    if (start_from >= length) return Just<int64_t>(-1);

    length = std::min(static_cast<size_t>(elements_base->length()), length);

    // Only FAST_{,HOLEY_}ELEMENTS can store non-numbers.
    if (!IsNumber(value) && !IsObjectElementsKind(Subclass::kind()) &&
        !IsAnyNonextensibleElementsKind(Subclass::kind())) {
      return Just<int64_t>(-1);
    }
    // NaN can never be found by strict equality.
    if (IsNaN(value)) return Just<int64_t>(-1);

    // k can be greater than receiver->length() below, but it is bounded by
    // elements_base->length() so we never read out of bounds. This means that
    // elements->get(k) can return the hole, for which the StrictEquals will
    // always fail.
    Tagged<FixedArray> elements = Cast<FixedArray>(receiver->elements());
    static_assert(FixedArray::kMaxLength <=
                  std::numeric_limits<uint32_t>::max());
    for (size_t k = start_from; k < length; ++k) {
      if (Object::StrictEquals(value,
                               elements->get(static_cast<uint32_t>(k)))) {
        return Just<int64_t>(k);
      }
    }
    return Just<int64_t>(-1);
  }
};

class FastPackedSmiElementsAccessor
    : public FastSmiOrObjectElementsAccessor<
          FastPackedSmiElementsAccessor,
          ElementsKindTraits<PACKED_SMI_ELEMENTS>> {};

class FastHoleySmiElementsAccessor
    : public FastSmiOrObjectElementsAccessor<
          FastHoleySmiElementsAccessor,
          ElementsKindTraits<HOLEY_SMI_ELEMENTS>> {};

class FastPackedObjectElementsAccessor
    : public FastSmiOrObjectElementsAccessor<
          FastPackedObjectElementsAccessor,
          ElementsKindTraits<PACKED_ELEMENTS>> {};

template <typename Subclass, typename KindTraits>
class FastNonextensibleObjectElementsAccessor
    : public FastSmiOrObjectElementsAccessor<Subclass, KindTraits> {
 public:
  using BackingStore = typename KindTraits::BackingStore;

  static Maybe<uint32_t> PushImpl(DirectHandle<JSArray> receiver,
                                  BuiltinArguments* args, uint32_t push_size) {
    UNREACHABLE();
  }

  static Maybe<bool> AddImpl(DirectHandle<JSObject> object, uint32_t index,
                             DirectHandle<Object> value,
                             PropertyAttributes attributes,
                             uint32_t new_capacity) {
    UNREACHABLE();
  }

  // TODO(duongn): refactor this due to code duplication of sealed version.
  // Consider using JSObject::NormalizeElements(). Also consider follow the fast
  // element logic instead of changing to dictionary mode.
  static Maybe<bool> SetLengthImpl(Isolate* isolate,
                                   DirectHandle<JSArray> array, uint32_t length,
                                   DirectHandle<FixedArrayBase> backing_store) {
    uint32_t old_length = 0;
    CHECK(Object::ToArrayIndex(array->length(), &old_length));
    if (length == old_length) {
      // Do nothing.
      return Just(true);
    }

    // Transition to DICTIONARY_ELEMENTS.
    // Convert to dictionary mode.
    DirectHandle<NumberDictionary> new_element_dictionary =
        old_length == 0 ? isolate->factory()->empty_slow_element_dictionary()
                        : array->GetElementsAccessor()->Normalize(array);

    // Migrate map.
    DirectHandle<Map> new_map =
        Map::Copy(isolate, direct_handle(array->map(), isolate),
                  "SlowCopyForSetLengthImpl");
    new_map->set_is_extensible(false);
    new_map->set_elements_kind(DICTIONARY_ELEMENTS);
    JSObject::MigrateToMap(isolate, array, new_map);

    if (!new_element_dictionary.is_null()) {
      array->set_elements(*new_element_dictionary);
    }

    if (array->elements() !=
        ReadOnlyRoots(isolate).empty_slow_element_dictionary()) {
      DirectHandle<NumberDictionary> dictionary(array->element_dictionary(),
                                                isolate);
      // Make sure we never go back to the fast case
      array->RequireSlowElements(*dictionary);
      JSObject::ApplyAttributesToDictionary(isolate, ReadOnlyRoots(isolate),
                                            dictionary,
                                            PropertyAttributes::NONE);
    }

    // Set length.
    DirectHandle<FixedArrayBase> new_backing_store(array->elements(), isolate);
    return DictionaryElementsAccessor::SetLengthImpl(isolate, array, length,
                                                     new_backing_store);
  }
};

class FastPackedNonextensibleObjectElementsAccessor
    : public FastNonextensibleObjectElementsAccessor<
          FastPackedNonextensibleObjectElementsAccessor,
          ElementsKindTraits<PACKED_NONEXTENSIBLE_ELEMENTS>> {};

class FastHoleyNonextensibleObjectElementsAccessor
    : public FastNonextensibleObjectElementsAccessor<
          FastHoleyNonextensibleObjectElementsAccessor,
          ElementsKindTraits<HOLEY_NONEXTENSIBLE_ELEMENTS>> {};

template <typename Subclass, typename KindTraits>
class FastSealedObjectElementsAccessor
    : public FastSmiOrObjectElementsAccessor<Subclass, KindTraits> {
 public:
  using BackingStore = typename KindTraits::BackingStore;

  static DirectHandle<Object> RemoveElement(DirectHandle<JSArray> receiver,
                                            Where remove_position) {
    UNREACHABLE();
  }

  static void DeleteImpl(DirectHandle<JSObject> obj, InternalIndex entry) {
    UNREACHABLE();
  }

  static void DeleteAtEnd(DirectHandle<JSObject> obj,
                          DirectHandle<BackingStore> backing_store,
                          uint32_t entry) {
    UNREACHABLE();
  }

  static void DeleteCommon(DirectHandle<JSObject> obj, uint32_t entry,
                           DirectHandle<FixedArrayBase> store) {
    UNREACHABLE();
  }

  static MaybeDirectHandle<Object> PopImpl(DirectHandle<JSArray> receiver) {
    UNREACHABLE();
  }

  static Maybe<uint32_t> PushImpl(DirectHandle<JSArray> receiver,
                                  BuiltinArguments* args, uint32_t push_size) {
    UNREACHABLE();
  }

  static Maybe<bool> AddImpl(DirectHandle<JSObject> object, uint32_t index,
                             DirectHandle<Object> value,
                             PropertyAttributes attributes,
                             uint32_t new_capacity) {
    UNREACHABLE();
  }

  // TODO(duongn): refactor this due to code duplication of nonextensible
  // version. Consider using JSObject::NormalizeElements(). Also consider follow
  // the fast element logic instead of changing to dictionary mode.
  static Maybe<bool> SetLengthImpl(Isolate* isolate,
                                   DirectHandle<JSArray> array, uint32_t length,
                                   DirectHandle<FixedArrayBase> backing_store) {
    uint32_t old_length = 0;
    CHECK(Object::ToArrayIndex(array->length(), &old_length));
    if (length == old_length) {
      // Do nothing.
      return Just(true);
    }

    // Transition to DICTIONARY_ELEMENTS.
    // Convert to dictionary mode
    DirectHandle<NumberDictionary> new_element_dictionary =
        old_length == 0 ? isolate->factory()->empty_slow_element_dictionary()
                        : array->GetElementsAccessor()->Normalize(array);

    // Migrate map.
    DirectHandle<Map> new_map =
        Map::Copy(isolate, direct_handle(array->map(), isolate),
                  "SlowCopyForSetLengthImpl");
    new_map->set_is_extensible(false);
    new_map->set_elements_kind(DICTIONARY_ELEMENTS);
    JSObject::MigrateToMap(isolate, array, new_map);

    if (!new_element_dictionary.is_null()) {
      array->set_elements(*new_element_dictionary);
    }

    if (array->elements() !=
        ReadOnlyRoots(isolate).empty_slow_element_dictionary()) {
      DirectHandle<NumberDictionary> dictionary(array->element_dictionary(),
                                                isolate);
      // Make sure we never go back to the fast case
      array->RequireSlowElements(*dictionary);
      JSObject::ApplyAttributesToDictionary(isolate, ReadOnlyRoots(isolate),
                                            dictionary,
                                            PropertyAttributes::SEALED);
    }

    // Set length
    DirectHandle<FixedArrayBase> new_backing_store(array->elements(), isolate);
    return DictionaryElementsAccessor::SetLengthImpl(isolate, array, length,
                                                     new_backing_store);
  }
};

class FastPackedSealedObjectElementsAccessor
    : public FastSealedObjectElementsAccessor<
          FastPackedSealedObjectElementsAccessor,
          ElementsKindTraits<PACKED_SEALED_ELEMENTS>> {};

class SharedArrayElementsAccessor
    : public FastSealedObjectElementsAccessor<
          SharedArrayElementsAccessor,
          ElementsKindTraits<SHARED_ARRAY_ELEMENTS>> {
 public:
  static Handle<Object> GetAtomicInternalImpl(
      Isolate* isolate, Tagged<FixedArrayBase> backing_store,
      InternalIndex entry, SeqCstAccessTag tag) {
    return handle(Cast<BackingStore>(backing_store)->get(entry.as_int(), tag),
                  isolate);
  }

  static void SetAtomicInternalImpl(Tagged<FixedArrayBase> backing_store,
                                    InternalIndex entry, Tagged<Object> value,
                                    SeqCstAccessTag tag) {
    Cast<BackingStore>(backing_store)->set(entry.as_int(), value, tag);
  }
[Step 12: Duration 2.96 seconds| Input tokens: 421,003 | Output tokens: 2,460]
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ Step 13 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'init_rag_db' with arguments: {'id': 'elements_recon_v1'}                                                                                                                │
╰────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
Error executing tool 'init_rag_db' with arguments {'id': 'elements_recon_v1'}: NameError: name 'rag_db_id' is not defined
Please try again or use another tool
[Step 13: Duration 15.26 seconds| Input tokens: 517,229 | Output tokens: 3,385]
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ Step 14 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'init_rag_db' with arguments: {'id': 'elements_recon_v1'}                                                                                                                │
╰────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
Error executing tool 'init_rag_db' with arguments {'id': 'elements_recon_v1'}: NameError: name 'rag_db_id' is not defined
Please try again or use another tool
[Step 14: Duration 10.63 seconds| Input tokens: 613,530 | Output tokens: 3,798]
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ Step 15 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'read_file' with arguments: {'file_path': 'objects/elements.cc', 'section': 2}                                                                                           │
╰────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
Command: cd /Users/tarun/v8/v8/src && wc -l '/Users/tarun/v8/v8/src/objects/elements.cc'
Command: cd /Users/tarun/v8/v8/src && sed -n '3001,5779p' '/Users/tarun/v8/v8/src/objects/elements.cc'
Observations: Showing section 2/2 (lines 3001-5779) of 'objects/elements.cc':
  static Handle<Object> SwapAtomicInternalImpl(
      Isolate* isolate, Tagged<FixedArrayBase> backing_store,
      InternalIndex entry, Tagged<Object> value, SeqCstAccessTag tag) {
    return handle(
        Cast<BackingStore>(backing_store)->swap(entry.as_int(), value, tag),
        isolate);
  }

  static Tagged<Object> CompareAndSwapAtomicInternalImpl(
      Tagged<FixedArrayBase> backing_store, InternalIndex entry,
      Tagged<Object> expected, Tagged<Object> value, SeqCstAccessTag tag) {
    return Cast<BackingStore>(backing_store)
        ->compare_and_swap(entry.as_int(), expected, value, tag);
  }
};

class FastHoleySealedObjectElementsAccessor
    : public FastSealedObjectElementsAccessor<
          FastHoleySealedObjectElementsAccessor,
          ElementsKindTraits<HOLEY_SEALED_ELEMENTS>> {};

template <typename Subclass, typename KindTraits>
class FastFrozenObjectElementsAccessor
    : public FastSmiOrObjectElementsAccessor<Subclass, KindTraits> {
 public:
  using BackingStore = typename KindTraits::BackingStore;

  static inline void SetImpl(DirectHandle<JSObject> holder, InternalIndex entry,
                             Tagged<Object> value) {
    UNREACHABLE();
  }

  static inline void SetImpl(Tagged<FixedArrayBase> backing_store,
                             InternalIndex entry, Tagged<Object> value) {
    UNREACHABLE();
  }

  static inline void SetImpl(Tagged<FixedArrayBase> backing_store,
                             InternalIndex entry, Tagged<Object> value,
                             WriteBarrierMode mode) {
    UNREACHABLE();
  }

  static DirectHandle<Object> RemoveElement(DirectHandle<JSArray> receiver,
                                            Where remove_position) {
    UNREACHABLE();
  }

  static void DeleteImpl(DirectHandle<JSObject> obj, InternalIndex entry) {
    UNREACHABLE();
  }

  static void DeleteAtEnd(DirectHandle<JSObject> obj,
                          DirectHandle<BackingStore> backing_store,
                          uint32_t entry) {
    UNREACHABLE();
  }

  static void DeleteCommon(DirectHandle<JSObject> obj, uint32_t entry,
                           DirectHandle<FixedArrayBase> store) {
    UNREACHABLE();
  }

  static MaybeDirectHandle<Object> PopImpl(DirectHandle<JSArray> receiver) {
    UNREACHABLE();
  }

  static Maybe<uint32_t> PushImpl(DirectHandle<JSArray> receiver,
                                  BuiltinArguments* args, uint32_t push_size) {
    UNREACHABLE();
  }

  static Maybe<bool> AddImpl(DirectHandle<JSObject> object, uint32_t index,
                             DirectHandle<Object> value,
                             PropertyAttributes attributes,
                             uint32_t new_capacity) {
    UNREACHABLE();
  }

  static Maybe<bool> SetLengthImpl(Isolate* isolate,
                                   DirectHandle<JSArray> array, uint32_t length,
                                   DirectHandle<FixedArrayBase> backing_store) {
    UNREACHABLE();
  }

  static void ReconfigureImpl(DirectHandle<JSObject> object,
                              DirectHandle<FixedArrayBase> store,
                              InternalIndex entry, DirectHandle<Object> value,
                              PropertyAttributes attributes) {
    UNREACHABLE();
  }
};

class FastPackedFrozenObjectElementsAccessor
    : public FastFrozenObjectElementsAccessor<
          FastPackedFrozenObjectElementsAccessor,
          ElementsKindTraits<PACKED_FROZEN_ELEMENTS>> {};

class FastHoleyFrozenObjectElementsAccessor
    : public FastFrozenObjectElementsAccessor<
          FastHoleyFrozenObjectElementsAccessor,
          ElementsKindTraits<HOLEY_FROZEN_ELEMENTS>> {};

class FastHoleyObjectElementsAccessor
    : public FastSmiOrObjectElementsAccessor<
          FastHoleyObjectElementsAccessor, ElementsKindTraits<HOLEY_ELEMENTS>> {
};

// Helper templates to statically determine if our destination type can contain
// the source type.
template <ElementsKind Kind, typename ElementType, ElementsKind SourceKind,
          typename SourceElementType>
struct CopyBetweenBackingStoresImpl;

template <typename Subclass, typename KindTraits>
class FastDoubleElementsAccessor
    : public FastElementsAccessor<Subclass, KindTraits> {
 public:
  static Handle<Object> GetImpl(Isolate* isolate,
                                Tagged<FixedArrayBase> backing_store,
                                InternalIndex entry) {
    return FixedDoubleArray::get(Cast<FixedDoubleArray>(backing_store),
                                 entry.as_int(), isolate);
  }

  static inline void SetImpl(DirectHandle<JSObject> holder, InternalIndex entry,
                             Tagged<Object> value) {
    SetImpl(holder->elements(), entry, value);
  }

  static inline void SetImpl(Tagged<FixedArrayBase> backing_store,
                             InternalIndex entry, Tagged<Object> value) {
    Cast<FixedDoubleArray>(backing_store)
        ->set(entry.as_int(), Object::NumberValue(value));
  }

  static inline void SetImpl(Tagged<FixedArrayBase> backing_store,
                             InternalIndex entry, Tagged<Object> value,
                             WriteBarrierMode mode) {
    Cast<FixedDoubleArray>(backing_store)
        ->set(entry.as_int(), Object::NumberValue(value));
  }

  static void CopyElementsImpl(Isolate* isolate, Tagged<FixedArrayBase> from,
                               uint32_t from_start, Tagged<FixedArrayBase> to,
                               ElementsKind from_kind, uint32_t to_start,
                               int packed_size, int copy_size) {
    DisallowGarbageCollection no_gc;
    switch (from_kind) {
      case PACKED_SMI_ELEMENTS:
        CopyPackedSmiToDoubleElements(from, from_start, to, to_start,
                                      packed_size, copy_size);
        break;
      case HOLEY_SMI_ELEMENTS:
        CopySmiToDoubleElements(from, from_start, to, to_start, copy_size);
        break;
      case PACKED_DOUBLE_ELEMENTS:
      case HOLEY_DOUBLE_ELEMENTS:
        CopyDoubleToDoubleElements(from, from_start, to, to_start, copy_size);
        break;
      case PACKED_ELEMENTS:
      case PACKED_FROZEN_ELEMENTS:
      case PACKED_SEALED_ELEMENTS:
      case PACKED_NONEXTENSIBLE_ELEMENTS:
      case HOLEY_ELEMENTS:
      case HOLEY_FROZEN_ELEMENTS:
      case HOLEY_SEALED_ELEMENTS:
      case HOLEY_NONEXTENSIBLE_ELEMENTS:
      case SHARED_ARRAY_ELEMENTS:
        CopyObjectToDoubleElements(from, from_start, to, to_start, copy_size);
        break;
      case DICTIONARY_ELEMENTS:
        CopyDictionaryToDoubleElements(isolate, from, from_start, to, to_start,
                                       copy_size);
        break;
      case FAST_SLOPPY_ARGUMENTS_ELEMENTS:
      case SLOW_SLOPPY_ARGUMENTS_ELEMENTS:
      case FAST_STRING_WRAPPER_ELEMENTS:
      case SLOW_STRING_WRAPPER_ELEMENTS:
      case WASM_ARRAY_ELEMENTS:
      case NO_ELEMENTS:
#define TYPED_ARRAY_CASE(Type, type, TYPE, ctype) case TYPE##_ELEMENTS:
        TYPED_ARRAYS(TYPED_ARRAY_CASE)
        RAB_GSAB_TYPED_ARRAYS(TYPED_ARRAY_CASE)
#undef TYPED_ARRAY_CASE
        // This function is currently only used for JSArrays with non-zero
        // length.
        UNREACHABLE();
    }
  }

  static Maybe<bool> CollectValuesOrEntriesImpl(
      Isolate* isolate, DirectHandle<JSObject> object,
      DirectHandle<FixedArray> values_or_entries, bool get_entries,
      int* nof_items, PropertyFilter filter) {
    DirectHandle<FixedDoubleArray> elements(
        Cast<FixedDoubleArray>(object->elements()), isolate);
    int count = 0;
    uint32_t length = elements->length();
    for (uint32_t index = 0; index < length; ++index) {
      InternalIndex entry(index);
      if (!Subclass::HasEntryImpl(isolate, *elements, entry)) continue;
      DirectHandle<Object> value = Subclass::GetImpl(isolate, *elements, entry);
      if (get_entries) {
        value = MakeEntryPair(isolate, index, value);
      }
      values_or_entries->set(count++, *value);
    }
    *nof_items = count;
    return Just(true);
  }

  static Maybe<int64_t> IndexOfValueImpl(Isolate* isolate,
                                         DirectHandle<JSObject> receiver,
                                         DirectHandle<Object> search_value,
                                         size_t start_from, size_t length) {
    DCHECK(JSObject::PrototypeHasNoElements(isolate, *receiver));
    DisallowGarbageCollection no_gc;
    Tagged<FixedArrayBase> elements_base = receiver->elements();
    Tagged<Object> value = *search_value;

    length = std::min(static_cast<size_t>(elements_base->length()), length);

    if (start_from >= length) return Just<int64_t>(-1);

    if (!IsNumber(value)) {
      return Just<int64_t>(-1);
    }
    if (IsNaN(value)) {
      return Just<int64_t>(-1);
    }
    double numeric_search_value = Object::NumberValue(value);
    Tagged<FixedDoubleArray> elements =
        Cast<FixedDoubleArray>(receiver->elements());

    static_assert(FixedDoubleArray::kMaxLength <=
                  std::numeric_limits<int>::max());
    for (size_t k = start_from; k < length; ++k) {
      int k_int = static_cast<int>(k);
      if (elements->is_the_hole(k_int)) {
        continue;
      }
      if (elements->get_scalar(k_int) == numeric_search_value) {
        return Just<int64_t>(k);
      }
    }
    return Just<int64_t>(-1);
  }
};

class FastPackedDoubleElementsAccessor
    : public FastDoubleElementsAccessor<
          FastPackedDoubleElementsAccessor,
          ElementsKindTraits<PACKED_DOUBLE_ELEMENTS>> {};

class FastHoleyDoubleElementsAccessor
    : public FastDoubleElementsAccessor<
          FastHoleyDoubleElementsAccessor,
          ElementsKindTraits<HOLEY_DOUBLE_ELEMENTS>> {};

enum IsSharedBuffer : bool { kShared = true, kUnshared = false };

// Super class for all external element arrays.
template <ElementsKind Kind, typename ElementType>
class TypedElementsAccessor
    : public ElementsAccessorBase<TypedElementsAccessor<Kind, ElementType>,
                                  ElementsKindTraits<Kind>> {
 public:
  using BackingStore = typename ElementsKindTraits<Kind>::BackingStore;
  using AccessorClass = TypedElementsAccessor<Kind, ElementType>;

  // Conversions from (other) scalar values.
  static ElementType FromScalar(int value) {
    return static_cast<ElementType>(value);
  }
  static ElementType FromScalar(uint32_t value) {
    return static_cast<ElementType>(value);
  }
  static ElementType FromScalar(double value) {
    return FromScalar(DoubleToInt32(value));
  }
  static ElementType FromScalar(int64_t value) { UNREACHABLE(); }
  static ElementType FromScalar(uint64_t value) { UNREACHABLE(); }

  // Conversions from objects / handles.
  static ElementType FromObject(Tagged<Object> value,
                                bool* lossless = nullptr) {
    if (IsSmi(value)) {
      return FromScalar(Smi::ToInt(value));
    } else if (IsHeapNumber(value)) {
      return FromScalar(Cast<HeapNumber>(value)->value());
    } else {
      // Clamp undefined here as well. All other types have been
      // converted to a number type further up in the call chain.
      DCHECK(IsUndefined(value));
      return FromScalar(Cast<Oddball>(value)->to_number_raw());
    }
  }
  static ElementType FromHandle(DirectHandle<Object> value,
                                bool* lossless = nullptr) {
    return FromObject(*value, lossless);
  }

  // Conversion of scalar value to handlified object.
  static Handle<Object> ToHandle(Isolate* isolate, ElementType value);

  static void SetImpl(DirectHandle<JSObject> holder, InternalIndex entry,
                      Tagged<Object> value) {
    auto typed_array = Cast<JSTypedArray>(holder);
    DCHECK_LE(entry.raw_value(), typed_array->GetLength());
    auto* entry_ptr =
        static_cast<ElementType*>(typed_array->DataPtr()) + entry.raw_value();
    auto is_shared = typed_array->buffer()->is_shared() ? kShared : kUnshared;
    SetImpl(entry_ptr, FromObject(value), is_shared);
  }

  static void SetImpl(ElementType* data_ptr, ElementType value,
                      IsSharedBuffer is_shared) {
    // TODO(ishell, v8:8875): Independent of pointer compression, 8-byte size
    // fields (external pointers, doubles and BigInt data) are not always 8-byte
    // aligned. This is relying on undefined behaviour in C++, since {data_ptr}
    // is not aligned to {alignof(ElementType)}.
    if (!is_shared) {
      base::WriteUnalignedValue(reinterpret_cast<Address>(data_ptr), value);
      return;
    }

    // The JavaScript memory model allows for racy reads and writes to a
    // SharedArrayBuffer's backing store. Using relaxed atomics is not strictly
    // required for JavaScript, but will avoid undefined behaviour in C++ and is
    // unlikely to introduce noticable overhead.
    if (IsAligned(reinterpret_cast<uintptr_t>(data_ptr),
                  alignof(std::atomic<ElementType>))) {
      // Use a single relaxed atomic store.
      static_assert(sizeof(std::atomic<ElementType>) == sizeof(ElementType));
      reinterpret_cast<std::atomic<ElementType>*>(data_ptr)->store(
          value, std::memory_order_relaxed);
      return;
    }

    // Some static CHECKs (are optimized out if succeeding) to ensure that
    // {data_ptr} is at least four byte aligned, and {std::atomic<uint32_t>}
    // has size and alignment of four bytes, such that we can cast the
    // {data_ptr} to it.
    CHECK_LE(kInt32Size, alignof(ElementType));
    CHECK_EQ(kInt32Size, alignof(std::atomic<uint32_t>));
    CHECK_EQ(kInt32Size, sizeof(std::atomic<uint32_t>));
    // And dynamically check that we indeed have at least four byte alignment.
    DCHECK(IsAligned(reinterpret_cast<uintptr_t>(data_ptr), kInt32Size));
    // Store as multiple 32-bit words. Make {kNumWords} >= 1 to avoid compiler
    // warnings for the empty array or memcpy to an empty object.
    constexpr size_t kNumWords =
        std::max(size_t{1}, sizeof(ElementType) / kInt32Size);
    uint32_t words|kNumWords];
    CHECK_EQ(sizeof(words), sizeof(value));
    memcpy(words, &value, sizeof(value));
    for (size_t word = 0; word < kNumWords; ++word) {
      static_assert(sizeof(std::atomic<uint32_t>) == sizeof(uint32_t));
      reinterpret_cast<std::atomic<uint32_t>*>(data_ptr)|word].store(
          words|word], std::memory_order_relaxed);
    }
  }

  static Handle<Object> GetInternalImpl(Isolate* isolate,
                                        DirectHandle<JSObject> holder,
                                        InternalIndex entry) {
    auto typed_array = Cast<JSTypedArray>(holder);
    DCHECK_LT(entry.raw_value(), typed_array->GetLength());
    DCHECK(!typed_array->IsDetachedOrOutOfBounds());
    auto* element_ptr =
        static_cast<ElementType*>(typed_array->DataPtr()) + entry.raw_value();
    auto is_shared = typed_array->buffer()->is_shared() ? kShared : kUnshared;
    ElementType elem = GetImpl(element_ptr, is_shared);
    return ToHandle(isolate, elem);
  }

  static Handle<Object> GetImpl(Isolate* isolate,
                                Tagged<FixedArrayBase> backing_store,
                                InternalIndex entry) {
    UNREACHABLE();
  }

  static ElementType GetImpl(ElementType* data_ptr, IsSharedBuffer is_shared) {
    // TODO(ishell, v8:8875): Independent of pointer compression, 8-byte size
    // fields (external pointers, doubles and BigInt data) are not always
    // 8-byte aligned.
    if (!is_shared) {
      return base::ReadUnalignedValue<ElementType>(
          reinterpret_cast<Address>(data_ptr));
    }

    // The JavaScript memory model allows for racy reads and writes to a
    // SharedArrayBuffer's backing store. Using relaxed atomics is not strictly
    // required for JavaScript, but will avoid undefined behaviour in C++ and is
    // unlikely to introduce noticable overhead.
    if (IsAligned(reinterpret_cast<uintptr_t>(data_ptr),
                  alignof(std::atomic<ElementType>))) {
      // Use a single relaxed atomic load.
      static_assert(sizeof(std::atomic<ElementType>) == sizeof(ElementType));
      // Note: acquire semantics are not needed here, but clang seems to merge
      // this atomic load with the non-atomic load above if we use relaxed
      // semantics. This will result in TSan failures.
      return reinterpret_cast<std::atomic<ElementType>*>(data_ptr)->load(
          std::memory_order_acquire);
    }

    // Some static CHECKs (are optimized out if succeeding) to ensure that
    // {data_ptr} is at least four byte aligned, and {std::atomic<uint32_t>}
    // has size and alignment of four bytes, such that we can cast the
    // {data_ptr} to it.
    CHECK_LE(kInt32Size, alignof(ElementType));
    CHECK_EQ(kInt32Size, alignof(std::atomic<uint32_t>));
    CHECK_EQ(kInt32Size, sizeof(std::atomic<uint32_t>));
    // And dynamically check that we indeed have at least four byte alignment.
    DCHECK(IsAligned(reinterpret_cast<uintptr_t>(data_ptr), kInt32Size));
    // Load in multiple 32-bit words. Make {kNumWords} >= 1 to avoid compiler
    // warnings for the empty array or memcpy to an empty object.
    constexpr size_t kNumWords =
        std::max(size_t{1}, sizeof(ElementType) / kInt32Size);
    uint32_t words|kNumWords];
    for (size_t word = 0; word < kNumWords; ++word) {
      static_assert(sizeof(std::atomic<uint32_t>) == sizeof(uint32_t));
      words|word] =
          reinterpret_cast<std::atomic<uint32_t>*>(data_ptr)|word].load(
              std::memory_order_relaxed);
    }
    ElementType result;
    CHECK_EQ(sizeof(words), sizeof(result));
    memcpy(&result, words, sizeof(result));
    return result;
  }

  static PropertyDetails GetDetailsImpl(Tagged<JSObject> holder,
                                        InternalIndex entry) {
    return PropertyDetails(PropertyKind::kData, NONE,
                           PropertyCellType::kNoCell);
  }

  static PropertyDetails GetDetailsImpl(Tagged<FixedArrayBase> backing_store,
                                        InternalIndex entry) {
    return PropertyDetails(PropertyKind::kData, NONE,
                           PropertyCellType::kNoCell);
  }

  static bool HasElementImpl(Isolate* isolate, Tagged<JSObject> holder,
                             size_t index, Tagged<FixedArrayBase> backing_store,
                             PropertyFilter filter) {
    return index < AccessorClass::GetCapacityImpl(holder, backing_store);
  }

  static bool HasAccessorsImpl(Tagged<JSObject> holder,
                               Tagged<FixedArrayBase> backing_store) {
    return false;
  }

  static Maybe<bool> SetLengthImpl(Isolate* isolate,
                                   DirectHandle<JSArray> array, uint32_t length,
                                   DirectHandle<FixedArrayBase> backing_store) {
    // External arrays do not support changing their length.
    UNREACHABLE();
  }

  static void DeleteImpl(DirectHandle<JSObject> obj, InternalIndex entry) {
    // Do nothing.
    //
    // TypedArray elements are configurable to explain detaching, but cannot be
    // deleted otherwise.
  }

  static InternalIndex GetEntryForIndexImpl(
      Isolate* isolate, Tagged<JSObject> holder,
      Tagged<FixedArrayBase> backing_store, size_t index,
      PropertyFilter filter) {
    return index < AccessorClass::GetCapacityImpl(holder, backing_store)
               ? InternalIndex(index)
               : InternalIndex::NotFound();
  }

  static size_t GetCapacityImpl(Tagged<JSObject> holder,
                                Tagged<FixedArrayBase> backing_store) {
    Tagged<JSTypedArray> typed_array = Cast<JSTypedArray>(holder);
    return typed_array->GetLength();
  }

  static size_t NumberOfElementsImpl(Isolate* isolate,
                                     Tagged<JSObject> receiver,
                                     Tagged<FixedArrayBase> backing_store) {
    return AccessorClass::GetCapacityImpl(receiver, backing_store);
  }

  V8_WARN_UNUSED_RESULT static ExceptionStatus AddElementsToKeyAccumulatorImpl(
      DirectHandle<JSObject> receiver, KeyAccumulator* accumulator,
      AddKeyConversion convert) {
    Isolate* isolate = receiver->GetIsolate();
    DirectHandle<FixedArrayBase> elements(receiver->elements(), isolate);
    size_t length = AccessorClass::GetCapacityImpl(*receiver, *elements);
    for (size_t i = 0; i < length; i++) {
      DirectHandle<Object> value =
          AccessorClass::GetInternalImpl(isolate, receiver, InternalIndex(i));
      RETURN_FAILURE_IF_NOT_SUCCESSFUL(accumulator->AddKey(value, convert));
    }
    return ExceptionStatus::kSuccess;
  }

  static Maybe<bool> CollectValuesOrEntriesImpl(
      Isolate* isolate, DirectHandle<JSObject> object,
      DirectHandle<FixedArray> values_or_entries, bool get_entries,
      int* nof_items, PropertyFilter filter) {
    int count = 0;
    if ((filter & ONLY_CONFIGURABLE) == 0) {
      DirectHandle<FixedArrayBase> elements(object->elements(), isolate);
      size_t length = AccessorClass::GetCapacityImpl(*object, *elements);
      for (size_t index = 0; index < length; ++index) {
        DirectHandle<Object> value = AccessorClass::GetInternalImpl(
            isolate, object, InternalIndex(index));
        if (get_entries) {
          value = MakeEntryPair(isolate, index, value);
        }
        values_or_entries->set(count++, *value);
      }
    }
    *nof_items = count;
    return Just(true);
  }

  static bool ToTypedSearchValue(double search_value,
                                 ElementType* typed_search_value) {
    if (!base::IsValueInRangeForNumericType<ElementType>(search_value) &&
        std::isfinite(search_value)) {
      // Return true if value can't be represented in this space.
      return true;
    }
    ElementType typed_value;
    if (IsFloat16TypedArrayElementsKind(Kind)) {
      typed_value = fp16_ieee_from_fp32_value(static_cast<float>(search_value));
      *typed_search_value = typed_value;
      return (static_cast<double>(fp16_ieee_to_fp32_value(typed_value)) !=
              search_value);  // Loss of precision.
    }
    typed_value = static_cast<ElementType>(search_value);
    *typed_search_value = typed_value;
    return static_cast<double>(typed_value) !=
           search_value;  // Loss of precision.
  }

  static MaybeDirectHandle<Object> FillImpl(DirectHandle<JSObject> receiver,
                                            DirectHandle<Object> value,
                                            size_t start, size_t end) {
    DirectHandle<JSTypedArray> typed_array = Cast<JSTypedArray>(receiver);
    DCHECK(!typed_array->IsDetachedOrOutOfBounds());
    DCHECK_LE(start, end);
    DCHECK_LE(end, typed_array->GetLength());
    DisallowGarbageCollection no_gc;
    ElementType scalar = FromHandle(value);
    ElementType* data = static_cast<ElementType*>(typed_array->DataPtr());
    ElementType* first = data + start;
    ElementType* last = data + end;
    if (typed_array->buffer()->is_shared()) {
      // TypedArrays backed by shared buffers need to be filled using atomic
      // operations. Since 8-byte data are not currently always 8-byte aligned,
      // manually fill using SetImpl, which abstracts over alignment and atomic
      // complexities.
      for (; first != last; ++first) {
        AccessorClass::SetImpl(first, scalar, kShared);
      }
    } else if ((scalar == 0 && !(std::is_floating_point_v<ElementType> &&
                                 IsMinusZero(scalar))) ||
               (std::is_integral_v<ElementType> &&
                scalar == static_cast<ElementType>(-1))) {
      // As of 2022-06, this is faster than {std::fill}.
      // We could extend this to any {scalar} that's a pattern of repeating
      // bytes, but patterns other than 0 and -1 are probably rare.
      size_t num_bytes = static_cast<size_t>(reinterpret_cast<int8_t*>(last) -
                                             reinterpret_cast<int8_t*>(first));
      memset(first, static_cast<int8_t>(scalar), num_bytes);
    } else if (COMPRESS_POINTERS_BOOL && alignof(ElementType) > kTaggedSize) {
      // TODO(ishell, v8:8875): See UnalignedSlot<T> for details.
      std::fill(UnalignedSlot<ElementType>(first),
                UnalignedSlot<ElementType>(last), scalar);
    } else {
      std::fill(first, last, scalar);
    }
    return MaybeDirectHandle<Object>(typed_array);
  }

  static Maybe<bool> IncludesValueImpl(Isolate* isolate,
                                       DirectHandle<JSObject> receiver,
                                       DirectHandle<Object> value,
                                       size_t start_from, size_t length) {
    DisallowGarbageCollection no_gc;
    Tagged<JSTypedArray> typed_array = Cast<JSTypedArray>(*receiver);

    if (typed_array->WasDetached()) {
      return Just(IsUndefined(*value, isolate) && length > start_from);
    }

    bool out_of_bounds = false;
    size_t new_length = typed_array->GetLengthOrOutOfBounds(out_of_bounds);
    if (V8_UNLIKELY(out_of_bounds)) {
      return Just(IsUndefined(*value, isolate) && length > start_from);
    }

    if (IsUndefined(*value, isolate) && length > new_length) {
      return Just(true);
    }

    // Prototype has no elements, and not searching for the hole --- limit
    // search to backing store length.
    if (new_length < length) {
      length = new_length;
    }

    ElementType typed_search_value;
    ElementType* data_ptr =
        reinterpret_cast<ElementType*>(typed_array->DataPtr());
    auto is_shared = typed_array->buffer()->is_shared() ? kShared : kUnshared;
    if (Kind == BIGINT64_ELEMENTS || Kind == BIGUINT64_ELEMENTS ||
        Kind == RAB_GSAB_BIGINT64_ELEMENTS ||
        Kind == RAB_GSAB_BIGUINT64_ELEMENTS) {
      if (!IsBigInt(*value)) return Just(false);
      bool lossless;
      typed_search_value = FromHandle(value, &lossless);
      if (!lossless) return Just(false);
    } else {
      if (!IsNumber(*value)) return Just(false);
      double search_value = Object::NumberValue(*value);
      if (!std::isfinite(search_value)) {
        // Integral types cannot represent +Inf or NaN.
        if (!IsFloatTypedArrayElementsKind(Kind)) {
          return Just(false);
        }
        if (std::isnan(search_value)) {
          for (size_t k = start_from; k < length; ++k) {
            if (IsFloat16TypedArrayElementsKind(Kind)) {
              float elem_k = fp16_ieee_to_fp32_value(
                  AccessorClass::GetImpl(data_ptr + k, is_shared));
              if (std::isnan(elem_k)) return Just(true);
            } else {
              double elem_k = static_cast<double>(
                  AccessorClass::GetImpl(data_ptr + k, is_shared));
              if (std::isnan(elem_k)) return Just(true);
            }
          }
          return Just(false);
        }
      }
      if (AccessorClass::ToTypedSearchValue(search_value,
                                            &typed_search_value)) {
        return Just(false);
      }
    }

    for (size_t k = start_from; k < length; ++k) {
      ElementType elem_k = AccessorClass::GetImpl(data_ptr + k, is_shared);
      if (elem_k == typed_search_value) return Just(true);
    }
    return Just(false);
  }

  static Maybe<int64_t> IndexOfValueImpl(Isolate* isolate,
                                         DirectHandle<JSObject> receiver,
                                         DirectHandle<Object> value,
                                         size_t start_from, size_t length) {
    DisallowGarbageCollection no_gc;
    Tagged<JSTypedArray> typed_array = Cast<JSTypedArray>(*receiver);

    // If this is called via Array.prototype.indexOf (not
    // TypedArray.prototype.indexOf), it's possible that the TypedArray is
    // detached / out of bounds here.
    if (V8_UNLIKELY(typed_array->WasDetached())) return Just<int64_t>(-1);
    bool out_of_bounds = false;
    size_t typed_array_length =
        typed_array->GetLengthOrOutOfBounds(out_of_bounds);
    if (V8_UNLIKELY(out_of_bounds)) {
      return Just<int64_t>(-1);
    }

    // Prototype has no elements, and not searching for the hole --- limit
    // search to backing store length.
    if (typed_array_length < length) {
      length = typed_array_length;
    }

    ElementType typed_search_value;

    ElementType* data_ptr =
        reinterpret_cast<ElementType*>(typed_array->DataPtr());
    if (IsBigIntTypedArrayElementsKind(Kind)) {
      if (!IsBigInt(*value)) return Just<int64_t>(-1);
      bool lossless;
      typed_search_value = FromHandle(value, &lossless);
      if (!lossless) return Just<int64_t>(-1);
    } else {
      if (!IsNumber(*value)) return Just<int64_t>(-1);
      double search_value = Object::NumberValue(*value);
      if (!std::isfinite(search_value)) {
        // Integral types cannot represent +Inf or NaN.
        if (!IsFloatTypedArrayElementsKind(Kind)) {
          return Just<int64_t>(-1);
        }
        if (std::isnan(search_value)) {
          return Just<int64_t>(-1);
        }
      }
      if (AccessorClass::ToTypedSearchValue(search_value,
                                            &typed_search_value)) {
        return Just<int64_t>(-1);
      }
    }

    auto is_shared = typed_array->buffer()->is_shared() ? kShared : kUnshared;
    for (size_t k = start_from; k < length; ++k) {
      ElementType elem_k = AccessorClass::GetImpl(data_ptr + k, is_shared);
      if (elem_k == typed_search_value) return Just<int64_t>(k);
    }
    return Just<int64_t>(-1);
  }

  static Maybe<int64_t> LastIndexOfValueImpl(DirectHandle<JSObject> receiver,
                                             DirectHandle<Object> value,
                                             size_t start_from) {
    DisallowGarbageCollection no_gc;
    Tagged<JSTypedArray> typed_array = Cast<JSTypedArray>(*receiver);

    DCHECK(!typed_array->IsDetachedOrOutOfBounds());

    ElementType typed_search_value;

    ElementType* data_ptr =
        reinterpret_cast<ElementType*>(typed_array->DataPtr());
    if (IsBigIntTypedArrayElementsKind(Kind)) {
      if (!IsBigInt(*value)) return Just<int64_t>(-1);
      bool lossless;
      typed_search_value = FromHandle(value, &lossless);
      if (!lossless) return Just<int64_t>(-1);
    } else {
      if (!IsNumber(*value)) return Just<int64_t>(-1);
      double search_value = Object::NumberValue(*value);
      if (!std::isfinite(search_value)) {
        if (!IsFloat16TypedArrayElementsKind(Kind) &&
            std::is_integral_v<ElementType>) {
          // Integral types cannot represent +Inf or NaN.
          return Just<int64_t>(-1);
        } else if (std::isnan(search_value)) {
          // Strict Equality Comparison of NaN is always false.
          return Just<int64_t>(-1);
        }
      }
      if (AccessorClass::ToTypedSearchValue(search_value,
                                            &typed_search_value)) {
        return Just<int64_t>(-1);
      }
    }

    size_t typed_array_length = typed_array->GetLength();
    if (V8_UNLIKELY(start_from >= typed_array_length)) {
      // This can happen if the TypedArray got resized when we did ToInteger
      // on the last parameter of lastIndexOf.
      DCHECK(typed_array->IsVariableLength());
      if (typed_array_length == 0) {
        return Just<int64_t>(-1);
      }
      start_from = typed_array_length - 1;
    }

    size_t k = start_from;
    auto is_shared = typed_array->buffer()->is_shared() ? kShared : kUnshared;
    do {
      ElementType elem_k = AccessorClass::GetImpl(data_ptr + k, is_shared);
      if (elem_k == typed_search_value) return Just<int64_t>(k);
    } while (k-- != 0);
    return Just<int64_t>(-1);
  }

  static void ReverseImpl(Tagged<JSObject> receiver) {
    DisallowGarbageCollection no_gc;
    Tagged<JSTypedArray> typed_array = Cast<JSTypedArray>(receiver);

    DCHECK(!typed_array->IsDetachedOrOutOfBounds());

    size_t len = typed_array->GetLength();
    if (len == 0) return;

    ElementType* data = static_cast<ElementType*>(typed_array->DataPtr());
    if (typed_array->buffer()->is_shared()) {
      // TypedArrays backed by shared buffers need to be reversed using atomic
      // operations. Since 8-byte data are not currently always 8-byte aligned,
      // manually reverse using GetImpl and SetImpl, which abstract over
      // alignment and atomic complexities.
      for (ElementType *first = data, *last = data + len - 1; first < last;
           ++first, --last) {
        ElementType first_value = AccessorClass::GetImpl(first, kShared);
        ElementType last_value = AccessorClass::GetImpl(last, kShared);
        AccessorClass::SetImpl(first, last_value, kShared);
        AccessorClass::SetImpl(last, first_value, kShared);
      }
    } else if (COMPRESS_POINTERS_BOOL && alignof(ElementType) > kTaggedSize) {
      // TODO(ishell, v8:8875): See UnalignedSlot<T> for details.
      std::reverse(UnalignedSlot<ElementType>(data),
                   UnalignedSlot<ElementType>(data + len));
    } else {
      std::reverse(data, data + len);
    }
  }

  static Handle<FixedArray> CreateListFromArrayLikeImpl(
      Isolate* isolate, DirectHandle<JSObject> object, uint32_t length) {
    DirectHandle<JSTypedArray> typed_array = Cast<JSTypedArray>(object);
    Handle<FixedArray> result = isolate->factory()->NewFixedArray(length);
    for (uint32_t i = 0; i < length; i++) {
      DirectHandle<Object> value = AccessorClass::GetInternalImpl(
          isolate, typed_array, InternalIndex(i));
      result->set(i, *value);
    }
    return result;
  }

  static void CopyTypedArrayElementsSliceImpl(Tagged<JSTypedArray> source,
                                              Tagged<JSTypedArray> destination,
                                              size_t start, size_t end) {
    DisallowGarbageCollection no_gc;
    DCHECK_EQ(destination->GetElementsKind(), AccessorClass::kind());
    CHECK(!source->IsDetachedOrOutOfBounds());
    CHECK(!destination->IsDetachedOrOutOfBounds());
    DCHECK_LE(start, end);
    DCHECK_LE(end, source->GetLength());
    size_t count = end - start;
    DCHECK_LE(count, destination->GetLength());
    ElementType* dest_data = static_cast<ElementType*>(destination->DataPtr());
    auto is_shared =
        source->buffer()->is_shared() || destination->buffer()->is_shared()
            ? kShared
            : kUnshared;
    switch (source->GetElementsKind()) {
#define TYPED_ARRAY_CASE(Type, type, TYPE, ctype)                             \
  case TYPE##_ELEMENTS: {                                                     \
    ctype* source_data = reinterpret_cast<ctype*>(source->DataPtr()) + start; \
    CopyBetweenBackingStores<TYPE##_ELEMENTS, ctype>(source_data, dest_data,  \
                                                     count, is_shared);       \
    break;                                                                    \
  }
      TYPED_ARRAYS(TYPED_ARRAY_CASE)
#undef TYPED_ARRAY_CASE

#define TYPED_ARRAY_CASE(Type, type, TYPE, ctype, NON_RAB_GSAB_TYPE)          \
  case TYPE##_ELEMENTS: {                                                     \
    ctype* source_data = reinterpret_cast<ctype*>(source->DataPtr()) + start; \
    CopyBetweenBackingStores<NON_RAB_GSAB_TYPE##_ELEMENTS, ctype>(            \
        source_data, dest_data, count, is_shared);                            \
    break;                                                                    \
  }
      RAB_GSAB_TYPED_ARRAYS_WITH_NON_RAB_GSAB_ELEMENTS_KIND(TYPED_ARRAY_CASE)
#undef TYPED_ARRAY_CASE
      default:
        UNREACHABLE();
        break;
    }
  }

  // TODO(v8:11111): Update this once we have external RAB / GSAB array types.
  static bool HasSimpleRepresentation(ExternalArrayType type) {
    return !(type == kExternalFloat32Array || type == kExternalFloat64Array ||
             type == kExternalUint8ClampedArray ||
             type == kExternalFloat16Array);
  }

  template <ElementsKind SourceKind, typename SourceElementType>
  static void CopyBetweenBackingStores(SourceElementType* source_data_ptr,
                                       ElementType* dest_data_ptr,
                                       size_t length,
                                       IsSharedBuffer is_shared) {
    CopyBetweenBackingStoresImpl<Kind, ElementType, SourceKind,
                                 SourceElementType>::Copy(source_data_ptr,
                                                          dest_data_ptr, length,
                                                          is_shared);
  }

  static void CopyElementsFromTypedArray(Tagged<JSTypedArray> source,
                                         Tagged<JSTypedArray> destination,
                                         size_t length, size_t offset) {
    // The source is a typed array, so we know we don't need to do ToNumber
    // side-effects, as the source elements will always be a number.
    DisallowGarbageCollection no_gc;

    CHECK(!source->IsDetachedOrOutOfBounds());
    CHECK(!destination->IsDetachedOrOutOfBounds());

    DCHECK_LE(offset, destination->GetLength());
    DCHECK_LE(length, destination->GetLength() - offset);
    DCHECK_LE(length, source->GetLength());

    ExternalArrayType source_type = source->type();
    ExternalArrayType destination_type = destination->type();

    bool same_type = source_type == destination_type;
    bool same_size = source->element_size() == destination->element_size();
    bool both_are_simple = HasSimpleRepresentation(source_type) &&
                           HasSimpleRepresentation(destination_type);

    uint8_t* source_data = static_cast<uint8_t*>(source->DataPtr());
    uint8_t* dest_data = static_cast<uint8_t*>(destination->DataPtr());
    size_t source_byte_length = source->GetByteLength();
    size_t dest_byte_length = destination->GetByteLength();

    bool source_shared = source->buffer()->is_shared();
    bool destination_shared = destination->buffer()->is_shared();

    // We can simply copy the backing store if the types are the same, or if
    // we are converting e.g. Uint8 <-> Int8, as the binary representation
    // will be the same. This is not the case for floats or clamped Uint8,
    // which have special conversion operations.
    if (same_type || (same_size && both_are_simple)) {
      size_t element_size = source->element_size();
      if (source_shared || destination_shared) {
        base::Relaxed_Memcpy(
            reinterpret_cast<base::Atomic8*>(dest_data + offset * element_size),
            reinterpret_cast<base::Atomic8*>(source_data),
            length * element_size);
      } else {
        std::memmove(dest_data + offset * element_size, source_data,
                     length * element_size);
      }
    } else {
      std::unique_ptr<uint8_t|]> cloned_source_elements;

      // If the typedarrays are overlapped, clone the source.
      if (dest_data + dest_byte_length > source_data &&
          source_data + source_byte_length > dest_data) {
        cloned_source_elements.reset(new uint8_t|source_byte_length]);
        if (source_shared) {
          base::Relaxed_Memcpy(
              reinterpret_cast<base::Atomic8*>(cloned_source_elements.get()),
              reinterpret_cast<base::Atomic8*>(source_data),
              source_byte_length);
        } else {
          std::memcpy(cloned_source_elements.get(), source_data,
                      source_byte_length);
        }
        source_data = cloned_source_elements.get();
      }

      switch (source->GetElementsKind()) {
#define TYPED_ARRAY_CASE(Type, type, TYPE, ctype)                   \
  case TYPE##_ELEMENTS:                                             \
    CopyBetweenBackingStores<TYPE##_ELEMENTS, ctype>(               \
        reinterpret_cast<ctype*>(source_data),                      \
        reinterpret_cast<ElementType*>(dest_data) + offset, length, \
        source_shared || destination_shared ? kShared : kUnshared); \
    break;
        TYPED_ARRAYS(TYPED_ARRAY_CASE)
        RAB_GSAB_TYPED_ARRAYS(TYPED_ARRAY_CASE)
        default:
          UNREACHABLE();
          break;
      }
#undef TYPED_ARRAY_CASE
    }
  }

  static bool HoleyPrototypeLookupRequired(Isolate* isolate,
                                           Tagged<Context> context,
                                           Tagged<JSArray> source) {
    DisallowGarbageCollection no_gc;
    DisallowJavascriptExecution no_js(isolate);

#ifdef V8_ENABLE_FORCE_SLOW_PATH
    if (isolate->force_slow_path()) return true;
#endif

    Tagged<Object> source_proto = source->map()->prototype();

    // Null prototypes are OK - we don't need to do prototype chain lookups on
    // them.
    if (IsNull(source_proto, isolate)) return false;
    if (IsJSProxy(source_proto)) return true;
    if (IsJSObject(source_proto) &&
        !context->native_context()->is_initial_array_prototype(
            Cast<JSObject>(source_proto))) {
      return true;
    }

    return !Protectors::IsNoElementsIntact(isolate);
  }

  static bool TryCopyElementsFastNumber(Tagged<Context> context,
                                        Tagged<JSArray> source,
                                        Tagged<JSTypedArray> destination,
                                        size_t length, size_t offset) {
    if (IsBigIntTypedArrayElementsKind(Kind)) return false;
    Isolate* isolate = source->GetIsolate();
    DisallowGarbageCollection no_gc;
    DisallowJavascriptExecution no_js(isolate);

    CHECK(!destination->WasDetached());
    bool out_of_bounds = false;
    CHECK_GE(destination->GetLengthOrOutOfBounds(out_of_bounds), length);
    CHECK(!out_of_bounds);

    size_t current_length;
    DCHECK(IsNumber(source->length()) &&
           TryNumberToSize(source->length(), &current_length) &&
           length <= current_length);
    USE(current_length);

    size_t dest_length = destination->GetLength();
    DCHECK(length + offset <= dest_length);
    USE(dest_length);

    ElementsKind kind = source->GetElementsKind();

    auto destination_shared =
        destination->buffer()->is_shared() ? kShared : kUnshared;

    // When we find the hole, we normally have to look up the element on the
    // prototype chain, which is not handled here and we return false instead.
    // When the array has the original array prototype, and that prototype has
    // not been changed in a way that would affect lookups, we can just convert
    // the hole into undefined.
    if (HoleyPrototypeLookupRequired(isolate, context, source)) return false;

    Tagged<Oddball> undefined = ReadOnlyRoots(isolate).undefined_value();
    ElementType* dest_data =
        reinterpret_cast<ElementType*>(destination->DataPtr()) + offset;

    // Fast-path for packed Smi kind.
    if (kind == PACKED_SMI_ELEMENTS) {
      Tagged<FixedArray> source_store = Cast<FixedArray>(source->elements());

      for (size_t i = 0; i < length; i++) {
        Tagged<Object> elem = source_store->get(static_cast<int>(i));
        ElementType elem_k;
        if (IsFloat16TypedArrayElementsKind(Kind))
          elem_k = fp16_ieee_from_fp32_value(Smi::ToInt(elem));
        else
          elem_k = FromScalar(Smi::ToInt(elem));
        SetImpl(dest_data + i, elem_k, destination_shared);
      }
      return true;
    } else if (kind == HOLEY_SMI_ELEMENTS) {
      Tagged<FixedArray> source_store = Cast<FixedArray>(source->elements());
      for (size_t i = 0; i < length; i++) {
        if (source_store->is_the_hole(isolate, static_cast<int>(i))) {
          SetImpl(dest_data + i, FromObject(undefined), destination_shared);
        } else {
          Tagged<Object> elem = source_store->get(static_cast<int>(i));
          ElementType elem_k;
          if (IsFloat16TypedArrayElementsKind(Kind))
            elem_k = fp16_ieee_from_fp32_value(Smi::ToInt(elem));
          else
            elem_k = FromScalar(Smi::ToInt(elem));
          SetImpl(dest_data + i, elem_k, destination_shared);
        }
      }
      return true;
    } else if (kind == PACKED_DOUBLE_ELEMENTS) {
      // Fast-path for packed double kind. We avoid boxing and then immediately
      // unboxing the double here by using get_scalar.
      Tagged<FixedDoubleArray> source_store =
          Cast<FixedDoubleArray>(source->elements());

      for (size_t i = 0; i < length; i++) {
        // Use the from_double conversion for this specific TypedArray type,
        // rather than relying on C++ to convert elem.
        double elem = source_store->get_scalar(static_cast<int>(i));
        SetImpl(dest_data + i, FromScalar(elem), destination_shared);
      }
      return true;
    } else if (kind == HOLEY_DOUBLE_ELEMENTS) {
      Tagged<FixedDoubleArray> source_store =
          Cast<FixedDoubleArray>(source->elements());
      for (size_t i = 0; i < length; i++) {
        if (source_store->is_the_hole(static_cast<int>(i))) {
          SetImpl(dest_data + i, FromObject(undefined), destination_shared);
        } else {
          double elem = source_store->get_scalar(static_cast<int>(i));
          SetImpl(dest_data + i, FromScalar(elem), destination_shared);
        }
      }
      return true;
    }
    return false;
  }

  // ES#sec-settypedarrayfromarraylike
  static Tagged<Object> CopyElementsHandleSlow(
      DirectHandle<JSAny> source, DirectHandle<JSTypedArray> destination,
      size_t length, size_t offset) {
    Isolate* isolate = destination->GetIsolate();
    // 8. Let k be 0.
    // 9. Repeat, while k < srcLength,
    for (size_t i = 0; i < length; i++) {
      DirectHandle<Object> elem;
      // a. Let Pk be ! ToString(𝔽(k)).
      // b. Let value be ? Get(src, Pk).
      LookupIterator it(isolate, source, i);
      ASSIGN_RETURN_FAILURE_ON_EXCEPTION(isolate, elem,
                                         Object::GetProperty(&it));
      // c. Let targetIndex be 𝔽(targetOffset + k).
      // d. Perform ? IntegerIndexedElementSet(target, targetIndex, value).
      //
      // Rest of loop body inlines ES#IntegerIndexedElementSet
      if (IsBigIntTypedArrayElementsKind(Kind)) {
        // 1. If O.||ContentType]] is BigInt, let numValue be ? ToBigInt(value).
        ASSIGN_RETURN_FAILURE_ON_EXCEPTION(isolate, elem,
                                           BigInt::FromObject(isolate, elem));
      } else {
        // 2. Otherwise, let numValue be ? ToNumber(value).
        ASSIGN_RETURN_FAILURE_ON_EXCEPTION(isolate, elem,
                                           Object::ToNumber(isolate, elem));
      }
      // 3. If IsValidIntegerIndex(O, index) is true, then
      //   a. Let offset be O.||ByteOffset]].
      //   b. Let elementSize be TypedArrayElementSize(O).
      //   c. Let indexedPosition be (ℝ(index) × elementSize) + offset.
      //   d. Let elementType be TypedArrayElementType(O).
      //   e. Perform SetValueInBuffer(O.||ViewedArrayBuffer]],
      //      indexedPosition, elementType, numValue, true, Unordered).
      bool out_of_bounds = false;
      size_t new_length = destination->GetLengthOrOutOfBounds(out_of_bounds);
      if (V8_UNLIKELY(out_of_bounds || destination->WasDetached() ||
                      new_length <= offset + i)) {
        // Proceed with the loop so that we call get getters for the source even
        // though we don't set the values in the target.
        continue;
      }
      SetImpl(destination, InternalIndex(offset + i), *elem);
      // e. Set k to k + 1.
    }
    // 10. Return unused.
    return *isolate->factory()->undefined_value();
  }

  // This doesn't guarantee that the destination array will be completely
  // filled. The caller must do this by passing a source with equal length, if
  // that is required.
  static Tagged<Object> CopyElementsHandleImpl(
      DirectHandle<JSAny> source, DirectHandle<JSObject> destination,
      size_t length, size_t offset) {
    Isolate* isolate = destination->GetIsolate();
    if (length == 0) return *isolate->factory()->undefined_value();

    DirectHandle<JSTypedArray> destination_ta = Cast<JSTypedArray>(destination);

    // All conversions from TypedArrays can be done without allocation.
    if (IsJSTypedArray(*source)) {
      CHECK(!destination_ta->WasDetached());
      bool out_of_bounds = false;
      CHECK_LE(offset + length,
               destination_ta->GetLengthOrOutOfBounds(out_of_bounds));
      CHECK(!out_of_bounds);
      auto source_ta = Cast<JSTypedArray>(source);
      ElementsKind source_kind = source_ta->GetElementsKind();
      bool source_is_bigint = IsBigIntTypedArrayElementsKind(source_kind);
      bool target_is_bigint = IsBigIntTypedArrayElementsKind(Kind);
      // If we have to copy more elements than we have in the source, we need to
      // do special handling and conversion; that happens in the slow case.
      if (source_is_bigint == target_is_bigint && !source_ta->WasDetached() &&
          length + offset <= source_ta->GetLength()) {
        CopyElementsFromTypedArray(*source_ta, *destination_ta, length, offset);
        return *isolate->factory()->undefined_value();
      }
    } else if (IsJSArray(*source)) {
      CHECK(!destination_ta->WasDetached());
      bool out_of_bounds = false;
      CHECK_LE(offset + length,
               destination_ta->GetLengthOrOutOfBounds(out_of_bounds));
      CHECK(!out_of_bounds);
      // Fast cases for packed numbers kinds where we don't need to allocate.
      auto source_js_array = Cast<JSArray>(source);
      size_t current_length;
      DCHECK(IsNumber(source_js_array->length()));
      if (TryNumberToSize(source_js_array->length(), &current_length) &&
          length <= current_length) {
        auto source_array = Cast<JSArray>(source);
        if (TryCopyElementsFastNumber(isolate->context(), *source_array,
                                      *destination_ta, length, offset)) {
          return *isolate->factory()->undefined_value();
        }
      }
    }
    // Final generic case that handles prototype chain lookups, getters, proxies
    // and observable side effects via valueOf, etc. In this case, it's possible
    // that the length getter detached / resized the underlying buffer.
    return CopyElementsHandleSlow(source, destination_ta, length, offset);
  }
};

template <ElementsKind Kind, typename ElementType, ElementsKind SourceKind,
          typename SourceElementType>
struct CopyBetweenBackingStoresImpl {
  static void Copy(SourceElementType* source_data_ptr,
                   ElementType* dest_data_ptr, size_t length,
                   IsSharedBuffer is_shared) {
    for (; length > 0; --length, ++source_data_ptr, ++dest_data_ptr) {
      // We use scalar accessors to avoid boxing/unboxing, so there are no
      // allocations.
      SourceElementType source_elem =
          TypedElementsAccessor<SourceKind, SourceElementType>::GetImpl(
              source_data_ptr, is_shared);
      ElementType dest_elem =
          TypedElementsAccessor<Kind, ElementType>::FromScalar(source_elem);

      TypedElementsAccessor<Kind, ElementType>::SetImpl(dest_data_ptr,
                                                        dest_elem, is_shared);
    }
  }
};

template <ElementsKind Kind, typename ElementType>
struct CopyBetweenBackingStoresImpl<Kind, ElementType, FLOAT16_ELEMENTS,
                                    uint16_t> {
  static void Copy(uint16_t* source_data_ptr, ElementType* dest_data_ptr,
                   size_t length, IsSharedBuffer is_shared) {
    for (; length > 0; --length, ++source_data_ptr, ++dest_data_ptr) {
      // We use scalar accessors to avoid boxing/unboxing, so there are no
      // allocations.
      uint16_t source_elem =
          TypedElementsAccessor<FLOAT16_ELEMENTS, uint16_t>::GetImpl(
              source_data_ptr, is_shared);
      ElementType dest_elem =
          TypedElementsAccessor<Kind, ElementType>::FromScalar(
              fp16_ieee_to_fp32_value(source_elem));

      TypedElementsAccessor<Kind, ElementType>::SetImpl(dest_data_ptr,
                                                        dest_elem, is_shared);
    }
  }
};

template <ElementsKind Kind, typename ElementType>
struct CopyBetweenBackingStoresImpl<Kind, ElementType,
                                    RAB_GSAB_FLOAT16_ELEMENTS, uint16_t> {
  static void Copy(uint16_t* source_data_ptr, ElementType* dest_data_ptr,
                   size_t length, IsSharedBuffer is_shared) {
    for (; length > 0; --length, ++source_data_ptr, ++dest_data_ptr) {
      // We use scalar accessors to avoid boxing/unboxing, so there are no
      // allocations.
      uint16_t source_elem =
          TypedElementsAccessor<RAB_GSAB_FLOAT16_ELEMENTS, uint16_t>::GetImpl(
              source_data_ptr, is_shared);
      ElementType dest_elem =
          TypedElementsAccessor<Kind, ElementType>::FromScalar(
              fp16_ieee_to_fp32_value(source_elem));

      TypedElementsAccessor<Kind, ElementType>::SetImpl(dest_data_ptr,
                                                        dest_elem, is_shared);
    }
  }
};

// static
template <>
Handle<Object> TypedElementsAccessor<INT8_ELEMENTS, int8_t>::ToHandle(
    Isolate* isolate, int8_t value) {
  return handle(Smi::FromInt(value), isolate);
}

// static
template <>
Handle<Object> TypedElementsAccessor<UINT8_ELEMENTS, uint8_t>::ToHandle(
    Isolate* isolate, uint8_t value) {
  return handle(Smi::FromInt(value), isolate);
}

// static
template <>
Handle<Object> TypedElementsAccessor<INT16_ELEMENTS, int16_t>::ToHandle(
    Isolate* isolate, int16_t value) {
  return handle(Smi::FromInt(value), isolate);
}

// static
template <>
Handle<Object> TypedElementsAccessor<UINT16_ELEMENTS, uint16_t>::ToHandle(
    Isolate* isolate, uint16_t value) {
  return handle(Smi::FromInt(value), isolate);
}

// static
template <>
Handle<Object> TypedElementsAccessor<INT32_ELEMENTS, int32_t>::ToHandle(
    Isolate* isolate, int32_t value) {
  return isolate->factory()->NewNumberFromInt(value);
}

// static
template <>
Handle<Object> TypedElementsAccessor<UINT32_ELEMENTS, uint32_t>::ToHandle(
    Isolate* isolate, uint32_t value) {
  return isolate->factory()->NewNumberFromUint(value);
}

// static
template <>
uint16_t TypedElementsAccessor<FLOAT16_ELEMENTS, uint16_t>::FromScalar(
    double value) {
  return DoubleToFloat16(value);
}

// static
template <>
float TypedElementsAccessor<FLOAT32_ELEMENTS, float>::FromScalar(double value) {
  return DoubleToFloat32(value);
}

// static
template <>
uint16_t TypedElementsAccessor<FLOAT16_ELEMENTS, uint16_t>::FromScalar(
    int value) {
  return fp16_ieee_from_fp32_value(value);
}

// static
template <>
uint16_t TypedElementsAccessor<FLOAT16_ELEMENTS, uint16_t>::FromScalar(
    uint32_t value) {
  return fp16_ieee_from_fp32_value(value);
}

// static
template <>
Handle<Object> TypedElementsAccessor<FLOAT16_ELEMENTS, uint16_t>::ToHandle(
    Isolate* isolate, uint16_t value) {
  return isolate->factory()->NewNumber(fp16_ieee_to_fp32_value(value));
}

// static
template <>
Handle<Object> TypedElementsAccessor<FLOAT32_ELEMENTS, float>::ToHandle(
    Isolate* isolate, float value) {
  return isolate->factory()->NewNumber(value);
}

// static
template <>
double TypedElementsAccessor<FLOAT64_ELEMENTS, double>::FromScalar(
    double value) {
  return value;
}

// static
template <>
Handle<Object> TypedElementsAccessor<FLOAT64_ELEMENTS, double>::ToHandle(
    Isolate* isolate, double value) {
  return isolate->factory()->NewNumber(value);
}

// static
template <>
uint8_t TypedElementsAccessor<UINT8_CLAMPED_ELEMENTS, uint8_t>::FromScalar(
    int value) {
  if (value < 0x00) return 0x00;
  if (value > 0xFF) return 0xFF;
  return static_cast<uint8_t>(value);
}

// static
template <>
uint8_t TypedElementsAccessor<UINT8_CLAMPED_ELEMENTS, uint8_t>::FromScalar(
    uint32_t value) {
  // We need this special case for Uint32 -> Uint8Clamped, because the highest
  // Uint32 values will be negative as an int, clamping to 0, rather than 255.
  if (value > 0xFF) return 0xFF;
  return static_cast<uint8_t>(value);
}

// static
template <>
uint8_t TypedElementsAccessor<UINT8_CLAMPED_ELEMENTS, uint8_t>::FromScalar(
    double value) {
  // Handle NaNs and less than zero values which clamp to zero.
  if (!(value > 0)) return 0;
  if (value > 0xFF) return 0xFF;
  return static_cast<uint8_t>(lrint(value));
}

// static
template <>
Handle<Object> TypedElementsAccessor<UINT8_CLAMPED_ELEMENTS, uint8_t>::ToHandle(
    Isolate* isolate, uint8_t value) {
  return handle(Smi::FromInt(value), isolate);
}

// static
template <>
int64_t TypedElementsAccessor<BIGINT64_ELEMENTS, int64_t>::FromScalar(
    int value) {
  UNREACHABLE();
}

// static
template <>
int64_t TypedElementsAccessor<BIGINT64_ELEMENTS, int64_t>::FromScalar(
    uint32_t value) {
  UNREACHABLE();
}

// static
template <>
int64_t TypedElementsAccessor<BIGINT64_ELEMENTS, int64_t>::FromScalar(
    double value) {
  UNREACHABLE();
}

// static
template <>
int64_t TypedElementsAccessor<BIGINT64_ELEMENTS, int64_t>::FromScalar(
    int64_t value) {
  return value;
}

// static
template <>
int64_t TypedElementsAccessor<BIGINT64_ELEMENTS, int64_t>::FromScalar(
    uint64_t value) {
  return static_cast<int64_t>(value);
}

// static
template <>
int64_t TypedElementsAccessor<BIGINT64_ELEMENTS, int64_t>::FromObject(
    Tagged<Object> value, bool* lossless) {
  return Cast<BigInt>(value)->AsInt64(lossless);
}

// static
template <>
Handle<Object> TypedElementsAccessor<BIGINT64_ELEMENTS, int64_t>::ToHandle(
    Isolate* isolate, int64_t value) {
  return BigInt::FromInt64(isolate, value);
}

// static
template <>
uint64_t TypedElementsAccessor<BIGUINT64_ELEMENTS, uint64_t>::FromScalar(
    int value) {
  UNREACHABLE();
}

// static
template <>
uint64_t TypedElementsAccessor<BIGUINT64_ELEMENTS, uint64_t>::FromScalar(
    uint32_t value) {
  UNREACHABLE();
}

// static
template <>
uint64_t TypedElementsAccessor<BIGUINT64_ELEMENTS, uint64_t>::FromScalar(
    double value) {
  UNREACHABLE();
}

// static
template <>
uint64_t TypedElementsAccessor<BIGUINT64_ELEMENTS, uint64_t>::FromScalar(
    int64_t value) {
  return static_cast<uint64_t>(value);
}

// static
template <>
uint64_t TypedElementsAccessor<BIGUINT64_ELEMENTS, uint64_t>::FromScalar(
    uint64_t value) {
  return value;
}

// static
template <>
uint64_t TypedElementsAccessor<BIGUINT64_ELEMENTS, uint64_t>::FromObject(
    Tagged<Object> value, bool* lossless) {
  return Cast<BigInt>(value)->AsUint64(lossless);
}

// static
template <>
Handle<Object> TypedElementsAccessor<BIGUINT64_ELEMENTS, uint64_t>::ToHandle(
    Isolate* isolate, uint64_t value) {
  return BigInt::FromUint64(isolate, value);
}

// static
template <>
Handle<Object> TypedElementsAccessor<RAB_GSAB_INT8_ELEMENTS, int8_t>::ToHandle(
    Isolate* isolate, int8_t value) {
  return handle(Smi::FromInt(value), isolate);
}

// static
template <>
Handle<Object> TypedElementsAccessor<RAB_GSAB_UINT8_ELEMENTS,
                                     uint8_t>::ToHandle(Isolate* isolate,
                                                        uint8_t value) {
  return handle(Smi::FromInt(value), isolate);
}

// static
template <>
Handle<Object> TypedElementsAccessor<RAB_GSAB_INT16_ELEMENTS,
                                     int16_t>::ToHandle(Isolate* isolate,
                                                        int16_t value) {
  return handle(Smi::FromInt(value), isolate);
}

// static
template <>
Handle<Object> TypedElementsAccessor<RAB_GSAB_UINT16_ELEMENTS,
                                     uint16_t>::ToHandle(Isolate* isolate,
                                                         uint16_t value) {
  return handle(Smi::FromInt(value), isolate);
}

// static
template <>
Handle<Object> TypedElementsAccessor<RAB_GSAB_INT32_ELEMENTS,
                                     int32_t>::ToHandle(Isolate* isolate,
                                                        int32_t value) {
  return isolate->factory()->NewNumberFromInt(value);
}

// static
template <>
Handle<Object> TypedElementsAccessor<RAB_GSAB_UINT32_ELEMENTS,
                                     uint32_t>::ToHandle(Isolate* isolate,
                                                         uint32_t value) {
  return isolate->factory()->NewNumberFromUint(value);
}

// static
template <>
uint16_t TypedElementsAccessor<RAB_GSAB_FLOAT16_ELEMENTS, uint16_t>::FromScalar(
    double value) {
  return DoubleToFloat16(value);
}

// static
template <>
uint16_t TypedElementsAccessor<RAB_GSAB_FLOAT16_ELEMENTS, uint16_t>::FromScalar(
    int value) {
  return fp16_ieee_from_fp32_value(value);
}

// static
template <>
uint16_t TypedElementsAccessor<RAB_GSAB_FLOAT16_ELEMENTS, uint16_t>::FromScalar(
    uint32_t value) {
  return fp16_ieee_from_fp32_value(value);
}

// static
template <>
Handle<Object> TypedElementsAccessor<RAB_GSAB_FLOAT16_ELEMENTS,
                                     uint16_t>::ToHandle(Isolate* isolate,
                                                         uint16_t value) {
  return isolate->factory()->NewHeapNumber(fp16_ieee_to_fp32_value(value));
}

// static
template <>
float TypedElementsAccessor<RAB_GSAB_FLOAT32_ELEMENTS, float>::FromScalar(
    double value) {
  return DoubleToFloat32(value);
}

// static
template <>
Handle<Object> TypedElementsAccessor<RAB_GSAB_FLOAT32_ELEMENTS,
                                     float>::ToHandle(Isolate* isolate,
                                                      float value) {
  return isolate->factory()->NewNumber(value);
}

// static
template <>
double TypedElementsAccessor<RAB_GSAB_FLOAT64_ELEMENTS, double>::FromScalar(
    double value) {
  return value;
}

// static
template <>
Handle<Object> TypedElementsAccessor<RAB_GSAB_FLOAT64_ELEMENTS,
                                     double>::ToHandle(Isolate* isolate,
                                                       double value) {
  return isolate->factory()->NewNumber(value);
}

// static
template <>
uint8_t TypedElementsAccessor<RAB_GSAB_UINT8_CLAMPED_ELEMENTS,
                              uint8_t>::FromScalar(int value) {
  if (value < 0x00) return 0x00;
  if (value > 0xFF) return 0xFF;
  return static_cast<uint8_t>(value);
}

// static
template <>
uint8_t TypedElementsAccessor<RAB_GSAB_UINT8_CLAMPED_ELEMENTS,
                              uint8_t>::FromScalar(uint32_t value) {
  // We need this special case for Uint32 -> Uint8Clamped, because the highest
  // Uint32 values will be negative as an int, clamping to 0, rather than 255.
  if (value > 0xFF) return 0xFF;
  return static_cast<uint8_t>(value);
}

// static
template <>
uint8_t TypedElementsAccessor<RAB_GSAB_UINT8_CLAMPED_ELEMENTS,
                              uint8_t>::FromScalar(double value) {
  // Handle NaNs and less than zero values which clamp to zero.
  if (!(value > 0)) return 0;
  if (value > 0xFF) return 0xFF;
  return static_cast<uint8_t>(lrint(value));
}

// static
template <>
Handle<Object> TypedElementsAccessor<RAB_GSAB_UINT8_CLAMPED_ELEMENTS,
                                     uint8_t>::ToHandle(Isolate* isolate,
                                                        uint8_t value) {
  return handle(Smi::FromInt(value), isolate);
}

// static
template <>
int64_t TypedElementsAccessor<RAB_GSAB_BIGINT64_ELEMENTS, int64_t>::FromScalar(
    int value) {
  UNREACHABLE();
}

// static
template <>
int64_t TypedElementsAccessor<RAB_GSAB_BIGINT64_ELEMENTS, int64_t>::FromScalar(
    uint32_t value) {
  UNREACHABLE();
}

// static
template <>
int64_t TypedElementsAccessor<RAB_GSAB_BIGINT64_ELEMENTS, int64_t>::FromScalar(
    double value) {
  UNREACHABLE();
}

// static
template <>
int64_t TypedElementsAccessor<RAB_GSAB_BIGINT64_ELEMENTS, int64_t>::FromScalar(
    int64_t value) {
  return value;
}

// static
template <>
int64_t TypedElementsAccessor<RAB_GSAB_BIGINT64_ELEMENTS, int64_t>::FromScalar(
    uint64_t value) {
  return static_cast<int64_t>(value);
}

// static
template <>
int64_t TypedElementsAccessor<RAB_GSAB_BIGINT64_ELEMENTS, int64_t>::FromObject(
    Tagged<Object> value, bool* lossless) {
  return Cast<BigInt>(value)->AsInt64(lossless);
}

// static
template <>
Handle<Object> TypedElementsAccessor<RAB_GSAB_BIGINT64_ELEMENTS,
                                     int64_t>::ToHandle(Isolate* isolate,
                                                        int64_t value) {
  return BigInt::FromInt64(isolate, value);
}

// static
template <>
uint64_t TypedElementsAccessor<RAB_GSAB_BIGUINT64_ELEMENTS,
                               uint64_t>::FromScalar(int value) {
  UNREACHABLE();
}

// static
template <>
uint64_t TypedElementsAccessor<RAB_GSAB_BIGUINT64_ELEMENTS,
                               uint64_t>::FromScalar(uint32_t value) {
  UNREACHABLE();
}

// static
template <>
uint64_t TypedElementsAccessor<RAB_GSAB_BIGUINT64_ELEMENTS,
                               uint64_t>::FromScalar(double value) {
  UNREACHABLE();
}

// static
template <>
uint64_t TypedElementsAccessor<RAB_GSAB_BIGUINT64_ELEMENTS,
                               uint64_t>::FromScalar(int64_t value) {
  return static_cast<uint64_t>(value);
}

// static
template <>
uint64_t TypedElementsAccessor<RAB_GSAB_BIGUINT64_ELEMENTS,
                               uint64_t>::FromScalar(uint64_t value) {
  return value;
}

// static
template <>
uint64_t TypedElementsAccessor<RAB_GSAB_BIGUINT64_ELEMENTS,
                               uint64_t>::FromObject(Tagged<Object> value,
                                                     bool* lossless) {
  return Cast<BigInt>(value)->AsUint64(lossless);
}

// static
template <>
Handle<Object> TypedElementsAccessor<RAB_GSAB_BIGUINT64_ELEMENTS,
                                     uint64_t>::ToHandle(Isolate* isolate,
                                                         uint64_t value) {
  return BigInt::FromUint64(isolate, value);
}

#define FIXED_ELEMENTS_ACCESSOR(Type, type, TYPE, ctype) \
  using Type##ElementsAccessor = TypedElementsAccessor<TYPE##_ELEMENTS, ctype>;
TYPED_ARRAYS(FIXED_ELEMENTS_ACCESSOR)
RAB_GSAB_TYPED_ARRAYS(FIXED_ELEMENTS_ACCESSOR)
#undef FIXED_ELEMENTS_ACCESSOR

template <typename Subclass, typename ArgumentsAccessor, typename KindTraits>
class SloppyArgumentsElementsAccessor
    : public ElementsAccessorBase<Subclass, KindTraits> {
 public:
  static void ConvertArgumentsStoreResult(
      DirectHandle<SloppyArgumentsElements> elements,
      DirectHandle<Object> result) {
    UNREACHABLE();
  }

  static Handle<Object> GetImpl(Isolate* isolate,
                                Tagged<FixedArrayBase> parameters,
                                InternalIndex entry) {
    DirectHandle<SloppyArgumentsElements> elements(
        Cast<SloppyArgumentsElements>(parameters), isolate);
    uint32_t length = elements->length();
    if (entry.as_uint32() < length) {
      // Read context mapped entry.
      DisallowGarbageCollection no_gc;
      Tagged<Object> probe =
          elements->mapped_entries(entry.as_uint32(), kRelaxedLoad);
      DCHECK(!IsTheHole(probe, isolate));
      Tagged<Context> context = elements->context();
      int context_entry = Smi::ToInt(probe);
      DCHECK(!IsTheHole(context->get(context_entry), isolate));
      return handle(context->get(context_entry), isolate);
    } else {
      // Entry is not context mapped, defer to the arguments.
      Handle<Object> result = ArgumentsAccessor::GetImpl(
          isolate, elements->arguments(), entry.adjust_down(length));
      return Subclass::ConvertArgumentsStoreResult(isolate, elements, result);
    }
  }

  static Maybe<bool> TransitionElementsKindImpl(DirectHandle<JSObject> object,
                                                DirectHandle<Map> map) {
    UNREACHABLE();
  }

  static Maybe<bool> GrowCapacityAndConvertImpl(DirectHandle<JSObject> object,
                                                uint32_t capacity) {
    UNREACHABLE();
  }

  static inline void SetImpl(DirectHandle<JSObject> holder, InternalIndex entry,
                             Tagged<Object> value) {
    SetImpl(holder->elements(), entry, value);
  }

  static inline void SetImpl(Tagged<FixedArrayBase> store, InternalIndex entry,
                             Tagged<Object> value) {
    Tagged<SloppyArgumentsElements> elements =
        Cast<SloppyArgumentsElements>(store);
    uint32_t length = elements->length();
    if (entry.as_uint32() < length) {
      // Store context mapped entry.
      DisallowGarbageCollection no_gc;
      Tagged<Object> probe =
          elements->mapped_entries(entry.as_uint32(), kRelaxedLoad);
      DCHECK(!IsTheHole(probe));
      Tagged<Context> context = Cast<Context>(elements->context());
      int context_entry = Smi::ToInt(probe);
      DCHECK(!IsTheHole(context->get(context_entry)));
      context->set(context_entry, value);
    } else {
      //  Entry is not context mapped defer to arguments.
      Tagged<FixedArray> arguments = elements->arguments();
      Tagged<Object> current =
          ArgumentsAccessor::GetRaw(arguments, entry.adjust_down(length));
      if (IsAliasedArgumentsEntry(current)) {
        Tagged<AliasedArgumentsEntry> alias =
            Cast<AliasedArgumentsEntry>(current);
        Tagged<Context> context = Cast<Context>(elements->context());
        int context_entry = alias->aliased_context_slot();
        DCHECK(!IsTheHole(context->get(context_entry)));
        context->set(context_entry, value);
      } else {
        ArgumentsAccessor::SetImpl(arguments, entry.adjust_down(length), value);
      }
    }
  }

  static Maybe<bool> SetLengthImpl(Isolate* isolate,
                                   DirectHandle<JSArray> array, uint32_t length,
                                   DirectHandle<FixedArrayBase> parameter_map) {
    // Sloppy arguments objects are not arrays.
    UNREACHABLE();
  }

  static uint32_t GetCapacityImpl(Tagged<JSObject> holder,
                                  Tagged<FixedArrayBase> store) {
    Tagged<SloppyArgumentsElements> elements =
        Cast<SloppyArgumentsElements>(store);
    Tagged<FixedArray> arguments = elements->arguments();
    return elements->length() +
           ArgumentsAccessor::GetCapacityImpl(holder, arguments);
  }

  static uint32_t GetMaxNumberOfEntries(Isolate* isolate,
                                        Tagged<JSObject> holder,
                                        Tagged<FixedArrayBase> backing_store) {
    Tagged<SloppyArgumentsElements> elements =
        Cast<SloppyArgumentsElements>(backing_store);
    Tagged<FixedArrayBase> arguments = elements->arguments();
    size_t max_entries =
        ArgumentsAccessor::GetMaxNumberOfEntries(isolate, holder, arguments);
    DCHECK_LE(max_entries, std::numeric_limits<uint32_t>::max());
    return elements->length() + static_cast<uint32_t>(max_entries);
  }

  static uint32_t NumberOfElementsImpl(Isolate* isolate,
                                       Tagged<JSObject> receiver,
                                       Tagged<FixedArrayBase> backing_store) {
    Tagged<SloppyArgumentsElements> elements =
        Cast<SloppyArgumentsElements>(backing_store);
    Tagged<FixedArrayBase> arguments = elements->arguments();
    uint32_t nof_elements = 0;
    uint32_t length = elements->length();
    for (uint32_t index = 0; index < length; index++) {
      if (HasParameterMapArg(isolate, elements, index)) nof_elements++;
    }
    return nof_elements + ArgumentsAccessor::NumberOfElementsImpl(
                              isolate, receiver, arguments);
  }

  V8_WARN_UNUSED_RESULT static ExceptionStatus AddElementsToKeyAccumulatorImpl(
      DirectHandle<JSObject> receiver, KeyAccumulator* accumulator,
      AddKeyConversion convert) {
    Isolate* isolate = accumulator->isolate();
    DirectHandle<FixedArrayBase> elements(receiver->elements(), isolate);
    uint32_t length = GetCapacityImpl(*receiver, *elements);
    for (uint32_t index = 0; index < length; index++) {
      InternalIndex entry(index);
      if (!HasEntryImpl(isolate, *elements, entry)) continue;
      DirectHandle<Object> value = GetImpl(isolate, *elements, entry);
      RETURN_FAILURE_IF_NOT_SUCCESSFUL(accumulator->AddKey(value, convert));
    }
    return ExceptionStatus::kSuccess;
  }

  static bool HasEntryImpl(Isolate* isolate, Tagged<FixedArrayBase> parameters,
                           InternalIndex entry) {
    Tagged<SloppyArgumentsElements> elements =
        Cast<SloppyArgumentsElements>(parameters);
    uint32_t length = elements->length();
    if (entry.raw_value() < length) {
      return HasParameterMapArg(isolate, elements, entry.raw_value());
    }
    Tagged<FixedArrayBase> arguments = elements->arguments();
    return ArgumentsAccessor::HasEntryImpl(isolate, arguments,
                                           entry.adjust_down(length));
  }

  static bool HasAccessorsImpl(Tagged<JSObject> holder,
                               Tagged<FixedArrayBase> backing_store) {
    Tagged<SloppyArgumentsElements> elements =
        Cast<SloppyArgumentsElements>(backing_store);
    Tagged<FixedArray> arguments = elements->arguments();
    return ArgumentsAccessor::HasAccessorsImpl(holder, arguments);
  }

  static InternalIndex GetEntryForIndexImpl(Isolate* isolate,
                                            Tagged<JSObject> holder,
                                            Tagged<FixedArrayBase> parameters,
                                            size_t index,
                                            PropertyFilter filter) {
    Tagged<SloppyArgumentsElements> elements =
        Cast<SloppyArgumentsElements>(parameters);
    if (HasParameterMapArg(isolate, elements, index)) {
      return InternalIndex(index);
    }
    Tagged<FixedArray> arguments = elements->arguments();
    InternalIndex entry = ArgumentsAccessor::GetEntryForIndexImpl(
        isolate, holder, arguments, index, filter);
    if (entry.is_not_found()) return entry;
    // Arguments entries could overlap with the dictionary entries, hence offset
    // them by the number of context mapped entries.
    return entry.adjust_up(elements->length());
  }

  static PropertyDetails GetDetailsImpl(Tagged<JSObject> holder,
                                        InternalIndex entry) {
    Tagged<SloppyArgumentsElements> elements =
        Cast<SloppyArgumentsElements>(holder->elements());
    uint32_t length = elements->length();
    if (entry.as_uint32() < length) {
      return PropertyDetails(PropertyKind::kData, NONE,
                             PropertyCellType::kNoCell);
    }
    Tagged<FixedArray> arguments = elements->arguments();
    return ArgumentsAccessor::GetDetailsImpl(arguments,
                                             entry.adjust_down(length));
  }

  static bool HasParameterMapArg(Isolate* isolate,
                                 Tagged<SloppyArgumentsElements> elements,
                                 size_t index) {
    uint32_t length = elements->length();
    if (index >= length) return false;
    return !IsTheHole(
        elements->mapped_entries(static_cast<uint32_t>(index), kRelaxedLoad),
        isolate);
  }

  static void DeleteImpl(DirectHandle<JSObject> obj, InternalIndex entry) {
    DirectHandle<SloppyArgumentsElements> elements(
        Cast<SloppyArgumentsElements>(obj->elements()), obj->GetIsolate());
    uint32_t length = elements->length();
    InternalIndex delete_or_entry = entry;
    if (entry.as_uint32() < length) {
      delete_or_entry = InternalIndex::NotFound();
    }
    Subclass::SloppyDeleteImpl(obj, elements, delete_or_entry);
    // SloppyDeleteImpl allocates a new dictionary elements store. For making
    // heap verification happy we postpone clearing out the mapped entry.
    if (entry.as_uint32() < length) {
      elements->set_mapped_entries(entry.as_uint32(),
                                   GetReadOnlyRoots().the_hole_value());
    }
  }

  static void SloppyDeleteImpl(DirectHandle<JSObject> obj,
                               DirectHandle<SloppyArgumentsElements> elements,
                               InternalIndex entry) {
    // Implemented in subclasses.
    UNREACHABLE();
  }

  V8_WARN_UNUSED_RESULT static ExceptionStatus CollectElementIndicesImpl(
      DirectHandle<JSObject> object, DirectHandle<FixedArrayBase> backing_store,
      KeyAccumulator* keys) {
    Isolate* isolate = keys->isolate();
    uint32_t nof_indices = 0;
    Handle<FixedArray> indices = isolate->factory()->NewFixedArray(
        GetCapacityImpl(*object, *backing_store));
    DirectCollectElementIndicesImpl(isolate, object, backing_store,
                                    GetKeysConversion::kKeepNumbers,
                                    ENUMERABLE_STRINGS, indices, &nof_indices);
    SortIndices(isolate, indices, nof_indices);
    for (uint32_t i = 0; i < nof_indices; i++) {
      RETURN_FAILURE_IF_NOT_SUCCESSFUL(keys->AddKey(indices->get(i)));
    }
    return ExceptionStatus::kSuccess;
  }

  static Handle<FixedArray> DirectCollectElementIndicesImpl(
      Isolate* isolate, DirectHandle<JSObject> object,
      DirectHandle<FixedArrayBase> backing_store, GetKeysConversion convert,
      PropertyFilter filter, Handle<FixedArray> list, uint32_t* nof_indices,
      uint32_t insertion_index = 0) {
    auto elements = Cast<SloppyArgumentsElements>(backing_store);
    uint32_t length = elements->length();

    for (uint32_t i = 0; i < length; ++i) {
      if (IsTheHole(elements->mapped_entries(i, kRelaxedLoad), isolate))
        continue;
      if (convert == GetKeysConversion::kConvertToString) {
        DirectHandle<String> index_string =
            isolate->factory()->Uint32ToString(i);
        list->set(insertion_index, *index_string);
      } else {
        list->set(insertion_index, Smi::FromInt(i));
      }
      insertion_index++;
    }

    DirectHandle<FixedArray> store(elements->arguments(), isolate);
    return ArgumentsAccessor::DirectCollectElementIndicesImpl(
        isolate, object, store, convert, filter, list, nof_indices,
        insertion_index);
  }

  static Maybe<bool> IncludesValueImpl(Isolate* isolate,
                                       DirectHandle<JSObject> object,
                                       DirectHandle<Object> value,
                                       size_t start_from, size_t length) {
    DCHECK(JSObject::PrototypeHasNoElements(isolate, *object));
    DirectHandle<Map> original_map(object->map(), isolate);
    DirectHandle<SloppyArgumentsElements> elements(
        Cast<SloppyArgumentsElements>(object->elements()), isolate);
    bool search_for_hole = IsUndefined(*value, isolate);

    for (size_t k = start_from; k < length; ++k) {
      DCHECK_EQ(object->map(), *original_map);
      InternalIndex entry =
          GetEntryForIndexImpl(isolate, *object, *elements, k, ALL_PROPERTIES);
      if (entry.is_not_found()) {
        if (search_for_hole) return Just(true);
        continue;
      }

      DirectHandle<Object> element_k =
          Subclass::GetImpl(isolate, *elements, entry);

      if (IsAccessorPair(*element_k)) {
        LookupIterator it(isolate, object, k, LookupIterator::OWN);
        DCHECK(it.IsFound());
        DCHECK_EQ(it.state(), LookupIterator::ACCESSOR);
        ASSIGN_RETURN_ON_EXCEPTION_VALUE(isolate, element_k,
                                         Object::GetPropertyWithAccessor(&it),
                                         Nothing<bool>());

        if (Object::SameValueZero(*value, *element_k)) return Just(true);

        if (object->map() != *original_map) {
          // Some mutation occurred in accessor. Abort "fast" path
          return IncludesValueSlowPath(isolate, object, value, k + 1, length);
        }
      } else if (Object::SameValueZero(*value, *element_k)) {
        return Just(true);
      }
    }
    return Just(false);
  }

  static Maybe<int64_t> IndexOfValueImpl(Isolate* isolate,
                                         DirectHandle<JSObject> object,
                                         DirectHandle<Object> value,
                                         size_t start_from, size_t length) {
    DCHECK(JSObject::PrototypeHasNoElements(isolate, *object));
    DirectHandle<Map> original_map(object->map(), isolate);
    DirectHandle<SloppyArgumentsElements> elements(
        Cast<SloppyArgumentsElements>(object->elements()), isolate);

    for (size_t k = start_from; k < length; ++k) {
      DCHECK_EQ(object->map(), *original_map);
      InternalIndex entry =
          GetEntryForIndexImpl(isolate, *object, *elements, k, ALL_PROPERTIES);
      if (entry.is_not_found()) {
        continue;
      }

      DirectHandle<Object> element_k =
          Subclass::GetImpl(isolate, *elements, entry);

      if (IsAccessorPair(*element_k)) {
        LookupIterator it(isolate, object, k, LookupIterator::OWN);
        DCHECK(it.IsFound());
        DCHECK_EQ(it.state(), LookupIterator::ACCESSOR);
        ASSIGN_RETURN_ON_EXCEPTION_VALUE(isolate, element_k,
                                         Object::GetPropertyWithAccessor(&it),
                                         Nothing<int64_t>());

        if (Object::StrictEquals(*value, *element_k)) {
          return Just<int64_t>(k);
        }

        if (object->map() != *original_map) {
          // Some mutation occurred in accessor. Abort "fast" path.
          return IndexOfValueSlowPath(isolate, object, value, k + 1, length);
        }
      } else if (Object::StrictEquals(*value, *element_k)) {
        return Just<int64_t>(k);
      }
    }
    return Just<int64_t>(-1);
  }
};

class SlowSloppyArgumentsElementsAccessor
    : public SloppyArgumentsElementsAccessor<
          SlowSloppyArgumentsElementsAccessor, DictionaryElementsAccessor,
          ElementsKindTraits<SLOW_SLOPPY_ARGUMENTS_ELEMENTS>> {
 public:
  static Handle<Object> ConvertArgumentsStoreResult(
      Isolate* isolate, DirectHandle<SloppyArgumentsElements> elements,
      Handle<Object> result) {
    // Elements of the arguments object in slow mode might be slow aliases.
    if (IsAliasedArgumentsEntry(*result)) {
      DisallowGarbageCollection no_gc;
      Tagged<AliasedArgumentsEntry> alias =
          Cast<AliasedArgumentsEntry>(*result);
      Tagged<Context> context = elements->context();
      int context_entry = alias->aliased_context_slot();
      DCHECK(!IsTheHole(context->get(context_entry), isolate));
      return handle(context->get(context_entry), isolate);
    }
    return result;
  }
  static void SloppyDeleteImpl(DirectHandle<JSObject> obj,
                               DirectHandle<SloppyArgumentsElements> elements,
                               InternalIndex entry) {
    // No need to delete a context mapped entry from the arguments elements.
    if (entry.is_not_found()) return;
    Isolate* isolate = obj->GetIsolate();
    DirectHandle<NumberDictionary> dict(
        Cast<NumberDictionary>(elements->arguments()), isolate);
    uint32_t length = elements->length();
    dict =
        NumberDictionary::DeleteEntry(isolate, dict, entry.adjust_down(length));
    elements->set_arguments(*dict);
  }
  static Maybe<bool> AddImpl(DirectHandle<JSObject> object, uint32_t index,
                             DirectHandle<Object> value,
                             PropertyAttributes attributes,
                             uint32_t new_capacity) {
    Isolate* isolate = object->GetIsolate();
    DirectHandle<SloppyArgumentsElements> elements(
        Cast<SloppyArgumentsElements>(object->elements()), isolate);
    DirectHandle<FixedArrayBase> old_arguments(elements->arguments(), isolate);
    DirectHandle<NumberDictionary> dictionary =
        IsNumberDictionary(*old_arguments)
            ? Cast<NumberDictionary>(old_arguments)
            : JSObject::NormalizeElements(object);
    PropertyDetails details(PropertyKind::kData, attributes,
                            PropertyCellType::kNoCell);
    DirectHandle<NumberDictionary> new_dictionary =
        NumberDictionary::Add(isolate, dictionary, index, value, details);
    if (attributes != NONE) object->RequireSlowElements(*new_dictionary);
    if (*dictionary != *new_dictionary) {
      elements->set_arguments(*new_dictionary);
    }
    return Just(true);
  }

  static void ReconfigureImpl(DirectHandle<JSObject> object,
                              DirectHandle<FixedArrayBase> store,
                              InternalIndex entry, DirectHandle<Object> value,
                              PropertyAttributes attributes) {
    Isolate* isolate = object->GetIsolate();
    auto elements = Cast<SloppyArgumentsElements>(store);
    uint32_t length = elements->length();
    if (entry.as_uint32() < length) {
      Tagged<Object> probe =
          elements->mapped_entries(entry.as_uint32(), kRelaxedLoad);
      DCHECK(!IsTheHole(probe, isolate));
      Tagged<Context> context = elements->context();
      int context_entry = Smi::ToInt(probe);
      DCHECK(!IsTheHole(context->get(context_entry), isolate));
      context->set(context_entry, *value);

      // Redefining attributes of an aliased element destroys fast aliasing.
      elements->set_mapped_entries(entry.as_uint32(),
                                   ReadOnlyRoots(isolate).the_hole_value());
      // For elements that are still writable we re-establish slow aliasing.
      if ((attributes & READ_ONLY) == 0) {
        value = isolate->factory()->NewAliasedArgumentsEntry(context_entry);
      }

      PropertyDetails details(PropertyKind::kData, attributes,
                              PropertyCellType::kNoCell);
      DirectHandle<NumberDictionary> arguments(
          Cast<NumberDictionary>(elements->arguments()), isolate);
      arguments = NumberDictionary::Add(isolate, arguments, entry.as_uint32(),
                                        value, details);
      // If the attributes were NONE, we would have called set rather than
      // reconfigure.
      DCHECK_NE(NONE, attributes);
      object->RequireSlowElements(*arguments);
      elements->set_arguments(*arguments);
    } else {
      DirectHandle<FixedArrayBase> arguments(elements->arguments(), isolate);
      DictionaryElementsAccessor::ReconfigureImpl(
          object, arguments, entry.adjust_down(length), value, attributes);
    }
  }
};

class FastSloppyArgumentsElementsAccessor
    : public SloppyArgumentsElementsAccessor<
          FastSloppyArgumentsElementsAccessor, FastHoleyObjectElementsAccessor,
          ElementsKindTraits<FAST_SLOPPY_ARGUMENTS_ELEMENTS>> {
 public:
  static Handle<Object> ConvertArgumentsStoreResult(
      Isolate* isolate, DirectHandle<SloppyArgumentsElements> parameter_map,
      Handle<Object> result) {
    DCHECK(!IsAliasedArgumentsEntry(*result));
    return result;
  }

  static DirectHandle<FixedArray> GetArguments(Isolate* isolate,
                                               Tagged<FixedArrayBase> store) {
    Tagged<SloppyArgumentsElements> elements =
        Cast<SloppyArgumentsElements>(store);
    return DirectHandle<FixedArray>(elements->arguments(), isolate);
  }

  static DirectHandle<NumberDictionary> NormalizeImpl(
      DirectHandle<JSObject> object, DirectHandle<FixedArrayBase> elements) {
    DirectHandle<FixedArray> arguments =
        GetArguments(object->GetIsolate(), *elements);
    return FastHoleyObjectElementsAccessor::NormalizeImpl(object, arguments);
  }

  static DirectHandle<NumberDictionary> NormalizeArgumentsElements(
      DirectHandle<JSObject> object,
      DirectHandle<SloppyArgumentsElements> elements, InternalIndex* entry) {
    DirectHandle<NumberDictionary> dictionary =
        JSObject::NormalizeElements(object);
    elements->set_arguments(*dictionary);
    // kMaxUInt32 indicates that a context mapped element got deleted. In this
    // case we only normalize the elements (aka. migrate to SLOW_SLOPPY).
    if (entry->is_not_found()) return dictionary;
    uint32_t length = elements->length();
    if (entry->as_uint32() >= length) {
      *entry =
          dictionary
              ->FindEntry(object->GetIsolate(), entry->as_uint32() - length)
              .adjust_up(length);
    }
    return dictionary;
  }

  static void SloppyDeleteImpl(DirectHandle<JSObject> obj,
                               DirectHandle<SloppyArgumentsElements> elements,
                               InternalIndex entry) {
    // Always normalize element on deleting an entry.
    NormalizeArgumentsElements(obj, elements, &entry);
    SlowSloppyArgumentsElementsAccessor::SloppyDeleteImpl(obj, elements, entry);
  }

  static Maybe<bool> AddImpl(DirectHandle<JSObject> object, uint32_t index,
                             DirectHandle<Object> value,
                             PropertyAttributes attributes,
                             uint32_t new_capacity) {
    DCHECK_EQ(NONE, attributes);
    Isolate* isolate = object->GetIsolate();
    DirectHandle<SloppyArgumentsElements> elements(
        Cast<SloppyArgumentsElements>(object->elements()), isolate);
    DirectHandle<FixedArray> old_arguments(elements->arguments(), isolate);
    if (IsNumberDictionary(*old_arguments) ||
        static_cast<uint32_t>(old_arguments->length()) < new_capacity) {
      MAYBE_RETURN(GrowCapacityAndConvertImpl(object, new_capacity),
                   Nothing<bool>());
    }
    Tagged<FixedArray> arguments = elements->arguments();
    // For fast holey objects, the entry equals the index. The code above made
    // sure that there's enough space to store the value. We cannot convert
    // index to entry explicitly since the slot still contains the hole, so the
    // current EntryForIndex would indicate that it is "absent" by returning
    // kMaxUInt32.
    FastHoleyObjectElementsAccessor::SetImpl(arguments, InternalIndex(index),
                                             *value);
    return Just(true);
  }

  static void ReconfigureImpl(DirectHandle<JSObject> object,
                              DirectHandle<FixedArrayBase> store,
                              InternalIndex entry, DirectHandle<Object> value,
                              PropertyAttributes attributes) {
    DCHECK_EQ(object->elements(), *store);
    DirectHandle<SloppyArgumentsElements> elements(
        Cast<SloppyArgumentsElements>(*store), object->GetIsolate());
    NormalizeArgumentsElements(object, elements, &entry);
    SlowSloppyArgumentsElementsAccessor::ReconfigureImpl(object, store, entry,
                                                         value, attributes);
  }

  static void CopyElementsImpl(Isolate* isolate, Tagged<FixedArrayBase> from,
                               uint32_t from_start, Tagged<FixedArrayBase> to,
                               ElementsKind from_kind, uint32_t to_start,
                               int packed_size, int copy_size) {
    DCHECK(!IsNumberDictionary(to));
    if (from_kind == SLOW_SLOPPY_ARGUMENTS_ELEMENTS) {
      CopyDictionaryToObjectElements(isolate, from, from_start, to,
                                     HOLEY_ELEMENTS, to_start, copy_size);
    } else {
      DCHECK_EQ(FAST_SLOPPY_ARGUMENTS_ELEMENTS, from_kind);
      CopyObjectToObjectElements(isolate, from, HOLEY_ELEMENTS, from_start, to,
                                 HOLEY_ELEMENTS, to_start, copy_size);
    }
  }

  static Maybe<bool> GrowCapacityAndConvertImpl(DirectHandle<JSObject> object,
                                                uint32_t capacity) {
    Isolate* isolate = object->GetIsolate();
    DirectHandle<SloppyArgumentsElements> elements(
        Cast<SloppyArgumentsElements>(object->elements()), isolate);
    DirectHandle<FixedArray> old_arguments(
        Cast<FixedArray>(elements->arguments()), isolate);
    ElementsKind from_kind = object->GetElementsKind();
    // This method should only be called if there's a reason to update the
    // elements.
    DCHECK(from_kind == SLOW_SLOPPY_ARGUMENTS_ELEMENTS ||
           static_cast<uint32_t>(old_arguments->length()) < capacity);
    DirectHandle<FixedArrayBase> arguments;
    ASSIGN_RETURN_ON_EXCEPTION_VALUE(
        isolate, arguments,
        ConvertElementsWithCapacity(object, old_arguments, from_kind, capacity),
        Nothing<bool>());
    DirectHandle<Map> new_map = JSObject::GetElementsTransitionMap(
        object, FAST_SLOPPY_ARGUMENTS_ELEMENTS);
    JSObject::MigrateToMap(isolate, object, new_map);
    elements->set_arguments(Cast<FixedArray>(*arguments));
    JSObject::ValidateElements(*object);
    return Just(true);
  }
};

template <typename Subclass, typename BackingStoreAccessor, typename KindTraits>
class StringWrapperElementsAccessor
    : public ElementsAccessorBase<Subclass, KindTraits> {
 public:
  static Handle<Object> GetInternalImpl(Isolate* isolate,
                                        DirectHandle<JSObject> holder,
                                        InternalIndex entry) {
    return GetImpl(holder, entry);
  }

  static Handle<Object> GetImpl(DirectHandle<JSObject> holder,
                                InternalIndex entry) {
    Isolate* isolate = holder->GetIsolate();
    DirectHandle<String> string(GetString(*holder), isolate);
    uint32_t length = static_cast<uint32_t>(string->length());
    if (entry.as_uint32() < length) {
      return isolate->factory()->LookupSingleCharacterStringFromCode(
          String::Flatten(isolate, string)->Get(entry.as_int()));
    }
    return BackingStoreAccessor::GetImpl(isolate, holder->elements(),
                                         entry.adjust_down(length));
  }

  static Handle<Object> GetImpl(Isolate* isolate,
                                Tagged<FixedArrayBase> elements,
                                InternalIndex entry) {
    UNREACHABLE();
  }

  static PropertyDetails GetDetailsImpl(Tagged<JSObject> holder,
                                        InternalIndex entry) {
    uint32_t length = static_cast<uint32_t>(GetString(holder)->length());
    if (entry.as_uint32() < length) {
      PropertyAttributes attributes =
          static_cast<PropertyAttributes>(READ_ONLY | DONT_DELETE);
      return PropertyDetails(PropertyKind::kData, attributes,
                             PropertyCellType::kNoCell);
    }
    return BackingStoreAccessor::GetDetailsImpl(holder,
                                                entry.adjust_down(length));
  }

  static InternalIndex GetEntryForIndexImpl(
      Isolate* isolate, Tagged<JSObject> holder,
      Tagged<FixedArrayBase> backing_store, size_t index,
      PropertyFilter filter) {
    uint32_t length = static_cast<uint32_t>(GetString(holder)->length());
    if (index < length) return InternalIndex(index);
    InternalIndex backing_store_entry =
        BackingStoreAccessor::GetEntryForIndexImpl(
            isolate, holder, backing_store, index, filter);
    if (backing_store_entry.is_not_found()) return backing_store_entry;
    return backing_store_entry.adjust_up(length);
  }

  static void DeleteImpl(DirectHandle<JSObject> holder, InternalIndex entry) {
    uint32_t length = static_cast<uint32_t>(GetString(*holder)->length());
    if (entry.as_uint32() < length) {
      return;  // String contents can't be deleted.
    }
    BackingStoreAccessor::DeleteImpl(holder, entry.adjust_down(length));
  }

  static void SetImpl(DirectHandle<JSObject> holder, InternalIndex entry,
                      Tagged<Object> value) {
    uint32_t length = static_cast<uint32_t>(GetString(*holder)->length());
    if (entry.as_uint32() < length) {
      return;  // String contents are read-only.
    }
    BackingStoreAccessor::SetImpl(holder->elements(), entry.adjust_down(length),
                                  value);
  }

  static Maybe<bool> AddImpl(DirectHandle<JSObject> object, uint32_t index,
                             DirectHandle<Object> value,
                             PropertyAttributes attributes,
                             uint32_t new_capacity) {
    DCHECK(index >= static_cast<uint32_t>(GetString(*object)->length()));
    // Explicitly grow fast backing stores if needed. Dictionaries know how to
    // extend their capacity themselves.
    if (KindTraits::Kind == FAST_STRING_WRAPPER_ELEMENTS &&
        (object->GetElementsKind() == SLOW_STRING_WRAPPER_ELEMENTS ||
         BackingStoreAccessor::GetCapacityImpl(*object, object->elements()) !=
             new_capacity)) {
      MAYBE_RETURN(GrowCapacityAndConvertImpl(object, new_capacity),
                   Nothing<bool>());
    }
    BackingStoreAccessor::AddImpl(object, index, value, attributes,
                                  new_capacity);
    return Just(true);
  }

  static void ReconfigureImpl(DirectHandle<JSObject> object,
                              DirectHandle<FixedArrayBase> store,
                              InternalIndex entry, DirectHandle<Object> value,
                              PropertyAttributes attributes) {
    uint32_t length = static_cast<uint32_t>(GetString(*object)->length());
    if (entry.as_uint32() < length) {
      return;  // String contents can't be reconfigured.
    }
    BackingStoreAccessor::ReconfigureImpl(
        object, store, entry.adjust_down(length), value, attributes);
  }

  V8_WARN_UNUSED_RESULT static ExceptionStatus AddElementsToKeyAccumulatorImpl(
      DirectHandle<JSObject> receiver, KeyAccumulator* accumulator,
      AddKeyConversion convert) {
    Isolate* isolate = receiver->GetIsolate();
    DirectHandle<String> string(GetString(*receiver), isolate);
    string = String::Flatten(isolate, string);
    uint32_t length = static_cast<uint32_t>(string->length());
    for (uint32_t i = 0; i < length; i++) {
      DirectHandle<String> key =
          isolate->factory()->LookupSingleCharacterStringFromCode(
              string->Get(i));
      RETURN_FAILURE_IF_NOT_SUCCESSFUL(accumulator->AddKey(key, convert));
    }
    return BackingStoreAccessor::AddElementsToKeyAccumulatorImpl(
        receiver, accumulator, convert);
  }

  V8_WARN_UNUSED_RESULT static ExceptionStatus CollectElementIndicesImpl(
      DirectHandle<JSObject> object, DirectHandle<FixedArrayBase> backing_store,
      KeyAccumulator* keys) {
    uint32_t length = GetString(*object)->length();
    Factory* factory = keys->isolate()->factory();
    for (uint32_t i = 0; i < length; i++) {
      RETURN_FAILURE_IF_NOT_SUCCESSFUL(
          keys->AddKey(factory->NewNumberFromUint(i)));
    }
    return BackingStoreAccessor::CollectElementIndicesImpl(object,
                                                           backing_store, keys);
  }

  static Maybe<bool> GrowCapacityAndConvertImpl(DirectHandle<JSObject> object,
                                                uint32_t capacity) {
    DirectHandle<FixedArrayBase> old_elements(object->elements(),
                                              object->GetIsolate());
    ElementsKind from_kind = object->GetElementsKind();
    if (from_kind == FAST_STRING_WRAPPER_ELEMENTS) {
      // The optimizing compiler relies on the prototype lookups of String
      // objects always returning undefined. If there's a store to the
      // initial String.prototype object, make sure all the optimizations
      // are invalidated.
      object->GetIsolate()->UpdateNoElementsProtectorOnSetLength(object);
    }
    // This method should only be called if there's a reason to update the
    // elements.
    DCHECK(from_kind == SLOW_STRING_WRAPPER_ELEMENTS ||
           static_cast<uint32_t>(old_elements->length()) < capacity);
    return Subclass::BasicGrowCapacityAndConvertImpl(
        object, old_elements, from_kind, FAST_STRING_WRAPPER_ELEMENTS,
        capacity);
  }

  static void CopyElementsImpl(Isolate* isolate, Tagged<FixedArrayBase> from,
                               uint32_t from_start, Tagged<FixedArrayBase> to,
                               ElementsKind from_kind, uint32_t to_start,
                               int packed_size, int copy_size) {
    DCHECK(!IsNumberDictionary(to));
    if (from_kind == SLOW_STRING_WRAPPER_ELEMENTS) {
      CopyDictionaryToObjectElements(isolate, from, from_start, to,
                                     HOLEY_ELEMENTS, to_start, copy_size);
    } else {
      DCHECK_EQ(FAST_STRING_WRAPPER_ELEMENTS, from_kind);
      CopyObjectToObjectElements(isolate, from, HOLEY_ELEMENTS, from_start, to,
                                 HOLEY_ELEMENTS, to_start, copy_size);
    }
  }

  static uint32_t NumberOfElementsImpl(Isolate* isolate,
                                       Tagged<JSObject> object,
                                       Tagged<FixedArrayBase> backing_store) {
    uint32_t length = GetString(object)->length();
    return length + BackingStoreAccessor::NumberOfElementsImpl(isolate, object,
                                                               backing_store);
  }

 private:
  static Tagged<String> GetString(Tagged<JSObject> holder) {
    DCHECK(IsJSPrimitiveWrapper(holder));
    Tagged<JSPrimitiveWrapper> js_value = Cast<JSPrimitiveWrapper>(holder);
    DCHECK(IsString(js_value->value()));
    return Cast<String>(js_value->value());
  }
};

class FastStringWrapperElementsAccessor
    : public StringWrapperElementsAccessor<
          FastStringWrapperElementsAccessor, FastHoleyObjectElementsAccessor,
          ElementsKindTraits<FAST_STRING_WRAPPER_ELEMENTS>> {
 public:
  static DirectHandle<NumberDictionary> NormalizeImpl(
      DirectHandle<JSObject> object, DirectHandle<FixedArrayBase> elements) {
    return FastHoleyObjectElementsAccessor::NormalizeImpl(object, elements);
  }
};

class SlowStringWrapperElementsAccessor
    : public StringWrapperElementsAccessor<
          SlowStringWrapperElementsAccessor, DictionaryElementsAccessor,
          ElementsKindTraits<SLOW_STRING_WRAPPER_ELEMENTS>> {
 public:
  static bool HasAccessorsImpl(Tagged<JSObject> holder,
                               Tagged<FixedArrayBase> backing_store) {
    return DictionaryElementsAccessor::HasAccessorsImpl(holder, backing_store);
  }
};

}  // namespace

MaybeDirectHandle<Object> ArrayConstructInitializeElements(
    DirectHandle<JSArray> array, JavaScriptArguments* args) {
  if (args->length() == 0) {
    // Optimize the case where there are no parameters passed.
    JSArray::Initialize(array, JSArray::kPreallocatedArrayElements);
    return array;

  } else if (args->length() == 1 && IsNumber(*args->at(0))) {
    uint32_t length;
    if (!Object::ToArrayLength(*args->at(0), &length)) {
      return ThrowArrayLengthRangeError(array->GetIsolate());
    }

    // Optimize the case where there is one argument and the argument is a small
    // smi.
    if (length > 0 && length < JSArray::kInitialMaxFastElementArray) {
      ElementsKind elements_kind = array->GetElementsKind();
      JSArray::Initialize(array, length, length);

      if (!IsHoleyElementsKind(elements_kind)) {
        elements_kind = GetHoleyElementsKind(elements_kind);
        JSObject::TransitionElementsKind(array, elements_kind);
      }
    } else if (length == 0) {
      JSArray::Initialize(array, JSArray::kPreallocatedArrayElements);
    } else {
      // Take the argument as the length.
      JSArray::Initialize(array, 0);
      MAYBE_RETURN_NULL(JSArray::SetLength(array, length));
    }
    return array;
  }

  Factory* factory = array->GetIsolate()->factory();

  // Set length and elements on the array.
  int number_of_elements = args->length();
  JSObject::EnsureCanContainElements(array, args, number_of_elements,
                                     ALLOW_CONVERTED_DOUBLE_ELEMENTS);

  // Allocate an appropriately typed elements array.
  ElementsKind elements_kind = array->GetElementsKind();
  DirectHandle<FixedArrayBase> elms;
  if (IsDoubleElementsKind(elements_kind)) {
    elms =
        Cast<FixedArrayBase>(factory->NewFixedDoubleArray(number_of_elements));
  } else {
    elms = Cast<FixedArrayBase>(
        factory->NewFixedArrayWithHoles(number_of_elements));
  }

  // Fill in the content
  switch (elements_kind) {
    case HOLEY_SMI_ELEMENTS:
    case PACKED_SMI_ELEMENTS: {
      auto smi_elms = Cast<FixedArray>(elms);
      for (int entry = 0; entry < number_of_elements; entry++) {
        smi_elms->set(entry, (*args)|entry], SKIP_WRITE_BARRIER);
      }
      break;
    }
    case HOLEY_ELEMENTS:
    case PACKED_ELEMENTS: {
      DisallowGarbageCollection no_gc;
      WriteBarrierMode mode = elms->GetWriteBarrierMode(no_gc);
      auto object_elms = Cast<FixedArray>(elms);
      for (int entry = 0; entry < number_of_elements; entry++) {
        object_elms->set(entry, (*args)|entry], mode);
      }
      break;
    }
    case HOLEY_DOUBLE_ELEMENTS:
    case PACKED_DOUBLE_ELEMENTS: {
      auto double_elms = Cast<FixedDoubleArray>(elms);
      for (int entry = 0; entry < number_of_elements; entry++) {
        double_elms->set(entry, Object::NumberValue((*args)|entry]));
      }
      break;
    }
    default:
      UNREACHABLE();
  }

  array->set_elements(*elms);
  array->set_length(Smi::FromInt(number_of_elements));
  return array;
}

void CopyFastNumberJSArrayElementsToTypedArray(Address raw_context,
                                               Address raw_source,
                                               Address raw_destination,
                                               uintptr_t length,
                                               uintptr_t offset) {
  Tagged<Context> context = Cast<Context>(Tagged<Object>(raw_context));
  Tagged<JSArray> source = Cast<JSArray>(Tagged<Object>(raw_source));
  Tagged<JSTypedArray> destination =
      Cast<JSTypedArray>(Tagged<Object>(raw_destination));

  switch (destination->GetElementsKind()) {
#define TYPED_ARRAYS_CASE(Type, type, TYPE, ctype)           \
  case TYPE##_ELEMENTS:                                      \
    CHECK(Type##ElementsAccessor::TryCopyElementsFastNumber( \
        context, source, destination, length, offset));      \
    break;
    TYPED_ARRAYS(TYPED_ARRAYS_CASE)
    RAB_GSAB_TYPED_ARRAYS(TYPED_ARRAYS_CASE)
#undef TYPED_ARRAYS_CASE
    default:
      UNREACHABLE();
  }
}

void CopyTypedArrayElementsToTypedArray(Address raw_source,
                                        Address raw_destination,
                                        uintptr_t length, uintptr_t offset) {
  Tagged<JSTypedArray> source = Cast<JSTypedArray>(Tagged<Object>(raw_source));
  Tagged<JSTypedArray> destination =
      Cast<JSTypedArray>(Tagged<Object>(raw_destination));

  switch (destination->GetElementsKind()) {
#define TYPED_ARRAYS_CASE(Type, type, TYPE, ctype)                          \
  case TYPE##_ELEMENTS:                                                     \
    Type##ElementsAccessor::CopyElementsFromTypedArray(source, destination, \
                                                       length, offset);     \
    break;
    TYPED_ARRAYS(TYPED_ARRAYS_CASE)
    RAB_GSAB_TYPED_ARRAYS(TYPED_ARRAYS_CASE)
#undef TYPED_ARRAYS_CASE
    default:
      UNREACHABLE();
  }
}

void CopyTypedArrayElementsSlice(Address raw_source, Address raw_destination,
                                 uintptr_t start, uintptr_t end) {
  Tagged<JSTypedArray> source = Cast<JSTypedArray>(Tagged<Object>(raw_source));
  Tagged<JSTypedArray> destination =
      Cast<JSTypedArray>(Tagged<Object>(raw_destination));

  destination->GetElementsAccessor()->CopyTypedArrayElementsSlice(
      source, destination, start, end);
}

template <typename Mapping>
constexpr bool IsIdentityMapping(const Mapping& mapping, size_t index) {
  return (index >= std::size(mapping)) ||
         (mapping|index] == index && IsIdentityMapping(mapping, index + 1));
}

void ElementsAccessor::InitializeOncePerProcess() {
  // Here we create an array with more entries than element kinds.
  // This is due to the sandbox: this array is indexed with an ElementsKind
  // read directly from within the sandbox, which must therefore be considered
  // attacker-controlled. An ElementsKind is a uint8_t under the hood, so we
  // can either use an array with 256 entries or have an explicit bounds-check
  // on access. The latter is probably more expensive.
  static_assert(std::is_same_v<std::underlying_type_t<ElementsKind>, uint8_t>);
  static ElementsAccessor* accessor_array|256] = {
#define ACCESSOR_ARRAY(Class, Kind, Store) new Class(),
      ELEMENTS_LIST(ACCESSOR_ARRAY)
#undef ACCESSOR_ARRAY
  };

  static_assert((sizeof(accessor_array) / sizeof(*accessor_array)) >=
                kElementsKindCount);

  // Check that the ELEMENTS_LIST macro is in the same order as the ElementsKind
  // enum.
  constexpr ElementsKind elements_kinds_from_macro|] = {
#define ACCESSOR_KIND(Class, Kind, Store) Kind,
      ELEMENTS_LIST(ACCESSOR_KIND)
#undef ACCESSOR_KIND
  };
  static_assert(IsIdentityMapping(elements_kinds_from_macro, 0));

  elements_accessors_ = accessor_array;
}

void ElementsAccessor::TearDown() {
  if (elements_accessors_ == nullptr) return;
#define ACCESSOR_DELETE(Class, Kind, Store) delete elements_accessors_|Kind];
  ELEMENTS_LIST(ACCESSOR_DELETE)
#undef ACCESSOR_DELETE
  elements_accessors_ = nullptr;
}

Handle<JSArray> ElementsAccessor::Concat(Isolate* isolate,
                                         BuiltinArguments* args,
                                         uint32_t concat_size,
                                         uint32_t result_len) {
  ElementsKind result_elements_kind = GetInitialFastElementsKind();
  bool has_raw_doubles = false;
  {
    DisallowGarbageCollection no_gc;
    bool is_holey = false;
    for (uint32_t i = 0; i < concat_size; i++) {
      Tagged<Object> arg = (*args)|i];
      ElementsKind arg_kind = Cast<JSArray>(arg)->GetElementsKind();
      has_raw_doubles = has_raw_doubles || IsDoubleElementsKind(arg_kind);
      is_holey = is_holey || IsHoleyElementsKind(arg_kind);
      result_elements_kind =
          GetMoreGeneralElementsKind(result_elements_kind, arg_kind);
    }
    if (is_holey) {
      result_elements_kind = GetHoleyElementsKind(result_elements_kind);
    }
  }

  // If a double array is concatted into a fast elements array, the fast
  // elements array needs to be initialized to contain proper holes, since
  // boxing doubles may cause incremental marking.
  bool requires_double_boxing =
      has_raw_doubles && !IsDoubleElementsKind(result_elements_kind);
  auto mode =
      requires_double_boxing
          ? ArrayStorageAllocationMode::INITIALIZE_ARRAY_ELEMENTS_WITH_HOLE
          : ArrayStorageAllocationMode::DONT_INITIALIZE_ARRAY_ELEMENTS;
  Handle<JSArray> result_array = isolate->factory()->NewJSArray(
      result_elements_kind, result_len, result_len, mode);
  if (result_len == 0) return result_array;

  uint32_t insertion_index = 0;
  DirectHandle<FixedArrayBase> storage(result_array->elements(), isolate);
  ElementsAccessor* accessor = ElementsAccessor::ForKind(result_elements_kind);
  for (uint32_t i = 0; i < concat_size; i++) {
    // It is crucial to keep |array| in a raw pointer form to avoid
    // performance degradation.
    Tagged<JSArray> array = Cast<JSArray>((*args)|i]);
    uint32_t len = 0;
    Object::ToArrayLength(array->length(), &len);
    if (len == 0) continue;
    ElementsKind from_kind = array->GetElementsKind();
    accessor->CopyElements(isolate, array, 0, from_kind, storage,
                           insertion_index, len);
    insertion_index += len;
  }

  DCHECK_EQ(insertion_index, result_len);
  return result_array;
}

ElementsAccessor** ElementsAccessor::elements_accessors_ = nullptr;

#undef ELEMENTS_LIST
#undef RETURN_NOTHING_IF_NOT_SUCCESSFUL
#undef RETURN_FAILURE_IF_NOT_SUCCESSFUL
}  // namespace internal
}  // namespace v8
[Step 15: Duration 10.75 seconds| Input tokens: 709,902 | Output tokens: 4,085]
Reached max steps.
[Step 16: Duration 93.78 seconds| Input tokens: 830,139 | Output tokens: 10,519]
Observations: Here is the final answer from your managed agent 'V8Search':
I will assemble a detailed inventory based on the repository scan. This will take a few moments. I'll list concrete file paths and symbols per subsection (a)-(f) and give short notes and
IDs you can use to reference items later.
I'll run targeted searches to collect file paths and key symbols for each subsection.
Searching repository for remaining relevant symbols... (this is internal reasoning, not a tool call)
I'll include items found earlier and a few more from compiler and builtins. Now preparing the final structured answer.
### 1. Task outcome (short version):

I scanned the V8 tree (main branch in the workspace) and produced a structured loci inventory covering keyed element access and elements-kind transitions. The inventory is grouped by the
requested subsections (a)-(f). Each entry is |id, file path, symbol/function/class, brief note]. IDs are short unique tags you can use to ask for deeper dives.

High-level hotspots:
- Core elements backend: src/objects/elements.cc / elements.h — ElementsAccessor hierarchy, CopyElements implementations, SetLengthImpl, TransitionElementsKind handling, 
Grow/GrowCapacity/Convert helpers. (IDs: ELEM:*)
- JSObject / JSArray APIs: src/objects/js-objects.cc / objects.cc / js-objects-inl.h / js-array.h — JSObject::TransitionElementsKind, JSArray::SetLength and helpers, NewElementsCapacity,
EnsureWritableFastElements, UpdateNoElementsProtector hooks. (IDs: JSOBJ:*, JSARR:*)
- CSA & Builtins runtime helpers: src/codegen/code-stub-assembler.{h,cc} and generated builtins *.gen.cc / handler-gen.cc / builtins-*.tq — CSA helpers 
TryGrowElementsCapacity/GrowElementsCapacity/CopyElements and builtin-Torque entry points (TransitionElementsKind macro/runtimes). (IDs: CSA:*)
- ICs & stubs: src/ic/* and src/builtins/*-ic-gen / builtins-handler-gen.cc — KeyedLoadIC/KeyedStoreIC generation, IC class (ic/ic.h, ic/ic.cc), accessor-assembler 
(ic/accessor-assembler.*) which emits keyed IC logic and feedback handling. (IDs: IC:*)
- Builtin fastpaths (Torque/CSA): src/builtins/array*.tq (array.tq, array-helpers / array-slice/splice/etc.), src/builtins/builtins-array.cc/.tq generated files. (IDs: BUILTIN:*)
- Compiler lowering & feedback: src/compiler/{access-info.*,js-create-lowering*,js-native-context-specialization*,js-call-reducer*,simplified-lowering*} — AccessInfo/AccessInfoFactory 
and many lowering passes that handle ElementsKind, bounds/hole checks and TransitionElementsKind op lowering. (IDs: COMPILER:*)
- Deopt/feedback vector, guard locations: feedback slot definitions in builtins/ic.tq / interpreter bytecode generation, IC::OnFeedbackChanged and runtime misses (ic/ic.cc, 
builtins/builtins-handler-gen.cc), and deopt-related code in deoptimizer/ and compiler guard lowering code. (IDs: DEOPT:*)

If you want, I can now expand any individual ID (open file, show function body, trace call-sites, or gather cross-references).

---

### 2. Task outcome (extremely detailed version):

Below is a structured inventory, grouped per subsection (a)-(f). Each item: |id, file path, symbol/function/class, brief note]. I prioritized the canonical/most current locations: C++ 
sources in src/objects, src/ic, CSA in src/codegen, Torque under src/builtins/*.tq and generated builtins in src/builtins.

Note: "CSA" = CodeStubAssembler helpers (codegen/*); "Torque" = src/builtins/*.tq (Torque definitions); Where functions have multiple overloads / helpers I included main entry and key 
helpers.

(a) Elements operations: TransitionElementsKind, EnsureCapacity / GrowElementsCapacity, CopyElements, SetLength, helpers (C++ and CSA/Torque)

- ELEM-001, src/objects/elements.cc, ElementsAccessorBase::TransitionElementsKindImpl / TransitionElementsKind / BasicGrowCapacityAndConvertImpl / GrowCapacityAndConvertImpl
  - Core C++ implementations for element-kind transitions and capacity grow+convert. Implements conversion path when elements kinds change (double<->object, smi->double etc.), and calls 
JSObject::GetElementsTransitionMap / ConvertElementsWithCapacity.
- ELEM-002, src/objects/elements.cc, ElementsAccessorBase::SetLengthImpl / ElementsAccessor::SetLength dispatch
  - Per-accessor SetLengthImpl logic; common algorithm for trimming/expanding backing store, calls GrowCapacityAndConvertImpl when expanding beyond capacity.
- ELEM-003, src/objects/elements.cc, CopyElementsImpl family (CopyObjectToObjectElements, CopyDoubleToObjectElements, CopyDoubleToDoubleElements, CopySmiToDoubleElements, 
CopyPackedSmiToDoubleElements, CopyDictionaryToObjectElements, etc.)
  - All concrete copy implementations (object/object, double/object, double/double, dictionary -> objects). Used by various ElementsAccessor::CopyElementsImpl specializations.
- ELEM-004, src/objects/elements.h, ElementsAccessor class hierarchy & virtual methods
  - Declaration of ElementsAccessor and virtual entry points (CopyElements, SetLength, GrowCapacity, TransitionElementsKind, etc.)
- ELEM-005, src/objects/elements-kind.h / elements-kind.cc, GetNextTransitionElementsKind, elements-kind mapping utilities
  - Helpers to compute next elements kind in transition sequences etc.
- ELEM-006, src/objects/js-objects.cc, JSObject::TransitionElementsKind(DirectHandle<JSObject>, ElementsKind)
  - Public API to transition an object to target elements kind; orchestrates map updates / elements conversion.
- ELEM-007, src/objects/js-objects-inl.h, JSObject inline utilities (GetElementsKind, GetElementsAccessor, EnsureWritableFastElements usage)
  - Inline helpers reading elements kind and dispatching to appropriate ElementsAccessor.
- ELEM-008, src/codegen/code-stub-assembler.h / src/codegen/code-stub-assembler.cc, CodeStubAssembler::TryGrowElementsCapacity, GrowElementsCapacity, PossiblyGrowElementsCapacity, 
CopyElements, TransitionElementsKind
  - CSA (C++ runtime assembler) helpers used by builtins / stubs to grow/copy/transition elements in generated code paths. Key for fast path stubs in builtins and IC stubs.
  - Specific functions:
    - TryGrowElementsCapacity(...) — attempts to grow and returns new elements pointer or fails.
    - GrowElementsCapacity(...) — allocate new elements and copy, used in runtime stubs.
    - CopyElements(ElementsKind, dst, dst_index, source, src_index, size) — CSA-level fast copy (memcpy where safe).
    - TransitionElementsKind(TNode<JSObject>, TNode<Map> map, ...) — emits runtime call/transition.
- ELEM-009, src/builtins/base.tq, TransitionElementsKind (Torque macro) and TransitionElementsKindWithKind (extern runtime)
  - Torque-level declarations / macros to call transition helpers from builtins logic. Also constants like kMaxCopyElements for CopyElements limits.
- ELEM-010, src/builtins/builtins-handler-gen.cc, HandlerBuiltinsAssembler::DispatchForElementsKindTransition / TransitionElementsKind usage
  - Generated handlers that invoke TransitionElementsKind from stubs and handle miss paths.
- ELEM-011, src/objects/fixed-array-inl.h & src/objects/fixed-array.h, FixedArray::CopyElements and FixedDoubleArray copy APIs
  - Low-level copy loops used by higher-level CopyElements calls.
- ELEM-012, src/objects/js-array.h / src/objects/objects.cc, JSObject::NewElementsCapacity / JSObject::EnsureWritableFastElements / UpdateNoElementsProtectorOnSetLength
  - Helpers used by SetLength/grow logic to compute new capacities and update protectors.

(b) Arrays core: JSArray::SetLength and helpers; elements accessors for JSArray/JSObject touching elements backing store, length updates, capacity growth

- JSARR-001, src/objects/objects.cc, Maybe<bool> JSArray::SetLength(DirectHandle<JSArray> array, uint32_t length)
  - High-level JSArray::SetLength entry; dispatches to array->GetElementsAccessor()->SetLength.
- JSARR-002, src/objects/elements.cc, ElementsAccessorBase::SetLengthImpl (see ELEM-002)
  - The per-accessor SetLengthImpl default logic for fast elements kinds; performs holeing, trim/grow, transitions.
- JSARR-003, src/objects/js-objects.cc, JSObject::TransitionElementsKind (detailed) and JSObject::SetMapAndElements
  - Low-level migration helper for map + elements updates; used during transition/grow.
- JSARR-004, src/objects/js-objects-inl.h, Inline macros: GetElementsKind, GetElementsAccessor(), EnsureWritableFastElements, NewElementsCapacity
  - Inline accessors used throughout runtime for quick checks and to branch between fast/dictionary modes.
- JSARR-005, src/objects/fixed-array.h / fixed-array-inl.h, FixedArray::FillWithHoles / RightTrimArray / LeftTrimFixedArray (heap trimming)
  - Backing store manipulation used by SetLength and MoveElements.
- JSARR-006, src/objects/allocation-site-inl.h, AllocationSite::SetElementsKind / UpdateAllocationSite logic
  - AllocationSite interactions when transitioning elements kind for array literal optimizations.
- JSARR-007, src/builtins/builtins-array.cc and builtins/builtins-array-gen.cc, JSArray builtins (push/pop/shift/unshift/splice wrappers call accessors)
  - C++ and generated wrappers that call the ElementsAccessor APIs for array ops; include fast-path checks and SetLength calls.
- JSARR-008, src/codegen/code-stub-assembler.cc/h, ArrayListSetLength implementation (CSA helper)
  - CSA helper that updates length for ArrayList used in builtins.

(c) Inline caches: KeyedStoreIC / KeyedLoadIC, stub state transitions, feedback collection for keyed accesses (elements-kind and KeyedStoreMode), Runtime/TF handlers

- IC-001, src/ic/ic.h, class IC and LoadIC / StoreIC / KeyedLoadIC / KeyedStoreIC declarations
  - Core IC class hierarchy, feedback tracking, slot management, OnFeedbackChanged.
- IC-002, src/ic/ic.cc, LoadIC::Load / KeyedLoadIC::Load / KeyedLoadIC::UpdateLoadElement / KeyedLoadIC::LoadElementPolymorphicHandlers / ComputeHandler / UpdateCaches
  - IC runtime logic to compute handlers, update caches, transitions between mono/poly/mega states; LoadElement handler selection for elements loads.
- IC-003, src/ic/accessor-assembler.cc / ic/accessor-assembler.h, AccessorAssembler::KeyedLoadIC / KeyedStoreIC / StoreIC / GenerateKeyedLoadIC / GenerateKeyedStoreIC and 
KeyedLoadICGeneric / KeyedStoreIC logic
  - CSA-generated (handler) assembler that emits the low-level stub code for keyed load/store ICs; emits the sequences that try monomorphic, polymorphic, megamorphic stubs, and tail-call
to runtime miss.
  - Key places:
    - KeyedLoadIC(...) (emits try-polymorphic & megamorphic paths)
    - KeyedStoreIC(...) (emits transition-handling, find candidate store transitions, call TransitionElementsKind when needed)
    - KeyedLoadICGeneric, KeyedStoreICGeneric: generic slow paths
- IC-004, src/ic/keyed-store-generic.cc / keyed-store-generic.h, KeyedStoreGenericAssembler::FindCandidateStoreICTransitionMapHandler, StoreIC_NoFeedbackGenerator
  - Logic to find transition maps for store operations (when storing at index may need to transition elements kind), and code-generator for store IC no-feedback stub.
- IC-005, src/builtins/builtins-ic-gen.cc & src/builtins/builtins-handler-gen.cc, Builtins::Generate_KeyedLoadIC / Generate_KeyedStoreIC / KeyedLoadIC_Megamorphic / 
KeyedStoreIC_Megamorphic / trampolines
  - Generated builtin entry points for ICs; these are referenced by interpreter and baseline stubs.
- IC-006, src/builtins/ic.tq, torque macros for feedback vector slot handling (LoadFeedbackVectorSlot / StoreFeedbackVectorSlot / ReportFeedbackUpdate)
  - Torque helpers used by generated stubs to read/update feedback vector slot states (e.g., monomorphic->polymorphic->megamorphic sentinel).
- IC-007, src/interpreter/interpreter-generator.cc / interpreter/interpreter-assembler.cc, interpreter calls to KeyedLoadIC / KeyedStoreIC (CallBuiltin/Builtin::kKeyedLoadIC etc.), 
LoadFeedbackVectorSlot usage
  - Places where the interpreter bytecode emits calls into the KeyedLoad/Store IC builtins and provides the feedback vector slot.
- IC-008, src/runtime/runtime-array.cc, RUNTIME_FUNCTION(Runtime_TransitionElementsKind) and Runtime_KeyedStoreIC_Miss, Runtime_KeyedLoadIC_Miss
  - Runtime functions that IC builtin tail-call to on miss or transition.
- IC-009, src/ic/handler-configuration-inl.h, handler mapping to concrete generated builtin code (e.g., KeyedStoreIC_SloppyArguments_* builtins)
  - Small mapping file connecting element-kind/flags to builtin handlers.

Relevant notes on IC state transitions:
- IC::UpdateCaches sets handlers based on lookup result and number of distinct maps encountered -> transitions from uninitialized -> monomorphic -> polymorphic -> megamorphic (often 
represented in feedback vector by specific sentinel objects).
- FeedbackVector slots (KeyedLoadIC / KeyedStoreIC slots) store weak references or handler code, builtins/ic.tq provides access.

(d) Builtins fast paths: ArrayPrototypePush/Pop/Slice/Splice/Concat/From/Spread (Torque/CSA definitions and generated C++ entry points)

- BUILTIN-001, src/builtins/array.tq, builtins/array.tq (top-level) — macro and builtin definitions for Array.prototype functions and their fast-paths
  - Contains Torque implementations, type-specialized macros, and helper macros for elements kinds.
- BUILTIN-002, src/builtins/array-slice.tq, array-splice.tq, array-to-spliced.tq, array-to-reversed.tq, array-to-sorted.tq, array-join.tq, array-copy-like builtins
  - Implementations of slice/splice/concat/shift/unshift/push/pop in Torque; include fast-path checks for IsFastPackedElementsKind and branch to Slow (Runtime) otherwise.
- BUILTIN-003, src/builtins/array-from.tq and array-of.tq, array-spread behavior and internal iteration – Torque implementations that call CopyElements/TypedArrayCopyElements where 
possible.
- BUILTIN-004, src/builtins/array-*.tq generate C++ builtins: builtins/*-gen.cc and builtins/builtins-array-gen.cc (generated).
  - See src/builtins/builtins-array-gen.cc + src/builtins/builtins-array.cc which use CSA to call ElementsAccessor methods. Generated CSA wrappers will call e.g., CopyElements(kind, 
copy, ...).
- BUILTIN-005, src/builtins/builtins-array.cc, C++ glue that calls ElementsAccessor methods for push/pop/splice and uses JSArray::SetLength and accessor-specific functions
  - Example: calls array->GetElementsAccessor()->Pop/Push/Shift/Unshift and JSArray::SetLength after modifications.
- BUILTIN-006, src/codegen/code-stub-assembler.cc/h, CSA helpers used inside builtins (CopyElements, PossiblyGrowElementsCapacity etc.), used by generated builtins to implement 
fast-paths.
- BUILTIN-007, src/objects/elements.cc, comments referencing builtins that call into CopyElements (e.g., array concat uses ElementsAccessor::Concat).
- BUILTIN-008, src/builtins/builtins-handler-gen.cc, HandlerBuiltinsAssembler where builtins branch to Runtime misses (TailCallRuntime(Runtime::kKeyedStoreIC_Miss ...) — shows where fast
path guards branch to slow-path runtime.
- Key fast-path guard patterns across Torque builtins:
  - Check IsFastPackedElementsKind or IsFastElementsKind (via GetElementsKind)
  - Check index within capacity and holeyness (IsHoleyElementsKind)
  - Ensure writable elements (EnsureWritableFastElements)
  - If typed arrays involved, use TypedArrayCopyElements or try fast number copy path, else goto Slow / Runtime.

(e) Compiler lowering: AccessInfo/AccessInfoFactory, JSCreateLowering, JSNativeContextSpecialization, JSCallReducer, JS(Load|Store)Indexed lowering, SimplifiedLowering logic related to 
ElementsKind, bounds/hole checks

- COMPILER-001, src/compiler/access-info.h / access-info.cc
  - AccessInfo structures representing access locations/semantics used by lowering and codegen, used to decide if an access can be lowered to a fast element access.
- COMPILER-002, src/compiler/access-builder.cc/h
  - Builds AccessInfo objects given high-level JS property access patterns including element loads/stores.
- COMPILER-003, src/compiler/js-create-lowering.cc / js-create-lowering.h
  - Lowering related to array/typed-array creation; picks appropriate ElementsKind for allocations.
- COMPILER-004, src/compiler/js-native-context-specialization.cc / .h
  - Adds optimizations for specialized contexts; contains code that creates TransitionElementsKind or TransitionElementsKindOrCheckMap nodes in the graph (see mention earlier).
- COMPILER-005, src/compiler/js-call-reducer.cc / js-call-reducer.h
  - Implements reductions for array builtins and may implement fast-path JSArray->native code transformations; references to JSArray::kMaxCopyElements and checks for elements_kind; 
contains BuildAppendJSArray etc.
- COMPILER-006, src/compiler/js-typed-lowering.cc / js-typed-lowering.h and js-intrinsic-lowering / js-generic-lowering
  - Lowering for typed array ops and specialized array builtins, including checks on elements kind and typed array element types.
- COMPILER-007, src/compiler/simplified-lowering.cc / simplified-lowering.h / simplified-operator.cc
  - Simplified operators include TransitionElementsKind and TransitionElementsKindOrCheckMap (IrOpcode definitions) for the compiler IR; the lowering emits runtime calls to transition 
where required.
- COMPILER-008, src/compiler/typed-optimization.cc / typed-optimization.h & compiler/typed-optimization.cc
  - Reduction pass for typed optimizations including special-case TransitionElementsKindOrCheckMap opcode.
- COMPILER-009, src/compiler/js-graph.h / js-graph.cc / js-operator.h
  - Graph builder helpers for JS(Load|Store)Indexed lowering; helpers to read map->elements_kind, bounds checks, convert holes to undefined, etc.
- COMPILER-010, src/compiler/js-call-reducer.cc (again) — specific lowering for array builtins (e.g., array push) to inline the fast path; uses AccessBuilder::ForFixedArrayElement with 
GetHoleyElementsKind(kind) etc.

(f) Deopt/feedback: deopt guards for elements kind and bounds; feedback vector slot kinds for keyed loads/stores; transitions that update/invalidate IC state; map stability assumptions

- DEOPT-001, src/ic/ic.h / ic.cc, IC::OnFeedbackChanged / IC::ComputeHandler / UpdateCaches
  - Where IC feedback vector is updated, including TraceFeedbackChange; this is the canonical place where IC transitions happen and feedback vector slots change to 
monomorphic/polymorphic/megamorphic.
- DEOPT-002, src/builtins/ic.tq, LoadFeedbackVectorSlot / StoreFeedbackVectorSlot / ReportFeedbackUpdate
  - Torque helpers used to read/write/update feedback vectors from generated builtins which may trigger state changes.
- DEOPT-003, src/interpreter/interpreter-generator.cc, LoadFeedbackVector / LoadFeedbackVectorSlot usage and bytecode feedback slot creation (bytecode generator supplies feedback slots)
  - Interpreter side that supplies the feedback vector and slot index for loads/stores/Keyed ops.
- DEOPT-004, src/codegen/code-stub-assembler.cc, CallRuntime_TransitionElementsKind and CallRuntime_* used by maglev/turboshaft lowering
  - Where stubs will call into runtime to perform transitions; runtime transition may invalidate optimized code by changing maps / writing to protectors.
- DEOPT-005, src/objects/js-objects.cc / js-objects-inl.h, JSObject::MigrateToMap / SetMapAndElements & UpdateNoElementsProtectorOnSetLength
  - When elements-kind transitions happen or map migrates, code may call UpdateNoElementsProtectorOnSetLength to invalidate optimizations (e.g., when prototype array prototype changed).
- DEOPT-006, src/deoptimizer/*, deoptimizer machinery (frame translation builder) that will materialize feedback vectors and handle deopts when guards fail.
- DEOPT-007, src/compiler/load-elimination.cc / simplified-lowering.cc / typed-optimization.cc, compiler passes that assume map stability and create guards which may deopt if maps or 
elements kind changes (TransitionElementsKind or TransitionElementsKindOrCheckMap nodes).
- DEOPT-008, src/builtins/builtins-handler-gen.cc and builtins/builtins-ic-gen.cc, builtins that tail-call Runtime::kKeyedStoreIC_Miss / Runtime::kKeyedLoadIC_Miss when fastpath fails — 
these ensure feedback is updated and code falls back to runtime which may update the IC state.

Examples / Representative implementations to inspect (quick pointers):
- src/objects/elements.cc — ElementsAccessor hierarchy and all CopyElements / Grow / SetLength logic. (ELEM-001..003)
- src/objects/js-objects.cc — JSObject::TransitionElementsKind implementation; map migration. (JSARR-003)
- src/codegen/code-stub-assembler.cc / .h — CSA helpers: TryGrowElementsCapacity, GrowElementsCapacity, CopyElements, PossiblyGrowElementsCapacity, TransitionElementsKind. (CSA-008 / 
BUILTIN-006)
- src/ic/accessor-assembler.cc / .h — IC generation; implementation of KeyedLoadIC/KeyedStoreIC sequences and feedback vector usage. (IC-003)
- src/ic/keyed-store-generic.cc — FindCandidateStoreICTransitionMapHandler logic and generic store handling. (IC-004)
- src/builtins/*.tq (array.tq, array-slice.tq, array-splice.tq, array-from.tq, typed-array.tq) — Torque builtins implementing fast-path checks and calls to CopyElements / 
TypedArrayCopyElements / TransitionElementsKind macros. (BUILTIN-001..003)
- src/builtins/builtins-handler-gen.cc — code that dispatches to runtime misses and elements-kind transition builtins. (ELEM-010 / IC-005)
- src/compiler/access-info.* and src/compiler/js-call-reducer.cc — lowering/frontend helpers assigning AccessInfo and lowering array builtin calls to fast paths. (COMPILER-001..005)
- src/ic/ic.h and src/ic/ic.cc — IC state mutations, feedback vector traces. (DEOPT-001)

---

Index of IDs (copyable):
- ELEM-001 .. ELEM-012: elements + CSA + Torque helpers
- JSARR-001 .. JSARR-008: JSArray / JSObject and array core
- IC-001 .. IC-009: Inline cache classes, assembler, generators and runtime miss handling
- BUILTIN-001 .. BUILTIN-008: Torque builtins and generated glue for array builtins
- COMPILER-001 .. COMPILER-010: Compiler lowering and AccessInfo pieces
- DEOPT-001 .. DEOPT-008: Deopt & feedback vector locations

If you want a narrower deep-dive, provide one or more IDs and I’ll open the exact files and show the relevant function bodies, call-sites, or flow (e.g., trace KeyedStoreIC path: 
interpreter bytecode -> KeyedStoreIC builtin -> accessor-assembler -> TryGrowElementsCapacity / TransitionElementsKind -> runtime miss).

---

### 3. Additional context (if relevant):

- Coverage completeness: I focused on the canonical areas under src/objects (elements handling), src/ic (inline caches & stub generation), src/builtins/*.tq (Torque builtins & generated 
code), src/codegen (CSA helpers), and src/compiler (lowering & AccessInfo). These are the key components for keyed element access, elements-kind transitions and IC feedback. Other 
related places that could be relevant for a deeper study:
  - src/runtime/runtime-array.cc & runtime/runtime-typedarray.cc — runtime handlers invoked by stubs (Runtime_TransitionElementsKind, Runtime_TypedArrayCopyElements).
  - src/baseline/* and src/interpreter/* — baseline/interpreter stub emission patterns and how they call IC builtins and supply feedback vectors (interpreter/interpreter-generator.cc 
showed many feedback loads).
  - src/deoptimizer/* — deopt translation and materialization of feedback vectors and frames when guards fail.
  - src/builtins/builtins-ic-gen.cc / builtins-handler-gen.cc — generated handlers for ICs; good to inspect for exact fast-path assembly.
  - src/maglev / src/turboshaft / src/turbofan — JIT pipelines also implement operations referring to TransitionElementsKind nodes (maglev IR had TransitionElementsKind op references in 
earlier search output).
- Terminology & patterns:
  - ElementsKind transitions often follow allowed sequences (smi -> double -> object or holey variations). Helpers like GetNextTransitionElementsKind and mapping tables are in 
objects/elements-kind.*.
  - Fast-paths in builtins/ICs usually attempt to operate directly on the backing store (FixedArray / FixedDoubleArray / ByteArray / TypedArray external memory) using CSA CopyElements / 
MoveElements and perform checks: elements kind, prototype no-elements protector, capacity bounds, typed-array detachment, and write barrier modes.
  - When fast-path fails, code usually tail-calls builtins or runtime misses (KeyedStoreIC_Miss / KeyedLoadIC_Miss / ElementsTransitionAndStoreIC_Miss), allowing runtime to update IC 
state and possibly perform elements-kind transitions via JSObject::TransitionElementsKind which may reconfigure maps and allocate new backing store.
- Next steps I can perform on any item:
  - Show a full function body (e.g., ElementsAccessorBase::SetLengthImpl) and annotate where capacity growth / trimming happens.
  - Trace call graph for KeyedStoreIC: interpreter -> builtin -> accessor assembler -> TryGrow / TransitionElementsKind -> runtime miss.
  - Extract all code locations that write to FeedbackVector slots for keyed operations (search builtins/ic.tq & generated stubs).
  - Produce a short sequence diagram for an array push that triggers elements-kind transition (Smi->Double->Object).

If you want me to open specific files and show the exact code snippet for any ID (or produce cross-references/call graph), reply with the IDs (e.g., "open ELEM-001 and IC-003") and I 
will expand them.
[Step 2: Duration 217.84 seconds| Input tokens: 10,030 | Output tokens: 2,668]
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ Step 3 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'V8Search' with arguments: {'task': 'Refresh Stage 1 inventory for current V8 main. Target region: Keyed array element access & elements-kind transitions. Produce       │
│ updated concrete loci with exact file paths and key functions/classes, grouped by:\n(a) Elements operations (TransitionElementsKind, EnsureCapacity/GrowElementsCapacity,              │
│ CopyElements, SetLength, helpers) across C++ and CSA/Torque.\n(b) Arrays core (JSArray::SetLength, elements accessors manipulating length/backing store/capacity growth).\n(c) Inline  │
│ caches (KeyedStoreIC/KeyedLoadIC, StoreIC/LoadIC if relevant), stub state transitions, generic stubs, feedback collection (elements-kind and KeyedStoreMode), runtime handlers.\n(d)   │
│ Builtins fast paths (ArrayPrototype Push/Pop/Slice/Splice/Concat/From/Spread) — Torque/CSA definitions and generated C++ entry points, with pointers to guard sites/slow-path          │
│ branches.\n(e) Compiler lowering (AccessInfo/AccessInfoFactory, JSCreateLowering, JSNativeContextSpecialization, JSCallReducer, JS(Load|Store)Indexed lowering, SimplifiedLowering     │
│ checks on ElementsKind, bounds/hole checks).\n(f) Deopt/feedback (guard locations for elements kind/bounds; feedback vector slot kinds for keyed loads/stores; transitions that        │
│ update/invalidate IC state; map stability checks).\nReturn as structured list: [id, file path, symbol/function/class, brief note]. Prefer most-current paths: src/objects, src/ic,     │
│ src/builtins/*.tq and -gen.cc, src/codegen, src/compiler, src/runtime. Include both old/new names if recently renamed (e.g., EnsureCapacity vs GrowElementsCapacity).'}                │
╰────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────── New run - V8Search ──────────────────────────────────────────────────────────────────────────────────╮
│                                                                                                                                                                                        │
│ You're a helpful agent named 'V8Search'.                                                                                                                                               │
│ You have been submitted this task by your manager.                                                                                                                                     │
│ ---                                                                                                                                                                                    │
│ Task:                                                                                                                                                                                  │
│ Refresh Stage 1 inventory for current V8 main. Target region: Keyed array element access & elements-kind transitions. Produce updated concrete loci with exact file paths and key      │
│ functions/classes, grouped by:                                                                                                                                                         │
│ (a) Elements operations (TransitionElementsKind, EnsureCapacity/GrowElementsCapacity, CopyElements, SetLength, helpers) across C++ and CSA/Torque.                                     │
│ (b) Arrays core (JSArray::SetLength, elements accessors manipulating length/backing store/capacity growth).                                                                            │
│ (c) Inline caches (KeyedStoreIC/KeyedLoadIC, StoreIC/LoadIC if relevant), stub state transitions, generic stubs, feedback collection (elements-kind and KeyedStoreMode), runtime       │
│ handlers.                                                                                                                                                                              │
│ (d) Builtins fast paths (ArrayPrototype Push/Pop/Slice/Splice/Concat/From/Spread) — Torque/CSA definitions and generated C++ entry points, with pointers to guard sites/slow-path      │
│ branches.                                                                                                                                                                              │
│ (e) Compiler lowering (AccessInfo/AccessInfoFactory, JSCreateLowering, JSNativeContextSpecialization, JSCallReducer, JS(Load|Store)Indexed lowering, SimplifiedLowering checks on      │
│ ElementsKind, bounds/hole checks).                                                                                                                                                     │
│ (f) Deopt/feedback (guard locations for elements kind/bounds; feedback vector slot kinds for keyed loads/stores; transitions that update/invalidate IC state; map stability checks).   │
│ Return as structured list: [id, file path, symbol/function/class, brief note\]. Prefer most-current paths: src/objects, src/ic, src/builtins/*.tq and -gen.cc, src/codegen,            │
│ src/compiler, src/runtime. Include both old/new names if recently renamed (e.g., EnsureCapacity vs GrowElementsCapacity).                                                              │
│ ---                                                                                                                                                                                    │
│ You're helping your manager solve a wider task: so make sure to not provide a one-line answer, but give as much information as possible to give them a clear understanding of the      │
│ answer.                                                                                                                                                                                │
│                                                                                                                                                                                        │
│ Your final_answer WILL HAVE to contain these parts:                                                                                                                                    │
│ ### 1. Task outcome (short version):                                                                                                                                                   │
│ ### 2. Task outcome (extremely detailed version):                                                                                                                                      │
│ ### 3. Additional context (if relevant):                                                                                                                                               │
│                                                                                                                                                                                        │
│ Put all these in your final_answer tool, everything that you do not pass as an argument to final_answer will be lost.                                                                  │
│ And even if your task resolution is not successful, please return as much context as possible, so that your manager can act upon this feedback.                                        │
│                                                                                                                                                                                        │
╰─ LiteLLMModel - gpt-5-mini ────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ Step 1 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'tree' with arguments: {'options': '-L 3 src -I "third_party|.git|out*|test|docs|tools" -f'}                                                                             │
╰────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
Command: cd /Users/tarun/v8/v8/src && tree -L 3 src -I "third_party|.git|out*|test|docs|tools" -f | head -n 1000
Observations: src  |error opening dir]

0 directories, 0 files
[Step 1: Duration 3.35 seconds| Input tokens: 2,145 | Output tokens: 174]
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ Step 2 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'fuzzy_finder' with arguments: {'pattern': 'TransitionElementsKind|EnsureCapacity|GrowElementsCapacity|CopyElements|SetLength|ElementsKind', 'options': '--filter'}      │
╰────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
Command: cd /Users/tarun/v8/v8/src && rg --hidden --no-follow --no-ignore-vcs --files 2>/dev/null | fzf --filter 'TransitionElementsKind|EnsureCapacity|GrowElementsCapacity|CopyElements|SetLength|ElementsKind' | head -n 1000
Observations: None
[Step 2: Duration 8.11 seconds| Input tokens: 4,353 | Output tokens: 542]
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ Step 3 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'fuzzy_finder' with arguments: {'pattern': 'elements', 'options': '--filter'}                                                                                            │
╰────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
Command: cd /Users/tarun/v8/v8/src && rg --hidden --no-follow --no-ignore-vcs --files 2>/dev/null | fzf --filter 'elements' | head -n 1000
Observations: objects/elements.h
objects/elements.cc
objects/elements-inl.h
objects/elements-kind.h
objects/elements-kind.cc
builtins/promise-all-element-closure.tq
torque/implementation-visitor.h
torque/implementation-visitor.cc
[Step 3: Duration 2.58 seconds| Input tokens: 6,617 | Output tokens: 635]
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ Step 4 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'ripgrep' with arguments: {'pattern': 'TransitionElementsKind\\(|TransitionElementsKind', 'options': '-n --hidden --no-ignore-vcs'}                                      │
╰────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
Command: cd /Users/tarun/v8/v8/src && rg -n --hidden --no-ignore-vcs 'TransitionElementsKind\(|TransitionElementsKind' | head -n 1000
Observations: debug/debug-evaluate.cc:383:  V(TransitionElementsKind)              \
maglev/maglev-ir.h:287:  V(TransitionElementsKind)                         \
maglev/maglev-ir.h:361:  V(TransitionElementsKindOrCheckMap)         \
maglev/maglev-ir.h:9779:class TransitionElementsKind
maglev/maglev-ir.h:9780:    : public FixedInputValueNodeT<2, TransitionElementsKind> {
maglev/maglev-ir.h:9781:  using Base = FixedInputValueNodeT<2, TransitionElementsKind>;
maglev/maglev-ir.h:9784:  explicit TransitionElementsKind(
maglev/maglev-ir.h:9817:class TransitionElementsKindOrCheckMap
maglev/maglev-ir.h:9818:    : public FixedInputNodeT<2, TransitionElementsKindOrCheckMap> {
maglev/maglev-ir.h:9819:  using Base = FixedInputNodeT<2, TransitionElementsKindOrCheckMap>;
maglev/maglev-ir.h:9822:  explicit TransitionElementsKindOrCheckMap(
maglev/maglev-ir.cc:6528:void GenerateTransitionElementsKind(
maglev/maglev-ir.cc:6559:                __ CallRuntime(Runtime::kTransitionElementsKind);
maglev/maglev-ir.cc:6574:int TransitionElementsKind::MaxCallStackArgs() const {
maglev/maglev-ir.cc:6578:void TransitionElementsKind::SetValueLocationConstraints() {
maglev/maglev-ir.cc:6584:void TransitionElementsKind::GenerateCode(MaglevAssembler* masm,
maglev/maglev-ir.cc:6593:  GenerateTransitionElementsKind(masm, this, object, map,
maglev/maglev-ir.cc:6602:int TransitionElementsKindOrCheckMap::MaxCallStackArgs() const {
maglev/maglev-ir.cc:6606:void TransitionElementsKindOrCheckMap::SetValueLocationConstraints() {
maglev/maglev-ir.cc:6611:void TransitionElementsKindOrCheckMap::GenerateCode(
maglev/maglev-ir.cc:6620:  GenerateTransitionElementsKind(masm, this, object, map,
maglev/maglev-ir.cc:7449:void TransitionElementsKindOrCheckMap::PrintParams(
maglev/maglev-graph-builder.cc:4180:    case Opcode::kTransitionElementsKind:
maglev/maglev-graph-builder.cc:4755:ReduceResult MaglevGraphBuilder::BuildTransitionElementsKindOrCheckMap(
maglev/maglev-graph-builder.cc:4762:  // TransitionElementsKind doesn't happen in cases where we'd need to do
maglev/maglev-graph-builder.cc:4771:  AddNewNode<TransitionElementsKindOrCheckMap>(
maglev/maglev-graph-builder.cc:4824:ReduceResult MaglevGraphBuilder::BuildTransitionElementsKindAndCompareMaps(
maglev/maglev-graph-builder.cc:4836:  ValueNode* new_map = AddNewNode<TransitionElementsKind>(
maglev/maglev-graph-builder.cc:6493:      RETURN_IF_ABORT(BuildTransitionElementsKindOrCheckMap(
maglev/maglev-graph-builder.cc:6546:        map_check_result = BuildTransitionElementsKindOrCheckMap(
maglev/maglev-graph-builder.cc:6558:        map_check_result = BuildTransitionElementsKindAndCompareMaps(
maglev/maglev-graph-builder.h:2137:  ReduceResult BuildTransitionElementsKindOrCheckMap(
maglev/maglev-graph-builder.h:2146:  ReduceResult BuildTransitionElementsKindAndCompareMaps(
codegen/code-stub-assembler.cc:13546:void CodeStubAssembler::TransitionElementsKind(TNode<JSObject> object,
objects/allocation-site-inl.h:243:        JSObject::TransitionElementsKind(boilerplate, to_kind);
compiler/typed-optimization.cc:106:    case IrOpcode::kTransitionElementsKindOrCheckMap:
compiler/typed-optimization.cc:107:      return ReduceTransitionElementsKindOrCheckMap(node);
compiler/typed-optimization.cc:264:Reduction TypedOptimization::ReduceTransitionElementsKindOrCheckMap(
objects/js-objects-inl.h:169:      TransitionElementsKind(object, HOLEY_ELEMENTS);
objects/js-objects-inl.h:171:      TransitionElementsKind(object, PACKED_ELEMENTS);
objects/js-objects-inl.h:215:    TransitionElementsKind(object, target_kind);
objects/js-objects-inl.h:237:    TransitionElementsKind(object, HOLEY_DOUBLE_ELEMENTS);
objects/js-objects-inl.h:242:        TransitionElementsKind(object, HOLEY_DOUBLE_ELEMENTS);
objects/js-objects-inl.h:246:    TransitionElementsKind(object, PACKED_DOUBLE_ELEMENTS);
objects/elements-kind.cc:172:ElementsKind GetNextTransitionElementsKind(ElementsKind kind) {
ic/ic.cc:3242:    JSObject::TransitionElementsKind(Cast<JSObject>(object),
codegen/code-stub-assembler.h:3760:  void TransitionElementsKind(TNode<JSObject> object, TNode<Map> map,
runtime/runtime-object.cc:702:          JSObject::TransitionElementsKind(lookup_start_object, elements_kind);
objects/elements.h:110:  V8_WARN_UNUSED_RESULT virtual Maybe<bool> TransitionElementsKind(
compiler/js-native-context-specialization.cc:2339:      effect = graph()->NewNode(simplified()->TransitionElementsKindOrCheckMap(
compiler/js-native-context-specialization.cc:2378:            simplified()->TransitionElementsKind(ElementsTransition(
runtime/runtime.h:49:  F(TransitionElementsKind, 2, 1)      \
runtime/runtime.h:50:  F(TransitionElementsKindWithKind, 2, 1)
compiler/simplified-lowering.cc:4498:      case IrOpcode::kTransitionElementsKind: {
compiler/simplified-lowering.cc:4503:      case IrOpcode::kTransitionElementsKindOrCheckMap: {
objects/js-objects.cc:3494:      TransitionElementsKind(object, to_kind);
objects/js-objects.cc:4476:        JSObject::TransitionElementsKind(object, PACKED_ELEMENTS);
objects/js-objects.cc:4480:        JSObject::TransitionElementsKind(object, HOLEY_ELEMENTS);
objects/js-objects.cc:5495:void JSObject::TransitionElementsKind(DirectHandle<JSObject> object,
objects/js-objects.cc:5531:      // overflow, until all users of TransitionElementsKind can handle
compiler/simplified-operator.cc:410:  DCHECK_EQ(IrOpcode::kTransitionElementsKind, op->opcode());
compiler/simplified-operator.cc:416:  DCHECK_EQ(IrOpcode::kTransitionElementsKindOrCheckMap, op->opcode());
compiler/simplified-operator.cc:1988:const Operator* SimplifiedOperatorBuilder::TransitionElementsKind(
compiler/simplified-operator.cc:1991:      IrOpcode::kTransitionElementsKind,              // opcode
compiler/simplified-operator.cc:1993:      "TransitionElementsKind",                       // name
compiler/simplified-operator.cc:1998:const Operator* SimplifiedOperatorBuilder::TransitionElementsKindOrCheckMap(
compiler/simplified-operator.cc:2001:      IrOpcode::kTransitionElementsKindOrCheckMap,  // opcode
compiler/simplified-operator.cc:2003:      "TransitionElementsKindOrCheckMap",           // name
compiler/access-info.cc:388:    // TransitionElementsKind for a CheckMaps, avoiding mutation of the array.
compiler/load-elimination.h:324:  Reduction ReduceTransitionElementsKind(Node* node);
compiler/load-elimination.h:325:  Reduction ReduceTransitionElementsKindOrCheckMap(Node* node);
objects/map.cc:1116:  bool allow_store_transition = IsTransitionElementsKind(from_kind);
objects/map.cc:1134:  DCHECK(IsTransitionElementsKind(map->elements_kind()));
objects/map.cc:1146:        kind = GetNextTransitionElementsKind(kind);
runtime/runtime-array.cc:17:RUNTIME_FUNCTION(Runtime_TransitionElementsKind) {
runtime/runtime-array.cc:24:          ->TransitionElementsKind(object, to_map)
runtime/runtime-array.cc:26:    // TODO(victorgomes): EffectControlLinearizer::LowerTransitionElementsKind
runtime/runtime-array.cc:35:RUNTIME_FUNCTION(Runtime_TransitionElementsKindWithKind) {
runtime/runtime-array.cc:40:  JSObject::TransitionElementsKind(object, to_kind);
builtins/builtins-handler-gen.cc:164:          TransitionElementsKind(receiver, map, from_kind, to_kind, &miss);
compiler/node-properties.cc:447:      case IrOpcode::kTransitionElementsKindOrCheckMap: {
compiler/verifier.cc:1377:    case IrOpcode::kTransitionElementsKind:
compiler/verifier.cc:1381:    case IrOpcode::kTransitionElementsKindOrCheckMap:
compiler/turboshaft/maglev-early-lowering-reducer-inl.h:309:    TransitionElementsKind(object, map, transition_sources, transition_target,
compiler/turboshaft/maglev-early-lowering-reducer-inl.h:316:  void TransitionElementsKind(
compiler/turboshaft/maglev-early-lowering-reducer-inl.h:320:    // Turboshaft's TransitionElementsKind operation loads the map everytime, so
compiler/turboshaft/maglev-early-lowering-reducer-inl.h:333:          __ CallRuntime_TransitionElementsKind(
compiler/turboshaft/machine-lowering-reducer-inl.h:3175:  V<None> REDUCE(TransitionElementsKind)(V<HeapObject> object,
compiler/turboshaft/machine-lowering-reducer-inl.h:3192:          __ CallRuntime_TransitionElementsKind(
compiler/turboshaft/machine-lowering-reducer-inl.h:3201:  V<None> REDUCE(TransitionElementsKindOrCheckMap)(
compiler/turboshaft/machine-lowering-reducer-inl.h:3224:          __ CallRuntime_TransitionElementsKind(
compiler/turboshaft/machine-lowering-reducer-inl.h:3769:      __ CallRuntime_TransitionElementsKind(isolate_, __ NoContextConstant(),
objects/js-objects.h:695:  V8_EXPORT_PRIVATE static void TransitionElementsKind(
objects/lookup.cc:395:      JSObject::TransitionElementsKind(holder_obj, to);
objects/elements-kind.h:269:ElementsKind GetNextTransitionElementsKind(ElementsKind elements_kind);
objects/elements-kind.h:357:inline bool IsTransitionElementsKind(ElementsKind kind) {
objects/elements.cc:827:        JSObject::TransitionElementsKind(array, kind);
objects/elements.cc:942:  static Maybe<bool> TransitionElementsKindImpl(DirectHandle<JSObject> object,
objects/elements.cc:1031:  Maybe<bool> TransitionElementsKind(DirectHandle<JSObject> object,
objects/elements.cc:1033:    return Subclass::TransitionElementsKindImpl(object, map);
objects/elements.cc:2214:        JSObject::TransitionElementsKind(object, to_kind);
objects/elements.cc:2229:      JSObject::TransitionElementsKind(obj, GetHoleyElementsKind(kind));
objects/elements.cc:4766:  static Maybe<bool> TransitionElementsKindImpl(DirectHandle<JSObject> object,
objects/elements.cc:5553:        JSObject::TransitionElementsKind(array, elements_kind);
builtins/array-to-spliced.tq:93:  elementsKind = TransitionElementsKindForInsertionIfNeeded(
compiler/opcodes.h:547:  V(TransitionElementsKind)             \
compiler/opcodes.h:548:  V(TransitionElementsKindOrCheckMap)   \
builtins/builtins-array.cc:96:    JSObject::TransitionElementsKind(array, target_kind);
builtins/builtins-array.cc:237:    JSObject::TransitionElementsKind(array, PACKED_ELEMENTS);
builtins/base.tq:877:extern transitioning runtime TransitionElementsKindWithKind(
builtins/base.tq:1567:extern macro TransitionElementsKind(
builtins/array-splice.tq:126:transitioning macro TransitionElementsKindForInsertionIfNeeded(
builtins/array-splice.tq:154:    TransitionElementsKindWithKind(context, a, smiElementsKind);
builtins/array-splice.tq:183:  elementsKind = TransitionElementsKindForInsertionIfNeeded(
compiler/turbofan-typer.cc:1150:Type Typer::Visitor::TypeTransitionElementsKind(Node* node) { UNREACHABLE(); }
compiler/turbofan-typer.cc:1152:Type Typer::Visitor::TypeTransitionElementsKindOrCheckMap(Node* node) {
compiler/typed-optimization.h:71:  Reduction ReduceTransitionElementsKindOrCheckMap(Node* node);
compiler/load-elimination.cc:115:    case IrOpcode::kTransitionElementsKind:
compiler/load-elimination.cc:116:      return ReduceTransitionElementsKind(node);
compiler/load-elimination.cc:117:    case IrOpcode::kTransitionElementsKindOrCheckMap:
compiler/load-elimination.cc:118:      return ReduceTransitionElementsKindOrCheckMap(node);
compiler/load-elimination.cc:870:Reduction LoadElimination::ReduceTransitionElementsKind(Node* node) {
compiler/load-elimination.cc:910:Reduction LoadElimination::ReduceTransitionElementsKindOrCheckMap(Node* node) {
compiler/load-elimination.cc:1360:  struct TransitionElementsKindInfo {
compiler/load-elimination.cc:1367:  ZoneVector<TransitionElementsKindInfo> element_transitions_(&temp_zone);
compiler/load-elimination.cc:1395:          case IrOpcode::kTransitionElementsKind: {
compiler/load-elimination.cc:1405:          case IrOpcode::kTransitionElementsKindOrCheckMap: {
compiler/load-elimination.cc:1485:  for (const TransitionElementsKindInfo& t : element_transitions_) {
compiler/load-elimination.cc:1489:  for (const TransitionElementsKindInfo& t : element_transitions_) {
compiler/escape-analysis.cc:810:    case IrOpcode::kTransitionElementsKindOrCheckMap: {
compiler/simplified-operator.h:1121:  const Operator* TransitionElementsKind(ElementsTransition transition);
compiler/simplified-operator.h:1122:  const Operator* TransitionElementsKindOrCheckMap(
compiler/turboshaft/runtime-call-descriptors.h:214:  struct TransitionElementsKind : public Descriptor<TransitionElementsKind> {
compiler/turboshaft/runtime-call-descriptors.h:215:    static constexpr auto kFunction = Runtime::kTransitionElementsKind;
compiler/turboshaft/graph-builder.cc:2231:    case IrOpcode::kTransitionElementsKind:
compiler/turboshaft/graph-builder.cc:2232:      __ TransitionElementsKind(Map(node->InputAt(0)),
compiler/turboshaft/graph-builder.cc:2235:    case IrOpcode::kTransitionElementsKindOrCheckMap: {
compiler/turboshaft/graph-builder.cc:2239:      __ TransitionElementsKindOrCheckMap(
compiler/turboshaft/operations.h:274:  V(TransitionElementsKind)                     \
compiler/turboshaft/operations.h:275:  V(TransitionElementsKindOrCheckMap)           \
compiler/turboshaft/operations.h:6526:struct TransitionElementsKindOp
compiler/turboshaft/operations.h:6527:    : FixedArityOperationT<1, TransitionElementsKindOp> {
compiler/turboshaft/operations.h:6540:  TransitionElementsKindOp(OpIndex object, const ElementsTransition& transition)
compiler/turboshaft/operations.h:6547:struct TransitionElementsKindOrCheckMapOp
compiler/turboshaft/operations.h:6548:    : FixedArityOperationT<3, TransitionElementsKindOrCheckMapOp> {
compiler/turboshaft/operations.h:6561:  TransitionElementsKindOrCheckMapOp(
compiler/turboshaft/maglev-graph-building-phase.cc:2528:  maglev::ProcessResult Process(maglev::TransitionElementsKindOrCheckMap* node,
compiler/turboshaft/maglev-graph-building-phase.cc:2533:    __ TransitionElementsKindOrCheckMap(
compiler/turboshaft/maglev-graph-building-phase.cc:2540:  maglev::ProcessResult Process(maglev::TransitionElementsKind* node,
compiler/turboshaft/assembler.h:3925:  V<Object> CallRuntime_TransitionElementsKind(Isolate* isolate,
compiler/turboshaft/assembler.h:3929:    return CallRuntime<typename RuntimeCallDescriptor::TransitionElementsKind>(
compiler/turboshaft/assembler.h:4722:  void TransitionElementsKind(V<HeapObject> object,
compiler/turboshaft/assembler.h:4724:    ReduceIfReachableTransitionElementsKind(object, transition);
compiler/turboshaft/assembler.h:4726:  void TransitionElementsKindOrCheckMap(
compiler/turboshaft/assembler.h:4729:    ReduceIfReachableTransitionElementsKindOrCheckMap(object, map, frame_state,
[Step 4: Duration 3.69 seconds| Input tokens: 8,973 | Output tokens: 806]
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ Step 5 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'ripgrep' with arguments: {'pattern': 'EnsureCapacity|GrowElementsCapacity', 'options': '-n --hidden --no-ignore-vcs'}                                                   │
╰────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'ripgrep' with arguments: {'pattern': 'SetLength\\(|JSArray::SetLength|SetLength\\b', 'options': '-n --hidden --no-ignore-vcs'}                                          │
╰────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'ripgrep' with arguments: {'pattern': 'KeyedStoreIC|KeyedLoadIC|KeyedStoreMode', 'options': '-n --hidden --no-ignore-vcs'}                                               │
╰────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'ripgrep' with arguments: {'pattern': 'CopyElements\\(|CopyElements', 'options': '-n --hidden --no-ignore-vcs'}                                                          │
╰────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'ripgrep' with arguments: {'pattern': 'StoreIC|LoadIC\\b|FeedbackVectorSlotKind|kElementsKind', 'options': '-n --hidden --no-ignore-vcs'}                                │
╰────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'ripgrep' with arguments: {'pattern':                                                                                                                                    │
│ 'ArrayPrototype\\.push|ArrayPrototype\\.pop|ArrayPrototype\\.slice|ArrayPrototype\\.splice|ArrayPrototype\\.concat|ArrayFrom|Array.prototype\\.splice|Array\\.from|SpreadElement',     │
│ 'options': '-n --hidden --no-ignore-vcs'}                                                                                                                                              │
╰────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'ripgrep' with arguments: {'pattern':                                                                                                                                    │
│ 'AccessInfo|AccessInfoFactory|JSCreateLowering|JSNativeContextSpecialization|JSCallReducer|LoadIndexed|StoreIndexed|SimplifiedLowering', 'options': '-n --hidden --no-ignore-vcs'}     │
╰────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'ripgrep' with arguments: {'pattern': 'TransitionElementsKindWithKind|Runtime_TransitionElementsKind|kTransitionElementsKind|TransitionElementsKindWithKind', 'options': │
│ '-n --hidden --no-ignore-vcs'}                                                                                                                                                         │
╰────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
Command: cd /Users/tarun/v8/v8/src && rg -n --hidden --no-ignore-vcs 'EnsureCapacity|GrowElementsCapacity' | head -n 1000
Observations: objects/string-table.h:97:  Data* EnsureCapacity(PtrComprCageBase cage_base, int additional_elements);
objects/ordered-hash-table.cc:71:OrderedHashTable<Derived, entrysize>::EnsureCapacityForAdding(
objects/ordered-hash-table.cc:196:      OrderedHashSet::EnsureCapacityForAdding(isolate, table);
objects/ordered-hash-table.cc:404:      OrderedHashMap::EnsureCapacityForAdding(isolate, table);
objects/ordered-hash-table.cc:473:      OrderedNameDictionary::EnsureCapacityForAdding(isolate, table);
objects/ordered-hash-table.cc:585:OrderedHashTable<OrderedHashSet, 1>::EnsureCapacityForAdding(
objects/ordered-hash-table.cc:610:OrderedHashTable<OrderedHashMap, 2>::EnsureCapacityForAdding(
objects/ordered-hash-table.cc:639:OrderedHashTable<OrderedNameDictionary, 3>::EnsureCapacityForAdding(
codegen/code-stub-assembler.cc:3961:void CodeStubAssembler::PossiblyGrowElementsCapacity(
codegen/code-stub-assembler.cc:3972:  *var_elements = GrowElementsCapacity(array, var_elements->value(), kind, kind,
codegen/code-stub-assembler.cc:3995:  // FixedArray. In that case, PossiblyGrowElementsCapacity can fail even if no
codegen/code-stub-assembler.cc:4004:  PossiblyGrowElementsCapacity(kind, array, var_length.value(), &var_elements,
codegen/code-stub-assembler.cc:4067:  PossiblyGrowElementsCapacity(kind, array, var_length.value(), &var_elements,
codegen/code-stub-assembler.cc:6176:  Comment("TryGrowElementsCapacity");
codegen/code-stub-assembler.cc:6189:TNode<FixedArrayBase> CodeStubAssembler::TryGrowElementsCapacity(
codegen/code-stub-assembler.cc:6195:  return TryGrowElementsCapacity(object, elements, kind,
codegen/code-stub-assembler.cc:6201:TNode<FixedArrayBase> CodeStubAssembler::TryGrowElementsCapacity(
codegen/code-stub-assembler.cc:6206:  Comment("TryGrowElementsCapacity");
codegen/code-stub-assembler.cc:6218:  return GrowElementsCapacity(object, elements, kind, kind, capacity,
codegen/code-stub-assembler.cc:6223:TNode<FixedArrayBase> CodeStubAssembler::GrowElementsCapacity(
codegen/code-stub-assembler.cc:6229:  Comment("| GrowElementsCapacity");
codegen/code-stub-assembler.cc:6250:  Comment("] GrowElementsCapacity");
codegen/code-stub-assembler.cc:6254:template TNode<FixedArrayBase> CodeStubAssembler::GrowElementsCapacity<IntPtrT>(
codegen/code-stub-assembler.cc:13488:      TNode<FixedArrayBase> new_elements = TryGrowElementsCapacity(
codegen/code-stub-assembler.cc:13536:    TNode<FixedArrayBase> new_elements = GrowElementsCapacity(
codegen/code-stub-assembler.cc:13575:    GrowElementsCapacity(object, elements, from_kind, to_kind, array_length,
codegen/code-stub-assembler.h:2503:  TNode<FixedArrayBase> TryGrowElementsCapacity(TNode<HeapObject> object,
codegen/code-stub-assembler.h:2512:  TNode<FixedArrayBase> TryGrowElementsCapacity(TNode<HeapObject> object,
codegen/code-stub-assembler.h:2521:  TNode<FixedArrayBase> GrowElementsCapacity(
codegen/code-stub-assembler.h:2529:  void PossiblyGrowElementsCapacity(ElementsKind kind, TNode<HeapObject> array,
objects/objects.cc:5425:HandleType<Derived> HashTable<Derived, Shape>::EnsureCapacity(
objects/objects.cc:5512:  // EnsureCapacity will guarantee the hash table is never full.
objects/objects.cc:5536:  // EnsureCapacity will guarantee the hash table is never full.
objects/objects.cc:5556:    stringset = EnsureCapacity(isolate, stringset);
objects/objects.cc:5575:  table = EnsureCapacity(isolate, table);
objects/objects.cc:5737:  dictionary = Derived::EnsureCapacity(isolate, dictionary);
objects/objects.cc:6065:  table = Derived::EnsureCapacity(isolate, table);
objects/objects.cc:6176:  table = Derived::EnsureCapacity(isolate, table);
objects/objects.cc:6197:    set = EnsureCapacity(isolate, set);
objects/objects.cc:6662:  HashTable<DERIVED, SHAPE>::EnsureCapacity(Isolate*, Handle<DERIVED>, int,  \
objects/objects.cc:6665:  HashTable<DERIVED, SHAPE>::EnsureCapacity(LocalIsolate*, Handle<DERIVED>,  \
objects/objects.cc:6668:  HashTable<DERIVED, SHAPE>::EnsureCapacity(Isolate*, DirectHandle<DERIVED>, \
objects/objects.cc:6671:  HashTable<DERIVED, SHAPE>::EnsureCapacity(                                 \
strings/string-builder-inl.h:55:  EnsureCapacity(2);  // Subject slices are encoded with up to two smis.
strings/string-builder.cc:140:void FixedArrayBuilder::EnsureCapacity(Isolate* isolate, int elements) {
strings/string-builder.cc:190:void ReplacementStringBuilder::EnsureCapacity(int elements) {
strings/string-builder.cc:191:  array_builder_.EnsureCapacity(Isolate::FromHeap(heap_), elements);
strings/string-builder.cc:239:  EnsureCapacity(1);
strings/string-builder.h:21:  // EnsureCapacity is called.
strings/string-builder.h:25:  void EnsureCapacity(Isolate* isolate, int elements);
strings/string-builder.h:70:  void EnsureCapacity(int elements);
heap/new-spaces.h:208:  bool EnsureCapacity(size_t capacity);
base/numbers/bignum.h:91:  void EnsureCapacity(int size) {
snapshot/context-deserializer.cc:83:  void EnsureCapacity(size_t new_capacity) {
snapshot/context-deserializer.cc:116:    buffer.EnsureCapacity(size);
snapshot/context-deserializer.cc:157:    buffer.EnsureCapacity(size);
base/numbers/bignum.cc:30:  EnsureCapacity(1);
base/numbers/bignum.cc:42:  EnsureCapacity(needed_bigits);
base/numbers/bignum.cc:108:  EnsureCapacity(needed_bigits);
base/numbers/bignum.cc:159:  EnsureCapacity(1 + std::max(BigitLength(), other.BigitLength()) - exponent_);
base/numbers/bignum.cc:210:  EnsureCapacity(used_digits_ + 1);
base/numbers/bignum.cc:232:    EnsureCapacity(used_digits_ + 1);
base/numbers/bignum.cc:258:    EnsureCapacity(used_digits_ + 1);
base/numbers/bignum.cc:307:  EnsureCapacity(product_length);
base/numbers/bignum.cc:399:  EnsureCapacity(final_size / kBigitSize + 2);
base/numbers/bignum.cc:651:    EnsureCapacity(used_digits_ + zero_digits);
zone/zone-containers.h:187:    EnsureCapacity(ilist.size());
zone/zone-containers.h:201:    EnsureCapacity(new_size);
zone/zone-containers.h:209:    EnsureCapacity(new_size);
zone/zone-containers.h:226:      EnsureCapacity(new_size);
zone/zone-containers.h:241:  void reserve(size_t new_cap) { EnsureCapacity(new_cap); }
zone/zone-containers.h:398:  V8_INLINE void EnsureCapacity(size_t minimum) {
heap/new-spaces.cc:54:    EnsureCapacity(target_capacity_);
heap/new-spaces.cc:67:bool SemiSpace::EnsureCapacity(size_t capacity) {
heap/new-spaces.cc:99:  if (!EnsureCapacity(target_capacity_)) {
heap/new-spaces.cc:137:  if (!EnsureCapacity(new_capacity)) {
heap/new-spaces.cc:180:    EnsureCapacity(new_capacity);
runtime/runtime-collections.cc:26:      OrderedHashSet::EnsureCapacityForAdding(isolate, table);
runtime/runtime-collections.cc:40:      OrderedHashSet::EnsureCapacityForAdding(isolate, table);
runtime/runtime-collections.cc:85:      OrderedHashMap::EnsureCapacityForAdding(isolate, table);
runtime/runtime-collections.cc:102:      OrderedHashMap::EnsureCapacityForAdding(isolate, table);
builtins/growable-fixed-array.tq:9:    this.EnsureCapacity();
builtins/growable-fixed-array.tq:20:  macro EnsureCapacity(): void {
objects/js-struct.cc:467:  EnsureCapacity(isolate, 1);
objects/js-struct.cc:515:void SharedStructTypeRegistry::EnsureCapacity(PtrComprCageBase cage_base,
objects/string-forwarding-table.h:89:  BlockVector* EnsureCapacity(uint32_t block);
runtime/runtime-regexp.cc:1317:    builder.EnsureCapacity(isolate, kMaxBuilderEntriesPerRegExpMatch);
regexp/regexp-macro-assembler.cc:520:  Address new_stack_base = regexp_stack->EnsureCapacity(old_size * 2);
builtins/builtins-collections-gen.cc:2961:    // TODO(pwong): Port HashTable's Rehash() and EnsureCapacity() to CSA.
objects/contexts.cc:57:  names_table = names_table->EnsureCapacity(isolate, names_table, local_count);
objects/embedder-data-array.cc:28:DirectHandle<EmbedderDataArray> EmbedderDataArray::EnsureCapacity(
objects/embedder-data-array.h:36:  static DirectHandle<EmbedderDataArray> EnsureCapacity(
objects/hash-table.h:223:  V8_WARN_UNUSED_RESULT static HandleType<Derived> EnsureCapacity(
objects/hash-table.h:303:  HashTable<DERIVED, SHAPE>::EnsureCapacity(Isolate*, Handle<DERIVED>, int,  \
objects/hash-table.h:306:  HashTable<DERIVED, SHAPE>::EnsureCapacity(LocalIsolate*, Handle<DERIVED>,  \
objects/hash-table.h:310:      HashTable<DERIVED, SHAPE>::EnsureCapacity(                             \
objects/hash-table.h:314:      HashTable<DERIVED, SHAPE>::EnsureCapacity(                             \
objects/hash-table-inl.h:144:  // EnsureCapacity will guarantee the hash table is never full.
objects/hash-table-inl.h:310:  table = EnsureCapacity(isolate, table);
objects/ordered-hash-table.h:71:  static MaybeHandle<Derived> EnsureCapacityForAdding(Isolate* isolate,
objects/js-struct.h:107:  void EnsureCapacity(PtrComprCageBase cage_base, int additional_elements);
objects/string-table.cc:452:    Data* data = EnsureCapacity(isolate, 1);
objects/string-table.cc:500:StringTable::Data* StringTable::EnsureCapacity(PtrComprCageBase cage_base,
objects/string-table.cc:684:    Data* const data = EnsureCapacity(isolate, length);
objects/string-table.cc:706:    Data* const data = EnsureCapacity(isolate, 1);
objects/compilation-cache-table.cc:516:  return EnsureCapacity(isolate, cache);
objects/compilation-cache-table.cc:597:  cache = EnsureCapacity(isolate, cache);
objects/compilation-cache-table.cc:611:  cache = EnsureCapacity(isolate, cache);
objects/string-forwarding-table.cc:181:StringForwardingTable::BlockVector* StringForwardingTable::EnsureCapacity(
objects/string-forwarding-table.cc:217:  BlockVector* blocks = EnsureCapacity(block_index);
objects/string-forwarding-table.cc:246:  BlockVector* blocks = EnsureCapacity(block_index);
regexp/regexp-stack.h:80:  Address EnsureCapacity(size_t size);
regexp/regexp-stack.cc:34:    EnsureCapacity(thread_local_.memory_size_ + 1);
regexp/regexp-stack.cc:73:Address RegExpStack::EnsureCapacity(size_t size) {
builtins/builtins-internal-gen.cc:51:  elements = TryGrowElementsCapacity(object, elements, PACKED_DOUBLE_ELEMENTS,
builtins/builtins-internal-gen.cc:67:      TryGrowElementsCapacity(object, elements, PACKED_ELEMENTS, key, &runtime);
ic/keyed-store-generic.cc:329:      GrowElementsCapacity(receiver, elements, from_kind, to_kind, capacity,
ic/keyed-store-generic.cc:601:    // TODO(jkummerow): Use GrowElementsCapacity instead of bailing out.
api/api.cc:1077:  data = i::EmbedderDataArray::EnsureCapacity(i_isolate, data, index);
Command: cd /Users/tarun/v8/v8/src && rg -n --hidden --no-ignore-vcs 'StoreIC|LoadIC\b|FeedbackVectorSlotKind|kElementsKind' | head -n 1000
Observations: logging/runtime-call-stats.h:547:  V(KeyedStoreIC_ElementsTransitionAndStoreStub)  \
logging/runtime-call-stats.h:548:  V(KeyedStoreIC_KeyedStoreSloppyArgumentsStub)   \
logging/runtime-call-stats.h:549:  V(KeyedStoreIC_SlowStub)                        \
logging/runtime-call-stats.h:550:  V(KeyedStoreIC_StoreElementStub)                \
logging/runtime-call-stats.h:551:  V(KeyedStoreIC_StoreFastElementStub)            \
logging/runtime-call-stats.h:581:  V(StoreIC_HandlerCacheHit_Accessor)             \
logging/runtime-call-stats.h:582:  V(StoreIC_NonReceiver)                          \
logging/runtime-call-stats.h:583:  V(StoreIC_SlowStub)                             \
logging/runtime-call-stats.h:584:  V(StoreIC_StoreAccessorDH)                      \
logging/runtime-call-stats.h:585:  V(StoreIC_StoreAccessorOnPrototypeDH)           \
logging/runtime-call-stats.h:586:  V(StoreIC_StoreApiSetterOnPrototypeDH)          \
logging/runtime-call-stats.h:587:  V(StoreIC_StoreFieldDH)                         \
logging/runtime-call-stats.h:588:  V(StoreIC_StoreGlobalDH)                        \
logging/runtime-call-stats.h:589:  V(StoreIC_StoreGlobalTransitionDH)              \
logging/runtime-call-stats.h:590:  V(StoreIC_StoreInterceptorStub)                 \
logging/runtime-call-stats.h:591:  V(StoreIC_StoreNativeDataPropertyDH)            \
logging/runtime-call-stats.h:592:  V(StoreIC_StoreNativeDataPropertyOnPrototypeDH) \
logging/runtime-call-stats.h:593:  V(StoreIC_StoreNormalDH)                        \
logging/runtime-call-stats.h:594:  V(StoreIC_StoreTransitionDH)                    \
ic/accessor-assembler.cc:378:              // LoadIC case: the receiver is definitely not null or undefined.
ic/accessor-assembler.cc:1322:void AccessorAssembler::HandleStoreICNativeDataProperty(
ic/accessor-assembler.cc:1323:    const StoreICParameters* p, TNode<HeapObject> holder,
ic/accessor-assembler.cc:1335:void AccessorAssembler::HandleStoreICSmiHandlerJSSharedStructFieldCase(
ic/accessor-assembler.cc:1365:void AccessorAssembler::HandleStoreICHandlerCase(
ic/accessor-assembler.cc:1366:    const StoreICParameters* p, TNode<MaybeObject> handler, Label* miss,
ic/accessor-assembler.cc:1450:      HandleStoreICNativeDataProperty(p, CAST(holder), handler_word);
ic/accessor-assembler.cc:1453:      HandleStoreICSmiHandlerJSSharedStructFieldCase(p->context(), handler_word,
ic/accessor-assembler.cc:1458:      HandleStoreICSmiHandlerCase(handler_word, CAST(holder), p->value(), miss);
ic/accessor-assembler.cc:1490:          id = Runtime::kKeyedStoreIC_Slow;
ic/accessor-assembler.cc:1512:      HandleStoreICProtoHandler(p, CAST(strong_handler), &if_slow, miss,
ic/accessor-assembler.cc:1567:      HandleStoreICTransitionMapHandlerCase(p, map, miss,
ic/accessor-assembler.cc:1576:void AccessorAssembler::HandleStoreICTransitionMapHandlerCase(
ic/accessor-assembler.cc:1577:    const StoreICParameters* p, TNode<Map> transition_map, Label* miss,
ic/accessor-assembler.cc:1934:void AccessorAssembler::HandleStoreICProtoHandler(
ic/accessor-assembler.cc:1935:    const StoreICParameters* p, TNode<StoreHandler> handler, Label* slow,
ic/accessor-assembler.cc:1937:  Comment("HandleStoreICProtoHandler");
ic/accessor-assembler.cc:1941:    // Code sub-handlers are expected only in KeyedStoreICs.
ic/accessor-assembler.cc:2060:    HandleStoreICNativeDataProperty(p, holder, handler_word);
ic/accessor-assembler.cc:2113:void AccessorAssembler::HandleStoreToProxy(const StoreICParameters* p,
ic/accessor-assembler.cc:2147:void AccessorAssembler::HandleStoreICSmiHandlerCase(TNode<Word32T> handler_word,
ic/accessor-assembler.cc:3155:  // Must be kept in sync with LoadIC.
ic/accessor-assembler.cc:3202:    // Call into the stub that implements the non-inlined parts of LoadIC.
ic/accessor-assembler.cc:3211:    // Call into the stub that implements the non-inlined parts of LoadIC.
ic/accessor-assembler.cc:3227:void AccessorAssembler::LoadIC(const LoadICParameters* p) {
ic/accessor-assembler.cc:3273:    // Call into the stub that implements the non-inlined parts of LoadIC.
ic/accessor-assembler.cc:3599:void AccessorAssembler::KeyedLoadIC(const LoadICParameters* p,
ic/accessor-assembler.cc:3825:  // LoadIC handler logic below.
ic/accessor-assembler.cc:3856:void AccessorAssembler::StoreIC(const StoreICParameters* p) {
ic/accessor-assembler.cc:3878:    Comment("StoreIC_if_handler");
ic/accessor-assembler.cc:3879:    HandleStoreICHandlerCase(p, var_handler.value(), &miss,
ic/accessor-assembler.cc:3887:    Comment("StoreIC_try_polymorphic");
ic/accessor-assembler.cc:3904:    // TODO(v8:12548): refactor SetNamedIC as a subclass of StoreIC, which can
ic/accessor-assembler.cc:3907:                                         : Builtin::kStoreIC_NoFeedback;
ic/accessor-assembler.cc:3915:                                         : Runtime::kStoreIC_Miss;
ic/accessor-assembler.cc:3921:void AccessorAssembler::StoreGlobalIC(const StoreICParameters* pp) {
ic/accessor-assembler.cc:3956:      StoreICParameters p(
ic/accessor-assembler.cc:3960:          StoreICMode::kDefault);
ic/accessor-assembler.cc:3962:      HandleStoreICHandlerCase(&p, handler, &miss, ICMode::kGlobalIC);
ic/accessor-assembler.cc:4062:void AccessorAssembler::KeyedStoreIC(const StoreICParameters* p) {
ic/accessor-assembler.cc:4085:      Comment("KeyedStoreIC_if_handler");
ic/accessor-assembler.cc:4086:      HandleStoreICHandlerCase(p, var_handler.value(), &miss,
ic/accessor-assembler.cc:4094:      Comment("KeyedStoreIC_try_polymorphic");
ic/accessor-assembler.cc:4104:      Comment("KeyedStoreIC_try_megamorphic");
ic/accessor-assembler.cc:4111:      TailCallBuiltin(Builtin::kKeyedStoreIC_Megamorphic, p->context(),
ic/accessor-assembler.cc:4119:      Comment("KeyedStoreIC_try_polymorphic_name");
ic/accessor-assembler.cc:4132:    Comment("KeyedStoreIC_miss");
ic/accessor-assembler.cc:4133:    TailCallRuntime(Runtime::kKeyedStoreIC_Miss, p->context(), p->value(),
ic/accessor-assembler.cc:4138:void AccessorAssembler::DefineKeyedOwnIC(const StoreICParameters* p) {
ic/accessor-assembler.cc:4144:      // StoreICParameters flags and have builtins:kDefineKeyedOwnIC reusing
ic/accessor-assembler.cc:4181:      HandleStoreICHandlerCase(p, var_handler.value(), &miss,
ic/accessor-assembler.cc:4232:void AccessorAssembler::StoreInArrayLiteralIC(const StoreICParameters* p) {
ic/accessor-assembler.cc:4254:      // This is a stripped-down version of HandleStoreICHandlerCase.
ic/accessor-assembler.cc:4344:void AccessorAssembler::GenerateLoadIC() {
ic/accessor-assembler.cc:4354:  LoadIC(&p);
ic/accessor-assembler.cc:4446:  TailCallBuiltin(Builtin::kLoadIC, context, receiver, name, slot, vector);
ic/accessor-assembler.cc:4458:  TailCallBuiltin(Builtin::kLoadIC, context, receiver, name, slot, vector);
ic/accessor-assembler.cc:4662:void AccessorAssembler::GenerateKeyedLoadIC() {
ic/accessor-assembler.cc:4672:  KeyedLoadIC(&p, LoadAccessMode::kLoad);
ic/accessor-assembler.cc:4675:void AccessorAssembler::GenerateEnumeratedKeyedLoadIC() {
ic/accessor-assembler.cc:4689:  KeyedLoadIC(&p, LoadAccessMode::kLoad);
ic/accessor-assembler.cc:4714:  TailCallBuiltin(Builtin::kKeyedLoadIC, context, receiver, name, slot, vector);
ic/accessor-assembler.cc:4726:  TailCallBuiltin(Builtin::kKeyedLoadIC, context, receiver, name, slot, vector);
ic/accessor-assembler.cc:4740:  TailCallBuiltin(Builtin::kEnumeratedKeyedLoadIC, context, receiver, name,
ic/accessor-assembler.cc:4780:  StoreICParameters p(context, std::nullopt, name, value, flags, slot, vector,
ic/accessor-assembler.cc:4781:                      StoreICMode::kDefault);
ic/accessor-assembler.cc:4809:void AccessorAssembler::GenerateStoreIC() {
ic/accessor-assembler.cc:4820:  StoreICParameters p(context, receiver, name, value, flags, slot, vector,
ic/accessor-assembler.cc:4821:                      StoreICMode::kDefault);
ic/accessor-assembler.cc:4822:  StoreIC(&p);
ic/accessor-assembler.cc:4825:void AccessorAssembler::GenerateStoreIC_Megamorphic() {
ic/accessor-assembler.cc:4848:    StoreICParameters p(context, receiver, name, value, flags, slot, vector,
ic/accessor-assembler.cc:4849:                        StoreICMode::kDefault);
ic/accessor-assembler.cc:4850:    HandleStoreICHandlerCase(&p, var_handler.value(), &miss,
ic/accessor-assembler.cc:4856:    direct_exit.ReturnCallRuntime(Runtime::kStoreIC_Miss, context, value, slot,
ic/accessor-assembler.cc:4861:void AccessorAssembler::GenerateStoreICTrampoline() {
ic/accessor-assembler.cc:4871:  TailCallBuiltin(Builtin::kStoreIC, context, receiver, name, value, slot,
ic/accessor-assembler.cc:4875:void AccessorAssembler::GenerateStoreICTrampoline_Megamorphic() {
ic/accessor-assembler.cc:4885:  TailCallBuiltin(Builtin::kStoreIC_Megamorphic, context, receiver, name, value,
ic/accessor-assembler.cc:4889:void AccessorAssembler::GenerateStoreICBaseline() {
ic/accessor-assembler.cc:4899:  TailCallBuiltin(Builtin::kStoreIC, context, receiver, name, value, slot,
ic/accessor-assembler.cc:4914:  StoreICParameters p(context, receiver, name, value, flags, slot, vector,
ic/accessor-assembler.cc:4915:                      StoreICMode::kDefineNamedOwn);
ic/accessor-assembler.cc:4916:  // StoreIC is a generic helper than handle both set and define own
ic/accessor-assembler.cc:4918:  StoreIC(&p);
ic/accessor-assembler.cc:4949:void AccessorAssembler::GenerateKeyedStoreIC() {
ic/accessor-assembler.cc:4960:  StoreICParameters p(context, receiver, name, value, flags, slot, vector,
ic/accessor-assembler.cc:4961:                      StoreICMode::kDefault);
ic/accessor-assembler.cc:4962:  KeyedStoreIC(&p);
ic/accessor-assembler.cc:4965:void AccessorAssembler::GenerateKeyedStoreICTrampoline() {
ic/accessor-assembler.cc:4975:  TailCallBuiltin(Builtin::kKeyedStoreIC, context, receiver, name, value, slot,
ic/accessor-assembler.cc:4979:void AccessorAssembler::GenerateKeyedStoreICTrampoline_Megamorphic() {
ic/accessor-assembler.cc:4989:  TailCallBuiltin(Builtin::kKeyedStoreIC_Megamorphic, context, receiver, name,
ic/accessor-assembler.cc:4993:void AccessorAssembler::GenerateKeyedStoreICBaseline() {
ic/accessor-assembler.cc:5003:  TailCallBuiltin(Builtin::kKeyedStoreIC, context, receiver, name, value, slot,
ic/accessor-assembler.cc:5018:  StoreICParameters p(context, receiver, name, value, flags, slot, vector,
ic/accessor-assembler.cc:5019:                      StoreICMode::kDefineKeyedOwn);
ic/accessor-assembler.cc:5064:  StoreICParameters p(context, array, index, value, flags, slot, vector,
ic/accessor-assembler.cc:5065:                      StoreICMode::kDefault);
ic/accessor-assembler.cc:5313:  KeyedLoadIC(&p, LoadAccessMode::kHas);
ic/handler-configuration-inl.h:156:      return BUILTIN_CODE(isolate, KeyedStoreIC_SloppyArguments_InBounds);
ic/handler-configuration-inl.h:159:          isolate, KeyedStoreIC_SloppyArguments_NoTransitionGrowAndHandleCOW);
ic/handler-configuration-inl.h:163:          KeyedStoreIC_SloppyArguments_NoTransitionIgnoreTypedArrayOOB);
ic/handler-configuration-inl.h:166:                          KeyedStoreIC_SloppyArguments_NoTransitionHandleCOW);
ic/accessor-assembler.h:28:  void GenerateLoadIC();
ic/accessor-assembler.h:38:  void GenerateKeyedLoadIC();
ic/accessor-assembler.h:39:  void GenerateEnumeratedKeyedLoadIC();
ic/accessor-assembler.h:46:  void GenerateStoreIC();
ic/accessor-assembler.h:47:  void GenerateStoreIC_Megamorphic();
ic/accessor-assembler.h:48:  void GenerateStoreICTrampoline();
ic/accessor-assembler.h:49:  void GenerateStoreICTrampoline_Megamorphic();
ic/accessor-assembler.h:50:  void GenerateStoreICBaseline();
ic/accessor-assembler.h:76:  void GenerateKeyedStoreIC();
ic/accessor-assembler.h:77:  void GenerateKeyedStoreICTrampoline();
ic/accessor-assembler.h:78:  void GenerateKeyedStoreICTrampoline_Megamorphic();
ic/accessor-assembler.h:79:  void GenerateKeyedStoreICBaseline();
ic/accessor-assembler.h:221:  // Specialized LoadIC for inlined bytecode handler, hand-tuned to omit frame
ic/accessor-assembler.h:231:  enum class StoreICMode {
ic/accessor-assembler.h:237:  struct StoreICParameters {
ic/accessor-assembler.h:238:    StoreICParameters(TNode<Context> context,
ic/accessor-assembler.h:242:                      StoreICMode mode)
ic/accessor-assembler.h:266:      return mode_ == StoreICMode::kDefineNamedOwn;
ic/accessor-assembler.h:269:      return mode_ == StoreICMode::kDefineKeyedOwn;
ic/accessor-assembler.h:288:    StoreICMode mode_;
ic/accessor-assembler.h:294:  void HandleStoreICHandlerCase(
ic/accessor-assembler.h:295:      const StoreICParameters* p, TNode<MaybeObject> handler, Label* miss,
ic/accessor-assembler.h:304:  void HandleStoreICTransitionMapHandlerCase(const StoreICParameters* p,
ic/accessor-assembler.h:343:  // LoadIC contains the full LoadIC logic, while LoadIC_Noninlined contains
ic/accessor-assembler.h:345:  void LoadIC(const LoadICParameters* p);
ic/accessor-assembler.h:366:  void KeyedLoadIC(const LoadICParameters* p, LoadAccessMode access_mode);
ic/accessor-assembler.h:371:  void StoreIC(const StoreICParameters* p);
ic/accessor-assembler.h:372:  void StoreGlobalIC(const StoreICParameters* p);
ic/accessor-assembler.h:377:  void DefineKeyedOwnIC(const StoreICParameters* p);
ic/accessor-assembler.h:378:  void StoreInArrayLiteralIC(const StoreICParameters* p);
ic/accessor-assembler.h:413:  // LoadIC implementation.
ic/accessor-assembler.h:503:  // StoreIC implementation.
ic/accessor-assembler.h:505:  void HandleStoreICProtoHandler(const StoreICParameters* p,
ic/accessor-assembler.h:509:  void HandleStoreICSmiHandlerCase(TNode<Word32T> handler_word,
ic/accessor-assembler.h:512:  void HandleStoreICSmiHandlerJSSharedStructFieldCase(
ic/accessor-assembler.h:522:  void HandleStoreICNativeDataProperty(const StoreICParameters* p,
ic/accessor-assembler.h:526:  void HandleStoreToProxy(const StoreICParameters* p, TNode<JSProxy> proxy,
ic/keyed-store-generic.cc:25:  // chain to invoke setters. it's used by KeyedStoreIC and StoreIC to
ic/accessor-assembler.h:376:  void KeyedStoreIC(const StoreICParameters* p);
ic/keyed-store-generic.cc:110:                                const StoreICParameters* p,
ic/keyed-store-generic.cc:118:                                const StoreICParameters* p, Label* slow) {
ic/keyed-store-generic.cc:174:  TNode<Map> FindCandidateStoreICTransitionMapHandler(TNode<Map> map,
ic/keyed-store-generic.cc:224:void StoreICNoFeedbackGenerator::Generate(compiler::CodeAssemblerState* state) {
ic/keyed-store-generic.cc:226:  assembler.StoreIC_NoFeedback();
ic/keyed-store-generic.cc:235:  assembler.StoreIC_NoFeedback();
ic/keyed-store-generic.cc:800:TNode<Map> KeyedStoreGenericAssembler::FindCandidateStoreICTransitionMapHandler(
ic/keyed-store-generic.cc:867:    TNode<Uint16T> instance_type, const StoreICParameters* p,
ic/keyed-store-generic.cc:947:      TNode<Map> transition_map = FindCandidateStoreICTransitionMapHandler(
ic/keyed-store-generic.cc:955:      HandleStoreICTransitionMapHandlerCase(p, transition_map, slow, flags);
ic/keyed-store-generic.cc:1143:      HandleStoreICHandlerCase(p, var_handler.value(), &stub_cache_miss,
ic/keyed-store-generic.cc:1149:      TailCallRuntime(Runtime::kKeyedStoreIC_Miss, p->context(), p->value(),
ic/keyed-store-generic.cc:1188:    StoreICParameters p(context, receiver, var_unique.value(), value,
ic/keyed-store-generic.cc:1190:                        StoreICMode::kDefault);
ic/keyed-store-generic.cc:1264:void KeyedStoreGenericAssembler::StoreIC_NoFeedback() {
ic/keyed-store-generic.cc:1284:      StoreICParameters p(context, receiver, name, value, std::nullopt, {},
ic/keyed-store-generic.cc:1286:                          IsDefineNamedOwn() ? StoreICMode::kDefineNamedOwn
ic/keyed-store-generic.cc:1287:                                             : StoreICMode::kDefault);
ic/keyed-store-generic.cc:1296:                                      : Runtime::kStoreIC_Miss;
ic/keyed-store-generic.cc:1310:  StoreICParameters p(context, receiver, unique_name, value, std::nullopt, {},
ic/keyed-store-generic.cc:1311:                      UndefinedConstant(), StoreICMode::kDefault);
ic/ic.h:25:// IC is the base class for LoadIC, StoreIC, KeyedLoadIC, and KeyedStoreIC.
ic/ic.h:54:    return IsLoadIC() || IsLoadGlobalIC() || IsKeyedLoadIC();
ic/ic.h:58:           IsKeyedStoreIC() || IsStoreInArrayLiteralICKind(kind()) ||
ic/ic.h:123:  bool IsLoadIC() const { return IsLoadICKind(kind_); }
ic/ic.h:125:  bool IsKeyedLoadIC() const { return IsKeyedLoadICKind(kind_); }
ic/ic.h:132:  bool IsKeyedStoreIC() const { return IsKeyedStoreICKind(kind_); }
ic/ic.h:136:    return IsKeyedLoadIC() || IsKeyedStoreIC() || IsStoreInArrayLiteralIC() ||
ic/ic.h:184:class LoadIC : public IC {
ic/ic.h:186:  LoadIC(Isolate* isolate, Handle<FeedbackVector> vector, FeedbackSlot slot,
ic/ic.h:217:class LoadGlobalIC : public LoadIC {
ic/ic.h:221:      : LoadIC(isolate, vector, slot, kind) {}
ic/ic.h:227:class KeyedLoadIC : public LoadIC {
ic/ic.h:229:  KeyedLoadIC(Isolate* isolate, Handle<FeedbackVector> vector,
ic/ic.h:231:      : LoadIC(isolate, vector, slot, kind) {}
ic/ic.h:263:class StoreIC : public IC {
ic/ic.h:265:  StoreIC(Isolate* isolate, Handle<FeedbackVector> vector, FeedbackSlot slot,
ic/ic.h:291:class StoreGlobalIC : public StoreIC {
ic/ic.h:295:      : StoreIC(isolate, vector, slot, kind) {}
ic/ic.h:311:class KeyedStoreIC : public StoreIC {
ic/keyed-store-generic.cc:62:  void StoreIC_NoFeedback();
ic/ic.h:319:      : StoreIC(isolate, vector, slot, kind) {}
ic/ic.h:346:class StoreInArrayLiteralIC : public KeyedStoreIC {
ic/ic.h:350:      : KeyedStoreIC(isolate, vector, slot,
ic/keyed-store-generic.h:47:class StoreICNoFeedbackGenerator {
ic/ic.cc:134:  } else if (IsKeyedLoadIC()) {
ic/ic.cc:137:  } else if (IsKeyedStoreIC() || IsStoreInArrayLiteralIC() ||
ic/ic.cc:393:MaybeHandle<Object> LoadIC::Load(Handle<JSAny> object, Handle<Name> name,
ic/ic.cc:411:      TraceIC("LoadIC", name);
ic/ic.cc:452:                       : TraceIC("LoadIC", name);
ic/ic.cc:530:  return LoadIC::Load(global, name, update_feedback);
ic/ic.cc:582:  // TODO(gsathya): Support KeyedLoadIC, StoreIC and KeyedStoreIC.
ic/ic.cc:583:  if (!IsLoadIC()) return false;
ic/ic.cc:791:void LoadIC::UpdateCaches(LookupIterator* lookup) {
ic/ic.cc:834:  TraceIC("LoadIC", lookup->GetName());
ic/ic.cc:858:MaybeObjectHandle LoadIC::ComputeHandler(LookupIterator* lookup) {
ic/ic.cc:1162:KeyedAccessLoadMode KeyedLoadIC::GetKeyedAccessLoadModeFor(
ic/ic.cc:1180:void KeyedLoadIC::UpdateLoadElement(DirectHandle<HeapObject> receiver,
ic/ic.cc:1381:Handle<Object> KeyedLoadIC::LoadElementHandler(
ic/ic.cc:1443:void KeyedLoadIC::LoadElementPolymorphicHandlers(
ic/ic.cc:1547:MaybeHandle<Object> KeyedLoadIC::RuntimeLoad(DirectHandle<JSAny> object,
ic/ic.cc:1552:  if (IsKeyedLoadIC()) {
ic/ic.cc:1565:MaybeHandle<Object> KeyedLoadIC::LoadName(Handle<JSAny> object,
ic/ic.cc:1570:                             LoadIC::Load(object, name));
ic/ic.cc:1574:    TraceIC("LoadIC", key);
ic/ic.cc:1581:MaybeHandle<Object> KeyedLoadIC::Load(Handle<JSAny> object,
ic/ic.cc:1604:      TraceIC("LoadIC", key);
ic/ic.cc:1610:    TraceIC("LoadIC", key);
ic/ic.cc:1616:bool StoreIC::LookupForWrite(LookupIterator* it, DirectHandle<Object> value,
ic/ic.cc:1775:  return StoreIC::Store(global, name, value);
ic/ic.cc:1846:MaybeHandle<Object> StoreIC::Store(Handle<JSAny> object, Handle<Name> name,
ic/ic.cc:1852:    // KeyedStoreIC should handle DefineKeyedOwnIC with deprecated maps directly
ic/ic.cc:1874:      TRACE_HANDLER_STATS(isolate(), StoreIC_NonReceiver);
ic/ic.cc:1877:      TraceIC("StoreIC", name);
ic/ic.cc:1936:                      : TraceIC("StoreIC", name);
ic/ic.cc:1940:  // of StoreIC so their logic doesn't get mixed here.
ic/ic.cc:1943:  // IsAnyDefineOwn() can be true when this method is reused by KeyedStoreIC.
ic/ic.cc:1961:void StoreIC::UpdateCaches(LookupIterator* lookup, DirectHandle<Object> value,
ic/ic.cc:1984:  TraceIC("StoreIC", lookup->GetName());
ic/ic.cc:1987:MaybeObjectHandle StoreIC::ComputeHandler(LookupIterator* lookup) {
ic/ic.cc:1993:        TRACE_HANDLER_STATS(isolate(), StoreIC_StoreGlobalTransitionDH);
ic/ic.cc:2009:          TRACE_HANDLER_STATS(isolate(), StoreIC_SlowStub);
ic/ic.cc:2064:      // This is currently guaranteed by checks in StoreIC::Store.
ic/ic.cc:2072:        TRACE_HANDLER_STATS(isolate(), StoreIC_SlowStub);
ic/ic.cc:2077:        TRACE_HANDLER_STATS(isolate(), StoreIC_SlowStub);
ic/ic.cc:2087:          TRACE_HANDLER_STATS(isolate(), StoreIC_SlowStub);
ic/ic.cc:2092:          TRACE_HANDLER_STATS(isolate(), StoreIC_SlowStub);
ic/ic.cc:2098:        TRACE_HANDLER_STATS(isolate(), StoreIC_StoreNativeDataPropertyDH);
ic/ic.cc:2103:                            StoreIC_StoreNativeDataPropertyOnPrototypeDH);
ic/ic.cc:2114:          TRACE_HANDLER_STATS(isolate(), StoreIC_SlowStub);
ic/ic.cc:2123:          TRACE_HANDLER_STATS(isolate(), StoreIC_SlowStub);
ic/ic.cc:2142:            TRACE_HANDLER_STATS(isolate(), StoreIC_StoreApiSetterOnPrototypeDH);
ic/ic.cc:2149:          TRACE_HANDLER_STATS(isolate(), StoreIC_SlowStub);
ic/ic.cc:2153:          TRACE_HANDLER_STATS(isolate(), StoreIC_SlowStub);
ic/ic.cc:2159:          TRACE_HANDLER_STATS(isolate(), StoreIC_StoreAccessorDH);
ic/ic.cc:2163:        TRACE_HANDLER_STATS(isolate(), StoreIC_StoreAccessorOnPrototypeDH);
ic/ic.cc:2170:      TRACE_HANDLER_STATS(isolate(), StoreIC_SlowStub);
ic/ic.cc:2175:      // This is currently guaranteed by checks in StoreIC::Store.
ic/ic.cc:2184:          TRACE_HANDLER_STATS(isolate(), StoreIC_StoreGlobalDH);
ic/ic.cc:2188:        TRACE_HANDLER_STATS(isolate(), StoreIC_StoreNormalDH);
ic/ic.cc:2199:        TRACE_HANDLER_STATS(isolate(), StoreIC_SlowStub);
ic/ic.cc:2205:        TRACE_HANDLER_STATS(isolate(), StoreIC_StoreFieldDH);
ic/ic.cc:2228:      TRACE_HANDLER_STATS(isolate(), StoreIC_SlowStub);
ic/ic.cc:2242:        TRACE_HANDLER_STATS(isolate(), StoreIC_SlowStub);
ic/ic.cc:2259:void KeyedStoreIC::UpdateStoreElement(Handle<Map> receiver_map,
ic/ic.cc:2399:Handle<Object> KeyedStoreIC::StoreElementHandler(
ic/ic.h:317:  KeyedStoreIC(Isolate* isolate, Handle<FeedbackVector> vector,
ic/ic.cc:2427:    TRACE_HANDLER_STATS(isolate(), KeyedStoreIC_KeyedStoreSloppyArgumentsStub);
ic/ic.cc:2434:    TRACE_HANDLER_STATS(isolate(), KeyedStoreIC_StoreFastElementStub);
ic/ic.cc:2453:    TRACE_HANDLER_STATS(isolate(), KeyedStoreIC_StoreElementStub);
ic/ic.cc:2475:void KeyedStoreIC::StoreElementPolymorphicHandlers(
ic/ic.cc:2496:      TRACE_HANDLER_STATS(isolate(), KeyedStoreIC_SlowStub);
ic/ic.cc:2530:                            KeyedStoreIC_ElementsTransitionAndStoreStub);
ic/ic.cc:2577:MaybeHandle<Object> KeyedStoreIC::Store(Handle<JSAny> object,
ic/ic.cc:2584:    // TODO(v8:12548): refactor DefineKeyedOwnIC as a subclass of StoreIC
ic/ic.cc:2605:        StoreIC::Store(object, maybe_name, value, StoreOrigin::kMaybeKeyed));
ic/ic.cc:2609:        TraceIC("StoreIC", key);
ic/ic.cc:2656:  // TODO(v8:12548): refactor DefineKeyedOwnIC as a subclass of StoreIC
ic/ic.cc:2712:  TraceIC("StoreIC", key);
ic/ic.cc:2785:  // A monomorphic or polymorphic KeyedLoadIC with a string key can call the
ic/ic.cc:2786:  // LoadIC miss handler if the handler misses. Since the vector Nexus is
ic/ic.cc:2790:    LoadIC ic(isolate, vector, vector_slot, kind);
ic/ic.cc:2803:    KeyedLoadIC ic(isolate, vector, vector_slot, kind);
ic/ic.cc:2821:  // it is safe to call LoadIC::Load for global loads as well.
ic/ic.cc:2822:  LoadIC ic(isolate, vector, vector_slot, kind);
ic/ic.cc:2837:  LoadIC ic(isolate, vector, vector_slot, FeedbackSlotKind::kLoadProperty);
ic/ic.cc:2899:  LoadIC ic(isolate, vector, vector_slot, FeedbackSlotKind::kLoadProperty);
ic/ic.cc:2919:  KeyedLoadIC ic(isolate, vector, vector_slot, FeedbackSlotKind::kLoadKeyed);
ic/ic.cc:2924:RUNTIME_FUNCTION(Runtime_StoreIC_Miss) {
ic/ic.cc:2950:  StoreIC ic(isolate, vector, vector_slot, kind);
ic/ic.cc:2980:  // TODO(v8:12548): refactor DefineNamedOwnIC as a subclass of StoreIC, which
ic/ic.cc:2982:  StoreIC ic(isolate, vector, vector_slot, kind);
ic/ic.cc:3099:RUNTIME_FUNCTION(Runtime_KeyedStoreIC_Miss) {
ic/ic.cc:3127:  // TODO(v8:12548): refactor DefineKeyedOwnIC as a subclass of KeyedStoreIC,
ic/ic.cc:3129:  if (IsKeyedStoreICKind(kind) || IsDefineKeyedOwnICKind(kind)) {
ic/ic.cc:3130:    KeyedStoreIC ic(isolate, vector, vector_slot, kind);
ic/ic.cc:3164:  // TODO(v8:12548): refactor DefineKeyedOwnIC as a subclass of KeyedStoreIC,
ic/ic.cc:3166:  KeyedStoreIC ic(isolate, vector, vector_slot, kind);
ic/ic.cc:3193:RUNTIME_FUNCTION(Runtime_KeyedStoreIC_Slow) {
ic/ic.cc:3228:RUNTIME_FUNCTION(Runtime_ElementsTransitionAndStoreIC_Miss) {
ic/ic.cc:3250:    DCHECK(IsKeyedStoreICKind(kind) || IsSetNamedICKind(kind) ||
ic/ic.cc:4025:  if (!LoadIC::ShouldThrowReferenceError(slot_kind)) {
ic/ic.cc:4064:    // Stores initiated by StoreICs don't care about the exact result of
ic/ic.cc:4140:  KeyedLoadIC ic(isolate, vector, vector_slot, FeedbackSlotKind::kHasKeyed);
compiler/compilation-dependencies.cc:1057:      : CompilationDependency(kElementsKind), site_(site), kind_(kind) {
compiler/js-heap-broker.cc:367:  if (IsKeyedStoreICKind(kind)) {
compiler/js-heap-broker.cc:425:         IsKeyedStoreICKind(slot_kind) ||
compiler/js-heap-broker.cc:455:         IsKeyedHasICKind(slot_kind) || IsKeyedStoreICKind(slot_kind) ||
maglev/maglev-ir.cc:4220:  __ CallBuiltin<Builtin::kLoadIC>(
maglev/maglev-ir.cc:4255:  using D = CallInterfaceDescriptorFor<Builtin::kStoreIC>::type;
maglev/maglev-ir.cc:4259:  using D = CallInterfaceDescriptorFor<Builtin::kStoreIC>::type;
maglev/maglev-ir.cc:4267:  __ CallBuiltin<Builtin::kStoreIC>(
maglev/maglev-ir.cc:4523:  using D = CallInterfaceDescriptorFor<Builtin::kKeyedStoreIC>::type;
maglev/maglev-ir.cc:4527:  using D = CallInterfaceDescriptorFor<Builtin::kKeyedStoreIC>::type;
maglev/maglev-ir.cc:4536:  __ CallBuiltin<Builtin::kKeyedStoreIC>(
maglev/maglev-ir.cc:4699:  using D = CallInterfaceDescriptorFor<Builtin::kKeyedLoadIC>::type;
maglev/maglev-ir.cc:4703:  using D = CallInterfaceDescriptorFor<Builtin::kKeyedLoadIC>::type;
maglev/maglev-ir.cc:4711:  __ CallBuiltin<Builtin::kKeyedLoadIC>(
maglev/maglev-graph-builder.cc:5721:          return BuildCallBuiltin<Builtin::kStoreIC_Megamorphic>(
maglev/maglev-graph-builder.cc:6398:      return BuildCallBuiltin<Builtin::kKeyedStoreIC_Megamorphic>(
compiler/js-generic-lowering.cc:294:                  : Builtin::kKeyedLoadIC);
compiler/js-generic-lowering.cc:326:                  : Builtin::kLoadIC);
compiler/js-generic-lowering.cc:416:    // KeyedStoreIC is currently a base class for multiple keyed property store
compiler/js-generic-lowering.cc:419:    // TODO(v8:12548): refactor SetKeyedIC as a subclass of KeyedStoreIC, which
compiler/js-generic-lowering.cc:424:                  ? Builtin::kKeyedStoreICTrampoline_Megamorphic
compiler/js-generic-lowering.cc:425:                  : Builtin::kKeyedStoreICTrampoline);
compiler/js-generic-lowering.cc:432:                  ? Builtin::kKeyedStoreIC_Megamorphic
compiler/js-generic-lowering.cc:433:                  : Builtin::kKeyedStoreIC);
compiler/js-generic-lowering.cc:470:    // StoreIC is currently a base class for multiple property store operations
compiler/js-generic-lowering.cc:473:    // TODO(v8:12548): refactor SetNamedIC as a subclass of StoreIC, which can
compiler/js-generic-lowering.cc:478:                  ? Builtin::kStoreICTrampoline_Megamorphic
compiler/js-generic-lowering.cc:479:                  : Builtin::kStoreICTrampoline);
ic/ic.cc:2419:    TRACE_HANDLER_STATS(isolate(), KeyedStoreIC_SlowStub);
compiler/js-generic-lowering.cc:488:                  : Builtin::kStoreIC);
runtime/runtime.h:792:  F(ElementsTransitionAndStoreIC_Miss, 6, 1) \
runtime/runtime.h:794:  F(KeyedStoreIC_Miss, 5, 1)                 \
runtime/runtime.h:798:  F(KeyedStoreIC_Slow, 3, 1)                 \
runtime/runtime.h:812:  F(StoreIC_Miss, 5, 1)                      \
compiler/turboshaft/maglev-graph-building-phase.cc:1854:    GENERATE_AND_MAP_BUILTIN_CALL(node, Builtin::kKeyedStoreIC, frame_state,
compiler/turboshaft/maglev-graph-building-phase.cc:1867:    GENERATE_AND_MAP_BUILTIN_CALL(node, Builtin::kKeyedLoadIC, frame_state,
compiler/turboshaft/maglev-graph-building-phase.cc:1883:    GENERATE_AND_MAP_BUILTIN_CALL(node, Builtin::kStoreIC, frame_state,
compiler/turboshaft/maglev-graph-building-phase.cc:1896:    GENERATE_AND_MAP_BUILTIN_CALL(node, Builtin::kLoadIC, frame_state,
interpreter/interpreter-generator.cc:598:// Calls the LoadIC at FeedBackVector slot <slot> for <object> and the name at
interpreter/interpreter-generator.cc:654:// Calls the KeyedLoadIC at FeedBackVector slot <slot> for <object> and the key
interpreter/interpreter-generator.cc:664:  var_result = CallBuiltin(Builtin::kKeyedLoadIC, context, object, name, slot,
interpreter/interpreter-generator.cc:672:// Calls the EnumeratedKeyedLoadIC at FeedBackVector slot <slot> for <object>
interpreter/interpreter-generator.cc:685:  var_result = CallBuiltin(Builtin::kEnumeratedKeyedLoadIC, context, object,
interpreter/interpreter-generator.cc:720:// Calls the StoreIC at FeedBackVector slot <slot> for <object> and
interpreter/interpreter-generator.cc:724:  // StoreIC is currently a base class for multiple property store operations
interpreter/interpreter-generator.cc:727:  // TODO(v8:12548): refactor SetNamedIC as a subclass of StoreIC, which can be
interpreter/interpreter-generator.cc:729:  SetNamedProperty(Builtin::kStoreIC, NamedPropertyType::kNotOwn);
interpreter/interpreter-generator.cc:743:// Calls the KeyedStoreIC at FeedbackVector slot <slot> for <object> and
interpreter/interpreter-generator.cc:754:  // KeyedStoreIC is currently a base class for multiple keyed property store
interpreter/interpreter-generator.cc:757:  // TODO(v8:12548): refactor SetKeyedIC as a subclass of KeyedStoreIC, which
interpreter/interpreter-generator.cc:759:  TNode<Object> result = CallBuiltin(Builtin::kKeyedStoreIC, context, object,
interpreter/bytecodes.h:149:  /* Property loads (LoadIC) operations */                                     \
interpreter/bytecodes.h:166:  /* Propery stores (StoreIC) operations */                                    \
interpreter/bytecode-generator.cc:3529:    FeedbackSlot slot = feedback_spec()->AddStoreICSlot(language_mode());
interpreter/bytecode-generator.cc:3701:  FeedbackSlot slot = feedback_spec()->AddKeyedStoreICSlot(language_mode());
interpreter/bytecode-generator.cc:4352:      feedback_spec(), feedback_spec()->GetStoreICSlot(LanguageMode::kStrict));
interpreter/bytecode-generator.cc:4862:  FeedbackSlot slot = GetCachedStoreICSlot(object_expr, name);
interpreter/bytecode-generator.cc:5522:      FeedbackSlot slot = feedback_spec()->AddKeyedStoreICSlot(language_mode());
interpreter/bytecode-generator.cc:7245:      FeedbackSlot slot = feedback_spec()->AddKeyedStoreICSlot(language_mode());
interpreter/bytecode-generator.cc:8622:FeedbackSlot BytecodeGenerator::GetCachedStoreICSlot(const Expression* expr,
interpreter/bytecode-generator.cc:8625:    return feedback_spec()->AddStoreICSlot(language_mode());
interpreter/bytecode-generator.cc:8631:    return feedback_spec()->AddStoreICSlot(language_mode());
interpreter/bytecode-generator.cc:8639:  slot = feedback_spec()->AddStoreICSlot(language_mode());
interpreter/bytecode-generator.h:514:  FeedbackSlot GetCachedStoreICSlot(const Expression* expr,
baseline/baseline-compiler.cc:998:  // StoreIC is currently a base class for multiple property store operations
baseline/baseline-compiler.cc:1001:  // TODO(v8:12548): refactor SetNamedIC as a subclass of StoreIC, which can be
baseline/baseline-compiler.cc:1003:  CallBuiltin<Builtin::kStoreICBaseline>(
baseline/baseline-compiler.cc:1019:  // KeyedStoreIC is currently a base class for multiple keyed property store
baseline/baseline-compiler.cc:1022:  // TODO(v8:12548): refactor SetKeyedIC as a subclass of KeyedStoreIC, which
baseline/baseline-compiler.cc:1024:  CallBuiltin<Builtin::kKeyedStoreICBaseline>(
objects/transitions.h:68:// transition target, or a StoreIC handler for a transitioning store (which in
objects/elements.h:30:    DCHECK_LT(static_cast<int>(elements_kind), kElementsKindCount);
objects/js-objects.cc:5204:// Note, that the normal Load/StoreICs that load/store through the global object
objects/elements-kind.h:185:constexpr int kElementsKindCount = LAST_ELEMENTS_KIND - FIRST_ELEMENTS_KIND + 1;
objects/elements-kind.h:193:constexpr int kElementsKindBits = 6;
objects/elements-kind.h:194:static_assert((1 << kElementsKindBits) > LAST_ELEMENTS_KIND);
objects/elements-kind.h:195:static_assert((1 << (kElementsKindBits - 1)) <= LAST_ELEMENTS_KIND);
objects/feedback-vector.cc:801:          DCHECK(IsKeyedLoadICKind(kind()) || IsKeyedStoreICKind(kind()) ||
objects/feedback-vector.cc:1211:  if (IsKeyedStoreICKind(kind()) || IsKeyedLoadICKind(kind()) ||
objects/feedback-vector.cc:1249:    case Builtin::kKeyedStoreIC_SloppyArguments_InBounds:
objects/feedback-vector.cc:1250:    case Builtin::kKeyedStoreIC_SloppyArguments_NoTransitionGrowAndHandleCOW:
objects/feedback-vector.cc:1251:    case Builtin::kKeyedStoreIC_SloppyArguments_NoTransitionIgnoreTypedArrayOOB:
objects/feedback-vector.cc:1252:    case Builtin::kKeyedStoreIC_SloppyArguments_NoTransitionHandleCOW:
objects/feedback-vector.cc:1271:    case Builtin::kKeyedStoreIC_SloppyArguments_InBounds:
objects/feedback-vector.cc:1275:    case Builtin::kKeyedStoreIC_SloppyArguments_NoTransitionGrowAndHandleCOW:
objects/feedback-vector.cc:1279:    case Builtin::kKeyedStoreIC_SloppyArguments_NoTransitionIgnoreTypedArrayOOB:
objects/feedback-vector.cc:1283:    case Builtin::kKeyedStoreIC_SloppyArguments_NoTransitionHandleCOW:
objects/feedback-vector.cc:1295:  DCHECK(IsKeyedStoreICKind(kind()) || IsStoreInArrayLiteralICKind(kind()) ||
objects/feedback-vector.cc:1353:  DCHECK(IsKeyedStoreICKind(kind()) || IsKeyedLoadICKind(kind()) ||
objects/feedback-vector.cc:1408:      IsKeyedLoadICKind(nexus->kind()) || IsKeyedStoreICKind(nexus->kind()) ||
objects/elements.cc:5696:                kElementsKindCount);
objects/feedback-vector.h:132:inline bool IsKeyedStoreICKind(FeedbackSlotKind kind) {
objects/feedback-vector.h:158:         IsStoreGlobalICKind(kind) || IsKeyedStoreICKind(kind) ||
objects/feedback-vector.h:381:  DEFINE_SLOT_KIND_PREDICATE(IsLoadIC)
objects/feedback-vector.h:383:  DEFINE_SLOT_KIND_PREDICATE(IsKeyedLoadIC)
objects/feedback-vector.h:387:  DEFINE_SLOT_KIND_PREDICATE(IsKeyedStoreIC)
objects/feedback-vector.h:512:  FeedbackSlotKind GetStoreICSlot(LanguageMode language_mode) {
objects/feedback-vector.h:518:  FeedbackSlot AddStoreICSlot(LanguageMode language_mode) {
objects/feedback-vector.h:519:    return AddSlot(GetStoreICSlot(language_mode));
objects/feedback-vector.h:539:  FeedbackSlotKind GetKeyedStoreICSlotKind(LanguageMode language_mode) {
objects/feedback-vector.h:545:  FeedbackSlot AddKeyedStoreICSlot(LanguageMode language_mode) {
objects/feedback-vector.h:546:    return AddSlot(GetKeyedStoreICSlotKind(language_mode));
builtins/builtins-definitions.h:357:  TFH(KeyedStoreIC_Megamorphic, StoreWithVector)                               \
builtins/builtins-definitions.h:365:  TFH(StoreIC_NoFeedback, StoreNoFeedback)                                     \
builtins/builtins-definitions.h:369:  TFH(KeyedStoreIC_SloppyArguments_InBounds, StoreWithVector)                  \
builtins/builtins-definitions.h:370:  TFH(KeyedStoreIC_SloppyArguments_NoTransitionGrowAndHandleCOW,               \
builtins/builtins-definitions.h:372:  TFH(KeyedStoreIC_SloppyArguments_NoTransitionIgnoreTypedArrayOOB,            \
builtins/builtins-definitions.h:374:  TFH(KeyedStoreIC_SloppyArguments_NoTransitionHandleCOW, StoreWithVector)     \
builtins/builtins-definitions.h:739:  TFH(LoadIC, LoadWithVector)                                                  \
builtins/builtins-definitions.h:747:  TFH(KeyedLoadIC, KeyedLoadWithVector)                                        \
builtins/builtins-definitions.h:748:  TFH(EnumeratedKeyedLoadIC, EnumeratedKeyedLoad)                              \
builtins/builtins-definitions.h:757:  TFH(StoreIC, StoreWithVector)                                                \
builtins/builtins-definitions.h:758:  TFH(StoreIC_Megamorphic, StoreWithVector)                                    \
compiler/js-generic-lowering.cc:487:                  ? Builtin::kStoreIC_Megamorphic
builtins/builtins-definitions.h:760:  TFH(StoreICTrampoline_Megamorphic, Store)                                    \
builtins/builtins-definitions.h:761:  TFH(StoreICBaseline, StoreBaseline)                                          \
builtins/builtins-definitions.h:765:  TFH(KeyedStoreIC, StoreWithVector)                                           \
builtins/builtins-definitions.h:766:  TFH(KeyedStoreICTrampoline, Store)                                           \
builtins/builtins-definitions.h:767:  TFH(KeyedStoreICTrampoline_Megamorphic, Store)                               \
builtins/builtins-definitions.h:768:  TFH(KeyedStoreICBaseline, StoreBaseline)                                     \
builtins/base.tq:775:extern builtin LoadIC(
builtins/builtins-handler-gen.cc:24:  void Generate_KeyedStoreIC_SloppyArguments();
builtins/builtins-handler-gen.cc:57:void Builtins::Generate_KeyedStoreIC_Megamorphic(
builtins/builtins-handler-gen.cc:67:void Builtins::Generate_StoreIC_NoFeedback(
builtins/builtins-handler-gen.cc:69:  StoreICNoFeedbackGenerator::Generate(state);
builtins/builtins-handler-gen.cc:172:  TailCallRuntime(Runtime::kElementsTransitionAndStoreIC_Miss, context,
builtins/builtins-handler-gen.cc:317:  TailCallRuntime(Runtime::kKeyedStoreIC_Miss, context,
builtins/builtins-handler-gen.cc:387:void HandlerBuiltinsAssembler::Generate_KeyedStoreIC_SloppyArguments() {
builtins/builtins-handler-gen.cc:402:  TailCallRuntime(Runtime::kKeyedStoreIC_Miss, context, value, slot, vector,
builtins/builtins-handler-gen.cc:406:TF_BUILTIN(KeyedStoreIC_SloppyArguments_InBounds, HandlerBuiltinsAssembler) {
builtins/builtins-handler-gen.cc:407:  Generate_KeyedStoreIC_SloppyArguments();
builtins/builtins-handler-gen.cc:410:TF_BUILTIN(KeyedStoreIC_SloppyArguments_NoTransitionGrowAndHandleCOW,
builtins/builtins-handler-gen.cc:412:  Generate_KeyedStoreIC_SloppyArguments();
builtins/builtins-handler-gen.cc:415:TF_BUILTIN(KeyedStoreIC_SloppyArguments_NoTransitionIgnoreTypedArrayOOB,
builtins/builtins-handler-gen.cc:417:  Generate_KeyedStoreIC_SloppyArguments();
interpreter/bytecode-generator.cc:7231:      FeedbackSlot slot = GetCachedStoreICSlot(property->obj(), name);
builtins/builtins-ic-gen.cc:13:void Builtins::Generate_LoadIC(compiler::CodeAssemblerState* state) {
builtins/builtins-ic-gen.cc:15:  assembler.GenerateLoadIC();
builtins/builtins-ic-gen.cc:52:void Builtins::Generate_KeyedLoadIC(compiler::CodeAssemblerState* state) {
builtins/builtins-ic-gen.cc:54:  assembler.GenerateKeyedLoadIC();
builtins/builtins-ic-gen.cc:56:void Builtins::Generate_EnumeratedKeyedLoadIC(
builtins/builtins-ic-gen.cc:59:  assembler.GenerateEnumeratedKeyedLoadIC();
builtins/builtins-ic-gen.cc:110:void Builtins::Generate_StoreIC(compiler::CodeAssemblerState* state) {
builtins/builtins-ic-gen.cc:112:  assembler.GenerateStoreIC();
builtins/builtins-ic-gen.cc:114:void Builtins::Generate_StoreIC_Megamorphic(
builtins/builtins-ic-gen.cc:117:  assembler.GenerateStoreIC_Megamorphic();
builtins/builtins-ic-gen.cc:119:void Builtins::Generate_StoreICTrampoline(compiler::CodeAssemblerState* state) {
builtins/builtins-ic-gen.cc:123:void Builtins::Generate_StoreICTrampoline_Megamorphic(
builtins/builtins-ic-gen.cc:126:  assembler.GenerateStoreICTrampoline_Megamorphic();
builtins/builtins-ic-gen.cc:128:void Builtins::Generate_StoreICBaseline(compiler::CodeAssemblerState* state) {
builtins/builtins-ic-gen.cc:130:  assembler.GenerateStoreICBaseline();
builtins/builtins-ic-gen.cc:146:void Builtins::Generate_KeyedStoreIC(compiler::CodeAssemblerState* state) {
builtins/builtins-ic-gen.cc:148:  assembler.GenerateKeyedStoreIC();
builtins/builtins-ic-gen.cc:150:void Builtins::Generate_KeyedStoreICTrampoline(
builtins/builtins-ic-gen.cc:153:  assembler.GenerateKeyedStoreICTrampoline();
builtins/builtins-ic-gen.cc:155:void Builtins::Generate_KeyedStoreICTrampoline_Megamorphic(
builtins/builtins-ic-gen.cc:158:  assembler.GenerateKeyedStoreICTrampoline_Megamorphic();
builtins/builtins-ic-gen.cc:160:void Builtins::Generate_KeyedStoreICBaseline(
builtins/builtins-ic-gen.cc:163:  assembler.GenerateKeyedStoreICBaseline();
builtins/iterator.tq:74:      iteratorMethod = LoadIC(
builtins/iterator.tq:92:      LoadIC(context, receiver, IteratorSymbolConstant(), loadSlot, feedback);
objects/map-inl.h:589:  CHECK_LT(static_cast<int>(elements_kind), kElementsKindCount);
Command: cd /Users/tarun/v8/v8/src && rg -n --hidden --no-ignore-vcs 'SetLength\(|JSArray::SetLength|SetLength\b' | head -n 1000Command: cd /Users/tarun/v8/v8/src && rg -n --hidden --no-ignore-vcs 'CopyElements\(|CopyElements' | head -n 1000Command: cd /Users/tarun/v8/v8/src && rg -n --hidden --no-ignore-vcs 'TransitionElementsKindWithKind|Runtime_TransitionElementsKind|kTransitionElementsKind|TransitionElementsKindWithKind' | head -n 1000Command: cd /Users/tarun/v8/v8/src && rg -n --hidden --no-ignore-vcs 'KeyedStoreIC|KeyedLoadIC|KeyedStoreMode' | head -n 1000
builtins/builtins-handler-gen.cc:420:TF_BUILTIN(KeyedStoreIC_SloppyArguments_NoTransitionHandleCOW,

builtins/builtins-ic-gen.cc:121:  assembler.GenerateStoreICTrampoline();

builtins/builtins-definitions.h:759:  TFH(StoreICTrampoline, Store)                                                \
builtins/builtins-handler-gen.cc:422:  Generate_KeyedStoreIC_SloppyArguments();
init/bootstrapper.cc:124:  FixedArray::CopyElements(isolate, *new_array, 0, cache_, 0, cache_->length());
objects/fixed-array.cc:144:  CopyElements(isolate, *new_array, 0, *array, 0, old_length, mode);
strings/string-builder.cc:157:    FixedArray::CopyElements(isolate, *extended_array, 0, *array_, 0, length_);
objects/scope-info.cc:639:void ScopeInfo::CopyElements(Isolate* isolate, int dst_index,
runtime/runtime-typedarray.cc:50:RUNTIME_FUNCTION(Runtime_TypedArrayCopyElements) {
runtime/runtime-typedarray.cc:58:  return accessor->CopyElements(source, target, length, 0);
runtime/runtime-typedarray.cc:210:  return accessor->CopyElements(source, target, length, offset);
runtime/runtime.h:663:  F(TypedArrayCopyElements, 3, 1)              \
compiler/js-call-reducer.cc:6148:          jsgraph()->ConstantNoHole(JSArray::kMaxCopyElements));
compiler/js-call-reducer.cc:6183:            jsgraph()->ConstantNoHole(JSArray::kMaxCopyElements - 1), loop);
compiler/js-call-reducer.cc:6200:          // is in |1, kMaxCopyElements-1], and will break in representing
compiler/js-call-reducer.cc:6206:          static_assert(JSArray::kMaxCopyElements < kSmiMaxValue);
objects/property-array.h:52:  // Signature must be in sync with FixedArray::CopyElements().
objects/property-array.h:53:  inline static void CopyElements(Isolate* isolate, Tagged<PropertyArray> dst,
objects/property-array-inl.h:145:void PropertyArray::CopyElements(Isolate* isolate, Tagged<PropertyArray> dst,
objects/js-array.tq:197:extern macro CopyElements(
objects/js-array.tq:200:macro TorqueCopyElements(
objects/js-array.tq:203:  CopyElements(
objects/js-array.tq:207:macro TorqueCopyElements(
objects/js-array.tq:210:  CopyElements(
objects/fixed-array-inl.h:238:void TaggedArrayBase<D, S, P>::CopyElements(Isolate* isolate, Tagged<D> dst,
objects/fixed-array-inl.h:416:void FixedArray::CopyElements(Isolate* isolate, int dst_index,
objects/fixed-array-inl.h:419:  CopyElements(isolate, this, dst_index, src, src_index, len, mode);
objects/fixed-array-inl.h:430:  FixedArray::CopyElements(isolate, *ys, 0, *xs, 0, elements_to_copy, mode);
objects/fixed-array-inl.h:673:void WeakArrayList::CopyElements(Isolate* isolate, int dst_index,
objects/elements.h:194:  virtual void CopyElements(Isolate* isolate,
objects/elements.h:200:  virtual Tagged<Object> CopyElements(DirectHandle<JSAny> source,
objects/elements.h:241:  virtual void CopyElements(Isolate* isolate, Tagged<JSObject> source_holder,
objects/fixed-array.h:154:  inline static void CopyElements(Isolate* isolate, Tagged<Derived> dst,
objects/fixed-array.h:223:  using Super::CopyElements;
objects/fixed-array.h:229:  inline void CopyElements(Isolate* isolate, int dst_index,
objects/fixed-array.h:631:  inline void CopyElements(Isolate* isolate, int dst_index,
objects/elements.cc:195:// CopyElements, it copies all of elements from source after source_start to
objects/elements.cc:233:  to->CopyElements(isolate, to_start, from, from_start, copy_size,
objects/elements.cc:279:// See ElementsAccessorBase::CopyElements() for details.
objects/elements.cc:935:    Subclass::CopyElementsImpl(isolate, *old_elements, src_index, *new_elements,
objects/elements.cc:1080:  static void CopyElementsImpl(Isolate* isolate, Tagged<FixedArrayBase> from,
objects/elements.cc:1087:  void CopyElements(Isolate* isolate, Tagged<JSObject> from_holder,
objects/elements.cc:1101:    // NOTE: the Subclass::CopyElementsImpl() methods
objects/elements.cc:1110:    Subclass::CopyElementsImpl(isolate, from, from_start, *to, from_kind,
objects/elements.cc:1114:  void CopyElements(Isolate* isolate, DirectHandle<FixedArrayBase> source,
objects/elements.cc:1118:    Subclass::CopyElementsImpl(isolate, *source, 0, *destination, source_kind,
objects/elements.cc:1134:  Tagged<Object> CopyElements(DirectHandle<JSAny> source,
objects/elements.cc:1137:    return Subclass::CopyElementsHandleImpl(source, destination, length,
objects/elements.cc:1141:  static Tagged<Object> CopyElementsHandleImpl(
objects/elements.cc:1589:  static void CopyElementsImpl(Isolate* isolate, Tagged<FixedArrayBase> from,
objects/elements.cc:2350:    if (len > JSArray::kMaxCopyElements && dst_index == 0 &&
objects/elements.cc:2670:  // See ElementsAccessor::CopyElements() for details.
objects/elements.cc:2673:  static void CopyElementsImpl(Isolate* isolate, Tagged<FixedArrayBase> from,
objects/elements.cc:3144:  static void CopyElementsImpl(Isolate* isolate, Tagged<FixedArrayBase> from,
objects/elements.cc:3878:  static void CopyElementsFromTypedArray(Tagged<JSTypedArray> source,
objects/elements.cc:3985:  static bool TryCopyElementsFastNumber(Tagged<Context> context,
objects/elements.cc:4085:  static Tagged<Object> CopyElementsHandleSlow(
objects/elements.cc:4136:  static Tagged<Object> CopyElementsHandleImpl(
objects/elements.cc:4159:        CopyElementsFromTypedArray(*source_ta, *destination_ta, length, offset);
objects/elements.cc:4175:        if (TryCopyElementsFastNumber(isolate->context(), *source_array,
objects/elements.cc:4184:    return CopyElementsHandleSlow(source, destination_ta, length, offset);
objects/elements.cc:5280:  static void CopyElementsImpl(Isolate* isolate, Tagged<FixedArrayBase> from,
objects/elements.cc:5476:  static void CopyElementsImpl(Isolate* isolate, Tagged<FixedArrayBase> from,
objects/elements.cc:5633:    CHECK(Type##ElementsAccessor::TryCopyElementsFastNumber( \
objects/elements.cc:5654:    Type##ElementsAccessor::CopyElementsFromTypedArray(source, destination, \
objects/elements.cc:5764:    accessor->CopyElements(isolate, array, 0, from_kind, storage,
objects/keys.cc:82:    FixedArray::CopyElements(isolate, *combined_keys, 0, *own_keys, 0,
objects/js-array.h:127:  static const int kMaxCopyElements = 100;
objects/scope-info.h:332:  void CopyElements(Isolate* isolate, int dst_index, Tagged<ScopeInfo> src,
objects/contexts.cc:93:    CopyElements(isolate, *new_table, 0, *table, 0, old_length);
objects/regexp-match-info.cc:36:    RegExpMatchInfo::CopyElements(isolate, *new_info, 0, *match_info, 0,
wasm/canonical-types.cc:398:  WeakFixedArray::CopyElements(isolate, *new_rtts, 0, *old_rtts, 0, old_length);
wasm/canonical-types.cc:403:  WeakFixedArray::CopyElements(isolate, *new_wrappers, 0, *old_wrappers, 0,
codegen/code-stub-assembler.cc:5282:      // We can use CopyElements (memcpy) because we don't need to replace or
codegen/code-stub-assembler.cc:5283:      // convert any values. Since {to_elements} is in new-space, CopyElements
codegen/code-stub-assembler.cc:5287:      CopyElements(to_kind, to_elements, IntPtrConstant(0), source,
codegen/code-stub-assembler.cc:5466:      CopyElements(kind, to_elements, IntPtrConstant(0), source,
codegen/code-stub-assembler.cc:5772:void CodeStubAssembler::CopyElements(ElementsKind kind,
codegen/code-stub-assembler.cc:13443:    elements = CopyElementsOnWrite(object, elements, elements_kind,
codegen/code-stub-assembler.cc:13527:TNode<FixedArrayBase> CodeStubAssembler::CopyElementsOnWrite(
heap/factory.cc:2585:  T::CopyElements(isolate(), result, 0, *src, 0, len, mode);
heap/factory.cc:2605:  T::CopyElements(isolate(), result, 0, *src, 0, old_len, mode);
heap/factory.cc:2674:  raw->CopyElements(isolate(), 0, *src, 0, old_len, mode);
heap/factory.cc:2723:  result->CopyElements(isolate(), 0, *array, 0, new_len, mode);
builtins/array-to-spliced.tq:21:    CopyElements(kind, copy, 0, array.elements, 0, actualStart);
builtins/array-to-spliced.tq:43:    CopyElements(kind, copy, secondPartStart, array.elements, r, secondPartLen);
codegen/code-stub-assembler.h:2323:  void CopyElements(ElementsKind kind, TNode<FixedArrayBase> dst_elements,
codegen/code-stub-assembler.h:3754:  TNode<FixedArrayBase> CopyElementsOnWrite(TNode<HeapObject> object,
builtins/typed-array-from.tq:75:        // TypedArrayCopyElements which uses the same ordering as the default
builtins/typed-array-from.tq:104:            // in TypedArrayCopyElements
builtins/typed-array-from.tq:122:            // in TypedArrayCopyElements
builtins/typed-array-from.tq:135:            // code in TypedArrayCopyElements
builtins/typed-array-from.tq:189:        TypedArrayCopyElements(context, targetObj, finalSource, finalLengthNum);
builtins/typed-array-filter.tq:76:    // TypedArrayCopyElements() to avoid JSArray materialization. Or collect
builtins/typed-array-filter.tq:79:    TypedArrayCopyElements(context, typedArray, kept.ToJSArray(), lengthNumber);
builtins/array-splice.tq:52:macro DoCopyElements<FixedArrayType : type extends FixedArrayBase>(
builtins/array-splice.tq:55:  TorqueCopyElements(
builtins/array-splice.tq:110:          DoCopyElements(
builtins/array-slice.tq:24:  CopyElements(
builtins/array-slice.tq:79:  CopyElements(
builtins/typed-array-createtypedarray.tq:181:        TypedArrayCopyElements(
builtins/base.tq:539:const kMaxCopyElements:
builtins/base.tq:540:    constexpr int31 generates 'JSArray::kMaxCopyElements';
builtins/typed-array.tq:54:extern runtime TypedArrayCopyElements(Context, JSTypedArray, Object, Number):
builtins/array-to-sorted.tq:21:  CopyElements(
builtins/array-shift.tq:33:  if (newLength > kMaxCopyElements) goto Runtime;

Command: cd /Users/tarun/v8/v8/src && rg -n --hidden --no-ignore-vcs 'AccessInfo|AccessInfoFactory|JSCreateLowering|JSNativeContextSpecialization|JSCallReducer|LoadIndexed|StoreIndexed|SimplifiedLowering' | head -n 1000
Observations: debug/debug.cc:3046:  RegExpMatchInfo::CopyElements(isolate_, *regexp_match_info_, 0,
Command: cd /Users/tarun/v8/v8/src && rg -n --hidden --no-ignore-vcs 'ArrayPrototype\.push|ArrayPrototype\.pop|ArrayPrototype\.slice|ArrayPrototype\.splice|ArrayPrototype\.concat|ArrayFrom|Array.prototype\.splice|Array\.from|SpreadElement' | head -n 1000
api/api.cc:1507:  EnsureNotPublished(info, "v8::FunctionTemplate::SetLength");
codegen/code-stub-assembler.cc:18789:  ArrayListSetLength(array_with_space, new_length);
codegen/code-stub-assembler.cc:18803:void CodeStubAssembler::ArrayListSetLength(TNode<ArrayList> array,
execution/isolate.h:1648:  void UpdateNoElementsProtectorOnSetLength(DirectHandle<JSObject> object) {
codegen/code-stub-assembler.h:2351:  void ArrayListSetLength(TNode<ArrayList> array, TNode<Smi> length);
builtins/accessors.cc:208:  if (JSArray::SetLength(array, length).IsNothing()) {
builtins/builtins-collections-gen.cc:2541:        ArrayListSetLength(array, SmiConstant(1));
builtins/builtins-array.cc:182:          JSArray::SetLength(array, static_cast<uint32_t>(length)));
builtins/builtins-array.cc:260:    CHECK(accessor->SetLength(array, end).FromJust());
builtins/builtins-array.cc:508:        isolate, set_len_ok, JSArray::SetLength(array, new_length));
objects/objects.cc:3128:    // 2a. Return ArraySetLength(A, Desc).
objects/objects.cc:3129:    return ArraySetLength(isolate, o, desc, should_throw);
objects/objects.cc:3182:// Part of ES6 9.4.2.4 ArraySetLength.
objects/objects.cc:3194:  // Slow path: follow steps in ES6 9.4.2.4 "ArraySetLength".
objects/objects.cc:3220:Maybe<bool> JSArray::ArraySetLength(Isolate* isolate, DirectHandle<JSArray> a,
objects/objects.cc:3262:      // since we later use JSArray::SetLength instead of
objects/objects.cc:3285:  // Most of steps 16 through 19 is implemented by JSArray::SetLength.
objects/objects.cc:3286:  MAYBE_RETURN(JSArray::SetLength(a, new_len), Nothing<bool>());
objects/objects.cc:4754:Maybe<bool> JSArray::SetLength(DirectHandle<JSArray> array,
objects/objects.cc:4759:  return array->GetElementsAccessor()->SetLength(array, new_length);
objects/objects.cc:4833:bool JSArray::SetLengthWouldNormalize(uint32_t new_length) {
objects/objects.cc:4837:  return JSArray::SetLengthWouldNormalize(GetHeap(), new_length) &&
runtime/runtime-array.cc:76:          JSArray::SetLengthWouldNormalize(isolate->heap(), value)) {
objects/elements.h:78:  V8_WARN_UNUSED_RESULT virtual Maybe<bool> SetLength(
objects/js-array-inl.h:44:bool JSArray::SetLengthWouldNormalize(Heap* heap, uint32_t new_length) {
objects/js-array.h:62:  V8_EXPORT_PRIVATE static Maybe<bool> SetLength(DirectHandle<JSArray> array,
objects/js-array.h:77:  V8_WARN_UNUSED_RESULT static Maybe<bool> ArraySetLength(
objects/elements.cc:809:  Maybe<bool> SetLength(DirectHandle<JSArray> array, uint32_t length) final {
objects/elements.cc:992:      object->GetIsolate()->UpdateNoElementsProtectorOnSetLength(object);
objects/elements.cc:5465:      object->GetIsolate()->UpdateNoElementsProtectorOnSetLength(object);
objects/elements.cc:5560:      MAYBE_RETURN_NULL(JSArray::SetLength(array, length));
objects/value-serializer.cc:1791:  MAYBE_RETURN(JSArray::SetLength(array, length), MaybeHandle<JSArray>());
objects/value-serializer.cc:2719:        MAYBE_RETURN_NULL(JSArray::SetLength(js_array, length));
Observations: api/api.cc:1505:void FunctionTemplate::SetLength(int length) {
Observations: baseline/baseline-compiler.cc:954:  CallBuiltin<Builtin::kKeyedLoadICBaseline>(
baseline/baseline-compiler.cc:962:  CallBuiltin<Builtin::kEnumeratedKeyedLoadICBaseline>(
baseline/baseline-compiler.cc:1019:  // KeyedStoreIC is currently a base class for multiple keyed property store
baseline/baseline-compiler.cc:1022:  // TODO(v8:12548): refactor SetKeyedIC as a subclass of KeyedStoreIC, which
baseline/baseline-compiler.cc:1024:  CallBuiltin<Builtin::kKeyedStoreICBaseline>(
ic/accessor-assembler.cc:1490:          id = Runtime::kKeyedStoreIC_Slow;
ic/accessor-assembler.cc:1941:    // Code sub-handlers are expected only in KeyedStoreICs.
ic/accessor-assembler.cc:2922:        TailCallRuntime(Runtime::kKeyedLoadIC_Miss, p->context(),
ic/accessor-assembler.cc:3599:void AccessorAssembler::KeyedLoadIC(const LoadICParameters* p,
ic/accessor-assembler.cc:3636:    Comment("KeyedLoadIC_try_polymorphic");
ic/accessor-assembler.cc:3645:    Comment("KeyedLoadIC_try_megamorphic");
ic/accessor-assembler.cc:3654:        access_mode == LoadAccessMode::kLoad ? Builtin::kKeyedLoadIC_Megamorphic
ic/accessor-assembler.cc:3662:    Comment("KeyedLoadIC_try_uninitialized");
ic/accessor-assembler.cc:3671:    Comment("KeyedLoadIC_try_polymorphic_name");
ic/accessor-assembler.cc:3711:                          ? Builtin::kKeyedLoadIC_PolymorphicName
ic/accessor-assembler.cc:3720:    Comment("KeyedLoadIC_miss");
ic/accessor-assembler.cc:3722:        access_mode == LoadAccessMode::kLoad ? Runtime::kKeyedLoadIC_Miss
ic/accessor-assembler.cc:3728:void AccessorAssembler::KeyedLoadICGeneric(const LoadICParameters* p) {
ic/accessor-assembler.cc:3811:void AccessorAssembler::KeyedLoadICPolymorphicName(const LoadICParameters* p,
ic/accessor-assembler.cc:3848:    Comment("KeyedLoadIC_miss");
ic/accessor-assembler.cc:3850:        access_mode == LoadAccessMode::kLoad ? Runtime::kKeyedLoadIC_Miss
ic/accessor-assembler.cc:4062:void AccessorAssembler::KeyedStoreIC(const StoreICParameters* p) {
ic/accessor-assembler.cc:4085:      Comment("KeyedStoreIC_if_handler");
ic/accessor-assembler.cc:4094:      Comment("KeyedStoreIC_try_polymorphic");
ic/accessor-assembler.cc:4104:      Comment("KeyedStoreIC_try_megamorphic");
ic/accessor-assembler.cc:4111:      TailCallBuiltin(Builtin::kKeyedStoreIC_Megamorphic, p->context(),
ic/accessor-assembler.cc:4119:      Comment("KeyedStoreIC_try_polymorphic_name");
ic/accessor-assembler.cc:4132:    Comment("KeyedStoreIC_miss");
ic/accessor-assembler.cc:4133:    TailCallRuntime(Runtime::kKeyedStoreIC_Miss, p->context(), p->value(),
ic/accessor-assembler.cc:4662:void AccessorAssembler::GenerateKeyedLoadIC() {
ic/accessor-assembler.cc:4672:  KeyedLoadIC(&p, LoadAccessMode::kLoad);
ic/accessor-assembler.cc:4675:void AccessorAssembler::GenerateEnumeratedKeyedLoadIC() {
ic/accessor-assembler.cc:4689:  KeyedLoadIC(&p, LoadAccessMode::kLoad);
ic/accessor-assembler.cc:4692:void AccessorAssembler::GenerateKeyedLoadIC_Megamorphic() {
ic/accessor-assembler.cc:4702:  KeyedLoadICGeneric(&p);
ic/accessor-assembler.cc:4705:void AccessorAssembler::GenerateKeyedLoadICTrampoline() {
ic/accessor-assembler.cc:4714:  TailCallBuiltin(Builtin::kKeyedLoadIC, context, receiver, name, slot, vector);
ic/accessor-assembler.cc:4717:void AccessorAssembler::GenerateKeyedLoadICBaseline() {
ic/accessor-assembler.cc:4726:  TailCallBuiltin(Builtin::kKeyedLoadIC, context, receiver, name, slot, vector);
ic/accessor-assembler.cc:4729:void AccessorAssembler::GenerateEnumeratedKeyedLoadICBaseline() {
ic/accessor-assembler.cc:4740:  TailCallBuiltin(Builtin::kEnumeratedKeyedLoadIC, context, receiver, name,
ic/accessor-assembler.cc:4744:void AccessorAssembler::GenerateKeyedLoadICTrampoline_Megamorphic() {
ic/accessor-assembler.cc:4753:  TailCallBuiltin(Builtin::kKeyedLoadIC_Megamorphic, context, receiver, name,
ic/accessor-assembler.cc:4757:void AccessorAssembler::GenerateKeyedLoadIC_PolymorphicName() {
ic/accessor-assembler.cc:4767:  KeyedLoadICPolymorphicName(&p, LoadAccessMode::kLoad);
ic/accessor-assembler.cc:4949:void AccessorAssembler::GenerateKeyedStoreIC() {
ic/accessor-assembler.cc:4962:  KeyedStoreIC(&p);
ic/accessor-assembler.cc:4965:void AccessorAssembler::GenerateKeyedStoreICTrampoline() {
ic/accessor-assembler.cc:4975:  TailCallBuiltin(Builtin::kKeyedStoreIC, context, receiver, name, value, slot,
ic/accessor-assembler.cc:4979:void AccessorAssembler::GenerateKeyedStoreICTrampoline_Megamorphic() {
ic/accessor-assembler.cc:4989:  TailCallBuiltin(Builtin::kKeyedStoreIC_Megamorphic, context, receiver, name,
ic/accessor-assembler.cc:4993:void AccessorAssembler::GenerateKeyedStoreICBaseline() {
ic/accessor-assembler.cc:5003:  TailCallBuiltin(Builtin::kKeyedStoreIC, context, receiver, name, value, slot,
ic/accessor-assembler.cc:5313:  KeyedLoadIC(&p, LoadAccessMode::kHas);
ic/accessor-assembler.cc:5334:  // TODO(magardn): implement HasProperty handling in KeyedLoadICGeneric
ic/accessor-assembler.cc:5349:  KeyedLoadICPolymorphicName(&p, LoadAccessMode::kHas);
ic/handler-configuration-inl.h:156:      return BUILTIN_CODE(isolate, KeyedStoreIC_SloppyArguments_InBounds);
ic/handler-configuration-inl.h:159:          isolate, KeyedStoreIC_SloppyArguments_NoTransitionGrowAndHandleCOW);
ic/handler-configuration-inl.h:163:          KeyedStoreIC_SloppyArguments_NoTransitionIgnoreTypedArrayOOB);
ic/handler-configuration-inl.h:166:                          KeyedStoreIC_SloppyArguments_NoTransitionHandleCOW);
logging/runtime-call-stats.h:542:  V(KeyedLoadIC_KeyedLoadSloppyArgumentsStub)     \
logging/runtime-call-stats.h:543:  V(KeyedLoadIC_LoadElementDH)                    \
logging/runtime-call-stats.h:544:  V(KeyedLoadIC_LoadIndexedInterceptorStub)       \
logging/runtime-call-stats.h:545:  V(KeyedLoadIC_LoadIndexedStringDH)              \
logging/runtime-call-stats.h:546:  V(KeyedLoadIC_SlowStub)                         \
logging/runtime-call-stats.h:547:  V(KeyedStoreIC_ElementsTransitionAndStoreStub)  \
logging/runtime-call-stats.h:548:  V(KeyedStoreIC_KeyedStoreSloppyArgumentsStub)   \
logging/runtime-call-stats.h:549:  V(KeyedStoreIC_SlowStub)                        \
logging/runtime-call-stats.h:550:  V(KeyedStoreIC_StoreElementStub)                \
logging/runtime-call-stats.h:551:  V(KeyedStoreIC_StoreFastElementStub)            \
ic/accessor-assembler.h:38:  void GenerateKeyedLoadIC();
ic/accessor-assembler.h:39:  void GenerateEnumeratedKeyedLoadIC();
ic/accessor-assembler.h:40:  void GenerateKeyedLoadIC_Megamorphic();
ic/accessor-assembler.h:41:  void GenerateKeyedLoadIC_PolymorphicName();
ic/accessor-assembler.h:42:  void GenerateKeyedLoadICTrampoline();
ic/accessor-assembler.h:43:  void GenerateKeyedLoadICBaseline();
ic/accessor-assembler.h:44:  void GenerateEnumeratedKeyedLoadICBaseline();
ic/accessor-assembler.h:45:  void GenerateKeyedLoadICTrampoline_Megamorphic();
ic/accessor-assembler.h:76:  void GenerateKeyedStoreIC();
ic/accessor-assembler.h:77:  void GenerateKeyedStoreICTrampoline();
ic/accessor-assembler.h:78:  void GenerateKeyedStoreICTrampoline_Megamorphic();
ic/accessor-assembler.h:79:  void GenerateKeyedStoreICBaseline();
ic/accessor-assembler.h:366:  void KeyedLoadIC(const LoadICParameters* p, LoadAccessMode access_mode);
ic/accessor-assembler.h:367:  void KeyedLoadICGeneric(const LoadICParameters* p);
ic/accessor-assembler.h:368:  void KeyedLoadICPolymorphicName(const LoadICParameters* p,
ic/accessor-assembler.h:376:  void KeyedStoreIC(const StoreICParameters* p);
ic/accessor-assembler.h:529:  // KeyedLoadIC_Generic implementation.
runtime/runtime.h:793:  F(KeyedLoadIC_Miss, 4, 1)                  \
runtime/runtime.h:794:  F(KeyedStoreIC_Miss, 5, 1)                 \
runtime/runtime.h:798:  F(KeyedStoreIC_Slow, 3, 1)                 \
ic/keyed-store-generic.cc:25:  // chain to invoke setters. it's used by KeyedStoreIC and StoreIC to
ic/keyed-store-generic.cc:1149:      TailCallRuntime(Runtime::kKeyedStoreIC_Miss, p->context(), p->value(),
ic/ic.h:25:// IC is the base class for LoadIC, StoreIC, KeyedLoadIC, and KeyedStoreIC.
ic/ic.h:54:    return IsLoadIC() || IsLoadGlobalIC() || IsKeyedLoadIC();
ic/ic.h:58:           IsKeyedStoreIC() || IsStoreInArrayLiteralICKind(kind()) ||
ic/ic.h:125:  bool IsKeyedLoadIC() const { return IsKeyedLoadICKind(kind_); }
ic/ic.h:132:  bool IsKeyedStoreIC() const { return IsKeyedStoreICKind(kind_); }
ic/ic.h:136:    return IsKeyedLoadIC() || IsKeyedStoreIC() || IsStoreInArrayLiteralIC() ||
ic/ic.h:227:class KeyedLoadIC : public LoadIC {
ic/ic.h:229:  KeyedLoadIC(Isolate* isolate, Handle<FeedbackVector> vector,
ic/ic.h:311:class KeyedStoreIC : public StoreIC {
ic/ic.h:317:  KeyedStoreIC(Isolate* isolate, Handle<FeedbackVector> vector,
ic/ic.h:346:class StoreInArrayLiteralIC : public KeyedStoreIC {
ic/ic.h:350:      : KeyedStoreIC(isolate, vector, slot,
ic/ic.cc:134:  } else if (IsKeyedLoadIC()) {
ic/ic.cc:137:  } else if (IsKeyedStoreIC() || IsStoreInArrayLiteralIC() ||
ic/ic.cc:582:  // TODO(gsathya): Support KeyedLoadIC, StoreIC and KeyedStoreIC.
ic/ic.cc:1162:KeyedAccessLoadMode KeyedLoadIC::GetKeyedAccessLoadModeFor(
ic/ic.cc:1180:void KeyedLoadIC::UpdateLoadElement(DirectHandle<HeapObject> receiver,
ic/ic.cc:1381:Handle<Object> KeyedLoadIC::LoadElementHandler(
ic/ic.cc:1392:    TRACE_HANDLER_STATS(isolate(), KeyedLoadIC_LoadIndexedInterceptorStub);
ic/ic.cc:1399:    TRACE_HANDLER_STATS(isolate(), KeyedLoadIC_LoadIndexedStringDH);
ic/ic.cc:1404:    TRACE_HANDLER_STATS(isolate(), KeyedLoadIC_SlowStub);
ic/ic.cc:1413:    TRACE_HANDLER_STATS(isolate(), KeyedLoadIC_SlowStub);
ic/ic.cc:1421:    TRACE_HANDLER_STATS(isolate(), KeyedLoadIC_KeyedLoadSloppyArgumentsStub);
ic/ic.cc:1423:                      : BUILTIN_CODE(isolate(), KeyedLoadIC_SloppyArguments);
ic/ic.cc:1427:    TRACE_HANDLER_STATS(isolate(), KeyedLoadIC_LoadElementDH);
ic/ic.cc:1438:  TRACE_HANDLER_STATS(isolate(), KeyedLoadIC_LoadElementDH);
ic/ic.cc:1443:void KeyedLoadIC::LoadElementPolymorphicHandlers(
ic/ic.cc:1547:MaybeHandle<Object> KeyedLoadIC::RuntimeLoad(DirectHandle<JSAny> object,
ic/ic.cc:1552:  if (IsKeyedLoadIC()) {
ic/ic.cc:1565:MaybeHandle<Object> KeyedLoadIC::LoadName(Handle<JSAny> object,
ic/ic.cc:1581:MaybeHandle<Object> KeyedLoadIC::Load(Handle<JSAny> object,
ic/ic.cc:1852:    // KeyedStoreIC should handle DefineKeyedOwnIC with deprecated maps directly
ic/ic.cc:1943:  // IsAnyDefineOwn() can be true when this method is reused by KeyedStoreIC.
ic/ic.cc:2259:void KeyedStoreIC::UpdateStoreElement(Handle<Map> receiver_map,
ic/ic.cc:2399:Handle<Object> KeyedStoreIC::StoreElementHandler(
ic/ic.cc:2419:    TRACE_HANDLER_STATS(isolate(), KeyedStoreIC_SlowStub);
ic/ic.cc:2427:    TRACE_HANDLER_STATS(isolate(), KeyedStoreIC_KeyedStoreSloppyArgumentsStub);
ic/ic.cc:2434:    TRACE_HANDLER_STATS(isolate(), KeyedStoreIC_StoreFastElementStub);
ic/ic.cc:2453:    TRACE_HANDLER_STATS(isolate(), KeyedStoreIC_StoreElementStub);
ic/ic.cc:2475:void KeyedStoreIC::StoreElementPolymorphicHandlers(
ic/ic.cc:2496:      TRACE_HANDLER_STATS(isolate(), KeyedStoreIC_SlowStub);
ic/ic.cc:2530:                            KeyedStoreIC_ElementsTransitionAndStoreStub);
ic/ic.cc:2577:MaybeHandle<Object> KeyedStoreIC::Store(Handle<JSAny> object,
ic/ic.cc:2785:  // A monomorphic or polymorphic KeyedLoadIC with a string key can call the
ic/ic.cc:2802:    DCHECK(IsKeyedLoadICKind(kind));
ic/ic.cc:2803:    KeyedLoadIC ic(isolate, vector, vector_slot, kind);
ic/ic.cc:2904:RUNTIME_FUNCTION(Runtime_KeyedLoadIC_Miss) {
ic/ic.cc:2919:  KeyedLoadIC ic(isolate, vector, vector_slot, FeedbackSlotKind::kLoadKeyed);
ic/ic.cc:3099:RUNTIME_FUNCTION(Runtime_KeyedStoreIC_Miss) {
ic/ic.cc:3127:  // TODO(v8:12548): refactor DefineKeyedOwnIC as a subclass of KeyedStoreIC,
ic/ic.cc:3129:  if (IsKeyedStoreICKind(kind) || IsDefineKeyedOwnICKind(kind)) {
ic/ic.cc:3130:    KeyedStoreIC ic(isolate, vector, vector_slot, kind);
ic/ic.cc:3164:  // TODO(v8:12548): refactor DefineKeyedOwnIC as a subclass of KeyedStoreIC,
ic/ic.cc:3166:  KeyedStoreIC ic(isolate, vector, vector_slot, kind);
ic/ic.cc:3193:RUNTIME_FUNCTION(Runtime_KeyedStoreIC_Slow) {
ic/ic.cc:3250:    DCHECK(IsKeyedStoreICKind(kind) || IsSetNamedICKind(kind) ||
ic/ic.cc:4140:  KeyedLoadIC ic(isolate, vector, vector_slot, FeedbackSlotKind::kHasKeyed);
maglev/maglev-ir.cc:4523:  using D = CallInterfaceDescriptorFor<Builtin::kKeyedStoreIC>::type;
maglev/maglev-ir.cc:4527:  using D = CallInterfaceDescriptorFor<Builtin::kKeyedStoreIC>::type;
maglev/maglev-ir.cc:4536:  __ CallBuiltin<Builtin::kKeyedStoreIC>(
maglev/maglev-ir.cc:4699:  using D = CallInterfaceDescriptorFor<Builtin::kKeyedLoadIC>::type;
maglev/maglev-ir.cc:4703:  using D = CallInterfaceDescriptorFor<Builtin::kKeyedLoadIC>::type;
maglev/maglev-ir.cc:4711:  __ CallBuiltin<Builtin::kKeyedLoadIC>(
compiler/js-generic-lowering.cc:285:                  ? Builtin::kKeyedLoadICTrampoline_Megamorphic
compiler/js-generic-lowering.cc:286:                  : Builtin::kKeyedLoadICTrampoline);
compiler/js-generic-lowering.cc:293:                  ? Builtin::kKeyedLoadIC_Megamorphic
compiler/js-generic-lowering.cc:294:                  : Builtin::kKeyedLoadIC);
compiler/js-generic-lowering.cc:416:    // KeyedStoreIC is currently a base class for multiple keyed property store
compiler/js-generic-lowering.cc:419:    // TODO(v8:12548): refactor SetKeyedIC as a subclass of KeyedStoreIC, which
compiler/js-generic-lowering.cc:424:                  ? Builtin::kKeyedStoreICTrampoline_Megamorphic
compiler/js-generic-lowering.cc:425:                  : Builtin::kKeyedStoreICTrampoline);
compiler/js-generic-lowering.cc:432:                  ? Builtin::kKeyedStoreIC_Megamorphic
compiler/js-generic-lowering.cc:433:                  : Builtin::kKeyedStoreIC);
maglev/maglev-graph-builder.cc:6394:      return BuildCallBuiltin<Builtin::kKeyedLoadIC_Megamorphic>(
maglev/maglev-graph-builder.cc:6398:      return BuildCallBuiltin<Builtin::kKeyedStoreIC_Megamorphic>(
compiler/js-heap-broker.cc:357:  if (IsKeyedLoadICKind(kind)) {
compiler/js-heap-broker.cc:367:  if (IsKeyedStoreICKind(kind)) {
compiler/js-heap-broker.cc:423:  DCHECK(IsKeyedLoadICKind(slot_kind) || IsKeyedHasICKind(slot_kind) ||
compiler/js-heap-broker.cc:425:         IsKeyedStoreICKind(slot_kind) ||
compiler/js-heap-broker.cc:454:         IsDefineNamedOwnICKind(slot_kind) || IsKeyedLoadICKind(slot_kind) ||
compiler/js-heap-broker.cc:455:         IsKeyedHasICKind(slot_kind) || IsKeyedStoreICKind(slot_kind) ||
interpreter/interpreter-generator.cc:654:// Calls the KeyedLoadIC at FeedBackVector slot <slot> for <object> and the key
interpreter/interpreter-generator.cc:664:  var_result = CallBuiltin(Builtin::kKeyedLoadIC, context, object, name, slot,
interpreter/interpreter-generator.cc:672:// Calls the EnumeratedKeyedLoadIC at FeedBackVector slot <slot> for <object>
interpreter/interpreter-generator.cc:685:  var_result = CallBuiltin(Builtin::kEnumeratedKeyedLoadIC, context, object,
interpreter/interpreter-generator.cc:743:// Calls the KeyedStoreIC at FeedbackVector slot <slot> for <object> and
interpreter/interpreter-generator.cc:754:  // KeyedStoreIC is currently a base class for multiple keyed property store
interpreter/interpreter-generator.cc:757:  // TODO(v8:12548): refactor SetKeyedIC as a subclass of KeyedStoreIC, which
interpreter/interpreter-generator.cc:759:  TNode<Object> result = CallBuiltin(Builtin::kKeyedStoreIC, context, object,
interpreter/bytecode-generator.cc:3693:      feedback_index(feedback_spec()->AddKeyedLoadICSlot()));
interpreter/bytecode-generator.cc:3701:  FeedbackSlot slot = feedback_spec()->AddKeyedStoreICSlot(language_mode());
interpreter/bytecode-generator.cc:5468:          value, feedback_index(feedback_spec()->AddKeyedLoadICSlot()));
interpreter/bytecode-generator.cc:5522:      FeedbackSlot slot = feedback_spec()->AddKeyedStoreICSlot(language_mode());
interpreter/bytecode-generator.cc:5613:      FeedbackSlot slot = feedback_spec()->AddKeyedLoadICSlot();
interpreter/bytecode-generator.cc:6148:      BuildLoadKeyedProperty(obj, feedback_spec()->AddKeyedLoadICSlot());
interpreter/bytecode-generator.cc:6353:        object, feedback_index(feedback_spec()->AddKeyedLoadICSlot()));
interpreter/bytecode-generator.cc:6627:          feedback_index(feedback_spec()->AddKeyedLoadICSlot());
interpreter/bytecode-generator.cc:7140:          object, feedback_index(feedback_spec()->AddKeyedLoadICSlot()));
interpreter/bytecode-generator.cc:7245:      FeedbackSlot slot = feedback_spec()->AddKeyedStoreICSlot(language_mode());
builtins/builtins-ic-gen.cc:52:void Builtins::Generate_KeyedLoadIC(compiler::CodeAssemblerState* state) {
builtins/builtins-ic-gen.cc:54:  assembler.GenerateKeyedLoadIC();
builtins/builtins-ic-gen.cc:56:void Builtins::Generate_EnumeratedKeyedLoadIC(
builtins/builtins-ic-gen.cc:59:  assembler.GenerateEnumeratedKeyedLoadIC();
builtins/builtins-ic-gen.cc:61:void Builtins::Generate_EnumeratedKeyedLoadICBaseline(
builtins/builtins-ic-gen.cc:64:  assembler.GenerateEnumeratedKeyedLoadICBaseline();
builtins/builtins-ic-gen.cc:66:void Builtins::Generate_KeyedLoadIC_Megamorphic(
builtins/builtins-ic-gen.cc:69:  assembler.GenerateKeyedLoadIC_Megamorphic();
builtins/builtins-ic-gen.cc:71:void Builtins::Generate_KeyedLoadIC_PolymorphicName(
builtins/builtins-ic-gen.cc:74:  assembler.GenerateKeyedLoadIC_PolymorphicName();
builtins/builtins-ic-gen.cc:76:void Builtins::Generate_KeyedLoadICTrampoline(
builtins/builtins-ic-gen.cc:79:  assembler.GenerateKeyedLoadICTrampoline();
builtins/builtins-ic-gen.cc:81:void Builtins::Generate_KeyedLoadICBaseline(
builtins/builtins-ic-gen.cc:84:  assembler.GenerateKeyedLoadICBaseline();
builtins/builtins-ic-gen.cc:86:void Builtins::Generate_KeyedLoadICTrampoline_Megamorphic(
builtins/builtins-ic-gen.cc:89:  assembler.GenerateKeyedLoadICTrampoline_Megamorphic();
builtins/builtins-ic-gen.cc:146:void Builtins::Generate_KeyedStoreIC(compiler::CodeAssemblerState* state) {
builtins/builtins-ic-gen.cc:148:  assembler.GenerateKeyedStoreIC();
builtins/builtins-ic-gen.cc:150:void Builtins::Generate_KeyedStoreICTrampoline(
builtins/builtins-ic-gen.cc:153:  assembler.GenerateKeyedStoreICTrampoline();
builtins/builtins-ic-gen.cc:155:void Builtins::Generate_KeyedStoreICTrampoline_Megamorphic(
builtins/builtins-ic-gen.cc:158:  assembler.GenerateKeyedStoreICTrampoline_Megamorphic();
builtins/builtins-ic-gen.cc:160:void Builtins::Generate_KeyedStoreICBaseline(
builtins/builtins-ic-gen.cc:163:  assembler.GenerateKeyedStoreICBaseline();
builtins/builtins-handler-gen.cc:24:  void Generate_KeyedStoreIC_SloppyArguments();
builtins/builtins-handler-gen.cc:57:void Builtins::Generate_KeyedStoreIC_Megamorphic(
builtins/builtins-handler-gen.cc:317:  TailCallRuntime(Runtime::kKeyedStoreIC_Miss, context,
builtins/builtins-handler-gen.cc:367:TF_BUILTIN(KeyedLoadIC_SloppyArguments, HandlerBuiltinsAssembler) {
builtins/builtins-handler-gen.cc:382:    TailCallRuntime(Runtime::kKeyedLoadIC_Miss, context, receiver, key, slot,
builtins/builtins-handler-gen.cc:387:void HandlerBuiltinsAssembler::Generate_KeyedStoreIC_SloppyArguments() {
builtins/builtins-handler-gen.cc:402:  TailCallRuntime(Runtime::kKeyedStoreIC_Miss, context, value, slot, vector,
builtins/builtins-handler-gen.cc:406:TF_BUILTIN(KeyedStoreIC_SloppyArguments_InBounds, HandlerBuiltinsAssembler) {
builtins/builtins-handler-gen.cc:407:  Generate_KeyedStoreIC_SloppyArguments();
builtins/builtins-handler-gen.cc:410:TF_BUILTIN(KeyedStoreIC_SloppyArguments_NoTransitionGrowAndHandleCOW,
builtins/builtins-handler-gen.cc:412:  Generate_KeyedStoreIC_SloppyArguments();
builtins/builtins-handler-gen.cc:415:TF_BUILTIN(KeyedStoreIC_SloppyArguments_NoTransitionIgnoreTypedArrayOOB,
builtins/builtins-handler-gen.cc:417:  Generate_KeyedStoreIC_SloppyArguments();
builtins/builtins-handler-gen.cc:420:TF_BUILTIN(KeyedStoreIC_SloppyArguments_NoTransitionHandleCOW,
builtins/builtins-handler-gen.cc:422:  Generate_KeyedStoreIC_SloppyArguments();
builtins/builtins-handler-gen.cc:438:  TailCallRuntime(Runtime::kKeyedLoadIC_Miss, context, receiver, key, slot,
objects/feedback-vector.h:102:inline bool IsKeyedLoadICKind(FeedbackSlotKind kind) {
objects/feedback-vector.h:132:inline bool IsKeyedStoreICKind(FeedbackSlotKind kind) {
objects/feedback-vector.h:158:         IsStoreGlobalICKind(kind) || IsKeyedStoreICKind(kind) ||
objects/feedback-vector.h:383:  DEFINE_SLOT_KIND_PREDICATE(IsKeyedLoadIC)
objects/feedback-vector.h:387:  DEFINE_SLOT_KIND_PREDICATE(IsKeyedStoreIC)
objects/feedback-vector.h:504:  FeedbackSlot AddKeyedLoadICSlot() {
objects/feedback-vector.h:539:  FeedbackSlotKind GetKeyedStoreICSlotKind(LanguageMode language_mode) {
objects/feedback-vector.h:545:  FeedbackSlot AddKeyedStoreICSlot(LanguageMode language_mode) {
objects/feedback-vector.h:546:    return AddSlot(GetKeyedStoreICSlotKind(language_mode));
builtins/builtins-definitions.h:356:  TFH(KeyedLoadIC_PolymorphicName, LoadWithVector)                             \
builtins/builtins-definitions.h:357:  TFH(KeyedStoreIC_Megamorphic, StoreWithVector)                               \
builtins/builtins-definitions.h:367:  TFH(KeyedLoadIC_SloppyArguments, LoadWithVector)                             \
builtins/builtins-definitions.h:369:  TFH(KeyedStoreIC_SloppyArguments_InBounds, StoreWithVector)                  \
builtins/builtins-definitions.h:370:  TFH(KeyedStoreIC_SloppyArguments_NoTransitionGrowAndHandleCOW,               \
builtins/builtins-definitions.h:372:  TFH(KeyedStoreIC_SloppyArguments_NoTransitionIgnoreTypedArrayOOB,            \
builtins/builtins-definitions.h:374:  TFH(KeyedStoreIC_SloppyArguments_NoTransitionHandleCOW, StoreWithVector)     \
builtins/builtins-definitions.h:747:  TFH(KeyedLoadIC, KeyedLoadWithVector)                                        \
builtins/builtins-definitions.h:748:  TFH(EnumeratedKeyedLoadIC, EnumeratedKeyedLoad)                              \
builtins/builtins-definitions.h:749:  TFH(KeyedLoadIC_Megamorphic, KeyedLoadWithVector)                            \
builtins/builtins-definitions.h:750:  TFH(KeyedLoadICTrampoline, KeyedLoad)                                        \
builtins/builtins-definitions.h:751:  TFH(KeyedLoadICBaseline, KeyedLoadBaseline)                                  \
builtins/builtins-definitions.h:752:  TFH(EnumeratedKeyedLoadICBaseline, EnumeratedKeyedLoadBaseline)              \
builtins/builtins-definitions.h:753:  TFH(KeyedLoadICTrampoline_Megamorphic, KeyedLoad)                            \
builtins/builtins-definitions.h:765:  TFH(KeyedStoreIC, StoreWithVector)                                           \
builtins/builtins-definitions.h:766:  TFH(KeyedStoreICTrampoline, Store)                                           \
builtins/builtins-definitions.h:767:  TFH(KeyedStoreICTrampoline_Megamorphic, Store)                               \
builtins/builtins-definitions.h:768:  TFH(KeyedStoreICBaseline, StoreBaseline)                                     \
objects/feedback-vector.cc:801:          DCHECK(IsKeyedLoadICKind(kind()) || IsKeyedStoreICKind(kind()) ||
objects/feedback-vector.cc:1211:  if (IsKeyedStoreICKind(kind()) || IsKeyedLoadICKind(kind()) ||
objects/feedback-vector.cc:1228:  DCHECK(IsKeyedLoadICKind(kind()) || IsKeyedHasICKind(kind()));
objects/feedback-vector.cc:1249:    case Builtin::kKeyedStoreIC_SloppyArguments_InBounds:
objects/feedback-vector.cc:1250:    case Builtin::kKeyedStoreIC_SloppyArguments_NoTransitionGrowAndHandleCOW:
objects/feedback-vector.cc:1251:    case Builtin::kKeyedStoreIC_SloppyArguments_NoTransitionIgnoreTypedArrayOOB:
objects/feedback-vector.cc:1252:    case Builtin::kKeyedStoreIC_SloppyArguments_NoTransitionHandleCOW:
objects/feedback-vector.cc:1271:    case Builtin::kKeyedStoreIC_SloppyArguments_InBounds:
objects/feedback-vector.cc:1275:    case Builtin::kKeyedStoreIC_SloppyArguments_NoTransitionGrowAndHandleCOW:
objects/feedback-vector.cc:1279:    case Builtin::kKeyedStoreIC_SloppyArguments_NoTransitionIgnoreTypedArrayOOB:
objects/feedback-vector.cc:1283:    case Builtin::kKeyedStoreIC_SloppyArguments_NoTransitionHandleCOW:
objects/feedback-vector.cc:1295:  DCHECK(IsKeyedStoreICKind(kind()) || IsStoreInArrayLiteralICKind(kind()) ||
objects/feedback-vector.cc:1353:  DCHECK(IsKeyedStoreICKind(kind()) || IsKeyedLoadICKind(kind()) ||
objects/feedback-vector.cc:1408:      IsKeyedLoadICKind(nexus->kind()) || IsKeyedStoreICKind(nexus->kind()) ||
compiler/turboshaft/maglev-graph-building-phase.cc:1854:    GENERATE_AND_MAP_BUILTIN_CALL(node, Builtin::kKeyedStoreIC, frame_state,
compiler/turboshaft/maglev-graph-building-phase.cc:1867:    GENERATE_AND_MAP_BUILTIN_CALL(node, Builtin::kKeyedLoadIC, frame_state,
Observations: runtime/runtime-array.cc:17:RUNTIME_FUNCTION(Runtime_TransitionElementsKind) {
runtime/runtime-array.cc:35:RUNTIME_FUNCTION(Runtime_TransitionElementsKindWithKind) {
runtime/runtime.h:50:  F(TransitionElementsKindWithKind, 2, 1)
compiler/typed-optimization.cc:106:    case IrOpcode::kTransitionElementsKindOrCheckMap:
maglev/maglev-ir.cc:6559:                __ CallRuntime(Runtime::kTransitionElementsKind);
compiler/turboshaft/maglev-early-lowering-reducer-inl.h:333:          __ CallRuntime_TransitionElementsKind(
compiler/turboshaft/machine-lowering-reducer-inl.h:3192:          __ CallRuntime_TransitionElementsKind(
compiler/turboshaft/machine-lowering-reducer-inl.h:3224:          __ CallRuntime_TransitionElementsKind(
compiler/turboshaft/machine-lowering-reducer-inl.h:3769:      __ CallRuntime_TransitionElementsKind(isolate_, __ NoContextConstant(),
maglev/maglev-graph-builder.cc:4180:    case Opcode::kTransitionElementsKind:
compiler/simplified-operator.cc:410:  DCHECK_EQ(IrOpcode::kTransitionElementsKind, op->opcode());
compiler/simplified-operator.cc:416:  DCHECK_EQ(IrOpcode::kTransitionElementsKindOrCheckMap, op->opcode());
compiler/simplified-operator.cc:1991:      IrOpcode::kTransitionElementsKind,              // opcode
compiler/simplified-operator.cc:2001:      IrOpcode::kTransitionElementsKindOrCheckMap,  // opcode
compiler/simplified-lowering.cc:4498:      case IrOpcode::kTransitionElementsKind: {
compiler/simplified-lowering.cc:4503:      case IrOpcode::kTransitionElementsKindOrCheckMap: {
compiler/verifier.cc:1377:    case IrOpcode::kTransitionElementsKind:
compiler/verifier.cc:1381:    case IrOpcode::kTransitionElementsKindOrCheckMap:
compiler/turboshaft/runtime-call-descriptors.h:215:    static constexpr auto kFunction = Runtime::kTransitionElementsKind;
compiler/node-properties.cc:447:      case IrOpcode::kTransitionElementsKindOrCheckMap: {
compiler/turboshaft/graph-builder.cc:2231:    case IrOpcode::kTransitionElementsKind:
compiler/turboshaft/graph-builder.cc:2235:    case IrOpcode::kTransitionElementsKindOrCheckMap: {
compiler/load-elimination.cc:115:    case IrOpcode::kTransitionElementsKind:
compiler/load-elimination.cc:117:    case IrOpcode::kTransitionElementsKindOrCheckMap:
compiler/load-elimination.cc:1395:          case IrOpcode::kTransitionElementsKind: {
compiler/load-elimination.cc:1405:          case IrOpcode::kTransitionElementsKindOrCheckMap: {
compiler/turboshaft/assembler.h:3925:  V<Object> CallRuntime_TransitionElementsKind(Isolate* isolate,
compiler/escape-analysis.cc:810:    case IrOpcode::kTransitionElementsKindOrCheckMap: {
builtins/base.tq:877:extern transitioning runtime TransitionElementsKindWithKind(
builtins/array-splice.tq:154:    TransitionElementsKindWithKind(context, a, smiElementsKind);
Observations: flags/flag-definitions.h:818:// Enable verification of SimplifiedLowering in debug builds.
logging/runtime-call-stats.h:378:  ADD_THREAD_SPECIFIC_COUNTER(V, Optimize, SimplifiedLowering)                \
logging/runtime-call-stats.h:544:  V(KeyedLoadIC_LoadIndexedInterceptorStub)       \
logging/runtime-call-stats.h:545:  V(KeyedLoadIC_LoadIndexedStringDH)              \
compiler/heap-refs.cc:931:// Only used in JSNativeContextSpecialization.
compiler/js-call-reducer.cc:56:class JSCallReducerAssembler : public JSGraphAssembler {
compiler/js-call-reducer.cc:60:  JSCallReducerAssembler(JSCallReducer* reducer, Node* node,
compiler/js-call-reducer.cc:187:    TryCatchBuilder0(JSCallReducerAssembler* gasm, const TryFunction& try_body)
compiler/js-call-reducer.cc:218:    JSCallReducerAssembler* const gasm_;
compiler/js-call-reducer.cc:434:class IteratingArrayBuiltinReducerAssembler : public JSCallReducerAssembler {
compiler/js-call-reducer.cc:436:  IteratingArrayBuiltinReducerAssembler(JSCallReducer* reducer, Node* node)
compiler/js-call-reducer.cc:437:      : JSCallReducerAssembler(reducer, node) {
compiler/js-call-reducer.cc:541:class PromiseBuiltinReducerAssembler : public JSCallReducerAssembler {
compiler/js-call-reducer.cc:543:  PromiseBuiltinReducerAssembler(JSCallReducer* reducer, Node* node)
compiler/js-call-reducer.cc:544:      : JSCallReducerAssembler(reducer, node) {
compiler/js-call-reducer.cc:629:class FastApiCallReducerAssembler : public JSCallReducerAssembler {
compiler/js-call-reducer.cc:632:      JSCallReducer* reducer, Node* node,
compiler/js-call-reducer.cc:637:      : JSCallReducerAssembler(reducer, node),
compiler/js-call-reducer.cc:689:    // separate inputs, so that SimplifiedLowering can provide the best
compiler/js-call-reducer.cc:772:TNode<Number> JSCallReducerAssembler::SpeculativeToNumber(
compiler/js-call-reducer.cc:779:TNode<Smi> JSCallReducerAssembler::CheckSmi(TNode<Object> value) {
compiler/js-call-reducer.cc:784:TNode<Number> JSCallReducerAssembler::CheckNumber(TNode<Object> value) {
compiler/js-call-reducer.cc:789:TNode<String> JSCallReducerAssembler::CheckString(TNode<Object> value) {
compiler/js-call-reducer.cc:794:TNode<Number> JSCallReducerAssembler::CheckBounds(TNode<Number> value,
compiler/js-call-reducer.cc:802:TNode<Smi> JSCallReducerAssembler::TypeGuardUnsignedSmall(TNode<Object> value) {
compiler/js-call-reducer.cc:806:TNode<Object> JSCallReducerAssembler::TypeGuardNonInternal(
compiler/js-call-reducer.cc:811:TNode<Number> JSCallReducerAssembler::TypeGuardFixedArrayLength(
compiler/js-call-reducer.cc:819:TNode<Object> JSCallReducerAssembler::Call4(
compiler/js-call-reducer.cc:833:TNode<Object> JSCallReducerAssembler::JSCall3(
compiler/js-call-reducer.cc:849:TNode<Object> JSCallReducerAssembler::JSCall4(
compiler/js-call-reducer.cc:866:TNode<Object> JSCallReducerAssembler::CopyNode() {
compiler/js-call-reducer.cc:875:TNode<JSArray> JSCallReducerAssembler::CreateArrayNoThrow(
compiler/js-call-reducer.cc:882:TNode<JSArray> JSCallReducerAssembler::AllocateEmptyJSArray(
compiler/js-call-reducer.cc:904:TNode<Number> JSCallReducerAssembler::LoadMapElementsKind(TNode<Map> map) {
compiler/js-call-reducer.cc:913:TNode<Object> JSCallReducerAssembler::ReduceMathUnary(const Operator* op) {
compiler/js-call-reducer.cc:919:TNode<Object> JSCallReducerAssembler::ReduceMathBinary(const Operator* op) {
compiler/js-call-reducer.cc:928:TNode<String> JSCallReducerAssembler::ReduceStringPrototypeSubstring() {
compiler/js-call-reducer.cc:953:TNode<Boolean> JSCallReducerAssembler::ReduceStringPrototypeStartsWith(
compiler/js-call-reducer.cc:967:  DCHECK(search_string_length <= JSCallReducer::kMaxInlineMatchSequence);
compiler/js-call-reducer.cc:998:TNode<Boolean> JSCallReducerAssembler::ReduceStringPrototypeStartsWith() {
compiler/js-call-reducer.cc:1046:TNode<Boolean> JSCallReducerAssembler::ReduceStringPrototypeEndsWith(
compiler/js-call-reducer.cc:1056:  DCHECK_LE(search_string_length, JSCallReducer::kMaxInlineMatchSequence);
compiler/js-call-reducer.cc:1094:TNode<Boolean> JSCallReducerAssembler::ReduceStringPrototypeEndsWith() {
compiler/js-call-reducer.cc:1145:TNode<String> JSCallReducerAssembler::ReduceStringPrototypeCharAt(
compiler/js-call-reducer.cc:1172:TNode<String> JSCallReducerAssembler::ReduceStringPrototypeCharAt() {
compiler/js-call-reducer.cc:1188:TNode<String> JSCallReducerAssembler::ReduceStringPrototypeSlice() {
compiler/js-call-reducer.cc:1232:TNode<Object> JSCallReducerAssembler::ReduceJSCallMathMinMaxWithArrayLike(
compiler/js-call-reducer.cc:2326:// Remnant of old-style JSCallReducer code. Could be ported to graph assembler,
compiler/js-call-reducer.cc:2478:std::pair<Node*, Node*> JSCallReducer::ReleaseEffectAndControlFromAssembler(
compiler/js-call-reducer.cc:2479:    JSCallReducerAssembler* gasm) {
compiler/js-call-reducer.cc:2498:Reduction JSCallReducer::ReplaceWithSubgraph(JSCallReducerAssembler* gasm,
compiler/js-call-reducer.cc:2529:Reduction JSCallReducer::ReduceMathUnary(Node* node, const Operator* op) {
compiler/js-call-reducer.cc:2541:  JSCallReducerAssembler a(this, node);
compiler/js-call-reducer.cc:2546:Reduction JSCallReducer::ReduceMathBinary(Node* node, const Operator* op) {
compiler/js-call-reducer.cc:2558:  JSCallReducerAssembler a(this, node);
compiler/js-call-reducer.cc:2564:Reduction JSCallReducer::ReduceMathImul(Node* node) {
compiler/js-call-reducer.cc:2596:Reduction JSCallReducer::ReduceMathClz32(Node* node) {
compiler/js-call-reducer.cc:2623:Reduction JSCallReducer::ReduceMathMinMax(Node* node, const Operator* op,
compiler/js-call-reducer.cc:2653:Reduction JSCallReducer::Reduce(Node* node) {
compiler/js-call-reducer.cc:2675:void JSCallReducer::Finalize() {
compiler/js-call-reducer.cc:2696:Reduction JSCallReducer::ReduceArrayConstructor(Node* node) {
compiler/js-call-reducer.cc:2712:Reduction JSCallReducer::ReduceBooleanConstructor(Node* node) {
compiler/js-call-reducer.cc:2722:Reduction JSCallReducer::ReduceObjectConstructor(Node* node) {
compiler/js-call-reducer.cc:2746:Reduction JSCallReducer::ReduceFunctionPrototypeApply(Node* node) {
compiler/js-call-reducer.cc:2876:Reduction JSCallReducer::ReduceFunctionPrototypeBind(Node* node) {
compiler/js-call-reducer.cc:3009:Reduction JSCallReducer::ReduceFunctionPrototypeCall(Node* node) {
compiler/js-call-reducer.cc:3056:Reduction JSCallReducer::ReduceFunctionPrototypeHasInstance(Node* node) {
compiler/js-call-reducer.cc:3082:Reduction JSCallReducer::ReduceObjectGetPrototype(Node* node, Node* object) {
compiler/js-call-reducer.cc:3117:Reduction JSCallReducer::ReduceObjectGetPrototypeOf(Node* node) {
compiler/js-call-reducer.cc:3124:Reduction JSCallReducer::ReduceObjectIs(Node* node) {
compiler/js-call-reducer.cc:3134:Reduction JSCallReducer::ReduceObjectPrototypeGetProto(Node* node) {
compiler/js-call-reducer.cc:3140:Reduction JSCallReducer::ReduceObjectPrototypeHasOwnProperty(Node* node) {
compiler/js-call-reducer.cc:3277:Reduction JSCallReducer::ReduceObjectPrototypeIsPrototypeOf(Node* node) {
compiler/js-call-reducer.cc:3303:Reduction JSCallReducer::ReduceReflectApply(Node* node) {
compiler/js-call-reducer.cc:3325:Reduction JSCallReducer::ReduceReflectConstruct(Node* node) {
compiler/js-call-reducer.cc:3361:Reduction JSCallReducer::ReduceReflectGetPrototypeOf(Node* node) {
compiler/js-call-reducer.cc:3368:Reduction JSCallReducer::ReduceObjectCreate(Node* node) {
compiler/js-call-reducer.cc:3389:Reduction JSCallReducer::ReduceReflectGet(Node* node) {
compiler/js-call-reducer.cc:3463:Reduction JSCallReducer::ReduceReflectHas(Node* node) {
compiler/js-call-reducer.cc:3624:Reduction JSCallReducer::ReduceArrayForEach(Node* node,
compiler/js-call-reducer.cc:3636:Reduction JSCallReducer::ReduceArrayReduce(Node* node,
compiler/js-call-reducer.cc:3649:Reduction JSCallReducer::ReduceArrayReduceRight(Node* node,
compiler/js-call-reducer.cc:3662:Reduction JSCallReducer::ReduceArrayMap(Node* node,
compiler/js-call-reducer.cc:3681:Reduction JSCallReducer::ReduceArrayFilter(Node* node,
compiler/js-call-reducer.cc:3700:Reduction JSCallReducer::ReduceArrayFind(Node* node,
compiler/js-call-reducer.cc:3714:Reduction JSCallReducer::ReduceArrayFindIndex(Node* node,
compiler/js-call-reducer.cc:3728:Reduction JSCallReducer::ReduceArrayEvery(Node* node,
compiler/js-call-reducer.cc:3744:Reduction JSCallReducer::ReduceArrayIncludes(Node* node) {
compiler/js-call-reducer.cc:3758:Reduction JSCallReducer::ReduceArrayIndexOf(Node* node) {
compiler/js-call-reducer.cc:3770:Reduction JSCallReducer::ReduceArraySome(Node* node,
compiler/js-call-reducer.cc:3809:Reduction JSCallReducer::ReduceCallWasmFunction(Node* node,
compiler/js-call-reducer.cc:3880:Reduction JSCallReducer::ReduceCallApiFunction(Node* node,
compiler/js-call-reducer.cc:4047:  // JSNativeContextSpecialization::InlineApiCall method a bit.
compiler/js-call-reducer.cc:4141:Node* JSCallReducer::ConvertHoleToUndefined(Node* value, ElementsKind kind) {
compiler/js-call-reducer.cc:4149:void JSCallReducer::CheckIfConstructor(Node* construct) {
compiler/js-call-reducer.cc:4225:Node* JSCallReducer::CheckArrayLength(Node* array, ElementsKind elements_kind,
compiler/js-call-reducer.cc:4241:JSCallReducer::ReduceCallOrConstructWithArrayLikeOrSpreadOfCreateArguments(
compiler/js-call-reducer.cc:4417:Reduction JSCallReducer::ReduceCallOrConstructWithArrayLikeOrSpread(
compiler/js-call-reducer.cc:4461:    JSCallReducerAssembler a(this, node);
compiler/js-call-reducer.cc:4555:bool JSCallReducer::IsBuiltinOrApiFunction(JSFunctionRef function) const {
compiler/js-call-reducer.cc:4563:Reduction JSCallReducer::ReduceJSCall(Node* node) {
compiler/js-call-reducer.cc:4757:Reduction JSCallReducer::ReduceJSCall(Node* node,
compiler/js-call-reducer.cc:5163:TNode<Object> JSCallReducerAssembler::ReduceJSCallWithArrayLikeOrSpreadOfEmpty(
compiler/js-call-reducer.cc:5241:Reduction JSCallReducer::ReduceJSCallWithArrayLike(Node* node) {
compiler/js-call-reducer.cc:5263:Reduction JSCallReducer::ReduceJSCallWithSpread(Node* node) {
compiler/js-call-reducer.cc:5278:Reduction JSCallReducer::ReduceJSConstruct(Node* node) {
compiler/js-call-reducer.cc:5530:Reduction JSCallReducer::ReduceStringPrototypeIndexOfIncludes(
compiler/js-call-reducer.cc:5588:Reduction JSCallReducer::ReduceStringPrototypeSubstring(Node* node) {
compiler/js-call-reducer.cc:5596:  JSCallReducerAssembler a(this, node);
compiler/js-call-reducer.cc:5602:Reduction JSCallReducer::ReduceStringPrototypeSlice(Node* node) {
compiler/js-call-reducer.cc:5610:  JSCallReducerAssembler a(this, node);
compiler/js-call-reducer.cc:5616:Reduction JSCallReducer::ReduceStringPrototypeSubstr(Node* node) {
compiler/js-call-reducer.cc:5717:Reduction JSCallReducer::ReduceJSConstructWithArrayLike(Node* node) {
compiler/js-call-reducer.cc:5728:Reduction JSCallReducer::ReduceJSConstructWithSpread(Node* node) {
compiler/js-call-reducer.cc:5739:Reduction JSCallReducer::ReduceJSConstructForwardAllArgs(Node* node) {
compiler/js-call-reducer.cc:5773:Reduction JSCallReducer::ReduceReturnReceiver(Node* node) {
compiler/js-call-reducer.cc:5780:Reduction JSCallReducer::ReduceForInsufficientFeedback(
compiler/js-call-reducer.cc:5799:Node* JSCallReducer::LoadReceiverElementsKind(Node* receiver, Effect* effect,
compiler/js-call-reducer.cc:5818:void JSCallReducer::CheckIfElementsKind(Node* receiver_elements_kind,
compiler/js-call-reducer.cc:5849:Reduction JSCallReducer::ReduceArrayPrototypeAt(Node* node) {
compiler/js-call-reducer.cc:5898:Reduction JSCallReducer::ReduceArrayPrototypePush(Node* node) {
compiler/js-call-reducer.cc:5932:Reduction JSCallReducer::ReduceArrayPrototypePop(Node* node) {
compiler/js-call-reducer.cc:6077:Reduction JSCallReducer::ReduceArrayPrototypeShift(Node* node) {
compiler/js-call-reducer.cc:6324:Reduction JSCallReducer::ReduceArrayPrototypeSlice(Node* node) {
compiler/js-call-reducer.cc:6402:Reduction JSCallReducer::ReduceArrayIsArray(Node* node) {
compiler/js-call-reducer.cc:6426:Reduction JSCallReducer::ReduceArrayIterator(Node* node,
compiler/js-call-reducer.cc:6467:      JSCallReducerAssembler a(this, node);
compiler/js-call-reducer.cc:6491:Reduction JSCallReducer::ReduceArrayIteratorPrototypeNext(Node* node) {
compiler/js-call-reducer.cc:6748:Reduction JSCallReducer::ReduceStringPrototypeStringAt(
compiler/js-call-reducer.cc:6785:Reduction JSCallReducer::ReduceStringPrototypeStartsWith(Node* node) {
compiler/js-call-reducer.cc:6812:      JSCallReducerAssembler a(this, node);
compiler/js-call-reducer.cc:6818:  JSCallReducerAssembler a(this, node);
compiler/js-call-reducer.cc:6825:Reduction JSCallReducer::ReduceStringPrototypeEndsWith(Node* node) {
compiler/js-call-reducer.cc:6852:      JSCallReducerAssembler a(this, node);
compiler/js-call-reducer.cc:6858:  JSCallReducerAssembler a(this, node);
compiler/js-call-reducer.cc:6864:Reduction JSCallReducer::ReduceStringPrototypeCharAt(Node* node) {
compiler/js-call-reducer.cc:6890:      JSCallReducerAssembler a(this, node);
compiler/js-call-reducer.cc:6896:  JSCallReducerAssembler a(this, node);
compiler/js-call-reducer.cc:6903:Reduction JSCallReducer::ReduceStringPrototypeToLowerCaseIntl(Node* node) {
compiler/js-call-reducer.cc:6924:Reduction JSCallReducer::ReduceStringPrototypeToUpperCaseIntl(Node* node) {
compiler/js-call-reducer.cc:6948:Reduction JSCallReducer::ReduceStringFromCharCode(Node* node) {
compiler/js-call-reducer.cc:6973:Reduction JSCallReducer::ReduceStringFromCodePoint(Node* node) {
compiler/js-call-reducer.cc:6996:Reduction JSCallReducer::ReduceStringPrototypeIterator(Node* node) {
compiler/js-call-reducer.cc:7015:Reduction JSCallReducer::ReduceStringPrototypeLocaleCompareIntl(Node* node) {
compiler/js-call-reducer.cc:7079:Reduction JSCallReducer::ReduceStringIteratorPrototypeNext(Node* node) {
compiler/js-call-reducer.cc:7148:Reduction JSCallReducer::ReduceStringPrototypeConcat(Node* node) {
compiler/js-call-reducer.cc:7202:Reduction JSCallReducer::ReduceStringConstructor(Node* node,
compiler/js-call-reducer.cc:7268:Reduction JSCallReducer::ReducePromiseConstructor(Node* node) {
compiler/js-call-reducer.cc:7281:bool JSCallReducer::DoPromiseChecks(MapInference* inference) {
compiler/js-call-reducer.cc:7299:Reduction JSCallReducer::ReducePromisePrototypeCatch(Node* node) {
compiler/js-call-reducer.cc:7338:Node* JSCallReducer::CreateClosureFromBuiltinSharedFunctionInfo(
compiler/js-call-reducer.cc:7352:Reduction JSCallReducer::ReducePromisePrototypeFinally(Node* node) {
compiler/js-call-reducer.cc:7469:Reduction JSCallReducer::ReducePromisePrototypeThen(Node* node) {
compiler/js-call-reducer.cc:7534:Reduction JSCallReducer::ReducePromiseResolveTrampoline(Node* node) {
compiler/js-call-reducer.cc:7562:Reduction JSCallReducer::ReduceTypedArrayConstructor(
compiler/js-call-reducer.cc:7594:Reduction JSCallReducer::ReduceTypedArrayPrototypeToStringTag(Node* node) {
compiler/js-call-reducer.cc:7670:Reduction JSCallReducer::ReduceArrayBufferViewByteLengthAccessor(
compiler/js-call-reducer.cc:7725:  JSCallReducerAssembler a(this, node);
compiler/js-call-reducer.cc:7734:Reduction JSCallReducer::ReduceArrayBufferViewByteOffsetAccessor(
compiler/js-call-reducer.cc:7773:Reduction JSCallReducer::ReduceTypedArrayPrototypeLength(Node* node) {
compiler/js-call-reducer.cc:7806:  JSCallReducerAssembler a(this, node);
compiler/js-call-reducer.cc:7816:Reduction JSCallReducer::ReduceNumberIsFinite(Node* node) {
compiler/js-call-reducer.cc:7830:Reduction JSCallReducer::ReduceNumberIsInteger(Node* node) {
compiler/js-call-reducer.cc:7844:Reduction JSCallReducer::ReduceNumberIsSafeInteger(Node* node) {
compiler/js-call-reducer.cc:7858:Reduction JSCallReducer::ReduceNumberIsNaN(Node* node) {
compiler/js-call-reducer.cc:7871:Reduction JSCallReducer::ReduceMapPrototypeGet(Node* node) {
compiler/js-call-reducer.cc:7933:Reduction JSCallReducer::ReduceCollectionPrototypeHas(
compiler/js-call-reducer.cc:7966:Reduction JSCallReducer::ReduceMapPrototypeHas(Node* node) {
compiler/js-call-reducer.cc:7970:Reduction JSCallReducer::ReduceSetPrototypeHas(Node* node) {
compiler/js-call-reducer.cc:7974:Reduction JSCallReducer::ReduceCollectionIteration(
compiler/js-call-reducer.cc:7995:Reduction JSCallReducer::ReduceCollectionPrototypeSize(
compiler/js-call-reducer.cc:8019:Reduction JSCallReducer::ReduceCollectionIteratorPrototypeNext(
compiler/js-call-reducer.cc:8312:Reduction JSCallReducer::ReduceArrayBufferIsView(Node* node) {
compiler/js-call-reducer.cc:8322:Reduction JSCallReducer::ReduceArrayBufferViewAccessor(
compiler/js-call-reducer.cc:8357:  JSCallReducerAssembler a(this, node, effect);
compiler/js-call-reducer.cc:8401:Reduction JSCallReducer::ReduceDataViewAccess(Node* node, DataViewAccess access,
compiler/js-call-reducer.cc:8552:Reduction JSCallReducer::ReduceGlobalIsFinite(Node* node) {
compiler/js-call-reducer.cc:8578:Reduction JSCallReducer::ReduceGlobalIsNaN(Node* node) {
compiler/js-call-reducer.cc:8604:Reduction JSCallReducer::ReduceDatePrototypeGetTime(Node* node) {
compiler/js-call-reducer.cc:8622:Reduction JSCallReducer::ReduceDateNow(Node* node) {
compiler/js-call-reducer.cc:8632:Reduction JSCallReducer::ReduceNumberParseInt(Node* node) {
compiler/js-call-reducer.cc:8685:Reduction JSCallReducer::ReduceRegExpPrototypeTest(Node* node) {
compiler/js-call-reducer.cc:8709:  ZoneVector<PropertyAccessInfo> access_infos(graph()->zone());
compiler/js-call-reducer.cc:8710:  AccessInfoFactory access_info_factory(broker(), graph()->zone());
compiler/js-call-reducer.cc:8713:    access_infos.push_back(broker()->GetPropertyAccessInfo(
compiler/js-call-reducer.cc:8717:  PropertyAccessInfo ai_exec =
compiler/js-call-reducer.cc:8718:      access_info_factory.FinalizePropertyAccessInfosAsOne(access_infos,
compiler/js-call-reducer.cc:8776:Reduction JSCallReducer::ReduceNumberConstructor(Node* node) {
compiler/js-call-reducer.cc:8798:Reduction JSCallReducer::ReduceBigIntConstructor(Node* node) {
compiler/js-call-reducer.cc:8825:Reduction JSCallReducer::ReduceBigIntAsN(Node* node, Builtin builtin) {
compiler/js-call-reducer.cc:8861:std::optional<Reduction> JSCallReducer::TryReduceJSCallMathMinMaxWithArrayLike(
compiler/js-call-reducer.cc:8958:Reduction JSCallReducer::ReduceJSCallMathMinMaxWithArrayLike(Node* node,
compiler/js-call-reducer.cc:8965:  JSCallReducerAssembler a(this, node);
compiler/js-call-reducer.cc:8971:Reduction JSCallReducer::ReduceGetContinuationPreservedEmbedderData(
compiler/js-call-reducer.cc:8984:Reduction JSCallReducer::ReduceSetContinuationPreservedEmbedderData(
compiler/js-call-reducer.cc:9003:CompilationDependencies* JSCallReducer::dependencies() const {
compiler/js-call-reducer.cc:9007:Graph* JSCallReducer::graph() const { return jsgraph()->graph(); }
compiler/js-call-reducer.cc:9009:Isolate* JSCallReducer::isolate() const { return jsgraph()->isolate(); }
compiler/js-call-reducer.cc:9011:Factory* JSCallReducer::factory() const { return isolate()->factory(); }
compiler/js-call-reducer.cc:9013:NativeContextRef JSCallReducer::native_context() const {
compiler/js-call-reducer.cc:9017:CommonOperatorBuilder* JSCallReducer::common() const {
compiler/js-call-reducer.cc:9021:JSOperatorBuilder* JSCallReducer::javascript() const {
compiler/js-call-reducer.cc:9025:SimplifiedOperatorBuilder* JSCallReducer::simplified() const {
codegen/external-reference.h:575:  // The following version is used by JSCallReducer in the compiler
compiler/access-info.h:33:class ElementAccessInfo final {
compiler/access-info.h:35:  ElementAccessInfo(ZoneVector<MapRef>&& lookup_start_object_maps,
compiler/access-info.h:59:class PropertyAccessInfo final {
compiler/access-info.h:74:  static PropertyAccessInfo NotFound(Zone* zone, MapRef receiver_map,
compiler/access-info.h:76:  static PropertyAccessInfo DataField(
compiler/access-info.h:82:  static PropertyAccessInfo FastDataConstant(
compiler/access-info.h:88:  static PropertyAccessInfo FastAccessorConstant(
compiler/access-info.h:91:  static PropertyAccessInfo ModuleExport(Zone* zone, MapRef receiver_map,
compiler/access-info.h:93:  static PropertyAccessInfo StringLength(Zone* zone, MapRef receiver_map);
compiler/access-info.h:94:  static PropertyAccessInfo StringWrapperLength(Zone* zone,
compiler/access-info.h:96:  static PropertyAccessInfo Invalid(Zone* zone);
compiler/access-info.h:97:  static PropertyAccessInfo DictionaryProtoDataConstant(
compiler/access-info.h💯  static PropertyAccessInfo DictionaryProtoAccessorConstant(
compiler/access-info.h:104:  bool Merge(PropertyAccessInfo const* that, AccessMode access_mode,
compiler/access-info.h:190:  explicit PropertyAccessInfo(Zone* zone);
compiler/access-info.h:191:  PropertyAccessInfo(Zone* zone, Kind kind, OptionalJSObjectRef holder,
compiler/access-info.h:193:  PropertyAccessInfo(Zone* zone, Kind kind, OptionalJSObjectRef holder,
compiler/access-info.h:197:  PropertyAccessInfo(Kind kind, OptionalJSObjectRef holder,
compiler/access-info.h:203:  PropertyAccessInfo(Zone* zone, Kind kind, OptionalJSObjectRef holder,
compiler/access-info.h:228:// Factory class for {ElementAccessInfo}s and {PropertyAccessInfo}s.
compiler/access-info.h:229:class AccessInfoFactory final {
compiler/access-info.h:231:  AccessInfoFactory(JSHeapBroker* broker, Zone* zone);
compiler/access-info.h:233:  std::optional<ElementAccessInfo> ComputeElementAccessInfo(
compiler/access-info.h:235:  bool ComputeElementAccessInfos(
compiler/access-info.h:237:      ZoneVector<ElementAccessInfo>* access_infos) const;
compiler/access-info.h:239:  PropertyAccessInfo ComputePropertyAccessInfo(MapRef map, NameRef name,
compiler/access-info.h:242:  PropertyAccessInfo ComputeDictionaryProtoAccessInfo(
compiler/access-info.h:251:  bool FinalizePropertyAccessInfos(
compiler/access-info.h:252:      ZoneVector<PropertyAccessInfo> infos, AccessMode access_mode,
compiler/access-info.h:253:      ZoneVector<PropertyAccessInfo>* result) const;
compiler/access-info.h:258:  PropertyAccessInfo FinalizePropertyAccessInfosAsOne(
compiler/access-info.h:259:      ZoneVector<PropertyAccessInfo> infos, AccessMode access_mode) const;
compiler/access-info.h:262:  std::optional<ElementAccessInfo> ConsolidateElementLoad(
compiler/access-info.h:264:  PropertyAccessInfo LookupSpecialFieldAccessor(MapRef map, NameRef name) const;
compiler/access-info.h:265:  PropertyAccessInfo LookupTransition(MapRef map, NameRef name,
compiler/access-info.h:268:  PropertyAccessInfo ComputeDataFieldAccessInfo(MapRef receiver_map, MapRef map,
compiler/access-info.h:273:  PropertyAccessInfo ComputeAccessorDescriptorAccessInfo(
compiler/access-info.h:277:  PropertyAccessInfo Invalid() const {
compiler/access-info.h:278:    return PropertyAccessInfo::Invalid(zone());
compiler/access-info.h:281:  void MergePropertyAccessInfos(ZoneVector<PropertyAccessInfo> infos,
compiler/access-info.h:283:                                ZoneVector<PropertyAccessInfo>* result) const;
compiler/access-info.h:298:  AccessInfoFactory(const AccessInfoFactory&) = delete;
compiler/access-info.h:299:  AccessInfoFactory& operator=(const AccessInfoFactory&) = delete;
compiler/js-native-context-specialization.h:31:class ElementAccessInfo;
compiler/js-native-context-specialization.h:36:class PropertyAccessInfo;
compiler/js-native-context-specialization.h:44:class V8_EXPORT_PRIVATE JSNativeContextSpecialization final
compiler/js-native-context-specialization.h:54:  JSNativeContextSpecialization(Editor* editor, JSGraph* jsgraph,
compiler/js-native-context-specialization.h:57:  JSNativeContextSpecialization(const JSNativeContextSpecialization&) = delete;
compiler/js-native-context-specialization.h:58:  JSNativeContextSpecialization& operator=(
compiler/js-native-context-specialization.h:59:      const JSNativeContextSpecialization&) = delete;
compiler/js-native-context-specialization.h:62:    return "JSNativeContextSpecialization";
compiler/js-native-context-specialization.h:155:      ZoneVector<Node*>* if_exceptions, PropertyAccessInfo const& access_info,
compiler/js-native-context-specialization.h:160:      ZoneVector<Node*>* if_exceptions, PropertyAccessInfo const& access_info);
compiler/js-native-context-specialization.h:167:                                        PropertyAccessInfo const& access_info,
compiler/js-native-context-specialization.h:171:                                       PropertyAccessInfo const& access_info);
compiler/js-native-context-specialization.h:180:                                 PropertyAccessInfo const& access_info);
compiler/js-native-context-specialization.h:185:                                PropertyAccessInfo const& access_info);
compiler/js-native-context-specialization.h:195:                                        ElementAccessInfo const& access_info,
compiler/js-native-context-specialization.h:295:DEFINE_OPERATORS_FOR_FLAGS(JSNativeContextSpecialization::Flags)
compiler/compilation-dependencies.cc:405:      // AccessInfoFactory::ComputePropertyAccessInfo allows.
compiler/compilation-dependencies.cc:1546:    // Note: Keep sync'd with AccessInfoFactory::ComputePropertyAccessInfo.
compiler/js-heap-broker.cc:941:PropertyAccessInfo JSHeapBroker::GetPropertyAccessInfo(MapRef map, NameRef name,
compiler/js-heap-broker.cc:949:  AccessInfoFactory factory(this, zone());
compiler/js-heap-broker.cc:950:  PropertyAccessInfo access_info =
compiler/js-heap-broker.cc:951:      factory.ComputePropertyAccessInfo(map, name, access_mode);
compiler/js-heap-broker.cc:952:  TRACE(this, "Storing PropertyAccessInfo for "
compiler/use-info.h:109:  friend class SimplifiedLoweringVerifier;
objects/shared-function-info-inl.h:323:  // Built-in functions are handled by the JSCallReducer.
compiler/property-access-builder.cc:172:    PropertyAccessInfo const& access_info, Node* lookup_start_object) {
compiler/property-access-builder.cc:197:    PropertyAccessInfo const& access_info) {
compiler/property-access-builder.cc:208:    // Non-JSReceivers that passed AccessInfoFactory::ComputePropertyAccessInfo
compiler/property-access-builder.cc:230:    NameRef name, PropertyAccessInfo const& access_info,
compiler/property-access-builder.cc:341:    NameRef name, PropertyAccessInfo const& access_info,
builtins/builtins-handler-gen.cc:425:TF_BUILTIN(LoadIndexedInterceptorIC, CodeStubAssembler) {
objects/js-array.tq:30:  // iterator next calls in TurboFan (in the JSCallReducer) to
builtins/builtins-array-gen.cc:1478:    // the inlining in JSCallReducer::ReduceArrayIteratorPrototypeNext().
builtins/builtins-definitions.h:368:  TFH(LoadIndexedInterceptorIC, LoadWithVector)                                \
compiler/js-create-lowering.cc:57:Reduction JSCreateLowering::Reduce(Node* node) {
compiler/js-create-lowering.cc:114:Reduction JSCreateLowering::ReduceJSCreate(Node* node) {
compiler/js-create-lowering.cc:149:Reduction JSCreateLowering::ReduceJSCreateArguments(Node* node) {
compiler/js-create-lowering.cc:387:Reduction JSCreateLowering::ReduceJSCreateGeneratorObject(Node* node) {
compiler/js-create-lowering.cc:467:Reduction JSCreateLowering::ReduceNewArray(
compiler/js-create-lowering.cc:523:Reduction JSCreateLowering::ReduceNewArray(
compiler/js-create-lowering.cc:572:Reduction JSCreateLowering::ReduceNewArray(
compiler/js-create-lowering.cc:633:Reduction JSCreateLowering::ReduceJSCreateArray(Node* node) {
compiler/js-create-lowering.cc:748:Reduction JSCreateLowering::ReduceJSCreateArrayIterator(Node* node) {
compiler/js-create-lowering.cc:776:Reduction JSCreateLowering::ReduceJSCreateAsyncFunctionObject(Node* node) {
compiler/js-create-lowering.cc:855:Reduction JSCreateLowering::ReduceJSCreateCollectionIterator(Node* node) {
compiler/js-create-lowering.cc:888:Reduction JSCreateLowering::ReduceJSCreateBoundFunction(Node* node) {
compiler/js-create-lowering.cc:931:Reduction JSCreateLowering::ReduceJSCreateClosure(Node* node) {
compiler/js-create-lowering.cc:1028:Reduction JSCreateLowering::ReduceJSCreateIterResultObject(Node* node) {
compiler/js-create-lowering.cc:1052:Reduction JSCreateLowering::ReduceJSCreateStringIterator(Node* node) {
compiler/js-create-lowering.cc:1075:Reduction JSCreateLowering::ReduceJSCreateKeyValueArray(Node* node) {
compiler/js-create-lowering.cc:1105:Reduction JSCreateLowering::ReduceJSCreatePromise(Node* node) {
compiler/js-create-lowering.cc:1134:Reduction JSCreateLowering::ReduceJSCreateLiteralArrayOrObject(Node* node) {
compiler/js-create-lowering.cc:1160:Reduction JSCreateLowering::ReduceJSCreateEmptyLiteralArray(Node* node) {
compiler/js-create-lowering.cc:1184:Reduction JSCreateLowering::ReduceJSCreateEmptyLiteralObject(Node* node) {
compiler/js-create-lowering.cc:1215:Reduction JSCreateLowering::ReduceJSCreateLiteralRegExp(Node* node) {
compiler/js-create-lowering.cc:1232:Reduction JSCreateLowering::ReduceJSGetTemplateObject(Node* node) {
compiler/js-create-lowering.cc:1249:Reduction JSCreateLowering::ReduceJSCreateFunctionContext(Node* node) {
compiler/js-create-lowering.cc:1292:Reduction JSCreateLowering::ReduceJSCreateWithContext(Node* node) {
compiler/js-create-lowering.cc:1313:Reduction JSCreateLowering::ReduceJSCreateCatchContext(Node* node) {
compiler/js-create-lowering.cc:1334:Reduction JSCreateLowering::ReduceJSCreateBlockContext(Node* node) {
compiler/js-create-lowering.cc:1386:Reduction JSCreateLowering::ReduceJSCreateObject(Node* node) {
compiler/js-create-lowering.cc:1469:Reduction JSCreateLowering::ReduceJSCreateStringWrapper(Node* node) {
compiler/js-create-lowering.cc:1494:Node* JSCreateLowering::TryAllocateArguments(Node* effect, Node* control,
compiler/js-create-lowering.cc:1522:Node* JSCreateLowering::TryAllocateRestArguments(Node* effect, Node* control,
compiler/js-create-lowering.cc:1554:Node* JSCreateLowering::TryAllocateAliasedArguments(
compiler/js-create-lowering.cc:1625:Node* JSCreateLowering::TryAllocateAliasedArguments(
compiler/js-create-lowering.cc:1683:Node* JSCreateLowering::AllocateElements(Node* effect, Node* control,
compiler/js-create-lowering.cc:1708:Node* JSCreateLowering::AllocateElements(Node* effect, Node* control,
compiler/js-create-lowering.cc:1733:std::optional<Node*> JSCreateLowering::TryAllocateFastLiteral(
compiler/js-create-lowering.cc:1905:std::optional<Node*> JSCreateLowering::TryAllocateFastLiteralElements(
compiler/js-create-lowering.cc:1982:Node* JSCreateLowering::AllocateLiteralRegExp(
compiler/js-create-lowering.cc:2016:Factory* JSCreateLowering::factory() const {
compiler/js-create-lowering.cc:2020:Graph* JSCreateLowering::graph() const { return jsgraph()->graph(); }
compiler/js-create-lowering.cc:2022:CommonOperatorBuilder* JSCreateLowering::common() const {
compiler/js-create-lowering.cc:2026:CompilationDependencies* JSCreateLowering::dependencies() const {
compiler/js-create-lowering.cc:2030:SimplifiedOperatorBuilder* JSCreateLowering::simplified() const {
compiler/js-create-lowering.cc:2034:NativeContextRef JSCreateLowering::native_context() const {
compiler/simplified-lowering.h:29:class V8_EXPORT_PRIVATE SimplifiedLowering final {
compiler/simplified-lowering.h:31:  SimplifiedLowering(JSGraph* jsgraph, JSHeapBroker* broker, Zone* zone,
compiler/simplified-lowering.h:36:  ~SimplifiedLowering() = default;
compiler/simplified-lowering.h:57:  // directly used by code in SimplifiedLowering.
compiler/simplified-lowering.h:58:  // SimplifiedLowering code should call SimplifiedLowering::ChangeOp instead,
compiler/simplified-lowering.h:77:  // TODO(danno): SimplifiedLowering shouldn't know anything about the source
compiler/simplified-lowering-verifier.cc:38:void SimplifiedLoweringVerifier::CheckType(Node* node, const Type& type) {
compiler/simplified-lowering-verifier.cc:48:        "SimplifiedLoweringVerifierError: verified type %s of node #%d:%s "
compiler/simplified-lowering-verifier.cc:55:void SimplifiedLoweringVerifier::CheckAndSet(Node* node, const Type& type,
compiler/simplified-lowering-verifier.cc:70:void SimplifiedLoweringVerifier::ReportInvalidTypeCombination(
compiler/simplified-lowering-verifier.cc:80:      "SimplifiedLoweringVerifierError: invalid combination of input types %s "
compiler/simplified-lowering-verifier.cc:92:Truncation SimplifiedLoweringVerifier::GeneralizeTruncation(
compiler/simplified-lowering-verifier.cc:133:Truncation SimplifiedLoweringVerifier::JoinTruncation(const Truncation& t1,
compiler/simplified-lowering-verifier.cc:149:void SimplifiedLoweringVerifier::VisitNode(Node* node,
compiler/simplified-lowering-verifier.h:20:class SimplifiedLoweringVerifier final {
compiler/simplified-lowering-verifier.h:27:  SimplifiedLoweringVerifier(Zone* zone, Graph* graph)
compiler/representation-change.cc:148:    SimplifiedLoweringVerifier* verifier)
compiler/verifier.cc:1763:      // SLVerifierHint is internal to SimplifiedLowering and should never be
compiler/js-create-lowering.h:35:class V8_EXPORT_PRIVATE JSCreateLowering final
compiler/js-create-lowering.h:38:  JSCreateLowering(Editor* editor, JSGraph* jsgraph, JSHeapBroker* broker,
compiler/js-create-lowering.h:44:  ~JSCreateLowering() final = default;
compiler/js-create-lowering.h:46:  const char* reducer_name() const override { return "JSCreateLowering"; }
compiler/common-operator.h:37:// particular is not the same before SimplifiedLowering (JS semantics) and after
compiler/common-operator.h:39:// SimplifiedLowering, and use the BranchSemantics enum to know how branches
compiler/common-operator.h:550:  // matter. This operator is inserted only in SimplifiedLowering and is
compiler/common-operator.h:565:  // SLVerifierHint is used only during SimplifiedLowering. It may be introduced
compiler/common-operator.h:567:  // are removed at the end of SimplifiedLowering after verification.
compiler/load-elimination.cc:1084:        //   (cf. JSCreateLowering::AllocateFastLiteral).
compiler/js-native-context-specialization.cc:64:JSNativeContextSpecialization::JSNativeContextSpecialization(
compiler/js-native-context-specialization.cc:80:Reduction JSNativeContextSpecialization::Reduce(Node* node) {
compiler/js-native-context-specialization.cc:145:std::optional<size_t> JSNativeContextSpecialization::GetMaxStringLength(
compiler/js-native-context-specialization.cc:163:Reduction JSNativeContextSpecialization::ReduceJSToString(Node* node) {
compiler/js-native-context-specialization.cc:201:Handle<String> JSNativeContextSpecialization::CreateStringConstant(Node* node) {
compiler/js-native-context-specialization.cc:245:Reduction JSNativeContextSpecialization::ReduceJSAsyncFunctionEnter(
compiler/js-native-context-specialization.cc:282:Reduction JSNativeContextSpecialization::ReduceJSAsyncFunctionReject(
compiler/js-native-context-specialization.cc:318:Reduction JSNativeContextSpecialization::ReduceJSAsyncFunctionResolve(
compiler/js-native-context-specialization.cc:357:Handle<String> JSNativeContextSpecialization::Concatenate(
compiler/js-native-context-specialization.cc:441:bool JSNativeContextSpecialization::StringCanSafelyBeRead(Node* const node,
compiler/js-native-context-specialization.cc:458:Reduction JSNativeContextSpecialization::ReduceJSAdd(Node* node) {
compiler/js-native-context-specialization.cc:525:Reduction JSNativeContextSpecialization::ReduceJSGetSuperConstructor(
compiler/js-native-context-specialization.cc:553:JSNativeContextSpecialization::ReduceJSFindNonDefaultConstructorOrConstruct(
compiler/js-native-context-specialization.cc:697:Reduction JSNativeContextSpecialization::ReduceJSInstanceOf(Node* node) {
compiler/js-native-context-specialization.cc:726:  PropertyAccessInfo access_info =
compiler/js-native-context-specialization.cc:727:      broker()->GetPropertyAccessInfo(receiver_map, name, AccessMode::kLoad);
compiler/js-native-context-specialization.cc:829:JSNativeContextSpecialization::InferHasInPrototypeChainResult
compiler/js-native-context-specialization.cc:830:JSNativeContextSpecialization::InferHasInPrototypeChain(
compiler/js-native-context-specialization.cc:901:Reduction JSNativeContextSpecialization::ReduceJSHasInPrototypeChain(
compiler/js-native-context-specialization.cc:925:Reduction JSNativeContextSpecialization::ReduceJSOrdinaryHasInstance(
compiler/js-native-context-specialization.cc:981:Reduction JSNativeContextSpecialization::ReduceJSPromiseResolve(Node* node) {
compiler/js-native-context-specialization.cc:1027:Reduction JSNativeContextSpecialization::ReduceJSResolvePromise(Node* node) {
compiler/js-native-context-specialization.cc:1041:  ZoneVector<PropertyAccessInfo> access_infos(graph()->zone());
compiler/js-native-context-specialization.cc:1042:  AccessInfoFactory access_info_factory(broker(), graph()->zone());
compiler/js-native-context-specialization.cc:1045:    access_infos.push_back(broker()->GetPropertyAccessInfo(
compiler/js-native-context-specialization.cc:1048:  PropertyAccessInfo access_info =
compiler/js-native-context-specialization.cc:1049:      access_info_factory.FinalizePropertyAccessInfosAsOne(access_infos,
compiler/js-native-context-specialization.cc:1095:// PropertyAccessInfo kind for global accesses and using the existing mechanism
compiler/js-native-context-specialization.cc:1100:Reduction JSNativeContextSpecialization::ReduceGlobalAccess(
compiler/js-native-context-specialization.cc:1309:Reduction JSNativeContextSpecialization::ReduceJSLoadGlobal(Node* node) {
compiler/js-native-context-specialization.cc:1346:Reduction JSNativeContextSpecialization::ReduceJSStoreGlobal(Node* node) {
compiler/js-native-context-specialization.cc:1378:Reduction JSNativeContextSpecialization::ReduceMegaDOMPropertyAccess(
compiler/js-native-context-specialization.cc:1471:Reduction JSNativeContextSpecialization::ReduceNamedAccess(
compiler/js-native-context-specialization.cc:1543:  ZoneVector<PropertyAccessInfo> access_infos(zone());
compiler/js-native-context-specialization.cc:1545:    ZoneVector<PropertyAccessInfo> access_infos_for_feedback(zone());
compiler/js-native-context-specialization.cc:1557:      PropertyAccessInfo access_info =
compiler/js-native-context-specialization.cc:1558:          broker()->GetPropertyAccessInfo(map, feedback.name(), access_mode);
compiler/js-native-context-specialization.cc:1562:    AccessInfoFactory access_info_factory(broker(), graph()->zone());
compiler/js-native-context-specialization.cc:1563:    if (!access_info_factory.FinalizePropertyAccessInfos(
compiler/js-native-context-specialization.cc:1586:    PropertyAccessInfo access_info = access_infos.front();
compiler/js-native-context-specialization.cc:1690:      for (PropertyAccessInfo const& access_info : access_infos) {
compiler/js-native-context-specialization.cc:1710:      PropertyAccessInfo const& access_info = access_infos|j];
compiler/js-native-context-specialization.cc:1866:Reduction JSNativeContextSpecialization::ReduceJSLoadNamed(Node* node) {
compiler/js-native-context-specialization.cc:1904:Reduction JSNativeContextSpecialization::ReduceJSLoadNamedFromSuper(
compiler/js-native-context-specialization.cc:1915:Reduction JSNativeContextSpecialization::ReduceJSGetIterator(Node* node) {
compiler/js-native-context-specialization.cc:2115:Reduction JSNativeContextSpecialization::ReduceJSSetNamedProperty(Node* node) {
compiler/js-native-context-specialization.cc:2123:Reduction JSNativeContextSpecialization::ReduceJSDefineNamedOwnProperty(
compiler/js-native-context-specialization.cc:2133:Reduction JSNativeContextSpecialization::ReduceElementAccessOnString(
compiler/js-native-context-specialization.cc:2176:void JSNativeContextSpecialization::RemoveImpossibleMaps(
compiler/js-native-context-specialization.cc:2192:JSNativeContextSpecialization::TryRefineElementAccessFeedback(
compiler/js-native-context-specialization.cc:2211:Reduction JSNativeContextSpecialization::ReduceElementAccess(
compiler/js-native-context-specialization.cc:2252:  AccessInfoFactory access_info_factory(broker(), graph()->zone());
compiler/js-native-context-specialization.cc:2253:  ZoneVector<ElementAccessInfo> access_infos(zone());
compiler/js-native-context-specialization.cc:2254:  if (!access_info_factory.ComputeElementAccessInfos(refined_feedback,
compiler/js-native-context-specialization.cc:2262:    for (const ElementAccessInfo& access_info : access_infos) {
compiler/js-native-context-specialization.cc:2276:  for (const ElementAccessInfo& access_info : access_infos) {
compiler/js-native-context-specialization.cc:2290:    for (ElementAccessInfo const& access_info : access_infos) {
compiler/js-native-context-specialization.cc:2319:    for (ElementAccessInfo const& access_info : access_infos) {
compiler/js-native-context-specialization.cc:2330:    ElementAccessInfo access_info = access_infos.front();
compiler/js-native-context-specialization.cc:2366:      ElementAccessInfo const& access_info = access_infos|j];
compiler/js-native-context-specialization.cc:2449:Reduction JSNativeContextSpecialization::ReduceElementLoadFromHeapConstant(
compiler/js-native-context-specialization.cc:2535:Reduction JSNativeContextSpecialization::ReducePropertyAccess(
compiler/js-native-context-specialization.cc:2589:Reduction JSNativeContextSpecialization::ReduceEagerDeoptimize(
compiler/js-native-context-specialization.cc:2606:Reduction JSNativeContextSpecialization::ReduceJSHasProperty(Node* node) {
compiler/js-native-context-specialization.cc:2615:Reduction JSNativeContextSpecialization::ReduceJSLoadPropertyWithEnumeratedKey(
compiler/js-native-context-specialization.cc:2774:Reduction JSNativeContextSpecialization::ReduceJSLoadProperty(Node* node) {
compiler/js-native-context-specialization.cc:2790:Reduction JSNativeContextSpecialization::ReduceJSSetKeyedProperty(Node* node) {
compiler/js-native-context-specialization.cc:2798:Reduction JSNativeContextSpecialization::ReduceJSDefineKeyedOwnProperty(
compiler/js-native-context-specialization.cc:2808:Node* JSNativeContextSpecialization::InlinePropertyGetterCall(
compiler/js-native-context-specialization.cc:2812:    PropertyAccessInfo const& access_info) {
compiler/js-native-context-specialization.cc:2859:void JSNativeContextSpecialization::InlinePropertySetterCall(
compiler/js-native-context-specialization.cc:2862:    PropertyAccessInfo const& access_info) {
compiler/js-native-context-specialization.cc:2948:Node* JSNativeContextSpecialization::InlineApiCall(
compiler/js-native-context-specialization.cc:3006:std::optional<JSNativeContextSpecialization::ValueEffectControl>
compiler/js-native-context-specialization.cc:3007:JSNativeContextSpecialization::BuildPropertyLoad(
compiler/js-native-context-specialization.cc:3010:    PropertyAccessInfo const& access_info) {
compiler/js-native-context-specialization.cc:3064:JSNativeContextSpecialization::ValueEffectControl
compiler/js-native-context-specialization.cc:3065:JSNativeContextSpecialization::BuildPropertyTest(
compiler/js-native-context-specialization.cc:3066:    Node* effect, Node* control, PropertyAccessInfo const& access_info) {
compiler/js-native-context-specialization.cc:3082:std::optional<JSNativeContextSpecialization::ValueEffectControl>
compiler/js-native-context-specialization.cc:3083:JSNativeContextSpecialization::BuildPropertyAccess(
compiler/js-native-context-specialization.cc:3086:    ZoneVector<Node*>* if_exceptions, PropertyAccessInfo const& access_info,
compiler/js-native-context-specialization.cc:3107:JSNativeContextSpecialization::ValueEffectControl
compiler/js-native-context-specialization.cc:3108:JSNativeContextSpecialization::BuildPropertyStore(
compiler/js-native-context-specialization.cc:3111:    PropertyAccessInfo const& access_info, AccessMode access_mode) {
compiler/js-native-context-specialization.cc:3309:JSNativeContextSpecialization::ReduceJSDefineKeyedOwnPropertyInLiteral(
compiler/js-native-context-specialization.cc:3326:Reduction JSNativeContextSpecialization::ReduceJSStoreInArrayLiteral(
compiler/js-native-context-specialization.cc:3336:Reduction JSNativeContextSpecialization::ReduceJSToObject(Node* node) {
compiler/js-native-context-specialization.cc:3350:JSNativeContextSpecialization::ValueEffectControl
compiler/js-native-context-specialization.cc:3351:JSNativeContextSpecialization::BuildElementAccess(
compiler/js-native-context-specialization.cc:3353:    Node* context, ElementAccessInfo const& access_info,
compiler/js-native-context-specialization.cc:3735:JSNativeContextSpecialization::ValueEffectControl
compiler/js-native-context-specialization.cc:3736:JSNativeContextSpecialization::
compiler/js-native-context-specialization.cc:4043:Node* JSNativeContextSpecialization::BuildIndexedStringLoad(
compiler/js-native-context-specialization.cc:4101:Node* JSNativeContextSpecialization::BuildExtendPropertiesBackingStore(
compiler/js-native-context-specialization.cc:4174:Node* JSNativeContextSpecialization::BuildCheckEqualsName(NameRef name,
compiler/js-native-context-specialization.cc:4186:bool JSNativeContextSpecialization::CanTreatHoleAsUndefined(
compiler/js-native-context-specialization.cc:4203:bool JSNativeContextSpecialization::InferMaps(Node* object, Effect effect,
compiler/js-native-context-specialization.cc:4227:OptionalMapRef JSNativeContextSpecialization::InferRootMap(Node* object) const {
compiler/js-native-context-specialization.cc:4243:Node* JSNativeContextSpecialization::BuildLoadPrototypeFromObject(
compiler/js-native-context-specialization.cc:4254:JSNativeContextSpecialization::ReleaseEffectAndControlFromAssembler(
compiler/js-native-context-specialization.cc:4274:Graph* JSNativeContextSpecialization::graph() const {
compiler/js-native-context-specialization.cc:4278:Isolate* JSNativeContextSpecialization::isolate() const {
compiler/js-native-context-specialization.cc:4282:Factory* JSNativeContextSpecialization::factory() const {
compiler/js-native-context-specialization.cc:4286:CommonOperatorBuilder* JSNativeContextSpecialization::common() const {
compiler/js-native-context-specialization.cc:4290:JSOperatorBuilder* JSNativeContextSpecialization::javascript() const {
compiler/js-native-context-specialization.cc:4294:SimplifiedOperatorBuilder* JSNativeContextSpecialization::simplified() const {
compiler/js-call-reducer.h:31:class JSCallReducerAssembler;
compiler/js-call-reducer.h:41:class V8_EXPORT_PRIVATE JSCallReducer final : public AdvancedReducer {
compiler/js-call-reducer.h:51:  JSCallReducer(Editor* editor, JSGraph* jsgraph, JSHeapBroker* broker,
compiler/js-call-reducer.h:60:  // String.prototype.startsWith in JSCallReducer.
compiler/js-call-reducer.h:63:  const char* reducer_name() const override { return "JSCallReducer"; }
compiler/js-call-reducer.h:71:  // JSCallReducer outsources much work to a graph assembler.
compiler/js-call-reducer.h:259:  Reduction ReplaceWithSubgraph(JSCallReducerAssembler* gasm, Node* subgraph);
compiler/js-call-reducer.h:261:      JSCallReducerAssembler* gasm);
compiler/operation-typer.cc:714:  // SimplifiedLowering::VisitSpeculativeAdditiveOp.
compiler/operation-typer.cc:724:  // SimplifiedLowering::VisitSpeculativeAdditiveOp.
compiler/heap-refs.h:55:class PropertyAccessInfo;
compiler/simplified-operator.h:1196:  // SimplifiedLowering.
compiler/js-heap-broker.h:246:  PropertyAccessInfo GetPropertyAccessInfo(MapRef map, NameRef name,
compiler/js-heap-broker.h:475:  ZoneUnorderedMap<PropertyAccessTarget, PropertyAccessInfo,
compiler/js-heap-broker.h:488:  // ComputePropertyAccessInfo may call itself recursively. Thus we need to
compiler/pipeline.cc:958:    JSCallReducer::Flags call_reducer_flags = JSCallReducer::kNoFlags;
compiler/pipeline.cc:960:      call_reducer_flags |= JSCallReducer::kBailoutOnUninitialized;
compiler/pipeline.cc:963:      call_reducer_flags |= JSCallReducer::kInlineJSToWasmCalls;
compiler/pipeline.cc:965:    JSCallReducer call_reducer(&graph_reducer, data->jsgraph(), data->broker(),
compiler/pipeline.cc:973:    JSNativeContextSpecialization::Flags flags =
compiler/pipeline.cc:974:        JSNativeContextSpecialization::kNoFlags;
compiler/pipeline.cc:976:      flags |= JSNativeContextSpecialization::kBailoutOnUninitialized;
compiler/pipeline.cc:979:    // JSNativeContextSpecialization allocates out-of-heap objects
compiler/pipeline.cc:981:    JSNativeContextSpecialization native_context_specialization(
compiler/pipeline.cc:1163:    JSCreateLowering create_lowering(&graph_reducer, data->jsgraph(),
compiler/pipeline.cc:1187:    // ConstantFoldingReducer, JSCreateLowering, JSTypedLowering, and
compiler/pipeline.cc🔢struct SimplifiedLoweringPhase {
compiler/pipeline.cc:1235:  DECL_PIPELINE_PHASE_CONSTANTS(SimplifiedLowering)
compiler/pipeline.cc:1238:    SimplifiedLowering lowering(data->jsgraph(), data->broker(), temp_zone,
compiler/pipeline.cc:2590:  Run<SimplifiedLoweringPhase>(linkage);
compiler/pipeline.cc:2591:  RunPrintAndVerify(SimplifiedLoweringPhase::phase_name(), true);
compiler/representation-change.h:18:class SimplifiedLoweringVerifier;
compiler/representation-change.h:27:                        SimplifiedLoweringVerifier* verifier);
compiler/representation-change.h:62:  SimplifiedLoweringVerifier* verifier_;
compiler/turboshaft/maglev-graph-building-phase.cc:3791:      // adjusting if the difference exceeds 0.5 (like SimplifiedLowering does
compiler/turboshaft/maglev-graph-building-phase.cc:5803:// SimplifiedLowering, but is much less powerful (doesn't take truncations into
compiler/js-typed-lowering.cc:646:  // optimize to NewConsString later during SimplifiedLowering, but for that
compiler/js-typed-lowering.cc:2162:    // We need to check here in addition to JSCallReducer for Realms.
compiler/turboshaft/loop-peeling-reducer.h:71:  // the very end (which should happen when we have a SimplifiedLowering in
compiler/turboshaft/maglev-early-lowering-reducer-inl.h:27:  // we decide going forward (regarding SimplifiedLowering for instance), we
compiler/turboshaft/machine-lowering-phase.cc:22:  // during SimplifiedLowering. However, SimplifiedLowering is currently WIP,
compiler/turboshaft/machine-lowering-phase.cc:24:  // SimplifiedLowering just yet, so I'm hijacking MachineLoweringPhase to run
compiler/turboshaft/js-generic-lowering-reducer.h:20:// It should run after SimplifiedLowering, which should have already replaced
compiler/turboshaft/js-generic-lowering-reducer.h:22:// specialized operations. However, SimplifiedLowering won't be able to remove
ic/handler-configuration.h:222:  static inline Handle<Smi> LoadIndexedString(Isolate* isolate,
ic/handler-configuration-inl.h:121:Handle<Smi> LoadHandler::LoadIndexedString(Isolate* isolate,
compiler/simplified-lowering.cc:48:const char* kSimplifiedLoweringReducerName = "SimplifiedLowering";
compiler/simplified-lowering.cc:241:                                   SimplifiedLoweringVerifier* verifier)
compiler/simplified-lowering.cc:250:  SimplifiedLoweringVerifier* verifier_;
compiler/simplified-lowering.cc:284:  // directly used by code in RepresentationSelector and SimplifiedLowering.
compiler/simplified-lowering.cc:345:                         SimplifiedLoweringVerifier* verifier)
compiler/simplified-lowering.cc:744:  void RunLowerPhase(SimplifiedLowering* lowering) {
compiler/simplified-lowering.cc:813:      writer.PrintPhase("V8.TFSimplifiedLowering |after lower]");
compiler/simplified-lowering.cc:829:      writer.PrintPhase("V8.TFSimplifiedLowering |after verify]");
compiler/simplified-lowering.cc:840:  void Run(SimplifiedLowering* lowering) {
compiler/simplified-lowering.cc:1219:                   SimplifiedLowering* lowering) {
compiler/simplified-lowering.cc:1244:                SimplifiedLowering* lowering) {
compiler/simplified-lowering.cc:1273:  void VisitObjectIs(Node* node, Type type, SimplifiedLowering* lowering) {
compiler/simplified-lowering.cc:1293:  void VisitCheck(Node* node, Type type, SimplifiedLowering* lowering) {
compiler/simplified-lowering.cc:1306:  void VisitCall(Node* node, SimplifiedLowering* lowering) {
compiler/simplified-lowering.cc:1649:                                         SimplifiedLowering* lowering) {
compiler/simplified-lowering.cc:1739:                                  SimplifiedLowering* lowering) {
compiler/simplified-lowering.cc:1762:                                     SimplifiedLowering* lowering) {
compiler/simplified-lowering.cc:1883:  void VisitCheckBounds(Node* node, SimplifiedLowering* lowering) {
compiler/simplified-lowering.cc:2023:  void VisitFastApiCall(Node* node, SimplifiedLowering* lowering) {
compiler/simplified-lowering.cc:2122:                                SimplifiedLowering* lowering) {
compiler/simplified-lowering.cc:2268:  void VisitJSWasmCall(Node* node, SimplifiedLowering* lowering) {
compiler/simplified-lowering.cc:2328:                 SimplifiedLowering* lowering) {
compiler/simplified-lowering.cc:2390:          // During lowering, SimplifiedLowering generates Int32Constants which
compiler/simplified-lowering.cc:2394:          // because they were generated before SimplifiedLowering.
compiler/simplified-lowering.cc:4826:      observe_node_manager_->OnNodeChanged(kSimplifiedLoweringReducerName, node,
compiler/simplified-lowering.cc:4832:      observe_node_manager_->OnNodeChanged(kSimplifiedLoweringReducerName, node,
compiler/simplified-lowering.cc:4873:  SimplifiedLoweringVerifier* verifier_;  // Used to verify output graph.
compiler/simplified-lowering.cc:5038:SimplifiedLowering::SimplifiedLowering(
compiler/simplified-lowering.cc:5054:void SimplifiedLowering::LowerAllNodes() {
compiler/simplified-lowering.cc:5055:  SimplifiedLoweringVerifier* verifier = nullptr;
compiler/simplified-lowering.cc:5057:    verifier = zone_->New<SimplifiedLoweringVerifier>(zone_, graph());
compiler/simplified-lowering.cc:5066:void SimplifiedLowering::DoJSToNumberOrNumericTruncatesToFloat64(
compiler/simplified-lowering.cc:5171:void SimplifiedLowering::DoJSToNumberOrNumericTruncatesToWord32(
compiler/simplified-lowering.cc:5269:Node* SimplifiedLowering::Float64Round(Node* const node) {
compiler/simplified-lowering.cc:5285:Node* SimplifiedLowering::Float64Sign(Node* const node) {
compiler/simplified-lowering.cc:5301:Node* SimplifiedLowering::Int32Abs(Node* const node) {
compiler/simplified-lowering.cc:5316:Node* SimplifiedLowering::Int32Div(Node* const node) {
compiler/simplified-lowering.cc:5394:Node* SimplifiedLowering::Int32Mod(Node* const node) {
compiler/simplified-lowering.cc:5497:Node* SimplifiedLowering::Int32Sign(Node* const node) {
compiler/simplified-lowering.cc:5513:Node* SimplifiedLowering::Uint32Div(Node* const node) {
compiler/simplified-lowering.cc:5532:Node* SimplifiedLowering::Uint32Mod(Node* const node) {
compiler/simplified-lowering.cc:5595:void SimplifiedLowering::DoMax(Node* node, Operator const* op,
compiler/simplified-lowering.cc:5606:void SimplifiedLowering::DoMin(Node* node, Operator const* op,
compiler/simplified-lowering.cc:5617:void SimplifiedLowering::DoIntegral32ToBit(Node* node) {
compiler/simplified-lowering.cc:5627:void SimplifiedLowering::DoOrderedNumberToBit(Node* node) {
compiler/simplified-lowering.cc:5636:void SimplifiedLowering::DoNumberToBit(Node* node) {
compiler/simplified-lowering.cc:5645:void SimplifiedLowering::DoIntegerToUint8Clamped(Node* node) {
compiler/simplified-lowering.cc:5662:void SimplifiedLowering::DoNumberToUint8Clamped(Node* node) {
compiler/simplified-lowering.cc:5679:void SimplifiedLowering::DoSigned32ToUint8Clamped(Node* node) {
compiler/simplified-lowering.cc:5695:void SimplifiedLowering::DoUnsigned32ToUint8Clamped(Node* node) {
compiler/simplified-lowering.cc:5706:Node* SimplifiedLowering::ToNumberCode() {
compiler/simplified-lowering.cc:5714:Node* SimplifiedLowering::ToNumberConvertBigIntCode() {
compiler/simplified-lowering.cc:5724:Node* SimplifiedLowering::ToNumericCode() {
compiler/simplified-lowering.cc:5732:Operator const* SimplifiedLowering::ToNumberOperator() {
compiler/simplified-lowering.cc:5745:Operator const* SimplifiedLowering::ToNumberConvertBigIntOperator() {
compiler/simplified-lowering.cc:5759:Operator const* SimplifiedLowering::ToNumericOperator() {
compiler/simplified-lowering.cc:5772:void SimplifiedLowering::ChangeOp(Node* node, const Operator* new_op) {
compiler/simplified-lowering.cc:5776:    observe_node_manager_->OnNodeChanged(kSimplifiedLoweringReducerName, node,
compiler/access-info.cc:90:ElementAccessInfo::ElementAccessInfo(
compiler/access-info.cc💯PropertyAccessInfo PropertyAccessInfo::Invalid(Zone* zone) {
compiler/access-info.cc:101:  return PropertyAccessInfo(zone);
compiler/access-info.cc:105:PropertyAccessInfo PropertyAccessInfo::NotFound(Zone* zone, MapRef receiver_map,
compiler/access-info.cc:107:  return PropertyAccessInfo(zone, kNotFound, holder, {{receiver_map}, zone});
compiler/access-info.cc:111:PropertyAccessInfo PropertyAccessInfo::DataField(
compiler/access-info.cc:124:  return PropertyAccessInfo(kDataField, holder, transition_map, field_index,
compiler/access-info.cc:131:PropertyAccessInfo PropertyAccessInfo::FastDataConstant(
compiler/access-info.cc:138:  return PropertyAccessInfo(kFastDataConstant, holder, transition_map,
compiler/access-info.cc:145:PropertyAccessInfo PropertyAccessInfo::FastAccessorConstant(
compiler/access-info.cc:148:  return PropertyAccessInfo(zone, kFastAccessorConstant, holder, constant,
compiler/access-info.cc:153:PropertyAccessInfo PropertyAccessInfo::ModuleExport(Zone* zone,
compiler/access-info.cc:156:  return PropertyAccessInfo(zone, kModuleExport, {} /* holder */,
compiler/access-info.cc:162:PropertyAccessInfo PropertyAccessInfo::StringLength(Zone* zone,
compiler/access-info.cc:164:  return PropertyAccessInfo(zone, kStringLength, {}, {{receiver_map}, zone});
compiler/access-info.cc:168:PropertyAccessInfo PropertyAccessInfo::StringWrapperLength(
compiler/access-info.cc:170:  return PropertyAccessInfo(zone, kStringWrapperLength, {},
compiler/access-info.cc:175:PropertyAccessInfo PropertyAccessInfo::DictionaryProtoDataConstant(
compiler/access-info.cc:178:  return PropertyAccessInfo(zone, kDictionaryProtoDataConstant, holder,
compiler/access-info.cc:183:PropertyAccessInfo PropertyAccessInfo::DictionaryProtoAccessorConstant(
compiler/access-info.cc:186:  return PropertyAccessInfo(zone, kDictionaryProtoAccessorConstant, holder,
compiler/access-info.cc:191:PropertyAccessInfo::PropertyAccessInfo(Zone* zone)
compiler/access-info.cc:199:PropertyAccessInfo::PropertyAccessInfo(
compiler/access-info.cc:210:PropertyAccessInfo::PropertyAccessInfo(
compiler/access-info.cc:227:PropertyAccessInfo::PropertyAccessInfo(
compiler/access-info.cc:248:PropertyAccessInfo::PropertyAccessInfo(
compiler/access-info.cc:277:bool PropertyAccessInfo::Merge(PropertyAccessInfo const* that,
compiler/access-info.cc:366:ConstFieldInfo PropertyAccessInfo::GetConstFieldInfo() const {
compiler/access-info.cc:371:AccessInfoFactory::AccessInfoFactory(JSHeapBroker* broker, Zone* zone)
compiler/access-info.cc:374:std::optional<ElementAccessInfo> AccessInfoFactory::ComputeElementAccessInfo(
compiler/access-info.cc:377:  return ElementAccessInfo({{map}, zone()}, map.elements_kind(), zone());
compiler/access-info.cc:380:bool AccessInfoFactory::ComputeElementAccessInfos(
compiler/access-info.cc:382:    ZoneVector<ElementAccessInfo>* access_infos) const {
compiler/access-info.cc:389:    std::optional<ElementAccessInfo> access_info =
compiler/access-info.cc:400:    std::optional<ElementAccessInfo> access_info =
compiler/access-info.cc:401:        ComputeElementAccessInfo(target.value(), access_mode);
compiler/access-info.cc:414:PropertyAccessInfo AccessInfoFactory::ComputeDataFieldAccessInfo(
compiler/access-info.cc:505:      return PropertyAccessInfo::DataField(
compiler/access-info.cc:511:      return PropertyAccessInfo::FastDataConstant(
compiler/access-info.cc:523:PropertyAccessInfo AccessorAccessInfoHelper(
compiler/access-info.cc:525:    const AccessInfoFactory* ai_factory, MapRef receiver_map, NameRef name,
compiler/access-info.cc:545:      return PropertyAccessInfo::Invalid(zone);
compiler/access-info.cc:549:      return PropertyAccessInfo::Invalid(zone);
compiler/access-info.cc:553:      return PropertyAccessInfo::Invalid(zone);
compiler/access-info.cc:555:    return PropertyAccessInfo::ModuleExport(zone, receiver_map,
compiler/access-info.cc:563:    return PropertyAccessInfo::FastAccessorConstant(zone, receiver_map, holder,
compiler/access-info.cc:568:    return PropertyAccessInfo::Invalid(zone);
compiler/access-info.cc:576:  if (!accessor_ref.has_value()) return PropertyAccessInfo::Invalid(zone);
compiler/access-info.cc:584:      return PropertyAccessInfo::Invalid(zone);
compiler/access-info.cc:600:      return PropertyAccessInfo::Invalid(zone);
compiler/access-info.cc:609:      if (!api_holder_ref.has_value()) return PropertyAccessInfo::Invalid(zone);
compiler/access-info.cc:619:        PropertyAccessInfo access_info = ai_factory->ComputePropertyAccessInfo(
compiler/access-info.cc:628:    return PropertyAccessInfo::DictionaryProtoAccessorConstant(
compiler/access-info.cc:631:    return PropertyAccessInfo::FastAccessorConstant(
compiler/access-info.cc:638:PropertyAccessInfo AccessInfoFactory::ComputeAccessorDescriptorAccessInfo(
compiler/access-info.cc:652:  return AccessorAccessInfoHelper(isolate(), zone(), broker(), this,
compiler/access-info.cc:657:PropertyAccessInfo AccessInfoFactory::ComputeDictionaryProtoAccessInfo(
compiler/access-info.cc:671:    return PropertyAccessInfo::DictionaryProtoDataConstant(
compiler/access-info.cc:679:  return AccessorAccessInfoHelper(isolate(), zone(), broker(), this,
compiler/access-info.cc:684:bool AccessInfoFactory::TryLoadPropertyDetails(
compiler/access-info.cc:728:PropertyAccessInfo AccessInfoFactory::ComputePropertyAccessInfo(
compiler/access-info.cc:748:    PropertyAccessInfo access_info = LookupSpecialFieldAccessor(map, name);
compiler/access-info.cc:819:        return ComputeDictionaryProtoAccessInfo(
compiler/access-info.cc:842:          return ComputeDataFieldAccessInfo(receiver_map, map, name, holder,
compiler/access-info.cc:852:        return ComputeAccessorDescriptorAccessInfo(receiver_map, name, map,
compiler/access-info.cc:935:      return PropertyAccessInfo::NotFound(zone(), receiver_map, holder);
compiler/access-info.cc:953:    // AccessInfoFactory.
compiler/access-info.cc:958:PropertyAccessInfo AccessInfoFactory::FinalizePropertyAccessInfosAsOne(
compiler/access-info.cc:959:    ZoneVector<PropertyAccessInfo> access_infos, AccessMode access_mode) const {
compiler/access-info.cc:960:  ZoneVector<PropertyAccessInfo> merged_access_infos(zone());
compiler/access-info.cc:961:  MergePropertyAccessInfos(access_infos, access_mode, &merged_access_infos);
compiler/access-info.cc:963:    PropertyAccessInfo& result = merged_access_infos.front();
compiler/access-info.cc:972:void PropertyAccessInfo::RecordDependencies(
compiler/access-info.cc:980:bool AccessInfoFactory::FinalizePropertyAccessInfos(
compiler/access-info.cc:981:    ZoneVector<PropertyAccessInfo> access_infos, AccessMode access_mode,
compiler/access-info.cc:982:    ZoneVector<PropertyAccessInfo>* result) const {
compiler/access-info.cc:984:  MergePropertyAccessInfos(access_infos, access_mode, result);
compiler/access-info.cc:985:  for (PropertyAccessInfo const& info : *result) {
compiler/access-info.cc:988:  for (PropertyAccessInfo& info : *result) {
compiler/access-info.cc:994:void AccessInfoFactory::MergePropertyAccessInfos(
compiler/access-info.cc:995:    ZoneVector<PropertyAccessInfo> infos, AccessMode access_mode,
compiler/access-info.cc:996:    ZoneVector<PropertyAccessInfo>* result) const {
compiler/access-info.cc:1011:CompilationDependencies* AccessInfoFactory::dependencies() const {
compiler/access-info.cc:1014:Isolate* AccessInfoFactory::isolate() const { return broker()->isolate(); }
compiler/access-info.cc:1039:std::optional<ElementAccessInfo> AccessInfoFactory::ConsolidateElementLoad(
compiler/access-info.cc:1063:  return ElementAccessInfo(std::move(maps), elements_kind, zone());
compiler/access-info.cc:1066:PropertyAccessInfo AccessInfoFactory::LookupSpecialFieldAccessor(
compiler/access-info.cc:1072:      return PropertyAccessInfo::StringLength(zone(), map);
compiler/access-info.cc:1081:      return PropertyAccessInfo::StringWrapperLength(zone(), map);
compiler/access-info.cc:1109:    return PropertyAccessInfo::DataField(broker(), zone(), map, {{}, zone()},
compiler/access-info.cc:1116:PropertyAccessInfo AccessInfoFactory::LookupTransition(
compiler/access-info.cc:1202:      return PropertyAccessInfo::DataField(
compiler/access-info.cc:1207:      return PropertyAccessInfo::FastDataConstant(
compiler/property-access-builder.h:26:class PropertyAccessInfo;
compiler/property-access-builder.h:62:  Node* BuildLoadDataField(NameRef name, PropertyAccessInfo const& access_info,
compiler/property-access-builder.h:70:      PropertyAccessInfo const& access_info);
compiler/property-access-builder.h:87:                                     PropertyAccessInfo const& access_info,
compiler/property-access-builder.h:91:  Node* ResolveHolder(PropertyAccessInfo const& access_info,
ic/ic.cc:1392:    TRACE_HANDLER_STATS(isolate(), KeyedLoadIC_LoadIndexedInterceptorStub);
ic/ic.cc:1394:                      : BUILTIN_CODE(isolate(), LoadIndexedInterceptorIC);
ic/ic.cc:1399:    TRACE_HANDLER_STATS(isolate(), KeyedLoadIC_LoadIndexedStringDH);
ic/ic.cc:1401:    return LoadHandler::LoadIndexedString(isolate(), new_load_mode);
compiler/js-generic-lowering.cc:901:  // JSCallReducer.
compiler/js-generic-lowering.cc:1130:// Will be lowered in SimplifiedLowering.
maglev/maglev-assembler.cc:69:void MaglevAssembler::LoadDataField(const PolymorphicAccessInfo& access_info,
maglev/maglev-ir.h:6777:class PolymorphicAccessInfo {
maglev/maglev-ir.h:6788:  static PolymorphicAccessInfo NotFound(
maglev/maglev-ir.h:6790:    return PolymorphicAccessInfo(kNotFound, maps, Representation::Tagged());
maglev/maglev-ir.h:6792:  static PolymorphicAccessInfo Constant(
maglev/maglev-ir.h:6794:    return PolymorphicAccessInfo(kConstant, maps, Representation::Tagged(),
maglev/maglev-ir.h:6797:  static PolymorphicAccessInfo ConstantDouble(
maglev/maglev-ir.h:6799:    return PolymorphicAccessInfo(kConstantDouble, maps, constant);
maglev/maglev-ir.h:6801:  static PolymorphicAccessInfo DataLoad(
maglev/maglev-ir.h:6804:    return PolymorphicAccessInfo(kDataLoad, maps, representation, holder,
maglev/maglev-ir.h:6807:  static PolymorphicAccessInfo ModuleExport(
maglev/maglev-ir.h:6809:    return PolymorphicAccessInfo(kModuleExport, maps, Representation::Tagged(),
maglev/maglev-ir.h:6812:  static PolymorphicAccessInfo StringLength(
maglev/maglev-ir.h:6814:    return PolymorphicAccessInfo(kStringLength, maps, Representation::Smi());
maglev/maglev-ir.h:6848:  bool operator==(const PolymorphicAccessInfo& other) const {
maglev/maglev-ir.h:6903:  explicit PolymorphicAccessInfo(Kind kind,
maglev/maglev-ir.h:6910:  PolymorphicAccessInfo(Kind kind, const ZoneVector<compiler::MapRef>& maps,
maglev/maglev-ir.h:6920:  PolymorphicAccessInfo(Kind kind, const ZoneVector<compiler::MapRef>& maps,
maglev/maglev-ir.h:6929:  PolymorphicAccessInfo(Kind kind, const ZoneVector<compiler::MapRef>& maps,
maglev/maglev-assembler.h:749:  void LoadDataField(const PolymorphicAccessInfo& access_info, Register result,
maglev/maglev-graph-builder.cc:5213:    compiler::PropertyAccessInfo const& access_info) {
maglev/maglev-graph-builder.cc:5225:    // Non-JSReceivers that passed AccessInfoFactory::ComputePropertyAccessInfo
maglev/maglev-graph-builder.cc:5247:    compiler::PropertyAccessInfo const& access_info,
maglev/maglev-graph-builder.cc:5263:    compiler::PropertyAccessInfo const& access_info) {
maglev/maglev-graph-builder.cc:5272:    compiler::PropertyAccessInfo const& access_info) {
maglev/maglev-graph-builder.cc:5279:    compiler::PropertyAccessInfo const& access_info, ValueNode* receiver,
maglev/maglev-graph-builder.cc:5313:    compiler::PropertyAccessInfo const& access_info, ValueNode* receiver,
maglev/maglev-graph-builder.cc:5334:    compiler::PropertyAccessInfo const& access_info,
maglev/maglev-graph-builder.cc:5448:    compiler::PropertyAccessInfo const& access_info, ValueNode* receiver,
maglev/maglev-graph-builder.cc:5543:bool AccessInfoGuaranteedConst(
maglev/maglev-graph-builder.cc:5544:    compiler::PropertyAccessInfo const& access_info) {
maglev/maglev-graph-builder.cc:5565:    compiler::PropertyAccessInfo const& access_info) {
maglev/maglev-graph-builder.cc:5573:    case compiler::PropertyAccessInfo::kInvalid:
maglev/maglev-graph-builder.cc:5575:    case compiler::PropertyAccessInfo::kNotFound:
maglev/maglev-graph-builder.cc:5577:    case compiler::PropertyAccessInfo::kDataField:
maglev/maglev-graph-builder.cc:5578:    case compiler::PropertyAccessInfo::kFastDataConstant: {
maglev/maglev-graph-builder.cc:5582:                          AccessInfoGuaranteedConst(access_info),
maglev/maglev-graph-builder.cc:5586:    case compiler::PropertyAccessInfo::kDictionaryProtoDataConstant: {
maglev/maglev-graph-builder.cc:5592:    case compiler::PropertyAccessInfo::kFastAccessorConstant:
maglev/maglev-graph-builder.cc:5593:    case compiler::PropertyAccessInfo::kDictionaryProtoAccessorConstant:
maglev/maglev-graph-builder.cc:5596:    case compiler::PropertyAccessInfo::kModuleExport: {
maglev/maglev-graph-builder.cc:5601:    case compiler::PropertyAccessInfo::kStringLength: {
maglev/maglev-graph-builder.cc:5605:                          AccessInfoGuaranteedConst(access_info),
maglev/maglev-graph-builder.cc:5609:    case compiler::PropertyAccessInfo::kStringWrapperLength: {
maglev/maglev-graph-builder.cc:5620:    compiler::PropertyAccessInfo const& access_info,
maglev/maglev-graph-builder.cc:5629:    case compiler::PropertyAccessInfo::kFastAccessorConstant: {
maglev/maglev-graph-builder.cc:5633:    case compiler::PropertyAccessInfo::kDataField:
maglev/maglev-graph-builder.cc:5634:    case compiler::PropertyAccessInfo::kFastDataConstant: {
maglev/maglev-graph-builder.cc:5639:            AccessInfoGuaranteedConst(access_info), access_mode);
maglev/maglev-graph-builder.cc:5644:    case compiler::PropertyAccessInfo::kInvalid:
maglev/maglev-graph-builder.cc:5645:    case compiler::PropertyAccessInfo::kNotFound:
maglev/maglev-graph-builder.cc:5646:    case compiler::PropertyAccessInfo::kDictionaryProtoDataConstant:
maglev/maglev-graph-builder.cc:5647:    case compiler::PropertyAccessInfo::kDictionaryProtoAccessorConstant:
maglev/maglev-graph-builder.cc:5648:    case compiler::PropertyAccessInfo::kModuleExport:
maglev/maglev-graph-builder.cc:5649:    case compiler::PropertyAccessInfo::kStringLength:
maglev/maglev-graph-builder.cc:5650:    case compiler::PropertyAccessInfo::kStringWrapperLength:
maglev/maglev-graph-builder.cc:5657:    compiler::PropertyAccessInfo const& access_info,
maglev/maglev-graph-builder.cc:5747:  ZoneVector<compiler::PropertyAccessInfo> access_infos(zone());
maglev/maglev-graph-builder.cc:5748:  ZoneVector<compiler::PropertyAccessInfo> access_infos_for_feedback(zone());
maglev/maglev-graph-builder.cc:5761:    compiler::PropertyAccessInfo access_info =
maglev/maglev-graph-builder.cc:5762:        broker()->GetPropertyAccessInfo(map, feedback.name(), access_mode);
maglev/maglev-graph-builder.cc:5766:  compiler::AccessInfoFactory access_info_factory(broker(), zone());
maglev/maglev-graph-builder.cc:5767:  if (!access_info_factory.FinalizePropertyAccessInfos(
maglev/maglev-graph-builder.cc:5774:    compiler::PropertyAccessInfo const& access_info = access_infos.front();
maglev/maglev-graph-builder.cc:6119:    const compiler::ElementAccessInfo& access_info,
maglev/maglev-graph-builder.cc:6358:    const compiler::ElementAccessInfo& access_info,
maglev/maglev-graph-builder.cc:6416:  compiler::AccessInfoFactory access_info_factory(broker(), zone());
maglev/maglev-graph-builder.cc:6417:  ZoneVector<compiler::ElementAccessInfo> access_infos(zone());
maglev/maglev-graph-builder.cc:6418:  if (!access_info_factory.ComputeElementAccessInfos(refined_feedback,
maglev/maglev-graph-builder.cc:6435:    for (compiler::ElementAccessInfo const& access_info : access_infos) {
maglev/maglev-graph-builder.cc:6466:    compiler::ElementAccessInfo const& access_info = access_infos.front();
maglev/maglev-graph-builder.cc:6515:    const ZoneVector<compiler::ElementAccessInfo>& access_infos,
maglev/maglev-graph-builder.cc:6538:    compiler::ElementAccessInfo const& access_info = access_infos|i];
maglev/maglev-graph-builder.cc:6654:    const ZoneVector<compiler::PropertyAccessInfo>& access_infos,
maglev/maglev-graph-builder.cc:6664:    compiler::PropertyAccessInfo const& access_info = access_infos|i];
maglev/maglev-graph-builder.cc:6710:    compiler::PropertyAccessInfo const& access_info = access_infos|i];
maglev/maglev-graph-builder.cc:7645:  // JSNativeContextSpecialization::ReduceJSFindNonDefaultConstructorOrConstruct
maglev/maglev-graph-builder.cc:11382:  compiler::PropertyAccessInfo access_info = broker()->GetPropertyAccessInfo(
maglev/maglev-graph-builder.h:2244:      compiler::PropertyAccessInfo const& access_info);
maglev/maglev-graph-builder.h:2246:      compiler::PropertyAccessInfo const& access_info,
maglev/maglev-graph-builder.h:2250:      compiler::PropertyAccessInfo const& access_info);
maglev/maglev-graph-builder.h:2253:      compiler::PropertyAccessInfo const& access_info);
maglev/maglev-graph-builder.h:2256:  ValueNode* BuildLoadField(compiler::PropertyAccessInfo const& access_info,
maglev/maglev-graph-builder.h:2260:      compiler::PropertyAccessInfo const& access_info, ValueNode* receiver,
maglev/maglev-graph-builder.h:2263:      compiler::PropertyAccessInfo const& access_info, ValueNode* receiver,
maglev/maglev-graph-builder.h:2266:      compiler::PropertyAccessInfo const& access_info, ValueNode* receiver,
maglev/maglev-graph-builder.h:2286:      compiler::NameRef name, compiler::PropertyAccessInfo const& access_info);
maglev/maglev-graph-builder.h:2289:      compiler::NameRef name, compiler::PropertyAccessInfo const& access_info,
maglev/maglev-graph-builder.h:2293:      compiler::NameRef name, compiler::PropertyAccessInfo const& access_info,
maglev/maglev-graph-builder.h:2324:      const compiler::ElementAccessInfo& access_info,
maglev/maglev-graph-builder.h:2336:      const compiler::ElementAccessInfo& access_info,
maglev/maglev-graph-builder.h:2348:      const ZoneVector<compiler::ElementAccessInfo>& access_infos,
maglev/maglev-graph-builder.h:2355:      const ZoneVector<compiler::PropertyAccessInfo>& access_infos,
maglev/maglev-graph-builder.h:3085:  static size_t gvn_hash_value(const PolymorphicAccessInfo& access_info) {
execution/isolate.cc:7082:  // NOTE: Turbofan's JSNativeContextSpecialization and Maglev depend on
Observations: debug/debug-evaluate.cc:485:    case Bytecode::kCreateArrayFromIterable:
debug/debug-evaluate.cc:565:    case Builtin::kArrayFrom:
debug/debug-evaluate.cc:1269:        case Builtin::kArrayFrom:
debug/debug-evaluate.cc:1279:        case Builtin::kArrayFrom:
roots/roots.h:287:  APPLY(V, ArrayFromAsyncArrayLikeOnFulfilled,                                 \
roots/roots.h:289:  APPLY(V, ArrayFromAsyncArrayLikeOnRejected,                                  \
roots/roots.h:291:  APPLY(V, ArrayFromAsyncIterableOnFulfilled,                                  \
roots/roots.h:293:  APPLY(V, ArrayFromAsyncIterableOnRejected,                                   \
init/bootstrapper.cc:2227:                                 "StringFixedArrayFromIterable"),
init/bootstrapper.cc:2228:                             Builtin::kStringFixedArrayFromIterable, 1, kAdapt);
init/bootstrapper.cc:2231:  // The TemporalInsantFixedArrayFromIterable functions is created but not
init/bootstrapper.cc:2237:            "TemporalInstantFixedArrayFromIterable"),
init/bootstrapper.cc:2238:        Builtin::kTemporalInstantFixedArrayFromIterable, 1, kAdapt);
init/bootstrapper.cc:2544:    SimpleInstallFunction(isolate_, array_function, "from", Builtin::kArrayFrom,
init/bootstrapper.cc:2547:                          Builtin::kArrayFromAsync, 1, kDontAdapt);
init/bootstrapper.cc:4338:                          Builtin::kTypedArrayFrom, 1, kDontAdapt);
baseline/baseline-compiler.cc:1877:    CallBuiltin<Builtin::kCreateArrayFromSlowBoilerplate>(
baseline/baseline-compiler.cc:1885:void BaselineCompiler::VisitCreateArrayFromIterable() {
interpreter/bytecode-array-builder.h:277:  BytecodeArrayBuilder& CreateArrayFromIterable();
interpreter/interpreter-generator.cc:2543:        Builtin::kCreateArrayFromSlowBoilerplate, context, feedback_vector,
interpreter/interpreter-generator.cc:2593:// CreateArrayFromIterable
interpreter/interpreter-generator.cc:2597:IGNITION_HANDLER(CreateArrayFromIterable, InterpreterAssembler) {
runtime/runtime-wasm.cc:1242:    return *isolate->factory()->NewWasmArrayFromMemory(length, rtt, source);
runtime/runtime-wasm.cc:1260:        isolate->factory()->NewWasmArrayFromElementSegment(
builtins/builtins-proxy-gen.cc:121:  // 7. Let argArray be CreateArrayFromList(argumentsList).
builtins/builtins-proxy-gen.cc:176:  // 7. Let argArray be CreateArrayFromList(argumentsList).
builtins/arm64/builtins-arm64.cc:1052:         MemOperand(fp, InterpreterFrameConstants::kBytecodeArrayFromFp));
builtins/arm64/builtins-arm64.cc:1520:         MemOperand(fp, InterpreterFrameConstants::kBytecodeArrayFromFp));
builtins/arm64/builtins-arm64.cc:1552:         MemOperand(fp, InterpreterFrameConstants::kBytecodeArrayFromFp));
builtins/arm64/builtins-arm64.cc:1993:         MemOperand(fp, InterpreterFrameConstants::kBytecodeArrayFromFp));
builtins/arm64/builtins-arm64.cc:2078:         MemOperand(fp, InterpreterFrameConstants::kBytecodeArrayFromFp));
builtins/arm64/builtins-arm64.cc:5572:         MemOperand(fp, InterpreterFrameConstants::kBytecodeArrayFromFp));
interpreter/bytecodes.h:332:  V(CreateArrayFromIterable, ImplicitRegisterUse::kReadWriteAccumulator)       \
builtins/riscv/builtins-riscv.cc:847:              MemOperand(fp, InterpreterFrameConstants::kBytecodeArrayFromFp));
builtins/riscv/builtins-riscv.cc:1279:              MemOperand(fp, InterpreterFrameConstants::kBytecodeArrayFromFp));
builtins/riscv/builtins-riscv.cc:1314:              MemOperand(fp, InterpreterFrameConstants::kBytecodeArrayFromFp));
builtins/riscv/builtins-riscv.cc:1759:              MemOperand(fp, InterpreterFrameConstants::kBytecodeArrayFromFp));
builtins/riscv/builtins-riscv.cc:1802:              MemOperand(fp, InterpreterFrameConstants::kBytecodeArrayFromFp));
builtins/riscv/builtins-riscv.cc:5041:              MemOperand(fp, InterpreterFrameConstants::kBytecodeArrayFromFp));
builtins/riscv/builtins-riscv.cc:5059:              MemOperand(fp, InterpreterFrameConstants::kBytecodeArrayFromFp));
builtins/arm/builtins-arm.cc:819:         MemOperand(fp, InterpreterFrameConstants::kBytecodeArrayFromFp));
builtins/arm/builtins-arm.cc:1271:         MemOperand(fp, InterpreterFrameConstants::kBytecodeArrayFromFp));
builtins/arm/builtins-arm.cc:1304:         MemOperand(fp, InterpreterFrameConstants::kBytecodeArrayFromFp));
builtins/arm/builtins-arm.cc:1755:         MemOperand(fp, InterpreterFrameConstants::kBytecodeArrayFromFp));
builtins/arm/builtins-arm.cc:1796:         MemOperand(fp, InterpreterFrameConstants::kBytecodeArrayFromFp));
builtins/arm/builtins-arm.cc:4988:         MemOperand(fp, InterpreterFrameConstants::kBytecodeArrayFromFp));
interpreter/bytecode-generator.cc:4253:    // If we have a leading spread, use CreateArrayFromIterable to create
interpreter/bytecode-generator.cc:4257:    builder()->CreateArrayFromIterable().StoreAccumulatorInRegister(array);
builtins/builtins-array-gen.cc:1971:          Builtin::kCreateArrayFromSlowBoilerplateHelper, context,
builtins/builtins-array-gen.cc:2024:TF_BUILTIN(CreateArrayFromSlowBoilerplate, SlowBoilerplateCloneAssembler) {
builtins/builtins-array-gen.cc:2040:        Builtin::kCreateArrayFromSlowBoilerplateHelper, context,
builtins/builtins-array-gen.cc:2096:TF_BUILTIN(CreateArrayFromSlowBoilerplateHelper,
codegen/code-stub-assembler.cc:12438:TNode<BytecodeArray> CodeStubAssembler::LoadBytecodeArrayFromBaseline() {
codegen/code-stub-assembler.cc:12440:      LoadFromParentFrame(BaselineFrameConstants::kBytecodeArrayFromFp));
interpreter/bytecode-register.h:134:          InterpreterFrameConstants::kBytecodeArrayFromFp);
builtins/array-from-async.tq:7:extern enum ArrayFromAsyncLabels extends uint31
builtins/array-from-async.tq:8:    constexpr 'ArrayBuiltins::ArrayFromAsyncLabels' {
builtins/array-from-async.tq:23:transitioning macro ArrayFromAsyncAwaitPoint<T : type extends FunctionContext>(
builtins/array-from-async.tq:27:    rejectSlot: Slot<T, Undefined|JSFunction>, step: ArrayFromAsyncLabels,
builtins/array-from-async.tq:29:  *ContextSlot(resolveContext, stepSlot) = SmiTag<ArrayFromAsyncLabels>(step);
builtins/array-from-async.tq:45:RejectArrayFromAsyncPromise<T : type extends FunctionContext>(
builtins/array-from-async.tq:56:struct ArrayFromAsyncIterableResumeState {
builtins/array-from-async.tq:57:  step: ArrayFromAsyncLabels;
builtins/array-from-async.tq:62:type ArrayFromAsyncIterableResolveContext extends FunctionContext;
builtins/array-from-async.tq:63:extern enum ArrayFromAsyncIterableResolveContextSlots extends intptr
builtins/array-from-async.tq:64:    constexpr 'ArrayBuiltins::ArrayFromAsyncIterableResolveContextSlots' {
builtins/array-from-async.tq:65:  kArrayFromAsyncIterableResolveResumeStateStepSlot:
builtins/array-from-async.tq:66:      Slot<ArrayFromAsyncIterableResolveContext, Smi>,
builtins/array-from-async.tq:67:  kArrayFromAsyncIterableResolveResumeStateAwaitedValueSlot:
builtins/array-from-async.tq:68:      Slot<ArrayFromAsyncIterableResolveContext, JSAny>,
builtins/array-from-async.tq:69:  kArrayFromAsyncIterableResolveResumeStateIndexSlot:
builtins/array-from-async.tq:70:      Slot<ArrayFromAsyncIterableResolveContext, Smi>,
builtins/array-from-async.tq:71:  kArrayFromAsyncIterableResolvePromiseSlot:
builtins/array-from-async.tq:72:      Slot<ArrayFromAsyncIterableResolveContext, JSPromise>,
builtins/array-from-async.tq:73:  kArrayFromAsyncIterableResolvePromiseFunctionSlot:
builtins/array-from-async.tq:74:      Slot<ArrayFromAsyncIterableResolveContext, JSReceiver>,
builtins/array-from-async.tq:75:  kArrayFromAsyncIterableResolveOnFulfilledFunctionSlot:
builtins/array-from-async.tq:76:      Slot<ArrayFromAsyncIterableResolveContext, JSFunction|Undefined>,
builtins/array-from-async.tq:77:  kArrayFromAsyncIterableResolveOnRejectedFunctionSlot:
builtins/array-from-async.tq:78:      Slot<ArrayFromAsyncIterableResolveContext, JSFunction|Undefined>,
builtins/array-from-async.tq:79:  kArrayFromAsyncIterableResolveResultArraySlot:
builtins/array-from-async.tq:80:      Slot<ArrayFromAsyncIterableResolveContext, JSReceiver>,
builtins/array-from-async.tq:81:  kArrayFromAsyncIterableResolveIteratorSlot:
builtins/array-from-async.tq:82:      Slot<ArrayFromAsyncIterableResolveContext, JSReceiver>,
builtins/array-from-async.tq:83:  kArrayFromAsyncIterableResolveNextMethodSlot:
builtins/array-from-async.tq:84:      Slot<ArrayFromAsyncIterableResolveContext, JSAny>,
builtins/array-from-async.tq:85:  kArrayFromAsyncIterableResolveErrorSlot:
builtins/array-from-async.tq:86:      Slot<ArrayFromAsyncIterableResolveContext, JSAny>,
builtins/array-from-async.tq:87:  kArrayFromAsyncIterableResolveMapfnSlot:
builtins/array-from-async.tq:88:      Slot<ArrayFromAsyncIterableResolveContext, JSAny>,
builtins/array-from-async.tq:89:  kArrayFromAsyncIterableResolveThisArgSlot:
builtins/array-from-async.tq:90:      Slot<ArrayFromAsyncIterableResolveContext, JSAny>,
builtins/array-from-async.tq:91:  kArrayFromAsyncIterableResolveLength
builtins/array-from-async.tq:97:const kArrayFromAsyncIterableOnFulfilledSharedFun: constexpr intptr
builtins/array-from-async.tq:98:    generates 'RootIndex::kArrayFromAsyncIterableOnFulfilledSharedFun';
builtins/array-from-async.tq:99:const kArrayFromAsyncIterableOnRejectedSharedFun: constexpr intptr
builtins/array-from-async.tq💯    generates 'RootIndex::kArrayFromAsyncIterableOnRejectedSharedFun';
builtins/array-from-async.tq:102:macro CreateArrayFromAsyncIterableResolveContext(
builtins/array-from-async.tq:103:    implicit context: Context)(resumeState: ArrayFromAsyncIterableResumeState,
builtins/array-from-async.tq:106:    nativeContext: NativeContext): ArrayFromAsyncIterableResolveContext {
builtins/array-from-async.tq:107:  const resolveContext = %RawDownCast<ArrayFromAsyncIterableResolveContext>(
builtins/array-from-async.tq:110:          ArrayFromAsyncIterableResolveContextSlots::
builtins/array-from-async.tq:111:              kArrayFromAsyncIterableResolveLength));
builtins/array-from-async.tq:114:      ArrayFromAsyncIterableResolveContextSlots::
builtins/array-from-async.tq:115:          kArrayFromAsyncIterableResolveResumeStateStepSlot,
builtins/array-from-async.tq:116:      SmiTag<ArrayFromAsyncLabels>(resumeState.step));
builtins/array-from-async.tq:119:      ArrayFromAsyncIterableResolveContextSlots::
builtins/array-from-async.tq:120:          kArrayFromAsyncIterableResolveResumeStateAwaitedValueSlot,
builtins/array-from-async.tq:124:      ArrayFromAsyncIterableResolveContextSlots::
builtins/array-from-async.tq:125:          kArrayFromAsyncIterableResolveResumeStateIndexSlot,
builtins/array-from-async.tq:129:      ArrayFromAsyncIterableResolveContextSlots::
builtins/array-from-async.tq:130:          kArrayFromAsyncIterableResolvePromiseSlot,
builtins/array-from-async.tq:134:      ArrayFromAsyncIterableResolveContextSlots::
builtins/array-from-async.tq:135:          kArrayFromAsyncIterableResolvePromiseFunctionSlot,
builtins/array-from-async.tq:139:      ArrayFromAsyncIterableResolveContextSlots::
builtins/array-from-async.tq:140:          kArrayFromAsyncIterableResolveOnFulfilledFunctionSlot,
builtins/array-from-async.tq:142:          kArrayFromAsyncIterableOnFulfilledSharedFun, resolveContext,
builtins/array-from-async.tq:146:      ArrayFromAsyncIterableResolveContextSlots::
builtins/array-from-async.tq:147:          kArrayFromAsyncIterableResolveOnRejectedFunctionSlot,
builtins/array-from-async.tq:149:          kArrayFromAsyncIterableOnRejectedSharedFun, resolveContext,
builtins/array-from-async.tq:153:      ArrayFromAsyncIterableResolveContextSlots::
builtins/array-from-async.tq:154:          kArrayFromAsyncIterableResolveResultArraySlot,
builtins/array-from-async.tq:158:      ArrayFromAsyncIterableResolveContextSlots::
builtins/array-from-async.tq:159:          kArrayFromAsyncIterableResolveIteratorSlot,
builtins/array-from-async.tq:163:      ArrayFromAsyncIterableResolveContextSlots::
builtins/array-from-async.tq:164:          kArrayFromAsyncIterableResolveNextMethodSlot,
builtins/array-from-async.tq:168:      ArrayFromAsyncIterableResolveContextSlots::
builtins/array-from-async.tq:169:          kArrayFromAsyncIterableResolveErrorSlot,
builtins/array-from-async.tq:173:      ArrayFromAsyncIterableResolveContextSlots::
builtins/array-from-async.tq:174:          kArrayFromAsyncIterableResolveMapfnSlot,
builtins/array-from-async.tq:178:      ArrayFromAsyncIterableResolveContextSlots::
builtins/array-from-async.tq:179:          kArrayFromAsyncIterableResolveThisArgSlot,
builtins/array-from-async.tq:184:macro GetIteratorRecordFromArrayFromAsyncIterableResolveContext(
builtins/array-from-async.tq:185:    context: ArrayFromAsyncIterableResolveContext): iterator::IteratorRecord {
builtins/array-from-async.tq:188:      ArrayFromAsyncIterableResolveContextSlots::
builtins/array-from-async.tq:189:          kArrayFromAsyncIterableResolveIteratorSlot);
builtins/array-from-async.tq:193:      ArrayFromAsyncIterableResolveContextSlots::
builtins/array-from-async.tq:194:          kArrayFromAsyncIterableResolveNextMethodSlot);
builtins/array-from-async.tq:199:transitioning macro CreateArrayFromIterableAsynchronously(
builtins/array-from-async.tq:200:    context: ArrayFromAsyncIterableResolveContext): JSAny {
builtins/array-from-async.tq:206:        ArrayFromAsyncIterableResolveContextSlots::
builtins/array-from-async.tq:207:            kArrayFromAsyncIterableResolveMapfnSlot);
builtins/array-from-async.tq:211:        ArrayFromAsyncIterableResolveContextSlots::
builtins/array-from-async.tq:212:            kArrayFromAsyncIterableResolveThisArgSlot);
builtins/array-from-async.tq:216:        ArrayFromAsyncIterableResolveContextSlots::
builtins/array-from-async.tq:217:            kArrayFromAsyncIterableResolveResultArraySlot);
builtins/array-from-async.tq:219:    let resumeState = ArrayFromAsyncIterableResumeState{
builtins/array-from-async.tq:220:      step: SmiUntag<ArrayFromAsyncLabels>(
builtins/array-from-async.tq:221:          %RawDownCast<SmiTagged<ArrayFromAsyncLabels>>(*ContextSlot(
builtins/array-from-async.tq:223:              ArrayFromAsyncIterableResolveContextSlots::
builtins/array-from-async.tq:224:                  kArrayFromAsyncIterableResolveResumeStateStepSlot))),
builtins/array-from-async.tq:227:          ArrayFromAsyncIterableResolveContextSlots::
builtins/array-from-async.tq:228:              kArrayFromAsyncIterableResolveResumeStateAwaitedValueSlot),
builtins/array-from-async.tq:231:          ArrayFromAsyncIterableResolveContextSlots::
builtins/array-from-async.tq:232:              kArrayFromAsyncIterableResolveResumeStateIndexSlot)
builtins/array-from-async.tq:242:      if (resumeState.step == ArrayFromAsyncLabels::kGetIteratorStep) {
builtins/array-from-async.tq:244:            GetIteratorRecordFromArrayFromAsyncIterableResolveContext(context);
builtins/array-from-async.tq:252:        return ArrayFromAsyncIterableAwaitPoint(
builtins/array-from-async.tq:253:            context, ArrayFromAsyncLabels::kCheckIteratorValueAndMapping, next);
builtins/array-from-async.tq:256:          ArrayFromAsyncLabels::kCheckIteratorValueAndMapping) {
builtins/array-from-async.tq:260:            MessageTemplate::kIteratorResultNotAnObject, 'Array.fromAsync');
builtins/array-from-async.tq:277:            resumeState.step = ArrayFromAsyncLabels::kIteratorMapping;
builtins/array-from-async.tq:282:                ArrayFromAsyncLabels::kAddIteratorValueToTheArray;
builtins/array-from-async.tq:289:          resumeState.step = ArrayFromAsyncLabels::kDoneAndResolvePromise;
builtins/array-from-async.tq:291:      } else if (resumeState.step == ArrayFromAsyncLabels::kIteratorMapping) {
builtins/array-from-async.tq:302:        return ArrayFromAsyncIterableAwaitPoint(
builtins/array-from-async.tq:303:            context, ArrayFromAsyncLabels::kGetIteratorValueWithMapping,
builtins/array-from-async.tq:307:          ArrayFromAsyncLabels::kGetIteratorValueWithMapping) {
builtins/array-from-async.tq:309:        resumeState.step = ArrayFromAsyncLabels::kAddIteratorValueToTheArray;
builtins/array-from-async.tq:312:          ArrayFromAsyncLabels::kAddIteratorValueToTheArray) {
builtins/array-from-async.tq:324:            ArrayFromAsyncIterableResolveContextSlots::
builtins/array-from-async.tq:325:                kArrayFromAsyncIterableResolveResumeStateIndexSlot) =
builtins/array-from-async.tq:328:        resumeState.step = ArrayFromAsyncLabels::kGetIteratorStep;
builtins/array-from-async.tq:330:          resumeState.step == ArrayFromAsyncLabels::kDoneAndResolvePromise) {
builtins/array-from-async.tq:334:            ArrayFromAsyncIterableResolveContextSlots::
builtins/array-from-async.tq:335:                kArrayFromAsyncIterableResolvePromiseSlot);
builtins/array-from-async.tq:340:          resumeState.step == ArrayFromAsyncLabels::kCloseAsyncIterator) {
builtins/array-from-async.tq:341:        resumeState.step = ArrayFromAsyncLabels::kRejectPromise;
builtins/array-from-async.tq:344:            GetIteratorRecordFromArrayFromAsyncIterableResolveContext(context);
builtins/array-from-async.tq:346:          ArrayFromAsyncAsyncIteratorCloseOnException(iteratorRecord)
builtins/array-from-async.tq:352:      } else if (resumeState.step == ArrayFromAsyncLabels::kRejectPromise) {
builtins/array-from-async.tq:353:        return RejectArrayFromAsyncPromise<
builtins/array-from-async.tq:354:            ArrayFromAsyncIterableResolveContext>(
builtins/array-from-async.tq:356:            ArrayFromAsyncIterableResolveContextSlots::
builtins/array-from-async.tq:357:                kArrayFromAsyncIterableResolveErrorSlot,
builtins/array-from-async.tq:358:            ArrayFromAsyncIterableResolveContextSlots::
builtins/array-from-async.tq:359:                kArrayFromAsyncIterableResolvePromiseSlot);
builtins/array-from-async.tq:365:        ArrayFromAsyncIterableResolveContextSlots::
builtins/array-from-async.tq:366:            kArrayFromAsyncIterableResolveErrorSlot) = e;
builtins/array-from-async.tq:369:        GetIteratorRecordFromArrayFromAsyncIterableResolveContext(context);
builtins/array-from-async.tq:371:      ArrayFromAsyncAsyncIteratorCloseOnException(iteratorRecord)
builtins/array-from-async.tq:374:      return RejectArrayFromAsyncPromise<ArrayFromAsyncIterableResolveContext>(
builtins/array-from-async.tq:376:          ArrayFromAsyncIterableResolveContextSlots::
builtins/array-from-async.tq:377:              kArrayFromAsyncIterableResolveErrorSlot,
builtins/array-from-async.tq:378:          ArrayFromAsyncIterableResolveContextSlots::
builtins/array-from-async.tq:379:              kArrayFromAsyncIterableResolvePromiseSlot);
builtins/array-from-async.tq:385:transitioning macro ArrayFromAsyncIterableAwaitPoint(
builtins/array-from-async.tq:386:    context: ArrayFromAsyncIterableResolveContext, step: ArrayFromAsyncLabels,
builtins/array-from-async.tq:388:  return ArrayFromAsyncAwaitPoint<ArrayFromAsyncIterableResolveContext>(
builtins/array-from-async.tq:390:      ArrayFromAsyncIterableResolveContextSlots::
builtins/array-from-async.tq:391:          kArrayFromAsyncIterableResolveResumeStateStepSlot,
builtins/array-from-async.tq:392:      ArrayFromAsyncIterableResolveContextSlots::
builtins/array-from-async.tq:393:          kArrayFromAsyncIterableResolvePromiseFunctionSlot,
builtins/array-from-async.tq:394:      ArrayFromAsyncIterableResolveContextSlots::
builtins/array-from-async.tq:395:          kArrayFromAsyncIterableResolveOnFulfilledFunctionSlot,
builtins/array-from-async.tq:396:      ArrayFromAsyncIterableResolveContextSlots::
builtins/array-from-async.tq:397:          kArrayFromAsyncIterableResolveOnRejectedFunctionSlot,
builtins/array-from-async.tq:401:// `ArrayFromAsyncIterableOnFulfilled` is the callback function for the
builtins/array-from-async.tq:403:transitioning javascript builtin ArrayFromAsyncIterableOnFulfilled(
builtins/array-from-async.tq:406:  const context = %RawDownCast<ArrayFromAsyncIterableResolveContext>(context);
builtins/array-from-async.tq:409:      ArrayFromAsyncIterableResolveContextSlots::
builtins/array-from-async.tq:410:          kArrayFromAsyncIterableResolveResumeStateAwaitedValueSlot) = result;
builtins/array-from-async.tq:412:  return CreateArrayFromIterableAsynchronously(context);
builtins/array-from-async.tq:415:// `ArrayFromAsyncIterableOnRejected` is the callback function for the rejected
builtins/array-from-async.tq:417:transitioning javascript builtin ArrayFromAsyncIterableOnRejected(
builtins/array-from-async.tq:420:  const context = %RawDownCast<ArrayFromAsyncIterableResolveContext>(context);
builtins/array-from-async.tq:424:      ArrayFromAsyncIterableResolveContextSlots::
builtins/array-from-async.tq:425:          kArrayFromAsyncIterableResolveResumeStateStepSlot) =
builtins/array-from-async.tq:426:      SmiTag<ArrayFromAsyncLabels>(ArrayFromAsyncLabels::kCloseAsyncIterator);
builtins/array-from-async.tq:429:      ArrayFromAsyncIterableResolveContextSlots::
builtins/array-from-async.tq:430:          kArrayFromAsyncIterableResolveErrorSlot) = result;
builtins/array-from-async.tq:432:  return CreateArrayFromIterableAsynchronously(context);
builtins/array-from-async.tq:436:// Array.fromAsync
builtins/array-from-async.tq:438:transitioning macro ArrayFromAsyncAsyncIteratorCloseOnException(
builtins/array-from-async.tq:442:    const context = %RawDownCast<ArrayFromAsyncIterableResolveContext>(context);
builtins/array-from-async.tq:459:    const step = ArrayFromAsyncLabels::kRejectPromise;
builtins/array-from-async.tq:460:    ArrayFromAsyncIterableAwaitPoint(context, step, innerResult);
builtins/array-from-async.tq:468:extern macro ArrayFromAsyncIterableOnFulfilledSharedFunConstant():
builtins/array-from-async.tq:470:extern macro ArrayFromAsyncIterableOnRejectedSharedFunConstant():
builtins/array-from-async.tq:475:struct ArrayFromAsyncArrayLikeResumeState {
builtins/array-from-async.tq:476:  step: ArrayFromAsyncLabels;
builtins/array-from-async.tq:482:type ArrayFromAsyncArrayLikeResolveContext extends FunctionContext;
builtins/array-from-async.tq:483:extern enum ArrayFromAsyncArrayLikeResolveContextSlots extends intptr
builtins/array-from-async.tq:484:    constexpr 'ArrayBuiltins::ArrayFromAsyncArrayLikeResolveContextSlots' {
builtins/array-from-async.tq:485:  kArrayFromAsyncArrayLikeResolveResumeStateStepSlot:
builtins/array-from-async.tq:486:      Slot<ArrayFromAsyncArrayLikeResolveContext, Smi>,
builtins/array-from-async.tq:487:  kArrayFromAsyncArrayLikeResolveResumeStateAwaitedValueSlot:
builtins/array-from-async.tq:488:      Slot<ArrayFromAsyncArrayLikeResolveContext, JSAny>,
builtins/array-from-async.tq:489:  kArrayFromAsyncArrayLikeResolveResumeStateLenSlot:
builtins/array-from-async.tq:490:      Slot<ArrayFromAsyncArrayLikeResolveContext, Number>,
builtins/array-from-async.tq:491:  kArrayFromAsyncArrayLikeResolveResumeStateIndexSlot:
builtins/array-from-async.tq:492:      Slot<ArrayFromAsyncArrayLikeResolveContext, Smi>,
builtins/array-from-async.tq:493:  kArrayFromAsyncArrayLikeResolvePromiseSlot:
builtins/array-from-async.tq:494:      Slot<ArrayFromAsyncArrayLikeResolveContext, JSPromise>,
builtins/array-from-async.tq:495:  kArrayFromAsyncArrayLikeResolvePromiseFunctionSlot:
builtins/array-from-async.tq:496:      Slot<ArrayFromAsyncArrayLikeResolveContext, JSReceiver>,
builtins/array-from-async.tq:497:  kArrayFromAsyncArrayLikeResolveOnFulfilledFunctionSlot:
builtins/array-from-async.tq:498:      Slot<ArrayFromAsyncArrayLikeResolveContext, JSFunction|Undefined>,
builtins/array-from-async.tq:499:  kArrayFromAsyncArrayLikeResolveOnRejectedFunctionSlot:
builtins/array-from-async.tq:500:      Slot<ArrayFromAsyncArrayLikeResolveContext, JSFunction|Undefined>,
builtins/array-from-async.tq:501:  kArrayFromAsyncArrayLikeResolveResultArraySlot:
builtins/array-from-async.tq:502:      Slot<ArrayFromAsyncArrayLikeResolveContext, JSReceiver>,
builtins/array-from-async.tq:503:  kArrayFromAsyncArrayLikeResolveArrayLikeSlot:
builtins/array-from-async.tq:504:      Slot<ArrayFromAsyncArrayLikeResolveContext, JSReceiver>,
builtins/array-from-async.tq:505:  kArrayFromAsyncArrayLikeResolveErrorSlot:
builtins/array-from-async.tq:506:      Slot<ArrayFromAsyncArrayLikeResolveContext, JSAny>,
builtins/array-from-async.tq:507:  kArrayFromAsyncArrayLikeResolveMapfnSlot:
builtins/array-from-async.tq:508:      Slot<ArrayFromAsyncArrayLikeResolveContext, JSAny>,
builtins/array-from-async.tq:509:  kArrayFromAsyncArrayLikeResolveThisArgSlot:
builtins/array-from-async.tq:510:      Slot<ArrayFromAsyncArrayLikeResolveContext, JSAny>,
builtins/array-from-async.tq:511:  kArrayFromAsyncArrayLikeResolveLength
builtins/array-from-async.tq:514:const kArrayFromAsyncArrayLikeOnFulfilledSharedFun: constexpr intptr
builtins/array-from-async.tq:515:    generates 'RootIndex::kArrayFromAsyncArrayLikeOnFulfilledSharedFun';
builtins/array-from-async.tq:516:const kArrayFromAsyncArrayLikeOnRejectedSharedFun: constexpr intptr
builtins/array-from-async.tq:517:    generates 'RootIndex::kArrayFromAsyncArrayLikeOnRejectedSharedFun';
builtins/array-from-async.tq:519:macro CreateArrayFromAsyncArrayLikeResolveContext(
builtins/array-from-async.tq:520:    implicit context: Context)(resumeState: ArrayFromAsyncArrayLikeResumeState,
builtins/array-from-async.tq:523:    nativeContext: NativeContext): ArrayFromAsyncArrayLikeResolveContext {
builtins/array-from-async.tq:524:  const resolveContext = %RawDownCast<ArrayFromAsyncArrayLikeResolveContext>(
builtins/array-from-async.tq:527:          ArrayFromAsyncArrayLikeResolveContextSlots::
builtins/array-from-async.tq:528:              kArrayFromAsyncArrayLikeResolveLength));
builtins/array-from-async.tq:531:      ArrayFromAsyncArrayLikeResolveContextSlots::
builtins/array-from-async.tq:532:          kArrayFromAsyncArrayLikeResolveResumeStateStepSlot,
builtins/array-from-async.tq:533:      SmiTag<ArrayFromAsyncLabels>(resumeState.step));
builtins/array-from-async.tq:536:      ArrayFromAsyncArrayLikeResolveContextSlots::
builtins/array-from-async.tq:537:          kArrayFromAsyncArrayLikeResolveResumeStateAwaitedValueSlot,
builtins/array-from-async.tq:541:      ArrayFromAsyncArrayLikeResolveContextSlots::
builtins/array-from-async.tq:542:          kArrayFromAsyncArrayLikeResolveResumeStateLenSlot,
builtins/array-from-async.tq:546:      ArrayFromAsyncArrayLikeResolveContextSlots::
builtins/array-from-async.tq:547:          kArrayFromAsyncArrayLikeResolveResumeStateIndexSlot,
builtins/array-from-async.tq:551:      ArrayFromAsyncArrayLikeResolveContextSlots::
builtins/array-from-async.tq:552:          kArrayFromAsyncArrayLikeResolvePromiseSlot,
builtins/array-from-async.tq:556:      ArrayFromAsyncArrayLikeResolveContextSlots::
builtins/array-from-async.tq:557:          kArrayFromAsyncArrayLikeResolvePromiseFunctionSlot,
builtins/array-from-async.tq:561:      ArrayFromAsyncArrayLikeResolveContextSlots::
builtins/array-from-async.tq:562:          kArrayFromAsyncArrayLikeResolveOnFulfilledFunctionSlot,
builtins/array-from-async.tq:564:          kArrayFromAsyncArrayLikeOnFulfilledSharedFun, resolveContext,
builtins/array-from-async.tq:568:      ArrayFromAsyncArrayLikeResolveContextSlots::
builtins/array-from-async.tq:569:          kArrayFromAsyncArrayLikeResolveOnRejectedFunctionSlot,
builtins/array-from-async.tq:571:          kArrayFromAsyncArrayLikeOnRejectedSharedFun, resolveContext,
builtins/array-from-async.tq:575:      ArrayFromAsyncArrayLikeResolveContextSlots::
builtins/array-from-async.tq:576:          kArrayFromAsyncArrayLikeResolveResultArraySlot,
builtins/array-from-async.tq:580:      ArrayFromAsyncArrayLikeResolveContextSlots::
builtins/array-from-async.tq:581:          kArrayFromAsyncArrayLikeResolveArrayLikeSlot,
builtins/array-from-async.tq:585:      ArrayFromAsyncArrayLikeResolveContextSlots::
builtins/array-from-async.tq:586:          kArrayFromAsyncArrayLikeResolveErrorSlot,
builtins/array-from-async.tq:590:      ArrayFromAsyncArrayLikeResolveContextSlots::
builtins/array-from-async.tq:591:          kArrayFromAsyncArrayLikeResolveMapfnSlot,
builtins/array-from-async.tq:595:      ArrayFromAsyncArrayLikeResolveContextSlots::
builtins/array-from-async.tq:596:          kArrayFromAsyncArrayLikeResolveThisArgSlot,
builtins/array-from-async.tq:601:transitioning macro CreateArrayFromArrayLikeAsynchronously(
builtins/array-from-async.tq:602:    context: ArrayFromAsyncArrayLikeResolveContext): JSAny {
builtins/array-from-async.tq:606:        ArrayFromAsyncArrayLikeResolveContextSlots::
builtins/array-from-async.tq:607:            kArrayFromAsyncArrayLikeResolveMapfnSlot);
builtins/array-from-async.tq:611:        ArrayFromAsyncArrayLikeResolveContextSlots::
builtins/array-from-async.tq:612:            kArrayFromAsyncArrayLikeResolveThisArgSlot);
builtins/array-from-async.tq:616:        ArrayFromAsyncArrayLikeResolveContextSlots::
builtins/array-from-async.tq:617:            kArrayFromAsyncArrayLikeResolveResultArraySlot);
builtins/array-from-async.tq:619:    let resumeState = ArrayFromAsyncArrayLikeResumeState{
builtins/array-from-async.tq:620:      step: SmiUntag<ArrayFromAsyncLabels>(
builtins/array-from-async.tq:621:          %RawDownCast<SmiTagged<ArrayFromAsyncLabels>>(*ContextSlot(
builtins/array-from-async.tq:623:              ArrayFromAsyncArrayLikeResolveContextSlots::
builtins/array-from-async.tq:624:                  kArrayFromAsyncArrayLikeResolveResumeStateStepSlot))),
builtins/array-from-async.tq:627:          ArrayFromAsyncArrayLikeResolveContextSlots::
builtins/array-from-async.tq:628:              kArrayFromAsyncArrayLikeResolveResumeStateAwaitedValueSlot),
builtins/array-from-async.tq:631:          ArrayFromAsyncArrayLikeResolveContextSlots::
builtins/array-from-async.tq:632:              kArrayFromAsyncArrayLikeResolveResumeStateLenSlot),
builtins/array-from-async.tq:635:          ArrayFromAsyncArrayLikeResolveContextSlots::
builtins/array-from-async.tq:636:              kArrayFromAsyncArrayLikeResolveResumeStateIndexSlot)
builtins/array-from-async.tq:645:      if (resumeState.step == ArrayFromAsyncLabels::kGetArrayLikeValue) {
builtins/array-from-async.tq:648:            ArrayFromAsyncArrayLikeResolveContextSlots::
builtins/array-from-async.tq:649:                kArrayFromAsyncArrayLikeResolveArrayLikeSlot);
builtins/array-from-async.tq:658:          return ArrayFromAsyncArrayLikeAwaitPoint(
builtins/array-from-async.tq:659:              context, ArrayFromAsyncLabels::kCheckArrayLikeValueAndMapping,
builtins/array-from-async.tq:665:        resumeState.step = ArrayFromAsyncLabels::kDoneAndResolvePromise;
builtins/array-from-async.tq:668:          ArrayFromAsyncLabels::kCheckArrayLikeValueAndMapping) {
builtins/array-from-async.tq:675:              ArrayFromAsyncLabels::kGetArrayLikeValueWithMapping;
builtins/array-from-async.tq:677:          resumeState.step = ArrayFromAsyncLabels::kAddArrayLikeValueToTheArray;
builtins/array-from-async.tq:681:          ArrayFromAsyncLabels::kGetArrayLikeValueWithMapping) {
builtins/array-from-async.tq:688:        return ArrayFromAsyncArrayLikeAwaitPoint(
builtins/array-from-async.tq:689:            context, ArrayFromAsyncLabels::kAddArrayLikeValueToTheArray,
builtins/array-from-async.tq:693:          ArrayFromAsyncLabels::kAddArrayLikeValueToTheArray) {
builtins/array-from-async.tq:704:            ArrayFromAsyncArrayLikeResolveContextSlots::
builtins/array-from-async.tq:705:                kArrayFromAsyncArrayLikeResolveResumeStateIndexSlot) =
builtins/array-from-async.tq:708:        resumeState.step = ArrayFromAsyncLabels::kGetArrayLikeValue;
builtins/array-from-async.tq:710:          resumeState.step == ArrayFromAsyncLabels::kDoneAndResolvePromise) {
builtins/array-from-async.tq:714:            ArrayFromAsyncArrayLikeResolveContextSlots::
builtins/array-from-async.tq:715:                kArrayFromAsyncArrayLikeResolvePromiseSlot);
builtins/array-from-async.tq:719:      } else if (resumeState.step == ArrayFromAsyncLabels::kRejectPromise) {
builtins/array-from-async.tq:720:        return RejectArrayFromAsyncPromise<
builtins/array-from-async.tq:721:            ArrayFromAsyncArrayLikeResolveContext>(
builtins/array-from-async.tq:723:            ArrayFromAsyncArrayLikeResolveContextSlots::
builtins/array-from-async.tq:724:                kArrayFromAsyncArrayLikeResolveErrorSlot,
builtins/array-from-async.tq:725:            ArrayFromAsyncArrayLikeResolveContextSlots::
builtins/array-from-async.tq:726:                kArrayFromAsyncArrayLikeResolvePromiseSlot);
builtins/array-from-async.tq:732:        ArrayFromAsyncArrayLikeResolveContextSlots::
builtins/array-from-async.tq:733:            kArrayFromAsyncArrayLikeResolveErrorSlot) = e;
builtins/array-from-async.tq:735:    return RejectArrayFromAsyncPromise<ArrayFromAsyncArrayLikeResolveContext>(
builtins/array-from-async.tq:737:        ArrayFromAsyncArrayLikeResolveContextSlots::
builtins/array-from-async.tq:738:            kArrayFromAsyncArrayLikeResolveErrorSlot,
builtins/array-from-async.tq:739:        ArrayFromAsyncArrayLikeResolveContextSlots::
builtins/array-from-async.tq:740:            kArrayFromAsyncArrayLikeResolvePromiseSlot);
builtins/array-from-async.tq:745:transitioning macro ArrayFromAsyncArrayLikeAwaitPoint(
builtins/array-from-async.tq:746:    context: ArrayFromAsyncArrayLikeResolveContext, step: ArrayFromAsyncLabels,
builtins/array-from-async.tq:748:  return ArrayFromAsyncAwaitPoint<ArrayFromAsyncArrayLikeResolveContext>(
builtins/array-from-async.tq:750:      ArrayFromAsyncArrayLikeResolveContextSlots::
builtins/array-from-async.tq:751:          kArrayFromAsyncArrayLikeResolveResumeStateStepSlot,
builtins/array-from-async.tq:752:      ArrayFromAsyncArrayLikeResolveContextSlots::
builtins/array-from-async.tq:753:          kArrayFromAsyncArrayLikeResolvePromiseFunctionSlot,
builtins/array-from-async.tq:754:      ArrayFromAsyncArrayLikeResolveContextSlots::
builtins/array-from-async.tq:755:          kArrayFromAsyncArrayLikeResolveOnFulfilledFunctionSlot,
builtins/array-from-async.tq:756:      ArrayFromAsyncArrayLikeResolveContextSlots::
builtins/array-from-async.tq:757:          kArrayFromAsyncArrayLikeResolveOnRejectedFunctionSlot,
builtins/array-from-async.tq:761:// `ArrayFromAsyncArrayLikeOnFulfilled` is the callback function for the
builtins/array-from-async.tq:763:transitioning javascript builtin ArrayFromAsyncArrayLikeOnFulfilled(
builtins/array-from-async.tq:766:  const context = %RawDownCast<ArrayFromAsyncArrayLikeResolveContext>(context);
builtins/array-from-async.tq:769:      ArrayFromAsyncArrayLikeResolveContextSlots::
builtins/array-from-async.tq:770:          kArrayFromAsyncArrayLikeResolveResumeStateAwaitedValueSlot) = result;
builtins/array-from-async.tq:772:  return CreateArrayFromArrayLikeAsynchronously(context);
builtins/array-from-async.tq:775:// `ArrayFromAsyncArrayLikeOnRejected` is the callback function for the rejected
builtins/array-from-async.tq:777:transitioning javascript builtin ArrayFromAsyncArrayLikeOnRejected(
builtins/array-from-async.tq:780:  const context = %RawDownCast<ArrayFromAsyncArrayLikeResolveContext>(context);
builtins/array-from-async.tq:784:      ArrayFromAsyncArrayLikeResolveContextSlots::
builtins/array-from-async.tq:785:          kArrayFromAsyncArrayLikeResolveResumeStateStepSlot) =
builtins/array-from-async.tq:786:      SmiTag<ArrayFromAsyncLabels>(ArrayFromAsyncLabels::kRejectPromise);
builtins/array-from-async.tq:789:      ArrayFromAsyncArrayLikeResolveContextSlots::
builtins/array-from-async.tq:790:          kArrayFromAsyncArrayLikeResolveErrorSlot) = result;
builtins/array-from-async.tq:792:  return CreateArrayFromArrayLikeAsynchronously(context);
builtins/array-from-async.tq:795:extern macro ArrayFromAsyncArrayLikeOnFulfilledSharedFunConstant():
builtins/array-from-async.tq:797:extern macro ArrayFromAsyncArrayLikeOnRejectedSharedFunConstant():
builtins/array-from-async.tq:800:// --- Array.fromAsync builtin
builtins/array-from-async.tq:803:// Array.fromAsync ( asyncItems | , mapfn | , thisArg ] ] )
builtins/array-from-async.tq:807:@incrementUseCounter('v8::Isolate::kArrayFromAsync')
builtins/array-from-async.tq:808:transitioning javascript builtin ArrayFromAsync(
builtins/array-from-async.tq:882:      let resumeState = ArrayFromAsyncArrayLikeResumeState{
builtins/array-from-async.tq:883:        step: ArrayFromAsyncLabels::kGetArrayLikeValue,
builtins/array-from-async.tq:890:          CreateArrayFromAsyncArrayLikeResolveContext(
builtins/array-from-async.tq:894:      CreateArrayFromArrayLikeAsynchronously(arrayLikeResolveContext);
builtins/array-from-async.tq:900:          'Array.fromAsync');
builtins/array-from-async.tq:905:          'Array.fromAsync');
builtins/array-from-async.tq:937:    let iterableResumeState = ArrayFromAsyncIterableResumeState{
builtins/array-from-async.tq:938:      step: ArrayFromAsyncLabels::kGetIteratorStep,
builtins/array-from-async.tq:943:    const iterableResolveContext = CreateArrayFromAsyncIterableResolveContext(
builtins/array-from-async.tq:947:    CreateArrayFromIterableAsynchronously(iterableResolveContext);
builtins/typed-array-set.tq:77:      // 1. Choose SetTypedArrayFromTypedArray or SetTypedArrayFromArrayLike
builtins/typed-array-set.tq:109:// SetTypedArrayFromArrayLike
builtins/typed-array-set.tq:169:// SetTypedArrayFromTypedArray
builtins/builtins-array-gen.h:130:  enum ArrayFromAsyncIterableResolveContextSlots {
builtins/builtins-array-gen.h:131:    kArrayFromAsyncIterableResolveResumeStateStepSlot =
builtins/builtins-array-gen.h:133:    kArrayFromAsyncIterableResolveResumeStateAwaitedValueSlot,
builtins/builtins-array-gen.h:134:    kArrayFromAsyncIterableResolveResumeStateIndexSlot,
builtins/builtins-array-gen.h:135:    kArrayFromAsyncIterableResolvePromiseSlot,
builtins/builtins-array-gen.h:136:    kArrayFromAsyncIterableResolvePromiseFunctionSlot,
builtins/builtins-array-gen.h:137:    kArrayFromAsyncIterableResolveOnFulfilledFunctionSlot,
builtins/builtins-array-gen.h:138:    kArrayFromAsyncIterableResolveOnRejectedFunctionSlot,
builtins/builtins-array-gen.h:139:    kArrayFromAsyncIterableResolveResultArraySlot,
builtins/builtins-array-gen.h:140:    kArrayFromAsyncIterableResolveIteratorSlot,
builtins/builtins-array-gen.h:141:    kArrayFromAsyncIterableResolveNextMethodSlot,
builtins/builtins-array-gen.h:142:    kArrayFromAsyncIterableResolveErrorSlot,
builtins/builtins-array-gen.h:143:    kArrayFromAsyncIterableResolveMapfnSlot,
builtins/builtins-array-gen.h:144:    kArrayFromAsyncIterableResolveThisArgSlot,
builtins/builtins-array-gen.h:145:    kArrayFromAsyncIterableResolveLength
builtins/builtins-array-gen.h:148:  enum ArrayFromAsyncArrayLikeResolveContextSlots {
builtins/builtins-array-gen.h:149:    kArrayFromAsyncArrayLikeResolveResumeStateStepSlot =
builtins/builtins-array-gen.h:151:    kArrayFromAsyncArrayLikeResolveResumeStateAwaitedValueSlot,
builtins/builtins-array-gen.h:152:    kArrayFromAsyncArrayLikeResolveResumeStateLenSlot,
builtins/builtins-array-gen.h:153:    kArrayFromAsyncArrayLikeResolveResumeStateIndexSlot,
builtins/builtins-array-gen.h:154:    kArrayFromAsyncArrayLikeResolvePromiseSlot,
builtins/builtins-array-gen.h:155:    kArrayFromAsyncArrayLikeResolvePromiseFunctionSlot,
builtins/builtins-array-gen.h:156:    kArrayFromAsyncArrayLikeResolveOnFulfilledFunctionSlot,
builtins/builtins-array-gen.h:157:    kArrayFromAsyncArrayLikeResolveOnRejectedFunctionSlot,
builtins/builtins-array-gen.h:158:    kArrayFromAsyncArrayLikeResolveResultArraySlot,
builtins/builtins-array-gen.h:159:    kArrayFromAsyncArrayLikeResolveArrayLikeSlot,
builtins/builtins-array-gen.h:160:    kArrayFromAsyncArrayLikeResolveErrorSlot,
builtins/builtins-array-gen.h:161:    kArrayFromAsyncArrayLikeResolveMapfnSlot,
builtins/builtins-array-gen.h:162:    kArrayFromAsyncArrayLikeResolveThisArgSlot,
builtins/builtins-array-gen.h:163:    kArrayFromAsyncArrayLikeResolveLength
builtins/builtins-array-gen.h:166:  enum ArrayFromAsyncLabels {
interpreter/bytecode-array-builder.cc:1099:BytecodeArrayBuilder& BytecodeArrayBuilder::CreateArrayFromIterable() {
interpreter/bytecode-array-builder.cc:1100:  OutputCreateArrayFromIterable();
builtins/mips64/builtins-mips64.cc:797:        MemOperand(fp, InterpreterFrameConstants::kBytecodeArrayFromFp));
builtins/mips64/builtins-mips64.cc:1230:        MemOperand(fp, InterpreterFrameConstants::kBytecodeArrayFromFp));
builtins/mips64/builtins-mips64.cc:1264:        MemOperand(fp, InterpreterFrameConstants::kBytecodeArrayFromFp));
builtins/mips64/builtins-mips64.cc:1702:        MemOperand(fp, InterpreterFrameConstants::kBytecodeArrayFromFp));
builtins/mips64/builtins-mips64.cc:1743:        MemOperand(fp, InterpreterFrameConstants::kBytecodeArrayFromFp));
builtins/mips64/builtins-mips64.cc:3947:        MemOperand(fp, InterpreterFrameConstants::kBytecodeArrayFromFp));
builtins/mips64/builtins-mips64.cc:3964:        MemOperand(fp, InterpreterFrameConstants::kBytecodeArrayFromFp));
builtins/promise-all.tq:313:      //     Let valuesArray be CreateArrayFromList(values).
wasm/wrappers.cc:655:          BuildMultiReturnFixedArrayFromIterable(call, native_context);
wasm/wrappers.cc:1305:  V<FixedArray> BuildMultiReturnFixedArrayFromIterable(OpIndex iterable,
wasm/constant-expression-interface.cc:289:      WasmValue(isolate_->factory()->NewWasmArrayFromElements(
wasm/constant-expression-interface.cc:334:        isolate_->factory()->NewWasmArrayFromMemory(length, rtt, source);
wasm/constant-expression-interface.cc:352:        isolate_->factory()->NewWasmArrayFromElementSegment(
compiler/operator-properties.cc:42:    case IrOpcode::kJSCreateArrayFromIterable:
compiler/operator-properties.cc:195:    case IrOpcode::kJSCreateArrayFromIterable:
compiler/bytecode-graph-builder.cc:2432:void BytecodeGraphBuilder::VisitCreateArrayFromIterable() {
compiler/bytecode-graph-builder.cc:2433:  Node* iterable = NewNode(javascript()->CreateArrayFromIterable(),
compiler/wasm-compiler.h:825:  Node* BuildMultiReturnFixedArrayFromIterable(const wasm::FunctionSig* sig,
objects/intl-objects.cc:818:    // 3a. Let O be CreateArrayFromList(« locales »).
objects/intl-objects.cc:2083:MaybeHandle<JSArray> CreateArrayFromList(Isolate* isolate,
objects/intl-objects.cc:2142:  // 5. Return CreateArrayFromList(supportedLocales).
objects/intl-objects.cc:2143:  return CreateArrayFromList(isolate, supported_locales,
objects/intl-objects.cc:2157:  // 2. Return CreateArrayFromList(ll).
objects/intl-objects.cc:2158:  return CreateArrayFromList(isolate, maybe_ll.FromJust(),
objects/intl-objects.cc:2331:  // 9. Return ! CreateArrayFromList( list ).
objects/js-plural-rules.cc:321:  // CreateArrayFromList(pluralCategories)).
builtins/builtins-iterator-gen.cc:205:  FillFixedArrayFromIterable(context, iterable, iterator_fn, &values);
builtins/builtins-iterator-gen.cc:212:  FillFixedArrayFromIterable(context, iterable, iterator_fn, &values);
builtins/builtins-iterator-gen.cc:217:void IteratorBuiltinsAssembler::FillFixedArrayFromIterable(
builtins/builtins-iterator-gen.cc:269:  FillFixedArrayFromIterable(context, iterable, iterator_fn, &values);
builtins/builtins-iterator-gen.cc:346:TF_BUILTIN(StringFixedArrayFromIterable, IteratorBuiltinsAssembler) {
builtins/ia32/builtins-ia32.cc:748:         Operand(ebp, InterpreterFrameConstants::kBytecodeArrayFromFp));
builtins/ia32/builtins-ia32.cc:1059:         Operand(ebp, InterpreterFrameConstants::kBytecodeArrayFromFp));
builtins/ia32/builtins-ia32.cc:1092:         Operand(ebp, InterpreterFrameConstants::kBytecodeArrayFromFp));
builtins/ia32/builtins-ia32.cc:1762:         Operand(ebp, InterpreterFrameConstants::kBytecodeArrayFromFp));
builtins/ia32/builtins-ia32.cc:1800:         Operand(ebp, InterpreterFrameConstants::kBytecodeArrayFromFp));
builtins/ia32/builtins-ia32.cc:5464:         MemOperand(ebp, InterpreterFrameConstants::kBytecodeArrayFromFp));
builtins/x64/builtins-x64.cc:962:          Operand(rbp, InterpreterFrameConstants::kBytecodeArrayFromFp));
builtins/x64/builtins-x64.cc:1276:          Operand(rbp, InterpreterFrameConstants::kBytecodeArrayFromFp));
builtins/x64/builtins-x64.cc:1307:          Operand(rbp, InterpreterFrameConstants::kBytecodeArrayFromFp));
builtins/x64/builtins-x64.cc:1804:          Operand(rbp, InterpreterFrameConstants::kBytecodeArrayFromFp));
builtins/x64/builtins-x64.cc:1849:          Operand(rbp, InterpreterFrameConstants::kBytecodeArrayFromFp));
builtins/x64/builtins-x64.cc:5261:          MemOperand(rbp, InterpreterFrameConstants::kBytecodeArrayFromFp));
builtins/iterator-helpers.tq:836:      //  b. If next is false, return CreateArrayFromList(items).
builtins/array-from.tq:6:// Array.from( items |, mapfn |, thisArg ] ] )
builtins/array-from.tq:8:transitioning javascript builtin ArrayFrom(
builtins/loong64/builtins-loong64.cc:824:          MemOperand(fp, InterpreterFrameConstants::kBytecodeArrayFromFp));
builtins/loong64/builtins-loong64.cc:1272:          MemOperand(fp, InterpreterFrameConstants::kBytecodeArrayFromFp));
builtins/loong64/builtins-loong64.cc:1306:          MemOperand(fp, InterpreterFrameConstants::kBytecodeArrayFromFp));
builtins/loong64/builtins-loong64.cc:1756:          MemOperand(fp, InterpreterFrameConstants::kBytecodeArrayFromFp));
builtins/loong64/builtins-loong64.cc:1798:          MemOperand(fp, InterpreterFrameConstants::kBytecodeArrayFromFp));
builtins/loong64/builtins-loong64.cc:5021:          MemOperand(fp, InterpreterFrameConstants::kBytecodeArrayFromFp));
builtins/loong64/builtins-loong64.cc:5038:          MemOperand(fp, InterpreterFrameConstants::kBytecodeArrayFromFp));
builtins/object-groupby.tq:178:  //   a. Let elements be CreateArrayFromList(g.||Elements]]).
builtins/s390/builtins-s390.cc:204:             MemOperand(fp, InterpreterFrameConstants::kBytecodeArrayFromFp));
builtins/s390/builtins-s390.cc:1124:             MemOperand(fp, InterpreterFrameConstants::kBytecodeArrayFromFp));
builtins/s390/builtins-s390.cc:1545:             MemOperand(fp, InterpreterFrameConstants::kBytecodeArrayFromFp));
builtins/s390/builtins-s390.cc:1578:             MemOperand(fp, InterpreterFrameConstants::kBytecodeArrayFromFp));
builtins/s390/builtins-s390.cc:2030:             MemOperand(fp, InterpreterFrameConstants::kBytecodeArrayFromFp));
builtins/s390/builtins-s390.cc:2071:             MemOperand(fp, InterpreterFrameConstants::kBytecodeArrayFromFp));
objects/js-temporal-objects.cc:4065:  // 2. Let fieldsArray be ! CreateArrayFromList(fieldNames).
objects/js-temporal-objects.cc:11081:  // 8. Return ! CreateArrayFromList(possibleInstants).
objects/js-temporal-objects.cc:11122:  // 8. Return ! CreateArrayFromList(possibleInstants).
objects/js-temporal-objects.cc:11186:    // c. Return ! CreateArrayFromList(« instant »).
objects/js-temporal-objects.cc:11200:  // 8. Return ! CreateArrayFromList(possibleInstants).
objects/js-locale.cc:572:  // Return CreateArrayFromListAndPreferred( list, preferred ).
objects/js-locale.cc:630:  // Return CreateArrayFromListAndPreferred( list, preferred ).
objects/js-locale.cc:737:  // Let we be ! CreateArrayFromList( wi.||Weekend]] ).
builtins/builtins-generator-gen.cc:45:      LoadBytecodeArrayFromBaseline());
builtins/builtins-definitions.h:491:  /* Support for Array.from and other array-copying idioms */                  \
builtins/builtins-definitions.h:495:  TFS(CreateArrayFromSlowBoilerplate, NeedsContext::kYes, kFeedbackVector,     \
builtins/builtins-definitions.h:499:  TFC(CreateArrayFromSlowBoilerplateHelper, CreateFromSlowBoilerplateHelper)   \
builtins/builtins-definitions.h:2083:  TFJ(StringFixedArrayFromIterable, kJSArgcReceiverSlots + 1, kReceiver,       \
builtins/builtins-definitions.h:2085:  TFJ(TemporalInstantFixedArrayFromIterable, kJSArgcReceiverSlots + 1,         \
builtins/ppc/builtins-ppc.cc:234:             MemOperand(fp, InterpreterFrameConstants::kBytecodeArrayFromFp));
builtins/ppc/builtins-ppc.cc:1096:             MemOperand(fp, InterpreterFrameConstants::kBytecodeArrayFromFp));
builtins/ppc/builtins-ppc.cc:1521:             MemOperand(fp, InterpreterFrameConstants::kBytecodeArrayFromFp));
builtins/ppc/builtins-ppc.cc:1554:             MemOperand(fp, InterpreterFrameConstants::kBytecodeArrayFromFp));
builtins/ppc/builtins-ppc.cc:2015:             MemOperand(fp, InterpreterFrameConstants::kBytecodeArrayFromFp));
builtins/ppc/builtins-ppc.cc:2058:             MemOperand(fp, InterpreterFrameConstants::kBytecodeArrayFromFp));
builtins/aggregate-error.tq:32:  // ||Value]]: ! CreateArrayFromList(_errorsList_) }).
builtins/builtins-iterator-gen.h:86:  void FillFixedArrayFromIterable(TNode<Context> context,
builtins/builtins-object-gen.cc:288:        // Let entry be CreateArrayFromList(« key, value »).
builtins/map-groupby.tq:15:  //   a. Let elements be CreateArrayFromList(g.||Elements]]).
codegen/code-stub-assembler.h:3652:  TNode<BytecodeArray> LoadBytecodeArrayFromBaseline();
builtins/typed-array-from.tq:22:transitioning javascript builtin TypedArrayFrom(
builtins/builtins-temporal-gen.cc:24:  TNode<JSArray> CalendarFieldsArrayFromIterable(
builtins/builtins-temporal-gen.cc:29:  TNode<FixedArray> TemporalInstantFixedArrayFromIterable(
builtins/builtins-temporal-gen.cc:35:TNode<JSArray> TemporalBuiltinsAssembler::CalendarFieldsArrayFromIterable(
builtins/builtins-temporal-gen.cc:136:TemporalBuiltinsAssembler::TemporalInstantFixedArrayFromIterable(
builtins/builtins-temporal-gen.cc:195:TF_BUILTIN(TemporalInstantFixedArrayFromIterable, TemporalBuiltinsAssembler) {
builtins/builtins-temporal-gen.cc:199:  Return(TemporalInstantFixedArrayFromIterable(context, iterable));
builtins/builtins-temporal-gen.cc:218:  // Step 3 and later is inside CalendarFieldsArrayFromIterable
builtins/builtins-temporal-gen.cc:220:  Return(CalendarFieldsArrayFromIterable(context, calendar, iterable));
compiler/verifier.cc:775:    case IrOpcode::kJSCreateArrayFromIterable:
compiler/wasm-compiler.cc:7586:  Node* BuildMultiReturnFixedArrayFromIterable(const wasm::CanonicalSig* sig,
compiler/wasm-compiler.cc:8168:      Node* fixed_array = BuildMultiReturnFixedArrayFromIterable(
compiler/js-operator.h:969:  const Operator* CreateArrayFromIterable();
compiler/js-operator.cc:1400:const Operator* JSOperatorBuilder::CreateArrayFromIterable() {
compiler/js-operator.cc:1402:      IrOpcode::kJSCreateArrayFromIterable,  // opcode
compiler/js-operator.cc:1404:      "JSCreateArrayFromIterable",           // name
compiler/opcodes.h:162:  V(JSCreateArrayFromIterable)   \
compiler/turboshaft/maglev-graph-building-phase.cc:2141:                                  Builtin::kCreateArrayFromSlowBoilerplate,
compiler/js-generic-lowering.cc:772:    ReplaceWithBuiltinCall(node, Builtin::kCreateArrayFromSlowBoilerplate);
compiler/js-generic-lowering.cc:805:void JSGenericLowering::LowerJSCreateArrayFromIterable(Node* node) {
compiler/turbofan-typer.cc:1556:Type Typer::Visitor::TypeJSCreateArrayFromIterable(Node* node) {
execution/frame-constants.h:735:  static constexpr int kBytecodeArrayFromFp =
execution/frames.cc:3346:  DCHECK_EQ(UnoptimizedFrameConstants::kBytecodeArrayFromFp,
execution/frames.cc:3392:  DCHECK_EQ(InterpreterFrameConstants::kBytecodeArrayFromFp,
heap/factory.h:774:  Handle<WasmArray> NewWasmArrayFromElements(
heap/factory.h:777:  Handle<WasmArray> NewWasmArrayFromMemory(uint32_t length,
heap/factory.h:782:  Handle<Object> NewWasmArrayFromElementSegment(
maglev/maglev-graph-builder.cc:11786:void MaglevGraphBuilder::VisitCreateArrayFromIterable() {
maglev/maglev-ir.cc:3910:  __ CallBuiltin<Builtin::kCreateArrayFromSlowBoilerplate>(
profiler/tick-sample.cc:363:          frame->fp() + i::InterpreterFrameConstants::kBytecodeArrayFromFp);
heap/setup-heap-internal.cc:1585:  // Array.fromAsync:
heap/setup-heap-internal.cc:1588:        isolate_, Builtin::kArrayFromAsyncIterableOnFulfilled, 1);
heap/setup-heap-internal.cc:1592:        isolate_, Builtin::kArrayFromAsyncIterableOnRejected, 1);
heap/setup-heap-internal.cc:1596:        isolate_, Builtin::kArrayFromAsyncArrayLikeOnFulfilled, 1);
heap/setup-heap-internal.cc:1600:        isolate_, Builtin::kArrayFromAsyncArrayLikeOnRejected, 1);
heap/factory.cc:1987:Handle<WasmArray> Factory::NewWasmArrayFromElements(
heap/factory.cc:2008:Handle<WasmArray> Factory::NewWasmArrayFromMemory(uint32_t length,
heap/factory.cc:2030:Handle<Object> Factory::NewWasmArrayFromElementSegment(
[Step 5: Duration 10.94 seconds| Input tokens: 14,996 | Output tokens: 1,572]
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ Step 6 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'read_file' with arguments: {'file_path': 'objects/elements.h'}                                                                                                          │
╰────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
Command: cd /Users/tarun/v8/v8/src && wc -l '/Users/tarun/v8/v8/src/objects/elements.h'
Command: cd /Users/tarun/v8/v8/src && cat '/Users/tarun/v8/v8/src/objects/elements.h'
Observations: // Copyright 2012 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef V8_OBJECTS_ELEMENTS_H_
#define V8_OBJECTS_ELEMENTS_H_

#include "src/builtins/builtins-utils.h"
#include "src/objects/elements-kind.h"
#include "src/objects/internal-index.h"
#include "src/objects/keys.h"
#include "src/objects/objects.h"

namespace v8 {
namespace internal {

class JSTypedArray;

// Abstract base class for handles that can operate on objects with differing
// ElementsKinds.
class ElementsAccessor {
 public:
  ElementsAccessor() = default;
  virtual ~ElementsAccessor() = default;
  ElementsAccessor(const ElementsAccessor&) = delete;
  ElementsAccessor& operator=(const ElementsAccessor&) = delete;

  // Returns a shared ElementsAccessor for the specified ElementsKind.
  static ElementsAccessor* ForKind(ElementsKind elements_kind) {
    DCHECK_LT(static_cast<int>(elements_kind), kElementsKindCount);
    return elements_accessors_|elements_kind];
  }

  // Checks the elements of an object for consistency, asserting when a problem
  // is found.
  virtual void Validate(Tagged<JSObject> obj) = 0;

  // Returns true if a holder contains an element with the specified index
  // without iterating up the prototype chain. The first version takes the
  // backing store to use for the check, which must be compatible with the
  // ElementsKind of the ElementsAccessor; the second version uses
  // holder->elements() as the backing store. If a |filter| is specified,
  // the PropertyAttributes of the element at the given index are compared
  // to the given |filter|. If they match/overlap, the given index is ignored.
  // Note that only Dictionary elements have custom
  // PropertyAttributes associated, hence the |filter| argument is ignored for
  // all but DICTIONARY_ELEMENTS and SLOW_SLOPPY_ARGUMENTS_ELEMENTS.
  virtual bool HasElement(Tagged<JSObject> holder, uint32_t index,
                          Tagged<FixedArrayBase> backing_store,
                          PropertyFilter filter = ALL_PROPERTIES) = 0;

  inline bool HasElement(Tagged<JSObject> holder, uint32_t index,
                         PropertyFilter filter = ALL_PROPERTIES);

  // Note: this is currently not implemented for string wrapper and
  // typed array elements.
  virtual bool HasEntry(Tagged<JSObject> holder, InternalIndex entry) = 0;

  virtual Handle<Object> Get(Isolate* isolate, DirectHandle<JSObject> holder,
                             InternalIndex entry) = 0;

  // Currently only shared array elements support sequentially consistent
  // access.
  virtual Handle<Object> GetAtomic(Isolate* isolate,
                                   DirectHandle<JSObject> holder,
                                   InternalIndex entry,
                                   SeqCstAccessTag tag) = 0;

  virtual bool HasAccessors(Tagged<JSObject> holder) = 0;
  virtual size_t NumberOfElements(Isolate* isolate,
                                  Tagged<JSObject> holder) = 0;

  // Modifies the length data property as specified for JSArrays and resizes the
  // underlying backing store accordingly. The method honors the semantics of
  // changing array sizes as defined in ECMAScript 5.1 15.4.5.2, i.e. array that
  // have non-deletable elements can only be shrunk to the size of highest
  // element that is non-deletable.
  V8_WARN_UNUSED_RESULT virtual Maybe<bool> SetLength(
      DirectHandle<JSArray> holder, uint32_t new_length) = 0;

  // Copy all indices that have elements from |object| into the given
  // KeyAccumulator. For Dictionary-based element-kinds we filter out elements
  // whose PropertyAttribute match |filter|.
  V8_WARN_UNUSED_RESULT virtual ExceptionStatus CollectElementIndices(
      DirectHandle<JSObject> object, DirectHandle<FixedArrayBase> backing_store,
      KeyAccumulator* keys) = 0;

  V8_WARN_UNUSED_RESULT inline ExceptionStatus CollectElementIndices(
      DirectHandle<JSObject> object, KeyAccumulator* keys);

  virtual Maybe<bool> CollectValuesOrEntries(
      Isolate* isolate, DirectHandle<JSObject> object,
      DirectHandle<FixedArray> values_or_entries, bool get_entries,
      int* nof_items, PropertyFilter filter = ALL_PROPERTIES) = 0;

  virtual MaybeHandle<FixedArray> PrependElementIndices(
      Isolate* isolate, DirectHandle<JSObject> object,
      DirectHandle<FixedArrayBase> backing_store, DirectHandle<FixedArray> keys,
      GetKeysConversion convert, PropertyFilter filter = ALL_PROPERTIES) = 0;

  inline MaybeHandle<FixedArray> PrependElementIndices(
      Isolate* isolate, DirectHandle<JSObject> object,
      DirectHandle<FixedArray> keys, GetKeysConversion convert,
      PropertyFilter filter = ALL_PROPERTIES);

  V8_WARN_UNUSED_RESULT virtual ExceptionStatus AddElementsToKeyAccumulator(
      DirectHandle<JSObject> receiver, KeyAccumulator* accumulator,
      AddKeyConversion convert) = 0;

  V8_WARN_UNUSED_RESULT virtual Maybe<bool> TransitionElementsKind(
      DirectHandle<JSObject> object, DirectHandle<Map> map) = 0;
  V8_WARN_UNUSED_RESULT virtual Maybe<bool> GrowCapacityAndConvert(
      DirectHandle<JSObject> object, uint32_t capacity) = 0;
  // Unlike GrowCapacityAndConvert do not attempt to convert the backing store
  // and simply return false in this case.
  V8_WARN_UNUSED_RESULT virtual Maybe<bool> GrowCapacity(
      DirectHandle<JSObject> object, uint32_t index) = 0;

  static void InitializeOncePerProcess();
  static void TearDown();

  virtual void Set(DirectHandle<JSObject> holder, InternalIndex entry,
                   Tagged<Object> value) = 0;

  // Currently only shared array elements support sequentially consistent
  // access.
  virtual void SetAtomic(DirectHandle<JSObject> holder, InternalIndex entry,
                         Tagged<Object> value, SeqCstAccessTag tag) = 0;

  // Currently only shared array elements support sequentially consistent
  // access.
  virtual Handle<Object> SwapAtomic(Isolate* isolate,
                                    DirectHandle<JSObject> holder,
                                    InternalIndex entry, Tagged<Object> value,
                                    SeqCstAccessTag tag) = 0;

  virtual Handle<Object> CompareAndSwapAtomic(
      Isolate* isolate, DirectHandle<JSObject> holder, InternalIndex entry,
      Tagged<Object> expected, Tagged<Object> value, SeqCstAccessTag tag) = 0;

  V8_WARN_UNUSED_RESULT virtual Maybe<bool> Add(DirectHandle<JSObject> object,
                                                uint32_t index,
                                                DirectHandle<Object> value,
                                                PropertyAttributes attributes,
                                                uint32_t new_capacity) = 0;

  static Handle<JSArray> Concat(Isolate* isolate, BuiltinArguments* args,
                                uint32_t concat_size, uint32_t result_length);

  V8_WARN_UNUSED_RESULT virtual Maybe<uint32_t> Push(
      DirectHandle<JSArray> receiver, BuiltinArguments* args,
      uint32_t push_size) = 0;

  V8_WARN_UNUSED_RESULT virtual Maybe<uint32_t> Unshift(
      DirectHandle<JSArray> receiver, BuiltinArguments* args,
      uint32_t unshift_size) = 0;

  V8_WARN_UNUSED_RESULT virtual MaybeDirectHandle<Object> Pop(
      DirectHandle<JSArray> receiver) = 0;

  V8_WARN_UNUSED_RESULT virtual MaybeDirectHandle<Object> Shift(
      DirectHandle<JSArray> receiver) = 0;

  virtual DirectHandle<NumberDictionary> Normalize(
      DirectHandle<JSObject> object) = 0;

  virtual size_t GetCapacity(Tagged<JSObject> holder,
                             Tagged<FixedArrayBase> backing_store) = 0;

  V8_WARN_UNUSED_RESULT virtual MaybeDirectHandle<Object> Fill(
      DirectHandle<JSObject> receiver, DirectHandle<Object> obj_value,
      size_t start, size_t end) = 0;

  // Check an Object's own elements for an element (using SameValueZero
  // semantics)
  virtual Maybe<bool> IncludesValue(Isolate* isolate,
                                    DirectHandle<JSObject> receiver,
                                    DirectHandle<Object> value, size_t start,
                                    size_t length) = 0;

  // Check an Object's own elements for the index of an element (using SameValue
  // semantics)
  virtual Maybe<int64_t> IndexOfValue(Isolate* isolate,
                                      DirectHandle<JSObject> receiver,
                                      DirectHandle<Object> value, size_t start,
                                      size_t length) = 0;

  virtual Maybe<int64_t> LastIndexOfValue(DirectHandle<JSObject> receiver,
                                          DirectHandle<Object> value,
                                          size_t start) = 0;

  virtual void Reverse(Tagged<JSObject> receiver) = 0;

  virtual void CopyElements(Isolate* isolate,
                            DirectHandle<FixedArrayBase> source,
                            ElementsKind source_kind,
                            DirectHandle<FixedArrayBase> destination,
                            int size) = 0;

  virtual Tagged<Object> CopyElements(DirectHandle<JSAny> source,
                                      DirectHandle<JSObject> destination,
                                      size_t length, size_t offset) = 0;

  virtual Handle<FixedArray> CreateListFromArrayLike(
      Isolate* isolate, DirectHandle<JSObject> object, uint32_t length) = 0;

  virtual void CopyTypedArrayElementsSlice(Tagged<JSTypedArray> source,
                                           Tagged<JSTypedArray> destination,
                                           size_t start, size_t end) = 0;

 protected:
  friend class LookupIterator;

  // Element handlers distinguish between entries and indices when they
  // manipulate elements. Entries refer to elements in terms of their location
  // in the underlying storage's backing store representation, and are between 0
  // and GetCapacity. Indices refer to elements in terms of the value that would
  // be specified in JavaScript to access the element. In most implementations,
  // indices are equivalent to entries. In the NumberDictionary
  // ElementsAccessor, entries are mapped to an index using the KeyAt method on
  // the NumberDictionary.
  virtual InternalIndex GetEntryForIndex(Isolate* isolate,
                                         Tagged<JSObject> holder,
                                         Tagged<FixedArrayBase> backing_store,
                                         size_t index) = 0;

  virtual PropertyDetails GetDetails(Tagged<JSObject> holder,
                                     InternalIndex entry) = 0;
  virtual void Reconfigure(DirectHandle<JSObject> object,
                           DirectHandle<FixedArrayBase> backing_store,
                           InternalIndex entry, DirectHandle<Object> value,
                           PropertyAttributes attributes) = 0;

  // Deletes an element in an object.
  virtual void Delete(DirectHandle<JSObject> holder, InternalIndex entry) = 0;

  // NOTE: this method violates the handlified function signature convention:
  // raw pointer parameter |source_holder| in the function that allocates.
  // This is done intentionally to avoid ArrayConcat() builtin performance
  // degradation.
  virtual void CopyElements(Isolate* isolate, Tagged<JSObject> source_holder,
                            uint32_t source_start, ElementsKind source_kind,
                            DirectHandle<FixedArrayBase> destination,
                            uint32_t destination_start, int copy_size) = 0;

 private:
  V8_EXPORT_PRIVATE static ElementsAccessor** elements_accessors_;
};

V8_WARN_UNUSED_RESULT MaybeDirectHandle<Object>
ArrayConstructInitializeElements(DirectHandle<JSArray> array,
                                 JavaScriptArguments* args);

// Called directly from CSA.
// {raw_context}: Context pointer.
// {raw_source}: JSArray pointer.
// {raw_destination}: JSTypedArray pointer.
void CopyFastNumberJSArrayElementsToTypedArray(Address raw_context,
                                               Address raw_source,
                                               Address raw_destination,
                                               uintptr_t length,
                                               uintptr_t offset);
// {raw_source}, {raw_destination}: JSTypedArray pointers.
void CopyTypedArrayElementsToTypedArray(Address raw_source,
                                        Address raw_destination,
                                        uintptr_t length, uintptr_t offset);
// {raw_source}, {raw_destination}: JSTypedArray pointers.
void CopyTypedArrayElementsSlice(Address raw_source, Address raw_destination,
                                 uintptr_t start, uintptr_t end);

}  // namespace internal
}  // namespace v8

#endif  // V8_OBJECTS_ELEMENTS_H_
[Step 6: Duration 13.68 seconds| Input tokens: 80,734 | Output tokens: 2,175]
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ Step 7 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'read_file' with arguments: {'file_path': 'objects/elements.cc'}                                                                                                         │
╰────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
Command: cd /Users/tarun/v8/v8/src && wc -l '/Users/tarun/v8/v8/src/objects/elements.cc'
Observations: File 'objects/elements.cc' has 5779 lines and is divided into 2 sections (each section is 3000 lines).
To read this file, please specify a section number between 1 and 2 using the 'section' argument.
[Step 7: Duration 14.79 seconds| Input tokens: 149,153 | Output tokens: 2,906]
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ Step 8 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'read_file' with arguments: {'file_path': 'objects/elements.cc', 'section': 1}                                                                                           │
╰────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
Command: cd /Users/tarun/v8/v8/src && wc -l '/Users/tarun/v8/v8/src/objects/elements.cc'
Command: cd /Users/tarun/v8/v8/src && sed -n '1,3000p' '/Users/tarun/v8/v8/src/objects/elements.cc'
Observations: Showing section 1/2 (lines 1-3000) of 'objects/elements.cc':
// Copyright 2012 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "src/objects/elements.h"

#include "src/base/atomicops.h"
#include "src/base/safe_conversions.h"
#include "src/common/message-template.h"
#include "src/execution/arguments.h"
#include "src/execution/frames.h"
#include "src/execution/isolate-inl.h"
#include "src/execution/protectors-inl.h"
#include "src/heap/factory.h"
#include "src/heap/heap-inl.h"  // For MaxNumberToStringCacheSize.
#include "src/heap/heap-write-barrier-inl.h"
#include "src/numbers/conversions.h"
#include "src/objects/arguments-inl.h"
#include "src/objects/hash-table-inl.h"
#include "src/objects/js-array-buffer-inl.h"
#include "src/objects/js-array-inl.h"
#include "src/objects/js-shared-array-inl.h"
#include "src/objects/keys.h"
#include "src/objects/objects-inl.h"
#include "src/objects/slots-atomic-inl.h"
#include "src/objects/slots.h"
#include "src/utils/utils.h"
#include "third_party/fp16/src/include/fp16.h"

// Each concrete ElementsAccessor can handle exactly one ElementsKind,
// several abstract ElementsAccessor classes are used to allow sharing
// common code.
//
// Inheritance hierarchy:
// - ElementsAccessorBase                        (abstract)
//   - FastElementsAccessor                      (abstract)
//     - FastSmiOrObjectElementsAccessor
//       - FastPackedSmiElementsAccessor
//       - FastHoleySmiElementsAccessor
//       - FastPackedObjectElementsAccessor
//       - FastNonextensibleObjectElementsAccessor: template
//         - FastPackedNonextensibleObjectElementsAccessor
//         - FastHoleyNonextensibleObjectElementsAccessor
//       - FastSealedObjectElementsAccessor: template
//         - FastPackedSealedObjectElementsAccessor
//         - FastHoleySealedObjectElementsAccessor
//       - FastFrozenObjectElementsAccessor: template
//         - FastPackedFrozenObjectElementsAccessor
//         - FastHoleyFrozenObjectElementsAccessor
//       - FastHoleyObjectElementsAccessor
//     - FastDoubleElementsAccessor
//       - FastPackedDoubleElementsAccessor
//       - FastHoleyDoubleElementsAccessor
//   - TypedElementsAccessor: template, with instantiations:
//     - Uint8ElementsAccessor
//     - Int8ElementsAccessor
//     - Uint16ElementsAccessor
//     - Int16ElementsAccessor
//     - Uint32ElementsAccessor
//     - Int32ElementsAccessor
//     - Float32ElementsAccessor
//     - Float64ElementsAccessor
//     - Uint8ClampedElementsAccessor
//     - BigUint64ElementsAccessor
//     - BigInt64ElementsAccessor
//     - RabGsabUint8ElementsAccessor
//     - RabGsabInt8ElementsAccessor
//     - RabGsabUint16ElementsAccessor
//     - RabGsabInt16ElementsAccessor
//     - RabGsabUint32ElementsAccessor
//     - RabGsabInt32ElementsAccessor
//     - RabGsabFloat32ElementsAccessor
//     - RabGsabFloat64ElementsAccessor
//     - RabGsabUint8ClampedElementsAccessor
//     - RabGsabBigUint64ElementsAccessor
//     - RabGsabBigInt64ElementsAccessor
//   - DictionaryElementsAccessor
//   - SloppyArgumentsElementsAccessor
//     - FastSloppyArgumentsElementsAccessor
//     - SlowSloppyArgumentsElementsAccessor
//   - StringWrapperElementsAccessor
//     - FastStringWrapperElementsAccessor
//     - SlowStringWrapperElementsAccessor

namespace v8 {
namespace internal {

namespace {

#define RETURN_NOTHING_IF_NOT_SUCCESSFUL(call) \
  do {                                         \
    if (!(call)) return Nothing<bool>();       \
  } while (false)

#define RETURN_FAILURE_IF_NOT_SUCCESSFUL(call)          \
  do {                                                  \
    ExceptionStatus status_enum_result = (call);        \
    if (!status_enum_result) return status_enum_result; \
  } while (false)

static const int kPackedSizeNotKnown = -1;

enum Where { AT_START, AT_END };

// First argument in list is the accessor class, the second argument is the
// accessor ElementsKind, and the third is the backing store class.  Use the
// fast element handler for smi-only arrays.  The implementation is currently
// identical.  Note that the order must match that of the ElementsKind enum for
// the |accessor_array|]| below to work.
#define ELEMENTS_LIST(V)                                                      \
  V(FastPackedSmiElementsAccessor, PACKED_SMI_ELEMENTS, FixedArray)           \
  V(FastHoleySmiElementsAccessor, HOLEY_SMI_ELEMENTS, FixedArray)             \
  V(FastPackedObjectElementsAccessor, PACKED_ELEMENTS, FixedArray)            \
  V(FastHoleyObjectElementsAccessor, HOLEY_ELEMENTS, FixedArray)              \
  V(FastPackedDoubleElementsAccessor, PACKED_DOUBLE_ELEMENTS,                 \
    FixedDoubleArray)                                                         \
  V(FastHoleyDoubleElementsAccessor, HOLEY_DOUBLE_ELEMENTS, FixedDoubleArray) \
  V(FastPackedNonextensibleObjectElementsAccessor,                            \
    PACKED_NONEXTENSIBLE_ELEMENTS, FixedArray)                                \
  V(FastHoleyNonextensibleObjectElementsAccessor,                             \
    HOLEY_NONEXTENSIBLE_ELEMENTS, FixedArray)                                 \
  V(FastPackedSealedObjectElementsAccessor, PACKED_SEALED_ELEMENTS,           \
    FixedArray)                                                               \
  V(FastHoleySealedObjectElementsAccessor, HOLEY_SEALED_ELEMENTS, FixedArray) \
  V(FastPackedFrozenObjectElementsAccessor, PACKED_FROZEN_ELEMENTS,           \
    FixedArray)                                                               \
  V(FastHoleyFrozenObjectElementsAccessor, HOLEY_FROZEN_ELEMENTS, FixedArray) \
  V(SharedArrayElementsAccessor, SHARED_ARRAY_ELEMENTS, FixedArray)           \
  V(DictionaryElementsAccessor, DICTIONARY_ELEMENTS, NumberDictionary)        \
  V(FastSloppyArgumentsElementsAccessor, FAST_SLOPPY_ARGUMENTS_ELEMENTS,      \
    FixedArray)                                                               \
  V(SlowSloppyArgumentsElementsAccessor, SLOW_SLOPPY_ARGUMENTS_ELEMENTS,      \
    FixedArray)                                                               \
  V(FastStringWrapperElementsAccessor, FAST_STRING_WRAPPER_ELEMENTS,          \
    FixedArray)                                                               \
  V(SlowStringWrapperElementsAccessor, SLOW_STRING_WRAPPER_ELEMENTS,          \
    FixedArray)                                                               \
  V(Uint8ElementsAccessor, UINT8_ELEMENTS, ByteArray)                         \
  V(Int8ElementsAccessor, INT8_ELEMENTS, ByteArray)                           \
  V(Uint16ElementsAccessor, UINT16_ELEMENTS, ByteArray)                       \
  V(Int16ElementsAccessor, INT16_ELEMENTS, ByteArray)                         \
  V(Uint32ElementsAccessor, UINT32_ELEMENTS, ByteArray)                       \
  V(Int32ElementsAccessor, INT32_ELEMENTS, ByteArray)                         \
  V(BigUint64ElementsAccessor, BIGUINT64_ELEMENTS, ByteArray)                 \
  V(BigInt64ElementsAccessor, BIGINT64_ELEMENTS, ByteArray)                   \
  V(Uint8ClampedElementsAccessor, UINT8_CLAMPED_ELEMENTS, ByteArray)          \
  V(Float32ElementsAccessor, FLOAT32_ELEMENTS, ByteArray)                     \
  V(Float64ElementsAccessor, FLOAT64_ELEMENTS, ByteArray)                     \
  V(Float16ElementsAccessor, FLOAT16_ELEMENTS, ByteArray)                     \
  V(RabGsabUint8ElementsAccessor, RAB_GSAB_UINT8_ELEMENTS, ByteArray)         \
  V(RabGsabInt8ElementsAccessor, RAB_GSAB_INT8_ELEMENTS, ByteArray)           \
  V(RabGsabUint16ElementsAccessor, RAB_GSAB_UINT16_ELEMENTS, ByteArray)       \
  V(RabGsabInt16ElementsAccessor, RAB_GSAB_INT16_ELEMENTS, ByteArray)         \
  V(RabGsabUint32ElementsAccessor, RAB_GSAB_UINT32_ELEMENTS, ByteArray)       \
  V(RabGsabInt32ElementsAccessor, RAB_GSAB_INT32_ELEMENTS, ByteArray)         \
  V(RabGsabBigUint64ElementsAccessor, RAB_GSAB_BIGUINT64_ELEMENTS, ByteArray) \
  V(RabGsabBigInt64ElementsAccessor, RAB_GSAB_BIGINT64_ELEMENTS, ByteArray)   \
  V(RabGsabUint8ClampedElementsAccessor, RAB_GSAB_UINT8_CLAMPED_ELEMENTS,     \
    ByteArray)                                                                \
  V(RabGsabFloat32ElementsAccessor, RAB_GSAB_FLOAT32_ELEMENTS, ByteArray)     \
  V(RabGsabFloat64ElementsAccessor, RAB_GSAB_FLOAT64_ELEMENTS, ByteArray)     \
  V(RabGsabFloat16ElementsAccessor, RAB_GSAB_FLOAT16_ELEMENTS, ByteArray)

template <ElementsKind Kind>
class ElementsKindTraits {
 public:
  using BackingStore = FixedArrayBase;
};

#define ELEMENTS_TRAITS(Class, KindParam, Store)    \
  template <>                                       \
  class ElementsKindTraits<KindParam> {             \
   public: /* NOLINT */                             \
    static constexpr ElementsKind Kind = KindParam; \
    using BackingStore = Store;                     \
  };                                                \
  constexpr ElementsKind ElementsKindTraits<KindParam>::Kind;
ELEMENTS_LIST(ELEMENTS_TRAITS)
#undef ELEMENTS_TRAITS

V8_WARN_UNUSED_RESULT
MaybeDirectHandle<Object> ThrowArrayLengthRangeError(Isolate* isolate) {
  THROW_NEW_ERROR(isolate, NewRangeError(MessageTemplate::kInvalidArrayLength));
}

WriteBarrierMode GetWriteBarrierMode(Tagged<FixedArrayBase> elements,
                                     ElementsKind kind,
                                     const DisallowGarbageCollection& promise) {
  if (IsSmiElementsKind(kind)) return SKIP_WRITE_BARRIER;
  if (IsDoubleElementsKind(kind)) return SKIP_WRITE_BARRIER;
  return elements->GetWriteBarrierMode(promise);
}

// If kCopyToEndAndInitializeToHole is specified as the copy_size to
// CopyElements, it copies all of elements from source after source_start to
// destination array, padding any remaining uninitialized elements in the
// destination array with the hole.
constexpr int kCopyToEndAndInitializeToHole = -1;

void CopyObjectToObjectElements(Isolate* isolate,
                                Tagged<FixedArrayBase> from_base,
                                ElementsKind from_kind, uint32_t from_start,
                                Tagged<FixedArrayBase> to_base,
                                ElementsKind to_kind, uint32_t to_start,
                                int raw_copy_size) {
  ReadOnlyRoots roots(isolate);
  DCHECK(to_base->map() != roots.fixed_cow_array_map());
  DisallowGarbageCollection no_gc;
  int copy_size = raw_copy_size;
  if (raw_copy_size < 0) {
    DCHECK_EQ(kCopyToEndAndInitializeToHole, raw_copy_size);
    copy_size = std::min(from_base->length() - from_start,
                         to_base->length() - to_start);
    int start = to_start + copy_size;
    int length = to_base->length() - start;
    if (length > 0) {
      MemsetTagged(Cast<FixedArray>(to_base)->RawFieldOfElementAt(start),
                   roots.the_hole_value(), length);
    }
  }
  DCHECK((copy_size + static_cast<int>(to_start)) <= to_base->length() &&
         (copy_size + static_cast<int>(from_start)) <= from_base->length());
  if (copy_size == 0) return;
  Tagged<FixedArray> from = Cast<FixedArray>(from_base);
  Tagged<FixedArray> to = Cast<FixedArray>(to_base);
  DCHECK(IsSmiOrObjectElementsKind(from_kind));
  DCHECK(IsSmiOrObjectElementsKind(to_kind));

  WriteBarrierMode write_barrier_mode =
      (IsObjectElementsKind(from_kind) && IsObjectElementsKind(to_kind))
          ? UPDATE_WRITE_BARRIER
          : SKIP_WRITE_BARRIER;
  to->CopyElements(isolate, to_start, from, from_start, copy_size,
                   write_barrier_mode);
}

void CopyDictionaryToObjectElements(Isolate* isolate,
                                    Tagged<FixedArrayBase> from_base,
                                    uint32_t from_start,
                                    Tagged<FixedArrayBase> to_base,
                                    ElementsKind to_kind, uint32_t to_start,
                                    int raw_copy_size) {
  DisallowGarbageCollection no_gc;
  Tagged<NumberDictionary> from = Cast<NumberDictionary>(from_base);
  int copy_size = raw_copy_size;
  if (raw_copy_size < 0) {
    DCHECK_EQ(kCopyToEndAndInitializeToHole, raw_copy_size);
    copy_size = from->max_number_key() + 1 - from_start;
    int start = to_start + copy_size;
    int length = to_base->length() - start;
    if (length > 0) {
      MemsetTagged(Cast<FixedArray>(to_base)->RawFieldOfElementAt(start),
                   ReadOnlyRoots(isolate).the_hole_value(), length);
    }
  }
  DCHECK(to_base != from_base);
  DCHECK(IsSmiOrObjectElementsKind(to_kind));
  if (copy_size == 0) return;
  Tagged<FixedArray> to = Cast<FixedArray>(to_base);
  uint32_t to_length = to->length();
  if (to_start + copy_size > to_length) {
    copy_size = to_length - to_start;
  }
  WriteBarrierMode write_barrier_mode = GetWriteBarrierMode(to, to_kind, no_gc);
  for (int i = 0; i < copy_size; i++) {
    InternalIndex entry = from->FindEntry(isolate, i + from_start);
    if (entry.is_found()) {
      Tagged<Object> value = from->ValueAt(entry);
      DCHECK(!IsTheHole(value, isolate));
      to->set(i + to_start, value, write_barrier_mode);
    } else {
      to->set_the_hole(isolate, i + to_start);
    }
  }
}

// NOTE: this method violates the handlified function signature convention:
// raw pointer parameters in the function that allocates.
// See ElementsAccessorBase::CopyElements() for details.
void CopyDoubleToObjectElements(Isolate* isolate,
                                Tagged<FixedArrayBase> from_base,
                                uint32_t from_start,
                                Tagged<FixedArrayBase> to_base,
                                uint32_t to_start, int raw_copy_size) {
  int copy_size = raw_copy_size;
  if (raw_copy_size < 0) {
    DisallowGarbageCollection no_gc;
    DCHECK_EQ(kCopyToEndAndInitializeToHole, raw_copy_size);
    copy_size = std::min(from_base->length() - from_start,
                         to_base->length() - to_start);
    // Also initialize the area that will be copied over since HeapNumber
    // allocation below can cause an incremental marking step, requiring all
    // existing heap objects to be propertly initialized.
    int start = to_start;
    int length = to_base->length() - start;
    if (length > 0) {
      MemsetTagged(Cast<FixedArray>(to_base)->RawFieldOfElementAt(start),
                   ReadOnlyRoots(isolate).the_hole_value(), length);
    }
  }

  DCHECK((copy_size + static_cast<int>(to_start)) <= to_base->length() &&
         (copy_size + static_cast<int>(from_start)) <= from_base->length());
  if (copy_size == 0) return;

  // From here on, the code below could actually allocate. Therefore the raw
  // values are wrapped into handles.
  DirectHandle<FixedDoubleArray> from(Cast<FixedDoubleArray>(from_base),
                                      isolate);
  DirectHandle<FixedArray> to(Cast<FixedArray>(to_base), isolate);

  // Use an outer loop to not waste too much time on creating HandleScopes.
  // On the other hand we might overflow a single handle scope depending on
  // the copy_size.
  int offset = 0;
  while (offset < copy_size) {
    HandleScope scope(isolate);
    offset += 100;
    for (int i = offset - 100; i < offset && i < copy_size; ++i) {
      DirectHandle<Object> value =
          FixedDoubleArray::get(*from, i + from_start, isolate);
      to->set(i + to_start, *value, UPDATE_WRITE_BARRIER);
    }
  }
}

void CopyDoubleToDoubleElements(Tagged<FixedArrayBase> from_base,
                                uint32_t from_start,
                                Tagged<FixedArrayBase> to_base,
                                uint32_t to_start, int raw_copy_size) {
  DisallowGarbageCollection no_gc;
  int copy_size = raw_copy_size;
  if (raw_copy_size < 0) {
    DCHECK_EQ(kCopyToEndAndInitializeToHole, raw_copy_size);
    copy_size = std::min(from_base->length() - from_start,
                         to_base->length() - to_start);
    for (int i = to_start + copy_size; i < to_base->length(); ++i) {
      Cast<FixedDoubleArray>(to_base)->set_the_hole(i);
    }
  }
  DCHECK((copy_size + static_cast<int>(to_start)) <= to_base->length() &&
         (copy_size + static_cast<int>(from_start)) <= from_base->length());
  if (copy_size == 0) return;
  Tagged<FixedDoubleArray> from = Cast<FixedDoubleArray>(from_base);
  Tagged<FixedDoubleArray> to = Cast<FixedDoubleArray>(to_base);
  Address to_address = reinterpret_cast<Address>(to->begin());
  Address from_address = reinterpret_cast<Address>(from->begin());
  to_address += kDoubleSize * to_start;
  from_address += kDoubleSize * from_start;
#ifdef V8_COMPRESS_POINTERS
  // TODO(ishell, v8:8875): we use CopyTagged() in order to avoid unaligned
  // access to double values in the arrays. This will no longed be necessary
  // once the allocations alignment issue is fixed.
  int words_per_double = (kDoubleSize / kTaggedSize);
  CopyTagged(to_address, from_address,
             static_cast<size_t>(words_per_double * copy_size));
#else
  int words_per_double = (kDoubleSize / kSystemPointerSize);
  CopyWords(to_address, from_address,
            static_cast<size_t>(words_per_double * copy_size));
#endif
}

void CopySmiToDoubleElements(Tagged<FixedArrayBase> from_base,
                             uint32_t from_start,
                             Tagged<FixedArrayBase> to_base, uint32_t to_start,
                             int raw_copy_size) {
  DisallowGarbageCollection no_gc;
  int copy_size = raw_copy_size;
  if (raw_copy_size < 0) {
    DCHECK_EQ(kCopyToEndAndInitializeToHole, raw_copy_size);
    copy_size = from_base->length() - from_start;
    for (int i = to_start + copy_size; i < to_base->length(); ++i) {
      Cast<FixedDoubleArray>(to_base)->set_the_hole(i);
    }
  }
  DCHECK((copy_size + static_cast<int>(to_start)) <= to_base->length() &&
         (copy_size + static_cast<int>(from_start)) <= from_base->length());
  if (copy_size == 0) return;
  Tagged<FixedArray> from = Cast<FixedArray>(from_base);
  Tagged<FixedDoubleArray> to = Cast<FixedDoubleArray>(to_base);
  Tagged<Object> the_hole = GetReadOnlyRoots().the_hole_value();
  for (uint32_t from_end = from_start + static_cast<uint32_t>(copy_size);
       from_start < from_end; from_start++, to_start++) {
    Tagged<Object> hole_or_smi = from->get(from_start);
    if (hole_or_smi == the_hole) {
      to->set_the_hole(to_start);
    } else {
      to->set(to_start, Smi::ToInt(hole_or_smi));
    }
  }
}

void CopyPackedSmiToDoubleElements(Tagged<FixedArrayBase> from_base,
                                   uint32_t from_start,
                                   Tagged<FixedArrayBase> to_base,
                                   uint32_t to_start, int packed_size,
                                   int raw_copy_size) {
  DisallowGarbageCollection no_gc;
  int copy_size = raw_copy_size;
  uint32_t to_end;
  if (raw_copy_size < 0) {
    DCHECK_EQ(kCopyToEndAndInitializeToHole, raw_copy_size);
    copy_size = packed_size - from_start;
    to_end = to_base->length();
    for (uint32_t i = to_start + copy_size; i < to_end; ++i) {
      Cast<FixedDoubleArray>(to_base)->set_the_hole(i);
    }
  } else {
    to_end = to_start + static_cast<uint32_t>(copy_size);
  }
  DCHECK(static_cast<int>(to_end) <= to_base->length());
  DCHECK(packed_size >= 0 && packed_size <= copy_size);
  DCHECK((copy_size + static_cast<int>(to_start)) <= to_base->length() &&
         (copy_size + static_cast<int>(from_start)) <= from_base->length());
  if (copy_size == 0) return;
  Tagged<FixedArray> from = Cast<FixedArray>(from_base);
  Tagged<FixedDoubleArray> to = Cast<FixedDoubleArray>(to_base);
  for (uint32_t from_end = from_start + static_cast<uint32_t>(packed_size);
       from_start < from_end; from_start++, to_start++) {
    Tagged<Object> smi = from->get(from_start);
    DCHECK(!IsTheHole(smi));
    to->set(to_start, Smi::ToInt(smi));
  }
}

void CopyObjectToDoubleElements(Tagged<FixedArrayBase> from_base,
                                uint32_t from_start,
                                Tagged<FixedArrayBase> to_base,
                                uint32_t to_start, int raw_copy_size) {
  DisallowGarbageCollection no_gc;
  int copy_size = raw_copy_size;
  if (raw_copy_size < 0) {
    DCHECK_EQ(kCopyToEndAndInitializeToHole, raw_copy_size);
    copy_size = from_base->length() - from_start;
    for (int i = to_start + copy_size; i < to_base->length(); ++i) {
      Cast<FixedDoubleArray>(to_base)->set_the_hole(i);
    }
  }
  DCHECK((copy_size + static_cast<int>(to_start)) <= to_base->length() &&
         (copy_size + static_cast<int>(from_start)) <= from_base->length());
  if (copy_size == 0) return;
  Tagged<FixedArray> from = Cast<FixedArray>(from_base);
  Tagged<FixedDoubleArray> to = Cast<FixedDoubleArray>(to_base);
  Tagged<Hole> the_hole = GetReadOnlyRoots().the_hole_value();
  for (uint32_t from_end = from_start + copy_size; from_start < from_end;
       from_start++, to_start++) {
    Tagged<Object> hole_or_object = from->get(from_start);
    if (hole_or_object == the_hole) {
      to->set_the_hole(to_start);
    } else {
      to->set(to_start, Object::NumberValue(Cast<Number>(hole_or_object)));
    }
  }
}

void CopyDictionaryToDoubleElements(Isolate* isolate,
                                    Tagged<FixedArrayBase> from_base,
                                    uint32_t from_start,
                                    Tagged<FixedArrayBase> to_base,
                                    uint32_t to_start, int raw_copy_size) {
  DisallowGarbageCollection no_gc;
  Tagged<NumberDictionary> from = Cast<NumberDictionary>(from_base);
  int copy_size = raw_copy_size;
  if (copy_size < 0) {
    DCHECK_EQ(kCopyToEndAndInitializeToHole, copy_size);
    copy_size = from->max_number_key() + 1 - from_start;
    for (int i = to_start + copy_size; i < to_base->length(); ++i) {
      Cast<FixedDoubleArray>(to_base)->set_the_hole(i);
    }
  }
  if (copy_size == 0) return;
  Tagged<FixedDoubleArray> to = Cast<FixedDoubleArray>(to_base);
  uint32_t to_length = to->length();
  if (to_start + copy_size > to_length) {
    copy_size = to_length - to_start;
  }
  for (int i = 0; i < copy_size; i++) {
    InternalIndex entry = from->FindEntry(isolate, i + from_start);
    if (entry.is_found()) {
      to->set(i + to_start,
              Object::NumberValue(Cast<Number>(from->ValueAt(entry))));
    } else {
      to->set_the_hole(i + to_start);
    }
  }
}

void SortIndices(Isolate* isolate, DirectHandle<FixedArray> indices,
                 uint32_t sort_size) {
  if (sort_size == 0) return;

  // Use AtomicSlot wrapper to ensure that std::sort uses atomic load and
  // store operations that are safe for concurrent marking.
  AtomicSlot start(indices->RawFieldOfFirstElement());
  AtomicSlot end(start + sort_size);
  std::sort(start, end, |isolate](Tagged_t elementA, Tagged_t elementB) {
#ifdef V8_COMPRESS_POINTERS
    Tagged<Object> a(
        V8HeapCompressionScheme::DecompressTagged(isolate, elementA));
    Tagged<Object> b(
        V8HeapCompressionScheme::DecompressTagged(isolate, elementB));
#else
    Tagged<Object> a(elementA);
    Tagged<Object> b(elementB);
#endif
    if (IsSmi(a) || !IsUndefined(a, isolate)) {
      if (!IsSmi(b) && IsUndefined(b, isolate)) {
        return true;
      }
      return Object::NumberValue(Cast<Number>(a)) <
             Object::NumberValue(Cast<Number>(b));
    }
    return !IsSmi(b) && IsUndefined(b, isolate);
  });
  WriteBarrier::ForRange(isolate->heap(), *indices, ObjectSlot(start),
                         ObjectSlot(end));
}

Maybe<bool> IncludesValueSlowPath(Isolate* isolate,
                                  DirectHandle<JSObject> receiver,
                                  DirectHandle<Object> value, size_t start_from,
                                  size_t length) {
  bool search_for_hole = IsUndefined(*value, isolate);
  for (size_t k = start_from; k < length; ++k) {
    LookupIterator it(isolate, receiver, k);
    if (!it.IsFound()) {
      if (search_for_hole) return Just(true);
      continue;
    }
    DirectHandle<Object> element_k;
    ASSIGN_RETURN_ON_EXCEPTION_VALUE(isolate, element_k,
                                     Object::GetProperty(&it), Nothing<bool>());

    if (Object::SameValueZero(*value, *element_k)) return Just(true);
  }

  return Just(false);
}

Maybe<int64_t> IndexOfValueSlowPath(Isolate* isolate,
                                    DirectHandle<JSObject> receiver,
                                    DirectHandle<Object> value,
                                    size_t start_from, size_t length) {
  for (size_t k = start_from; k < length; ++k) {
    LookupIterator it(isolate, receiver, k);
    if (!it.IsFound()) {
      continue;
    }
    DirectHandle<Object> element_k;
    ASSIGN_RETURN_ON_EXCEPTION_VALUE(
        isolate, element_k, Object::GetProperty(&it), Nothing<int64_t>());

    if (Object::StrictEquals(*value, *element_k)) return Just<int64_t>(k);
  }

  return Just<int64_t>(-1);
}

// The InternalElementsAccessor is a helper class to expose otherwise protected
// methods to its subclasses. Namely, we don't want to publicly expose methods
// that take an entry (instead of an index) as an argument.
class InternalElementsAccessor : public ElementsAccessor {
 public:
  InternalIndex GetEntryForIndex(Isolate* isolate, Tagged<JSObject> holder,
                                 Tagged<FixedArrayBase> backing_store,
                                 size_t index) override = 0;

  PropertyDetails GetDetails(Tagged<JSObject> holder,
                             InternalIndex entry) override = 0;
};

// Base class for element handler implementations. Contains the
// the common logic for objects with different ElementsKinds.
// Subclasses must specialize method for which the element
// implementation differs from the base class implementation.
//
// This class is intended to be used in the following way:
//
//   class SomeElementsAccessor :
//       public ElementsAccessorBase<SomeElementsAccessor,
//                                   BackingStoreClass> {
//     ...
//   }
//
// This is an example of the Curiously Recurring Template Pattern (see
// http://en.wikipedia.org/wiki/Curiously_recurring_template_pattern).  We use
// CRTP to guarantee aggressive compile time optimizations (i.e.  inlining and
// specialization of SomeElementsAccessor methods).
template <typename Subclass, typename ElementsTraitsParam>
class ElementsAccessorBase : public InternalElementsAccessor {
 public:
  ElementsAccessorBase() = default;
  ElementsAccessorBase(const ElementsAccessorBase&) = delete;
  ElementsAccessorBase& operator=(const ElementsAccessorBase&) = delete;

  using ElementsTraits = ElementsTraitsParam;
  using BackingStore = typename ElementsTraitsParam::BackingStore;

  static ElementsKind kind() { return ElementsTraits::Kind; }

  static void ValidateContents(Tagged<JSObject> holder, size_t length) {}

  static void ValidateImpl(Tagged<JSObject> holder) {
    Tagged<FixedArrayBase> fixed_array_base = holder->elements();
    if (!IsHeapObject(fixed_array_base)) return;
    // Arrays that have been shifted in place can't be verified.
    if (IsFreeSpaceOrFiller(fixed_array_base)) return;
    size_t length = 0;
    if (IsJSArray(holder)) {
      Tagged<Object> length_obj = Cast<JSArray>(holder)->length();
      if (IsSmi(length_obj)) {
        length = Smi::ToInt(length_obj);
      }
    } else if (IsJSTypedArray(holder)) {
      length = Cast<JSTypedArray>(holder)->GetLength();
    } else {
      length = fixed_array_base->length();
    }
    Subclass::ValidateContents(holder, length);
  }

  void Validate(Tagged<JSObject> holder) final {
    DisallowGarbageCollection no_gc;
    Subclass::ValidateImpl(holder);
  }

  bool HasElement(Tagged<JSObject> holder, uint32_t index,
                  Tagged<FixedArrayBase> backing_store,
                  PropertyFilter filter) final {
    return Subclass::HasElementImpl(holder->GetIsolate(), holder, index,
                                    backing_store, filter);
  }

  static bool HasElementImpl(Isolate* isolate, Tagged<JSObject> holder,
                             size_t index, Tagged<FixedArrayBase> backing_store,
                             PropertyFilter filter = ALL_PROPERTIES) {
    return Subclass::GetEntryForIndexImpl(isolate, holder, backing_store, index,
                                          filter)
        .is_found();
  }

  bool HasEntry(Tagged<JSObject> holder, InternalIndex entry) final {
    return Subclass::HasEntryImpl(holder->GetIsolate(), holder->elements(),
                                  entry);
  }

  static bool HasEntryImpl(Isolate* isolate,
                           Tagged<FixedArrayBase> backing_store,
                           InternalIndex entry) {
    UNIMPLEMENTED();
  }

  bool HasAccessors(Tagged<JSObject> holder) final {
    return Subclass::HasAccessorsImpl(holder, holder->elements());
  }

  static bool HasAccessorsImpl(Tagged<JSObject> holder,
                               Tagged<FixedArrayBase> backing_store) {
    return false;
  }

  Handle<Object> Get(Isolate* isolate, DirectHandle<JSObject> holder,
                     InternalIndex entry) final {
    return Subclass::GetInternalImpl(isolate, holder, entry);
  }

  static Handle<Object> GetInternalImpl(Isolate* isolate,
                                        DirectHandle<JSObject> holder,
                                        InternalIndex entry) {
    return Subclass::GetImpl(isolate, holder->elements(), entry);
  }

  static Handle<Object> GetImpl(Isolate* isolate,
                                Tagged<FixedArrayBase> backing_store,
                                InternalIndex entry) {
    return handle(Cast<BackingStore>(backing_store)->get(entry.as_int()),
                  isolate);
  }

  Handle<Object> GetAtomic(Isolate* isolate, DirectHandle<JSObject> holder,
                           InternalIndex entry, SeqCstAccessTag tag) final {
    return Subclass::GetAtomicInternalImpl(isolate, holder->elements(), entry,
                                           tag);
  }

  static Handle<Object> GetAtomicInternalImpl(
      Isolate* isolate, Tagged<FixedArrayBase> backing_store,
      InternalIndex entry, SeqCstAccessTag tag) {
    UNREACHABLE();
  }

  void SetAtomic(DirectHandle<JSObject> holder, InternalIndex entry,
                 Tagged<Object> value, SeqCstAccessTag tag) final {
    Subclass::SetAtomicInternalImpl(holder->elements(), entry, value, tag);
  }

  static void SetAtomicInternalImpl(Tagged<FixedArrayBase> backing_store,
                                    InternalIndex entry, Tagged<Object> value,
                                    SeqCstAccessTag tag) {
    UNREACHABLE();
  }

  Handle<Object> SwapAtomic(Isolate* isolate, DirectHandle<JSObject> holder,
                            InternalIndex entry, Tagged<Object> value,
                            SeqCstAccessTag tag) final {
    return Subclass::SwapAtomicInternalImpl(isolate, holder->elements(), entry,
                                            value, tag);
  }

  static Handle<Object> SwapAtomicInternalImpl(
      Isolate* isolate, Tagged<FixedArrayBase> backing_store,
      InternalIndex entry, Tagged<Object> value, SeqCstAccessTag tag) {
    UNREACHABLE();
  }

  Handle<Object> CompareAndSwapAtomic(Isolate* isolate,
                                      DirectHandle<JSObject> holder,
                                      InternalIndex entry,
                                      Tagged<Object> expected,
                                      Tagged<Object> value,
                                      SeqCstAccessTag tag) final {
    return handle(HeapObject::SeqCst_CompareAndSwapField(
                      expected, value,
                      |=](Tagged<Object> expected_value,
                          Tagged<Object> new_value) {
                        return Subclass::CompareAndSwapAtomicInternalImpl(
                            holder->elements(), entry, expected_value,
                            new_value, tag);
                      }),
                  isolate);
  }

  static Tagged<Object> CompareAndSwapAtomicInternalImpl(
      Tagged<FixedArrayBase> backing_store, InternalIndex entry,
      Tagged<Object> expected, Tagged<Object> value, SeqCstAccessTag tag) {
    UNREACHABLE();
  }

  void Set(DirectHandle<JSObject> holder, InternalIndex entry,
           Tagged<Object> value) final {
    Subclass::SetImpl(holder, entry, value);
  }

  void Reconfigure(DirectHandle<JSObject> object,
                   DirectHandle<FixedArrayBase> store, InternalIndex entry,
                   DirectHandle<Object> value,
                   PropertyAttributes attributes) final {
    Subclass::ReconfigureImpl(object, store, entry, value, attributes);
  }

  static void ReconfigureImpl(DirectHandle<JSObject> object,
                              DirectHandle<FixedArrayBase> store,
                              InternalIndex entry, DirectHandle<Object> value,
                              PropertyAttributes attributes) {
    UNREACHABLE();
  }

  Maybe<bool> Add(DirectHandle<JSObject> object, uint32_t index,
                  DirectHandle<Object> value, PropertyAttributes attributes,
                  uint32_t new_capacity) final {
    return Subclass::AddImpl(object, index, value, attributes, new_capacity);
  }

  static Maybe<bool> AddImpl(DirectHandle<JSObject> object, uint32_t index,
                             DirectHandle<Object> value,
                             PropertyAttributes attributes,
                             uint32_t new_capacity) {
    UNREACHABLE();
  }

  Maybe<uint32_t> Push(DirectHandle<JSArray> receiver, BuiltinArguments* args,
                       uint32_t push_size) final {
    return Subclass::PushImpl(receiver, args, push_size);
  }

  static Maybe<uint32_t> PushImpl(DirectHandle<JSArray> receiver,
                                  BuiltinArguments* args, uint32_t push_sized) {
    UNREACHABLE();
  }

  Maybe<uint32_t> Unshift(DirectHandle<JSArray> receiver,
                          BuiltinArguments* args, uint32_t unshift_size) final {
    return Subclass::UnshiftImpl(receiver, args, unshift_size);
  }

  static Maybe<uint32_t> UnshiftImpl(DirectHandle<JSArray> receiver,
                                     BuiltinArguments* args,
                                     uint32_t unshift_size) {
    UNREACHABLE();
  }

  MaybeDirectHandle<Object> Pop(DirectHandle<JSArray> receiver) final {
    return Subclass::PopImpl(receiver);
  }

  static MaybeDirectHandle<Object> PopImpl(DirectHandle<JSArray> receiver) {
    UNREACHABLE();
  }

  MaybeDirectHandle<Object> Shift(DirectHandle<JSArray> receiver) final {
    return Subclass::ShiftImpl(receiver);
  }

  static MaybeDirectHandle<Object> ShiftImpl(DirectHandle<JSArray> receiver) {
    UNREACHABLE();
  }

  Maybe<bool> SetLength(DirectHandle<JSArray> array, uint32_t length) final {
    return Subclass::SetLengthImpl(
        array->GetIsolate(), array, length,
        direct_handle(array->elements(), array->GetIsolate()));
  }

  static Maybe<bool> SetLengthImpl(Isolate* isolate,
                                   DirectHandle<JSArray> array, uint32_t length,
                                   DirectHandle<FixedArrayBase> backing_store) {
    DCHECK(!array->SetLengthWouldNormalize(length));
    DCHECK(IsFastElementsKind(array->GetElementsKind()));
    uint32_t old_length = 0;
    CHECK(Object::ToArrayIndex(array->length(), &old_length));

    if (old_length < length) {
      ElementsKind kind = array->GetElementsKind();
      if (!IsHoleyElementsKind(kind)) {
        kind = GetHoleyElementsKind(kind);
        JSObject::TransitionElementsKind(array, kind);
      }
    }

    // Check whether the backing store should be shrunk.
    uint32_t capacity = backing_store->length();
    old_length = std::min(old_length, capacity);
    if (length == 0) {
      array->initialize_elements();
    } else if (length <= capacity) {
      if (IsSmiOrObjectElementsKind(kind())) {
        JSObject::EnsureWritableFastElements(array);
        if (array->elements() != *backing_store) {
          backing_store = direct_handle(array->elements(), isolate);
        }
      }
      if (2 * length + JSObject::kMinAddedElementsCapacity <= capacity) {
        // If more than half the elements won't be used, trim the array.
        // Do not trim from short arrays to prevent frequent trimming on
        // repeated pop operations.
        // Leave some space to allow for subsequent push operations.
        uint32_t new_capacity =
            length + 1 == old_length ? (capacity + length) / 2 : length;
        DCHECK_LT(new_capacity, capacity);
        isolate->heap()->RightTrimArray(Cast<BackingStore>(*backing_store),
                                        new_capacity, capacity);
        // Fill the non-trimmed elements with holes.
        Cast<BackingStore>(*backing_store)
            ->FillWithHoles(length, std::min(old_length, new_capacity));
      } else {
        // Otherwise, fill the unused tail with holes.
        Cast<BackingStore>(*backing_store)->FillWithHoles(length, old_length);
      }
    } else {
      // Check whether the backing store should be expanded.
      capacity = std::max(length, JSObject::NewElementsCapacity(capacity));
      MAYBE_RETURN(Subclass::GrowCapacityAndConvertImpl(array, capacity),
                   Nothing<bool>());
    }

    array->set_length(Smi::FromInt(length));
    JSObject::ValidateElements(*array);
    return Just(true);
  }

  size_t NumberOfElements(Isolate* isolate, Tagged<JSObject> receiver) final {
    return Subclass::NumberOfElementsImpl(isolate, receiver,
                                          receiver->elements());
  }

  static uint32_t NumberOfElementsImpl(Isolate* isolate,
                                       Tagged<JSObject> receiver,
                                       Tagged<FixedArrayBase> backing_store) {
    UNREACHABLE();
  }

  static size_t GetMaxIndex(Tagged<JSObject> receiver,
                            Tagged<FixedArrayBase> elements) {
    if (IsJSArray(receiver)) {
      DCHECK(IsSmi(Cast<JSArray>(receiver)->length()));
      return static_cast<uint32_t>(
          Smi::ToInt(Cast<JSArray>(receiver)->length()));
    }
    return Subclass::GetCapacityImpl(receiver, elements);
  }

  static size_t GetMaxNumberOfEntries(Isolate* isolate,
                                      Tagged<JSObject> receiver,
                                      Tagged<FixedArrayBase> elements) {
    return Subclass::GetMaxIndex(receiver, elements);
  }

  static MaybeDirectHandle<FixedArrayBase> ConvertElementsWithCapacity(
      DirectHandle<JSObject> object, DirectHandle<FixedArrayBase> old_elements,
      ElementsKind from_kind, uint32_t capacity) {
    return ConvertElementsWithCapacity(object, old_elements, from_kind,
                                       capacity, 0, 0);
  }

  static MaybeDirectHandle<FixedArrayBase> ConvertElementsWithCapacity(
      DirectHandle<JSObject> object, DirectHandle<FixedArrayBase> old_elements,
      ElementsKind from_kind, uint32_t capacity, uint32_t src_index,
      uint32_t dst_index) {
    Isolate* isolate = object->GetIsolate();
    DirectHandle<FixedArrayBase> new_elements;
    // TODO(victorgomes): Retrieve native context in optimized code
    // and remove the check isolate->context().is_null().
    if (IsDoubleElementsKind(kind())) {
      if (!isolate->context().is_null() &&
          !base::IsInRange(capacity, 0, FixedDoubleArray::kMaxLength)) {
        THROW_NEW_ERROR(isolate,
                        NewRangeError(MessageTemplate::kInvalidArrayLength));
      }
      new_elements = isolate->factory()->NewFixedDoubleArray(capacity);
    } else {
      if (!isolate->context().is_null() &&
          !base::IsInRange(capacity, 0, FixedArray::kMaxLength)) {
        THROW_NEW_ERROR(isolate,
                        NewRangeError(MessageTemplate::kInvalidArrayLength));
      }
      new_elements = isolate->factory()->NewFixedArray(capacity);
    }

    int packed_size = kPackedSizeNotKnown;
    if (IsFastPackedElementsKind(from_kind) && IsJSArray(*object)) {
      packed_size = Smi::ToInt(Cast<JSArray>(*object)->length());
    }

    Subclass::CopyElementsImpl(isolate, *old_elements, src_index, *new_elements,
                               from_kind, dst_index, packed_size,
                               kCopyToEndAndInitializeToHole);

    return MaybeDirectHandle<FixedArrayBase>(new_elements);
  }

  static Maybe<bool> TransitionElementsKindImpl(DirectHandle<JSObject> object,
                                                DirectHandle<Map> to_map) {
    Isolate* isolate = object->GetIsolate();
    DirectHandle<Map> from_map(object->map(), isolate);
    ElementsKind from_kind = from_map->elements_kind();
    ElementsKind to_kind = to_map->elements_kind();
    if (IsHoleyElementsKind(from_kind)) {
      to_kind = GetHoleyElementsKind(to_kind);
    }
    if (from_kind != to_kind) {
      // This method should never be called for any other case.
      DCHECK(IsFastElementsKind(from_kind));
      DCHECK(IsFastElementsKind(to_kind));
      DCHECK_NE(TERMINAL_FAST_ELEMENTS_KIND, from_kind);

      DirectHandle<FixedArrayBase> from_elements(object->elements(), isolate);
      if (object->elements() == ReadOnlyRoots(isolate).empty_fixed_array() ||
          IsDoubleElementsKind(from_kind) == IsDoubleElementsKind(to_kind)) {
        // No change is needed to the elements() buffer, the transition
        // only requires a map change.
        JSObject::MigrateToMap(isolate, object, to_map);
      } else {
        DCHECK(
            (IsSmiElementsKind(from_kind) && IsDoubleElementsKind(to_kind)) ||
            (IsDoubleElementsKind(from_kind) && IsObjectElementsKind(to_kind)));
        uint32_t capacity = static_cast<uint32_t>(object->elements()->length());
        DirectHandle<FixedArrayBase> elements;
        ASSIGN_RETURN_ON_EXCEPTION_VALUE(
            object->GetIsolate(), elements,
            ConvertElementsWithCapacity(object, from_elements, from_kind,
                                        capacity),
            Nothing<bool>());
        JSObject::SetMapAndElements(object, to_map, elements);
      }
      if (v8_flags.trace_elements_transitions) {
        JSObject::PrintElementsTransition(
            stdout, object, from_kind, from_elements, to_kind,
            direct_handle(object->elements(), isolate));
      }
    }
    return Just(true);
  }

  static Maybe<bool> GrowCapacityAndConvertImpl(DirectHandle<JSObject> object,
                                                uint32_t capacity) {
    ElementsKind from_kind = object->GetElementsKind();
    if (IsSmiOrObjectElementsKind(from_kind)) {
      // Array optimizations rely on the prototype lookups of Array objects
      // always returning undefined. If there is a store to the initial
      // prototype object, make sure all of these optimizations are invalidated.
      object->GetIsolate()->UpdateNoElementsProtectorOnSetLength(object);
    }
    DirectHandle<FixedArrayBase> old_elements(object->elements(),
                                              object->GetIsolate());
    // This method should only be called if there's a reason to update the
    // elements.
    DCHECK(IsDoubleElementsKind(from_kind) != IsDoubleElementsKind(kind()) ||
           IsDictionaryElementsKind(from_kind) ||
           static_cast<uint32_t>(old_elements->length()) < capacity);
    return Subclass::BasicGrowCapacityAndConvertImpl(
        object, old_elements, from_kind, kind(), capacity);
  }

  static Maybe<bool> BasicGrowCapacityAndConvertImpl(
      DirectHandle<JSObject> object, DirectHandle<FixedArrayBase> old_elements,
      ElementsKind from_kind, ElementsKind to_kind, uint32_t capacity) {
    DirectHandle<FixedArrayBase> elements;
    ASSIGN_RETURN_ON_EXCEPTION_VALUE(
        object->GetIsolate(), elements,
        ConvertElementsWithCapacity(object, old_elements, from_kind, capacity),
        Nothing<bool>());

    if (IsHoleyElementsKind(from_kind)) {
      to_kind = GetHoleyElementsKind(to_kind);
    }
    DirectHandle<Map> new_map =
        JSObject::GetElementsTransitionMap(object, to_kind);
    JSObject::SetMapAndElements(object, new_map, elements);

    // Transition through the allocation site as well if present.
    JSObject::UpdateAllocationSite(object, to_kind);

    if (v8_flags.trace_elements_transitions) {
      JSObject::PrintElementsTransition(stdout, object, from_kind, old_elements,
                                        to_kind, elements);
    }
    return Just(true);
  }

  Maybe<bool> TransitionElementsKind(DirectHandle<JSObject> object,
                                     DirectHandle<Map> map) final {
    return Subclass::TransitionElementsKindImpl(object, map);
  }

  Maybe<bool> GrowCapacityAndConvert(DirectHandle<JSObject> object,
                                     uint32_t capacity) final {
    return Subclass::GrowCapacityAndConvertImpl(object, capacity);
  }

  Maybe<bool> GrowCapacity(DirectHandle<JSObject> object,
                           uint32_t index) final {
    // This function is intended to be called from optimized code. We don't
    // want to trigger lazy deopts there, so refuse to handle cases that would.
    if (object->map()->is_prototype_map() ||
        object->WouldConvertToSlowElements(index)) {
      return Just(false);
    }
    DirectHandle<FixedArrayBase> old_elements(object->elements(),
                                              object->GetIsolate());
    uint32_t new_capacity = JSObject::NewElementsCapacity(index + 1);
    DCHECK(static_cast<uint32_t>(old_elements->length()) < new_capacity);
    const uint32_t kMaxLength = IsDoubleElementsKind(kind())
                                    ? FixedDoubleArray::kMaxLength
                                    : FixedArray::kMaxLength;
    if (new_capacity > kMaxLength) {
      return Just(false);
    }
    DirectHandle<FixedArrayBase> elements;
    ASSIGN_RETURN_ON_EXCEPTION_VALUE(
        object->GetIsolate(), elements,
        ConvertElementsWithCapacity(object, old_elements, kind(), new_capacity),
        Nothing<bool>());

    DCHECK_EQ(object->GetElementsKind(), kind());
    // Transition through the allocation site as well if present.
    if (JSObject::UpdateAllocationSite<AllocationSiteUpdateMode::kCheckOnly>(
            object, kind())) {
      return Just(false);
    }

    object->set_elements(*elements);
    return Just(true);
  }

  void Delete(DirectHandle<JSObject> obj, InternalIndex entry) final {
    Subclass::DeleteImpl(obj, entry);
  }

  static void CopyElementsImpl(Isolate* isolate, Tagged<FixedArrayBase> from,
                               uint32_t from_start, Tagged<FixedArrayBase> to,
                               ElementsKind from_kind, uint32_t to_start,
                               int packed_size, int copy_size) {
    UNREACHABLE();
  }

  void CopyElements(Isolate* isolate, Tagged<JSObject> from_holder,
                    uint32_t from_start, ElementsKind from_kind,
                    DirectHandle<FixedArrayBase> to, uint32_t to_start,
                    int copy_size) final {
    int packed_size = kPackedSizeNotKnown;
    bool is_packed =
        IsFastPackedElementsKind(from_kind) && IsJSArray(from_holder);
    if (is_packed) {
      packed_size = Smi::ToInt(Cast<JSArray>(from_holder)->length());
      if (copy_size >= 0 && packed_size > copy_size) {
        packed_size = copy_size;
      }
    }
    Tagged<FixedArrayBase> from = from_holder->elements();
    // NOTE: the Subclass::CopyElementsImpl() methods
    // violate the handlified function signature convention:
    // raw pointer parameters in the function that allocates. This is done
    // intentionally to avoid ArrayConcat() builtin performance degradation.
    //
    // Details: The idea is that allocations actually happen only in case of
    // copying from object with fast double elements to object with object
    // elements. In all the other cases there are no allocations performed and
    // handle creation causes noticeable performance degradation of the builtin.
    Subclass::CopyElementsImpl(isolate, from, from_start, *to, from_kind,
                               to_start, packed_size, copy_size);
  }

  void CopyElements(Isolate* isolate, DirectHandle<FixedArrayBase> source,
                    ElementsKind source_kind,
                    DirectHandle<FixedArrayBase> destination,
                    int size) override {
    Subclass::CopyElementsImpl(isolate, *source, 0, *destination, source_kind,
                               0, kPackedSizeNotKnown, size);
  }

  void CopyTypedArrayElementsSlice(Tagged<JSTypedArray> source,
                                   Tagged<JSTypedArray> destination,
                                   size_t start, size_t end) override {
    Subclass::CopyTypedArrayElementsSliceImpl(source, destination, start, end);
  }

  static void CopyTypedArrayElementsSliceImpl(Tagged<JSTypedArray> source,
                                              Tagged<JSTypedArray> destination,
                                              size_t start, size_t end) {
    UNREACHABLE();
  }

  Tagged<Object> CopyElements(DirectHandle<JSAny> source,
                              DirectHandle<JSObject> destination, size_t length,
                              size_t offset) final {
    return Subclass::CopyElementsHandleImpl(source, destination, length,
                                            offset);
  }

  static Tagged<Object> CopyElementsHandleImpl(
      DirectHandle<Object> source, DirectHandle<JSObject> destination,
      size_t length, size_t offset) {
    UNREACHABLE();
  }

  DirectHandle<NumberDictionary> Normalize(
      DirectHandle<JSObject> object) final {
    return Subclass::NormalizeImpl(
        object, direct_handle(object->elements(), object->GetIsolate()));
  }

  static DirectHandle<NumberDictionary> NormalizeImpl(
      DirectHandle<JSObject> object, DirectHandle<FixedArrayBase> elements) {
    UNREACHABLE();
  }

  Maybe<bool> CollectValuesOrEntries(Isolate* isolate,
                                     DirectHandle<JSObject> object,
                                     DirectHandle<FixedArray> values_or_entries,
                                     bool get_entries, int* nof_items,
                                     PropertyFilter filter) override {
    return Subclass::CollectValuesOrEntriesImpl(
        isolate, object, values_or_entries, get_entries, nof_items, filter);
  }

  static Maybe<bool> CollectValuesOrEntriesImpl(
      Isolate* isolate, DirectHandle<JSObject> object,
      DirectHandle<FixedArray> values_or_entries, bool get_entries,
      int* nof_items, PropertyFilter filter) {
    DCHECK_EQ(*nof_items, 0);
    KeyAccumulator accumulator(isolate, KeyCollectionMode::kOwnOnly,
                               ALL_PROPERTIES);
    RETURN_NOTHING_IF_NOT_SUCCESSFUL(Subclass::CollectElementIndicesImpl(
        object, direct_handle(object->elements(), isolate), &accumulator));
    DirectHandle<FixedArray> keys = accumulator.GetKeys();

    int count = 0;
    int i = 0;
    ElementsKind original_elements_kind = object->GetElementsKind();

    for (; i < keys->length(); ++i) {
      DirectHandle<Object> key(keys->get(i), isolate);
      uint32_t index;
      if (!Object::ToUint32(*key, &index)) continue;

      DCHECK_EQ(object->GetElementsKind(), original_elements_kind);
      InternalIndex entry = Subclass::GetEntryForIndexImpl(
          isolate, *object, object->elements(), index, filter);
      if (entry.is_not_found()) continue;
      PropertyDetails details = Subclass::GetDetailsImpl(*object, entry);

      DirectHandle<Object> value;
      if (details.kind() == PropertyKind::kData) {
        value = Subclass::GetInternalImpl(isolate, object, entry);
      } else {
        // This might modify the elements and/or change the elements kind.
        LookupIterator it(isolate, object, index, LookupIterator::OWN);
        ASSIGN_RETURN_ON_EXCEPTION_VALUE(
            isolate, value, Object::GetProperty(&it), Nothing<bool>());
      }
      if (get_entries) value = MakeEntryPair(isolate, index, value);
      values_or_entries->set(count++, *value);
      if (object->GetElementsKind() != original_elements_kind) break;
    }

    // Slow path caused by changes in elements kind during iteration.
    for (; i < keys->length(); i++) {
      DirectHandle<Object> key(keys->get(i), isolate);
      uint32_t index;
      if (!Object::ToUint32(*key, &index)) continue;

      if (filter & ONLY_ENUMERABLE) {
        InternalElementsAccessor* accessor =
            reinterpret_cast<InternalElementsAccessor*>(
                object->GetElementsAccessor());
        InternalIndex entry = accessor->GetEntryForIndex(
            isolate, *object, object->elements(), index);
        if (entry.is_not_found()) continue;
        PropertyDetails details = accessor->GetDetails(*object, entry);
        if (!details.IsEnumerable()) continue;
      }

      DirectHandle<Object> value;
      LookupIterator it(isolate, object, index, LookupIterator::OWN);
      ASSIGN_RETURN_ON_EXCEPTION_VALUE(isolate, value, Object::GetProperty(&it),
                                       Nothing<bool>());

      if (get_entries) value = MakeEntryPair(isolate, index, value);
      values_or_entries->set(count++, *value);
    }

    *nof_items = count;
    return Just(true);
  }

  V8_WARN_UNUSED_RESULT ExceptionStatus CollectElementIndices(
      DirectHandle<JSObject> object, DirectHandle<FixedArrayBase> backing_store,
      KeyAccumulator* keys) final {
    return Subclass::CollectElementIndicesImpl(object, backing_store, keys);
  }

  V8_WARN_UNUSED_RESULT static ExceptionStatus CollectElementIndicesImpl(
      DirectHandle<JSObject> object, DirectHandle<FixedArrayBase> backing_store,
      KeyAccumulator* keys) {
    DCHECK_NE(DICTIONARY_ELEMENTS, kind());
    // Non-dictionary elements can't have all-can-read accessors.
    size_t length = Subclass::GetMaxIndex(*object, *backing_store);
    PropertyFilter filter = keys->filter();
    Isolate* isolate = keys->isolate();
    Factory* factory = isolate->factory();
    for (size_t i = 0; i < length; i++) {
      if (Subclass::HasElementImpl(isolate, *object, i, *backing_store,
                                   filter)) {
        RETURN_FAILURE_IF_NOT_SUCCESSFUL(
            keys->AddKey(factory->NewNumberFromSize(i)));
      }
    }
    return ExceptionStatus::kSuccess;
  }

  static Handle<FixedArray> DirectCollectElementIndicesImpl(
      Isolate* isolate, DirectHandle<JSObject> object,
      DirectHandle<FixedArrayBase> backing_store, GetKeysConversion convert,
      PropertyFilter filter, Handle<FixedArray> list, uint32_t* nof_indices,
      uint32_t insertion_index = 0) {
    size_t length = Subclass::GetMaxIndex(*object, *backing_store);
    uint32_t const kMaxStringTableEntries =
        isolate->heap()->MaxNumberToStringCacheSize();
    for (size_t i = 0; i < length; i++) {
      if (Subclass::HasElementImpl(isolate, *object, i, *backing_store,
                                   filter)) {
        if (convert == GetKeysConversion::kConvertToString) {
          bool use_cache = i < kMaxStringTableEntries;
          DirectHandle<String> index_string =
              isolate->factory()->SizeToString(i, use_cache);
          list->set(insertion_index, *index_string);
        } else {
          DirectHandle<Object> number =
              isolate->factory()->NewNumberFromSize(i);
          list->set(insertion_index, *number);
        }
        insertion_index++;
      }
    }
    *nof_indices = insertion_index;
    return list;
  }

  MaybeHandle<FixedArray> PrependElementIndices(
      Isolate* isolate, DirectHandle<JSObject> object,
      DirectHandle<FixedArrayBase> backing_store, DirectHandle<FixedArray> keys,
      GetKeysConversion convert, PropertyFilter filter) final {
    return Subclass::PrependElementIndicesImpl(isolate, object, backing_store,
                                               keys, convert, filter);
  }

  static MaybeHandle<FixedArray> PrependElementIndicesImpl(
      Isolate* isolate, DirectHandle<JSObject> object,
      DirectHandle<FixedArrayBase> backing_store, DirectHandle<FixedArray> keys,
      GetKeysConversion convert, PropertyFilter filter) {
    uint32_t nof_property_keys = keys->length();
    size_t initial_list_length =
        Subclass::GetMaxNumberOfEntries(isolate, *object, *backing_store);

    if (initial_list_length > FixedArray::kMaxLength - nof_property_keys) {
      THROW_NEW_ERROR(isolate,
                      NewRangeError(MessageTemplate::kInvalidArrayLength));
    }
    initial_list_length += nof_property_keys;

    // Collect the element indices into a new list.
    DCHECK_LE(initial_list_length, std::numeric_limits<int>::max());
    MaybeHandle<FixedArray> raw_array = isolate->factory()->TryNewFixedArray(
        static_cast<int>(initial_list_length));
    Handle<FixedArray> combined_keys;

    // If we have a holey backing store try to precisely estimate the backing
    // store size as a last emergency measure if we cannot allocate the big
    // array.
    if (!raw_array.ToHandle(&combined_keys)) {
      if (IsHoleyOrDictionaryElementsKind(kind())) {
        // If we overestimate the result list size we might end up in the
        // large-object space which doesn't free memory on shrinking the list.
        // Hence we try to estimate the final size for holey backing stores more
        // precisely here.
        initial_list_length =
            Subclass::NumberOfElementsImpl(isolate, *object, *backing_store);
        initial_list_length += nof_property_keys;
      }
      DCHECK_LE(initial_list_length, std::numeric_limits<int>::max());
      combined_keys = isolate->factory()->NewFixedArray(
          static_cast<int>(initial_list_length));
    }

    uint32_t nof_indices = 0;
    bool needs_sorting = IsDictionaryElementsKind(kind()) ||
                         IsSloppyArgumentsElementsKind(kind());
    combined_keys = Subclass::DirectCollectElementIndicesImpl(
        isolate, object, backing_store,
        needs_sorting ? GetKeysConversion::kKeepNumbers : convert, filter,
        combined_keys, &nof_indices);

    if (needs_sorting) {
      SortIndices(isolate, combined_keys, nof_indices);
      // Indices from dictionary elements should only be converted after
      // sorting.
      if (convert == GetKeysConversion::kConvertToString) {
        for (uint32_t i = 0; i < nof_indices; i++) {
          DirectHandle<Object> index_string =
              isolate->factory()->Uint32ToString(
                  Object::NumberValue(combined_keys->get(i)));
          combined_keys->set(i, *index_string);
        }
      }
    }

    // Copy over the passed-in property keys.
    CopyObjectToObjectElements(isolate, *keys, PACKED_ELEMENTS, 0,
                               *combined_keys, PACKED_ELEMENTS, nof_indices,
                               nof_property_keys);

    // For holey elements and arguments we might have to shrink the collected
    // keys since the estimates might be off.
    if (IsHoleyOrDictionaryElementsKind(kind()) ||
        IsSloppyArgumentsElementsKind(kind())) {
      // Shrink combined_keys to the final size.
      int final_size = nof_indices + nof_property_keys;
      DCHECK_LE(final_size, combined_keys->length());
      return FixedArray::RightTrimOrEmpty(isolate, combined_keys, final_size);
    }

    return combined_keys;
  }

  V8_WARN_UNUSED_RESULT ExceptionStatus AddElementsToKeyAccumulator(
      DirectHandle<JSObject> receiver, KeyAccumulator* accumulator,
      AddKeyConversion convert) final {
    return Subclass::AddElementsToKeyAccumulatorImpl(receiver, accumulator,
                                                     convert);
  }

  static uint32_t GetCapacityImpl(Tagged<JSObject> holder,
                                  Tagged<FixedArrayBase> backing_store) {
    return backing_store->length();
  }

  size_t GetCapacity(Tagged<JSObject> holder,
                     Tagged<FixedArrayBase> backing_store) final {
    return Subclass::GetCapacityImpl(holder, backing_store);
  }

  static MaybeDirectHandle<Object> FillImpl(DirectHandle<JSObject> receiver,
                                            DirectHandle<Object> obj_value,
                                            size_t start, size_t end) {
    UNREACHABLE();
  }

  MaybeDirectHandle<Object> Fill(DirectHandle<JSObject> receiver,
                                 DirectHandle<Object> obj_value, size_t start,
                                 size_t end) override {
    return Subclass::FillImpl(receiver, obj_value, start, end);
  }

  static Maybe<bool> IncludesValueImpl(Isolate* isolate,
                                       DirectHandle<JSObject> receiver,
                                       DirectHandle<Object> value,
                                       size_t start_from, size_t length) {
    return IncludesValueSlowPath(isolate, receiver, value, start_from, length);
  }

  Maybe<bool> IncludesValue(Isolate* isolate, DirectHandle<JSObject> receiver,
                            DirectHandle<Object> value, size_t start_from,
                            size_t length) final {
    return Subclass::IncludesValueImpl(isolate, receiver, value, start_from,
                                       length);
  }

  static Maybe<int64_t> IndexOfValueImpl(Isolate* isolate,
                                         DirectHandle<JSObject> receiver,
                                         DirectHandle<Object> value,
                                         size_t start_from, size_t length) {
    return IndexOfValueSlowPath(isolate, receiver, value, start_from, length);
  }

  Maybe<int64_t> IndexOfValue(Isolate* isolate, DirectHandle<JSObject> receiver,
                              DirectHandle<Object> value, size_t start_from,
                              size_t length) final {
    return Subclass::IndexOfValueImpl(isolate, receiver, value, start_from,
                                      length);
  }

  static Maybe<int64_t> LastIndexOfValueImpl(DirectHandle<JSObject> receiver,
                                             DirectHandle<Object> value,
                                             size_t start_from) {
    UNREACHABLE();
  }

  Maybe<int64_t> LastIndexOfValue(DirectHandle<JSObject> receiver,
                                  DirectHandle<Object> value,
                                  size_t start_from) final {
    return Subclass::LastIndexOfValueImpl(receiver, value, start_from);
  }

  static void ReverseImpl(Tagged<JSObject> receiver) { UNREACHABLE(); }

  void Reverse(Tagged<JSObject> receiver) final {
    Subclass::ReverseImpl(receiver);
  }

  static InternalIndex GetEntryForIndexImpl(
      Isolate* isolate, Tagged<JSObject> holder,
      Tagged<FixedArrayBase> backing_store, size_t index,
      PropertyFilter filter) {
    DCHECK(IsFastElementsKind(kind()) ||
           IsAnyNonextensibleElementsKind(kind()));
    size_t length = Subclass::GetMaxIndex(holder, backing_store);
    if (IsHoleyElementsKindForRead(kind())) {
      DCHECK_IMPLIES(
          index < length,
          index <= static_cast<size_t>(std::numeric_limits<int>::max()));
      return index < length &&
                     !Cast<BackingStore>(backing_store)
                          ->is_the_hole(isolate, static_cast<int>(index))
                 ? InternalIndex(index)
                 : InternalIndex::NotFound();
    } else {
      return index < length ? InternalIndex(index) : InternalIndex::NotFound();
    }
  }

  InternalIndex GetEntryForIndex(Isolate* isolate, Tagged<JSObject> holder,
                                 Tagged<FixedArrayBase> backing_store,
                                 size_t index) final {
    return Subclass::GetEntryForIndexImpl(isolate, holder, backing_store, index,
                                          ALL_PROPERTIES);
  }

  static PropertyDetails GetDetailsImpl(Tagged<FixedArrayBase> backing_store,
                                        InternalIndex entry) {
    return PropertyDetails(PropertyKind::kData, NONE,
                           PropertyCellType::kNoCell);
  }

  static PropertyDetails GetDetailsImpl(Tagged<JSObject> holder,
                                        InternalIndex entry) {
    return PropertyDetails(PropertyKind::kData, NONE,
                           PropertyCellType::kNoCell);
  }

  PropertyDetails GetDetails(Tagged<JSObject> holder,
                             InternalIndex entry) final {
    return Subclass::GetDetailsImpl(holder, entry);
  }

  Handle<FixedArray> CreateListFromArrayLike(Isolate* isolate,
                                             DirectHandle<JSObject> object,
                                             uint32_t length) final {
    return Subclass::CreateListFromArrayLikeImpl(isolate, object, length);
  }

  static Handle<FixedArray> CreateListFromArrayLikeImpl(
      Isolate* isolate, DirectHandle<JSObject> object, uint32_t length) {
    UNREACHABLE();
  }
};

class DictionaryElementsAccessor
    : public ElementsAccessorBase<DictionaryElementsAccessor,
                                  ElementsKindTraits<DICTIONARY_ELEMENTS>> {
 public:
  static uint32_t GetMaxIndex(Tagged<JSObject> receiver,
                              Tagged<FixedArrayBase> elements) {
    // We cannot properly estimate this for dictionaries.
    UNREACHABLE();
  }

  static uint32_t GetMaxNumberOfEntries(Isolate* isolate,
                                        Tagged<JSObject> receiver,
                                        Tagged<FixedArrayBase> backing_store) {
    return NumberOfElementsImpl(isolate, receiver, backing_store);
  }

  static uint32_t NumberOfElementsImpl(Isolate* isolate,
                                       Tagged<JSObject> receiver,
                                       Tagged<FixedArrayBase> backing_store) {
    Tagged<NumberDictionary> dict = Cast<NumberDictionary>(backing_store);
    return dict->NumberOfElements();
  }

  static Maybe<bool> SetLengthImpl(Isolate* isolate,
                                   DirectHandle<JSArray> array, uint32_t length,
                                   DirectHandle<FixedArrayBase> backing_store) {
    auto dict = Cast<NumberDictionary>(backing_store);
    uint32_t old_length = 0;
    CHECK(Object::ToArrayLength(array->length(), &old_length));
    {
      DisallowGarbageCollection no_gc;
      ReadOnlyRoots roots(isolate);
      if (length < old_length) {
        if (dict->requires_slow_elements()) {
          // Find last non-deletable element in range of elements to be
          // deleted and adjust range accordingly.
          for (InternalIndex entry : dict->IterateEntries()) {
            Tagged<Object> index = dict->KeyAt(isolate, entry);
            if (dict->IsKey(roots, index)) {
              uint32_t number =
                  static_cast<uint32_t>(Object::NumberValue(index));
              if (length <= number && number < old_length) {
                PropertyDetails details = dict->DetailsAt(entry);
                if (!details.IsConfigurable()) length = number + 1;
              }
            }
          }
        }

        if (length == 0) {
          // Flush the backing store.
          array->initialize_elements();
        } else {
          // Remove elements that should be deleted.
          int removed_entries = 0;
          for (InternalIndex entry : dict->IterateEntries()) {
            Tagged<Object> index = dict->KeyAt(isolate, entry);
            if (dict->IsKey(roots, index)) {
              uint32_t number =
                  static_cast<uint32_t>(Object::NumberValue(index));
              if (length <= number && number < old_length) {
                dict->ClearEntry(entry);
                removed_entries++;
              }
            }
          }

          if (removed_entries > 0) {
            // Update the number of elements.
            dict->ElementsRemoved(removed_entries);
          }
        }
      }
    }

    DirectHandle<Number> length_obj =
        isolate->factory()->NewNumberFromUint(length);
    array->set_length(*length_obj);
    return Just(true);
  }

  static void CopyElementsImpl(Isolate* isolate, Tagged<FixedArrayBase> from,
                               uint32_t from_start, Tagged<FixedArrayBase> to,
                               ElementsKind from_kind, uint32_t to_start,
                               int packed_size, int copy_size) {
    UNREACHABLE();
  }

  static void DeleteImpl(DirectHandle<JSObject> obj, InternalIndex entry) {
    DirectHandle<NumberDictionary> dict(Cast<NumberDictionary>(obj->elements()),
                                        obj->GetIsolate());
    dict = NumberDictionary::DeleteEntry(obj->GetIsolate(), dict, entry);
    obj->set_elements(*dict);
  }

  static bool HasAccessorsImpl(Tagged<JSObject> holder,
                               Tagged<FixedArrayBase> backing_store) {
    DisallowGarbageCollection no_gc;
    Tagged<NumberDictionary> dict = Cast<NumberDictionary>(backing_store);
    if (!dict->requires_slow_elements()) return false;
    PtrComprCageBase cage_base = GetPtrComprCageBase(holder);
    ReadOnlyRoots roots = GetReadOnlyRoots();
    for (InternalIndex i : dict->IterateEntries()) {
      Tagged<Object> key = dict->KeyAt(cage_base, i);
      if (!dict->IsKey(roots, key)) continue;
      PropertyDetails details = dict->DetailsAt(i);
      if (details.kind() == PropertyKind::kAccessor) return true;
    }
    return false;
  }

  static Tagged<Object> GetRaw(Tagged<FixedArrayBase> store,
                               InternalIndex entry) {
    Tagged<NumberDictionary> backing_store = Cast<NumberDictionary>(store);
    return backing_store->ValueAt(entry);
  }

  static Handle<Object> GetImpl(Isolate* isolate,
                                Tagged<FixedArrayBase> backing_store,
                                InternalIndex entry) {
    return handle(GetRaw(backing_store, entry), isolate);
  }

  static Handle<Object> GetAtomicInternalImpl(
      Isolate* isolate, Tagged<FixedArrayBase> backing_store,
      InternalIndex entry, SeqCstAccessTag tag) {
    return handle(Cast<NumberDictionary>(backing_store)->ValueAt(entry, tag),
                  isolate);
  }

  static inline void SetImpl(DirectHandle<JSObject> holder, InternalIndex entry,
                             Tagged<Object> value) {
    SetImpl(holder->elements(), entry, value);
  }

  static inline void SetImpl(Tagged<FixedArrayBase> backing_store,
                             InternalIndex entry, Tagged<Object> value) {
    Cast<NumberDictionary>(backing_store)->ValueAtPut(entry, value);
  }

  static void SetAtomicInternalImpl(Tagged<FixedArrayBase> backing_store,
                                    InternalIndex entry, Tagged<Object> value,
                                    SeqCstAccessTag tag) {
    Cast<NumberDictionary>(backing_store)->ValueAtPut(entry, value, tag);
  }

  static Handle<Object> SwapAtomicInternalImpl(
      Isolate* isolate, Tagged<FixedArrayBase> backing_store,
      InternalIndex entry, Tagged<Object> value, SeqCstAccessTag tag) {
    return handle(
        Cast<NumberDictionary>(backing_store)->ValueAtSwap(entry, value, tag),
        isolate);
  }

  static Tagged<Object> CompareAndSwapAtomicInternalImpl(
      Tagged<FixedArrayBase> backing_store, InternalIndex entry,
      Tagged<Object> expected, Tagged<Object> value, SeqCstAccessTag tag) {
    return Cast<NumberDictionary>(backing_store)
        ->ValueAtCompareAndSwap(entry, expected, value, tag);
  }

  static void ReconfigureImpl(DirectHandle<JSObject> object,
                              DirectHandle<FixedArrayBase> store,
                              InternalIndex entry, DirectHandle<Object> value,
                              PropertyAttributes attributes) {
    Tagged<NumberDictionary> dictionary = Cast<NumberDictionary>(*store);
    if (attributes != NONE) object->RequireSlowElements(dictionary);
    dictionary->ValueAtPut(entry, *value);
    PropertyDetails details = dictionary->DetailsAt(entry);
    details =
        PropertyDetails(PropertyKind::kData, attributes,
                        PropertyCellType::kNoCell, details.dictionary_index());

    dictionary->DetailsAtPut(entry, details);
  }

  static Maybe<bool> AddImpl(DirectHandle<JSObject> object, uint32_t index,
                             DirectHandle<Object> value,
                             PropertyAttributes attributes,
                             uint32_t new_capacity) {
    PropertyDetails details(PropertyKind::kData, attributes,
                            PropertyCellType::kNoCell);
    DirectHandle<NumberDictionary> dictionary =
        object->HasFastElements() || object->HasFastStringWrapperElements()
            ? JSObject::NormalizeElements(object)
            : direct_handle(Cast<NumberDictionary>(object->elements()),
                            object->GetIsolate());
    DirectHandle<NumberDictionary> new_dictionary = NumberDictionary::Add(
        object->GetIsolate(), dictionary, index, value, details);
    new_dictionary->UpdateMaxNumberKey(index, object);
    if (attributes != NONE) object->RequireSlowElements(*new_dictionary);
    if (dictionary.is_identical_to(new_dictionary)) return Just(true);
    object->set_elements(*new_dictionary);
    return Just(true);
  }

  static bool HasEntryImpl(Isolate* isolate, Tagged<FixedArrayBase> store,
                           InternalIndex entry) {
    DisallowGarbageCollection no_gc;
    Tagged<NumberDictionary> dict = Cast<NumberDictionary>(store);
    Tagged<Object> index = dict->KeyAt(isolate, entry);
    return !IsTheHole(index, isolate);
  }

  static InternalIndex GetEntryForIndexImpl(Isolate* isolate,
                                            Tagged<JSObject> holder,
                                            Tagged<FixedArrayBase> store,
                                            size_t index,
                                            PropertyFilter filter) {
    DisallowGarbageCollection no_gc;
    Tagged<NumberDictionary> dictionary = Cast<NumberDictionary>(store);
    DCHECK_LE(index, std::numeric_limits<uint32_t>::max());
    InternalIndex entry =
        dictionary->FindEntry(isolate, static_cast<uint32_t>(index));
    if (entry.is_not_found()) return entry;

    if (filter != ALL_PROPERTIES) {
      PropertyDetails details = dictionary->DetailsAt(entry);
      PropertyAttributes attr = details.attributes();
      if ((int{attr} & filter) != 0) return InternalIndex::NotFound();
    }
    return entry;
  }

  static PropertyDetails GetDetailsImpl(Tagged<JSObject> holder,
                                        InternalIndex entry) {
    return GetDetailsImpl(holder->elements(), entry);
  }

  static PropertyDetails GetDetailsImpl(Tagged<FixedArrayBase> backing_store,
                                        InternalIndex entry) {
    return Cast<NumberDictionary>(backing_store)->DetailsAt(entry);
  }

  static uint32_t FilterKey(DirectHandle<NumberDictionary> dictionary,
                            InternalIndex entry, Tagged<Object> raw_key,
                            PropertyFilter filter) {
    DCHECK(IsNumber(raw_key));
    DCHECK_LE(Object::NumberValue(raw_key), kMaxUInt32);
    PropertyDetails details = dictionary->DetailsAt(entry);
    PropertyAttributes attr = details.attributes();
    if ((int{attr} & filter) != 0) return kMaxUInt32;
    return static_cast<uint32_t>(Object::NumberValue(raw_key));
  }

  static uint32_t GetKeyForEntryImpl(Isolate* isolate,
                                     DirectHandle<NumberDictionary> dictionary,
                                     InternalIndex entry,
                                     PropertyFilter filter) {
    DisallowGarbageCollection no_gc;
    Tagged<Object> raw_key = dictionary->KeyAt(isolate, entry);
    if (!dictionary->IsKey(ReadOnlyRoots(isolate), raw_key)) return kMaxUInt32;
    return FilterKey(dictionary, entry, raw_key, filter);
  }

  V8_WARN_UNUSED_RESULT static ExceptionStatus CollectElementIndicesImpl(
      DirectHandle<JSObject> object, DirectHandle<FixedArrayBase> backing_store,
      KeyAccumulator* keys) {
    if (keys->filter() & SKIP_STRINGS) return ExceptionStatus::kSuccess;
    Isolate* isolate = keys->isolate();
    auto dictionary = Cast<NumberDictionary>(backing_store);
    DirectHandle<FixedArray> elements = isolate->factory()->NewFixedArray(
        GetMaxNumberOfEntries(isolate, *object, *backing_store));
    int insertion_index = 0;
    PropertyFilter filter = keys->filter();
    ReadOnlyRoots roots(isolate);
    for (InternalIndex i : dictionary->IterateEntries()) {
      AllowGarbageCollection allow_gc;
      Tagged<Object> raw_key = dictionary->KeyAt(isolate, i);
      if (!dictionary->IsKey(roots, raw_key)) continue;
      uint32_t key = FilterKey(dictionary, i, raw_key, filter);
      if (key == kMaxUInt32) {
        // This might allocate, but {raw_key} is not used afterwards.
        keys->AddShadowingKey(raw_key, &allow_gc);
        continue;
      }
      elements->set(insertion_index, raw_key);
      insertion_index++;
    }
    SortIndices(isolate, elements, insertion_index);
    for (int i = 0; i < insertion_index; i++) {
      RETURN_FAILURE_IF_NOT_SUCCESSFUL(keys->AddKey(elements->get(i)));
    }
    return ExceptionStatus::kSuccess;
  }

  static Handle<FixedArray> DirectCollectElementIndicesImpl(
      Isolate* isolate, DirectHandle<JSObject> object,
      DirectHandle<FixedArrayBase> backing_store, GetKeysConversion convert,
      PropertyFilter filter, Handle<FixedArray> list, uint32_t* nof_indices,
      uint32_t insertion_index = 0) {
    if (filter & SKIP_STRINGS) return list;

    auto dictionary = Cast<NumberDictionary>(backing_store);
    for (InternalIndex i : dictionary->IterateEntries()) {
      uint32_t key = GetKeyForEntryImpl(isolate, dictionary, i, filter);
      if (key == kMaxUInt32) continue;
      DirectHandle<Object> index = isolate->factory()->NewNumberFromUint(key);
      list->set(insertion_index, *index);
      insertion_index++;
    }
    *nof_indices = insertion_index;
    return list;
  }

  V8_WARN_UNUSED_RESULT static ExceptionStatus AddElementsToKeyAccumulatorImpl(
      DirectHandle<JSObject> receiver, KeyAccumulator* accumulator,
      AddKeyConversion convert) {
    Isolate* isolate = accumulator->isolate();
    DirectHandle<NumberDictionary> dictionary(
        Cast<NumberDictionary>(receiver->elements()), isolate);
    ReadOnlyRoots roots(isolate);
    for (InternalIndex i : dictionary->IterateEntries()) {
      Tagged<Object> k = dictionary->KeyAt(isolate, i);
      if (!dictionary->IsKey(roots, k)) continue;
      Tagged<Object> value = dictionary->ValueAt(isolate, i);
      DCHECK(!IsTheHole(value, isolate));
      DCHECK(!IsAccessorPair(value));
      DCHECK(!IsAccessorInfo(value));
      RETURN_FAILURE_IF_NOT_SUCCESSFUL(accumulator->AddKey(value, convert));
    }
    return ExceptionStatus::kSuccess;
  }

  static bool IncludesValueFastPath(Isolate* isolate,
                                    DirectHandle<JSObject> receiver,
                                    DirectHandle<Object> value,
                                    size_t start_from, size_t length,
                                    Maybe<bool>* result) {
    DisallowGarbageCollection no_gc;
    Tagged<NumberDictionary> dictionary =
        Cast<NumberDictionary>(receiver->elements());
    Tagged<Object> the_hole = ReadOnlyRoots(isolate).the_hole_value();
    Tagged<Object> undefined = ReadOnlyRoots(isolate).undefined_value();

    // Scan for accessor properties. If accessors are present, then elements
    // must be accessed in order via the slow path.
    bool found = false;
    for (InternalIndex i : dictionary->IterateEntries()) {
      Tagged<Object> k = dictionary->KeyAt(isolate, i);
      if (k == the_hole) continue;
      if (k == undefined) continue;

      uint32_t index;
      if (!Object::ToArrayIndex(k, &index) || index < start_from ||
          index >= length) {
        continue;
      }

      if (dictionary->DetailsAt(i).kind() == PropertyKind::kAccessor) {
        // Restart from beginning in slow path, otherwise we may observably
        // access getters out of order
        return false;
      } else if (!found) {
        Tagged<Object> element_k = dictionary->ValueAt(isolate, i);
        if (Object::SameValueZero(*value, element_k)) found = true;
      }
    }

    *result = Just(found);
    return true;
  }

  static Maybe<bool> IncludesValueImpl(Isolate* isolate,
                                       DirectHandle<JSObject> receiver,
                                       DirectHandle<Object> value,
                                       size_t start_from, size_t length) {
    DCHECK(JSObject::PrototypeHasNoElements(isolate, *receiver));
    bool search_for_hole = IsUndefined(*value, isolate);

    if (!search_for_hole) {
      Maybe<bool> result = Nothing<bool>();
      if (DictionaryElementsAccessor::IncludesValueFastPath(
              isolate, receiver, value, start_from, length, &result)) {
        return result;
      }
    }
    ElementsKind original_elements_kind = receiver->GetElementsKind();
    USE(original_elements_kind);
    DirectHandle<NumberDictionary> dictionary(
        Cast<NumberDictionary>(receiver->elements()), isolate);
    // Iterate through the entire range, as accessing elements out of order is
    // observable.
    for (size_t k = start_from; k < length; ++k) {
      DCHECK_EQ(receiver->GetElementsKind(), original_elements_kind);
      InternalIndex entry =
          dictionary->FindEntry(isolate, static_cast<uint32_t>(k));
      if (entry.is_not_found()) {
        if (search_for_hole) return Just(true);
        continue;
      }

      PropertyDetails details = GetDetailsImpl(*dictionary, entry);
      switch (details.kind()) {
        case PropertyKind::kData: {
          Tagged<Object> element_k = dictionary->ValueAt(entry);
          if (Object::SameValueZero(*value, element_k)) return Just(true);
          break;
        }
        case PropertyKind::kAccessor: {
          LookupIterator it(isolate, receiver, k,
                            LookupIterator::OWN_SKIP_INTERCEPTOR);
          DCHECK(it.IsFound());
          DCHECK_EQ(it.state(), LookupIterator::ACCESSOR);
          DirectHandle<Object> element_k;

          ASSIGN_RETURN_ON_EXCEPTION_VALUE(isolate, element_k,
                                           Object::GetPropertyWithAccessor(&it),
                                           Nothing<bool>());

          if (Object::SameValueZero(*value, *element_k)) return Just(true);

          // Bailout to slow path if elements on prototype changed
          if (!JSObject::PrototypeHasNoElements(isolate, *receiver)) {
            return IncludesValueSlowPath(isolate, receiver, value, k + 1,
                                         length);
          }

          // Continue if elements unchanged
          if (*dictionary == receiver->elements()) continue;

          // Otherwise, bailout or update elements

          // If switched to initial elements, return true if searching for
          // undefined, and false otherwise.
          if (receiver->map()->GetInitialElements() == receiver->elements()) {
            return Just(search_for_hole);
          }

          // If switched to fast elements, continue with the correct accessor.
          if (receiver->GetElementsKind() != DICTIONARY_ELEMENTS) {
            ElementsAccessor* accessor = receiver->GetElementsAccessor();
            return accessor->IncludesValue(isolate, receiver, value, k + 1,
                                           length);
          }
          dictionary = direct_handle(
              Cast<NumberDictionary>(receiver->elements()), isolate);
          break;
        }
      }
    }
    return Just(false);
  }

  static Maybe<int64_t> IndexOfValueImpl(Isolate* isolate,
                                         DirectHandle<JSObject> receiver,
                                         DirectHandle<Object> value,
                                         size_t start_from, size_t length) {
    DCHECK(JSObject::PrototypeHasNoElements(isolate, *receiver));

    ElementsKind original_elements_kind = receiver->GetElementsKind();
    USE(original_elements_kind);
    DirectHandle<NumberDictionary> dictionary(
        Cast<NumberDictionary>(receiver->elements()), isolate);
    // Iterate through entire range, as accessing elements out of order is
    // observable.
    for (size_t k = start_from; k < length; ++k) {
      DCHECK_EQ(receiver->GetElementsKind(), original_elements_kind);
      DCHECK_LE(k, std::numeric_limits<uint32_t>::max());
      InternalIndex entry =
          dictionary->FindEntry(isolate, static_cast<uint32_t>(k));
      if (entry.is_not_found()) continue;

      PropertyDetails details =
          GetDetailsImpl(*dictionary, InternalIndex(entry));
      switch (details.kind()) {
        case PropertyKind::kData: {
          Tagged<Object> element_k = dictionary->ValueAt(entry);
          if (Object::StrictEquals(*value, element_k)) {
            return Just<int64_t>(k);
          }
          break;
        }
        case PropertyKind::kAccessor: {
          LookupIterator it(isolate, receiver, k,
                            LookupIterator::OWN_SKIP_INTERCEPTOR);
          DCHECK(it.IsFound());
          DCHECK_EQ(it.state(), LookupIterator::ACCESSOR);
          DirectHandle<Object> element_k;

          ASSIGN_RETURN_ON_EXCEPTION_VALUE(isolate, element_k,
                                           Object::GetPropertyWithAccessor(&it),
                                           Nothing<int64_t>());

          if (Object::StrictEquals(*value, *element_k)) return Just<int64_t>(k);

          // Bailout to slow path if elements on prototype changed.
          if (!JSObject::PrototypeHasNoElements(isolate, *receiver)) {
            return IndexOfValueSlowPath(isolate, receiver, value, k + 1,
                                        length);
          }

          // Continue if elements unchanged.
          if (*dictionary == receiver->elements()) continue;

          // Otherwise, bailout or update elements.
          if (receiver->GetElementsKind() != DICTIONARY_ELEMENTS) {
            // Otherwise, switch to slow path.
            return IndexOfValueSlowPath(isolate, receiver, value, k + 1,
                                        length);
          }
          dictionary = direct_handle(
              Cast<NumberDictionary>(receiver->elements()), isolate);
          break;
        }
      }
    }
    return Just<int64_t>(-1);
  }

  static void ValidateContents(Tagged<JSObject> holder, size_t length) {
    DisallowGarbageCollection no_gc;
#if DEBUG
    DCHECK_EQ(holder->map()->elements_kind(), DICTIONARY_ELEMENTS);
    if (!v8_flags.enable_slow_asserts) return;
    ReadOnlyRoots roots = GetReadOnlyRoots();
    Tagged<NumberDictionary> dictionary =
        Cast<NumberDictionary>(holder->elements());
    // Validate the requires_slow_elements and max_number_key values.
    bool requires_slow_elements = false;
    int max_key = 0;
    for (InternalIndex i : dictionary->IterateEntries()) {
      Tagged<Object> k;
      if (!dictionary->ToKey(roots, i, &k)) continue;
      DCHECK_LE(0.0, Object::NumberValue(k));
      if (Object::NumberValue(k) >
          NumberDictionary::kRequiresSlowElementsLimit) {
        requires_slow_elements = true;
      } else {
        max_key = std::max(max_key, Smi::ToInt(k));
      }
    }
    if (requires_slow_elements) {
      DCHECK(dictionary->requires_slow_elements());
    } else if (!dictionary->requires_slow_elements()) {
      DCHECK_LE(max_key, dictionary->max_number_key());
    }
#endif
  }
};

// Super class for all fast element arrays.
template <typename Subclass, typename KindTraits>
class FastElementsAccessor : public ElementsAccessorBase<Subclass, KindTraits> {
 public:
  using BackingStore = typename KindTraits::BackingStore;

  static DirectHandle<NumberDictionary> NormalizeImpl(
      DirectHandle<JSObject> object, DirectHandle<FixedArrayBase> store) {
    Isolate* isolate = object->GetIsolate();
    ElementsKind kind = Subclass::kind();

    // Ensure that notifications fire if the array or object prototypes are
    // normalizing.
    if (IsSmiOrObjectElementsKind(kind) ||
        kind == FAST_STRING_WRAPPER_ELEMENTS) {
      isolate->UpdateNoElementsProtectorOnNormalizeElements(object);
    }

    int capacity = object->GetFastElementsUsage();
    DirectHandle<NumberDictionary> dictionary =
        NumberDictionary::New(isolate, capacity);

    PropertyDetails details = PropertyDetails::Empty();
    int j = 0;
    int max_number_key = -1;
    for (int i = 0; j < capacity; i++) {
      if (IsHoleyElementsKindForRead(kind)) {
        if (Cast<BackingStore>(*store)->is_the_hole(isolate, i)) continue;
      }
      max_number_key = i;
      DirectHandle<Object> value =
          Subclass::GetImpl(isolate, *store, InternalIndex(i));
      dictionary =
          NumberDictionary::Add(isolate, dictionary, i, value, details);
      j++;
    }

    if (max_number_key > 0) {
      dictionary->UpdateMaxNumberKey(static_cast<uint32_t>(max_number_key),
                                     object);
    }
    return dictionary;
  }

  static void DeleteAtEnd(DirectHandle<JSObject> obj,
                          DirectHandle<BackingStore> backing_store,
                          uint32_t entry) {
    uint32_t length = static_cast<uint32_t>(backing_store->length());
    DCHECK_LT(entry, length);
    Isolate* isolate = obj->GetIsolate();
    for (; entry > 0; entry--) {
      if (!backing_store->is_the_hole(isolate, entry - 1)) break;
    }
    if (entry == 0) {
      Tagged<FixedArray> empty = ReadOnlyRoots(isolate).empty_fixed_array();
      // Dynamically ask for the elements kind here since we manually redirect
      // the operations for argument backing stores.
      if (obj->GetElementsKind() == FAST_SLOPPY_ARGUMENTS_ELEMENTS) {
        Cast<SloppyArgumentsElements>(obj->elements())->set_arguments(empty);
      } else {
        obj->set_elements(empty);
      }
      return;
    }

    isolate->heap()->RightTrimArray(*backing_store, entry, length);
  }

  static void DeleteCommon(DirectHandle<JSObject> obj, uint32_t entry,
                           DirectHandle<FixedArrayBase> store) {
    DCHECK(obj->HasSmiOrObjectElements() || obj->HasDoubleElements() ||
           obj->HasNonextensibleElements() || obj->HasFastArgumentsElements() ||
           obj->HasFastStringWrapperElements());
    DirectHandle<BackingStore> backing_store = Cast<BackingStore>(store);
    if (!IsJSArray(*obj) &&
        entry == static_cast<uint32_t>(store->length()) - 1) {
      DeleteAtEnd(obj, backing_store, entry);
      return;
    }

    Isolate* isolate = obj->GetIsolate();
    backing_store->set_the_hole(isolate, entry);

    // TODO(verwaest): Move this out of elements.cc.
    // If the backing store is larger than a certain size and
    // has too few used values, normalize it.
    const int kMinLengthForSparsenessCheck = 64;
    if (backing_store->length() < kMinLengthForSparsenessCheck) return;
    uint32_t length = 0;
    if (IsJSArray(*obj)) {
      Object::ToArrayLength(Cast<JSArray>(*obj)->length(), &length);
    } else {
      length = static_cast<uint32_t>(store->length());
    }

    // To avoid doing the check on every delete, use a counter-based heuristic.
    const int kLengthFraction = 16;
    // The above constant must be large enough to ensure that we check for
    // normalization frequently enough. At a minimum, it should be large
    // enough to reliably hit the "window" of remaining elements count where
    // normalization would be beneficial.
    static_assert(kLengthFraction >=
                  NumberDictionary::kEntrySize *
                      NumberDictionary::kPreferFastElementsSizeFactor);
    size_t current_counter = isolate->elements_deletion_counter();
    if (current_counter < length / kLengthFraction) {
      isolate->set_elements_deletion_counter(current_counter + 1);
      return;
    }
    // Reset the counter whenever the full check is performed.
    isolate->set_elements_deletion_counter(0);

    if (!IsJSArray(*obj)) {
      uint32_t i;
      for (i = entry + 1; i < length; i++) {
        if (!backing_store->is_the_hole(isolate, i)) break;
      }
      if (i == length) {
        DeleteAtEnd(obj, backing_store, entry);
        return;
      }
    }
    int num_used = 0;
    for (int i = 0; i < backing_store->length(); ++i) {
      if (!backing_store->is_the_hole(isolate, i)) {
        ++num_used;
        // Bail out if a number dictionary wouldn't be able to save much space.
        if (NumberDictionary::kPreferFastElementsSizeFactor *
                NumberDictionary::ComputeCapacity(num_used) *
                NumberDictionary::kEntrySize >
            static_cast<uint32_t>(backing_store->length())) {
          return;
        }
      }
    }
    JSObject::NormalizeElements(obj);
  }

  static void ReconfigureImpl(DirectHandle<JSObject> object,
                              DirectHandle<FixedArrayBase> store,
                              InternalIndex entry, DirectHandle<Object> value,
                              PropertyAttributes attributes) {
    DirectHandle<NumberDictionary> dictionary =
        JSObject::NormalizeElements(object);
    entry = InternalIndex(
        dictionary->FindEntry(object->GetIsolate(), entry.as_uint32()));
    DictionaryElementsAccessor::ReconfigureImpl(
        object, Cast<FixedArrayBase>(dictionary), entry, value, attributes);
  }

  static Maybe<bool> AddImpl(DirectHandle<JSObject> object, uint32_t index,
                             DirectHandle<Object> value,
                             PropertyAttributes attributes,
                             uint32_t new_capacity) {
    DCHECK_EQ(NONE, attributes);
    ElementsKind from_kind = object->GetElementsKind();
    ElementsKind to_kind = Subclass::kind();
    if (IsDictionaryElementsKind(from_kind) ||
        IsDoubleElementsKind(from_kind) != IsDoubleElementsKind(to_kind) ||
        Subclass::GetCapacityImpl(*object, object->elements()) !=
            new_capacity) {
      MAYBE_RETURN(Subclass::GrowCapacityAndConvertImpl(object, new_capacity),
                   Nothing<bool>());
    } else {
      if (IsFastElementsKind(from_kind) && from_kind != to_kind) {
        JSObject::TransitionElementsKind(object, to_kind);
      }
      if (IsSmiOrObjectElementsKind(from_kind)) {
        DCHECK(IsSmiOrObjectElementsKind(to_kind));
        JSObject::EnsureWritableFastElements(object);
      }
    }
    Subclass::SetImpl(object, InternalIndex(index), *value);
    return Just(true);
  }

  static void DeleteImpl(DirectHandle<JSObject> obj, InternalIndex entry) {
    ElementsKind kind = KindTraits::Kind;
    if (IsFastPackedElementsKind(kind) ||
        kind == PACKED_NONEXTENSIBLE_ELEMENTS) {
      JSObject::TransitionElementsKind(obj, GetHoleyElementsKind(kind));
    }
    if (IsSmiOrObjectElementsKind(KindTraits::Kind) ||
        IsNonextensibleElementsKind(kind)) {
      JSObject::EnsureWritableFastElements(obj);
    }
    DeleteCommon(obj, entry.as_uint32(),
                 direct_handle(obj->elements(), obj->GetIsolate()));
  }

  static bool HasEntryImpl(Isolate* isolate,
                           Tagged<FixedArrayBase> backing_store,
                           InternalIndex entry) {
    return !Cast<BackingStore>(backing_store)
                ->is_the_hole(isolate, entry.as_int());
  }

  static uint32_t NumberOfElementsImpl(Isolate* isolate,
                                       Tagged<JSObject> receiver,
                                       Tagged<FixedArrayBase> backing_store) {
    size_t max_index = Subclass::GetMaxIndex(receiver, backing_store);
    DCHECK_LE(max_index, std::numeric_limits<uint32_t>::max());
    if (IsFastPackedElementsKind(Subclass::kind())) {
      return static_cast<uint32_t>(max_index);
    }
    uint32_t count = 0;
    for (size_t i = 0; i < max_index; i++) {
      if (Subclass::HasEntryImpl(isolate, backing_store, InternalIndex(i))) {
        count++;
      }
    }
    return count;
  }

  V8_WARN_UNUSED_RESULT static ExceptionStatus AddElementsToKeyAccumulatorImpl(
      DirectHandle<JSObject> receiver, KeyAccumulator* accumulator,
      AddKeyConversion convert) {
    Isolate* isolate = accumulator->isolate();
    DirectHandle<FixedArrayBase> elements(receiver->elements(), isolate);
    size_t length =
        Subclass::GetMaxNumberOfEntries(isolate, *receiver, *elements);
    for (size_t i = 0; i < length; i++) {
      if (IsFastPackedElementsKind(KindTraits::Kind) ||
          HasEntryImpl(isolate, *elements, InternalIndex(i))) {
        RETURN_FAILURE_IF_NOT_SUCCESSFUL(accumulator->AddKey(
            Subclass::GetImpl(isolate, *elements, InternalIndex(i)), convert));
      }
    }
    return ExceptionStatus::kSuccess;
  }

  static void ValidateContents(Tagged<JSObject> holder, size_t length) {
#if DEBUG
    Isolate* isolate = holder->GetIsolate();
    Heap* heap = isolate->heap();
    Tagged<FixedArrayBase> elements = holder->elements();
    Tagged<Map> map = elements->map();
    if (IsSmiOrObjectElementsKind(KindTraits::Kind)) {
      DCHECK_NE(map, ReadOnlyRoots(heap).fixed_double_array_map());
    } else if (IsDoubleElementsKind(KindTraits::Kind)) {
      DCHECK_NE(map, ReadOnlyRoots(heap).fixed_cow_array_map());
      if (map == ReadOnlyRoots(heap).fixed_array_map()) DCHECK_EQ(0u, length);
    } else {
      UNREACHABLE();
    }
    if (length == 0u) return;  // nothing to do!
#if ENABLE_SLOW_DCHECKS
    DisallowGarbageCollection no_gc;
    Tagged<BackingStore> backing_store = Cast<BackingStore>(elements);
    DCHECK(length <= std::numeric_limits<int>::max());
    int length_int = static_cast<int>(length);
    if (IsSmiElementsKind(KindTraits::Kind)) {
      HandleScope scope(isolate);
      for (int i = 0; i < length_int; i++) {
        Tagged<Object> element = Cast<FixedArray>(backing_store)->get(i);
        DCHECK(IsSmi(element) || (IsHoleyElementsKind(KindTraits::Kind) &&
                                  IsTheHole(element, isolate)));
      }
    } else if (KindTraits::Kind == PACKED_ELEMENTS ||
               KindTraits::Kind == PACKED_DOUBLE_ELEMENTS) {
      for (int i = 0; i < length_int; i++) {
        DCHECK(!backing_store->is_the_hole(isolate, i));
      }
    } else {
      DCHECK(IsHoleyElementsKind(KindTraits::Kind));
    }
#endif
#endif
  }

  static MaybeDirectHandle<Object> PopImpl(DirectHandle<JSArray> receiver) {
    return Subclass::RemoveElement(receiver, AT_END);
  }

  static MaybeDirectHandle<Object> ShiftImpl(DirectHandle<JSArray> receiver) {
    return Subclass::RemoveElement(receiver, AT_START);
  }

  static Maybe<uint32_t> PushImpl(DirectHandle<JSArray> receiver,
                                  BuiltinArguments* args, uint32_t push_size) {
    DirectHandle<FixedArrayBase> backing_store(receiver->elements(),
                                               receiver->GetIsolate());
    return Subclass::AddArguments(receiver, backing_store, args, push_size,
                                  AT_END);
  }

  static Maybe<uint32_t> UnshiftImpl(DirectHandle<JSArray> receiver,
                                     BuiltinArguments* args,
                                     uint32_t unshift_size) {
    DirectHandle<FixedArrayBase> backing_store(receiver->elements(),
                                               receiver->GetIsolate());
    return Subclass::AddArguments(receiver, backing_store, args, unshift_size,
                                  AT_START);
  }

  static DirectHandle<FixedArrayBase> MoveElements(
      Isolate* isolate, DirectHandle<JSArray> receiver,
      DirectHandle<FixedArrayBase> backing_store, int dst_index, int src_index,
      int len, int hole_start, int hole_end) {
    DisallowGarbageCollection no_gc;
    Tagged<BackingStore> dst_elms = Cast<BackingStore>(*backing_store);
    if (len > JSArray::kMaxCopyElements && dst_index == 0 &&
        isolate->heap()->CanMoveObjectStart(dst_elms)) {
      dst_elms = Cast<BackingStore>(
          isolate->heap()->LeftTrimFixedArray(dst_elms, src_index));
      // Updates this backing_store handle.
      backing_store.SetValue(dst_elms);
      receiver->set_elements(dst_elms);
      // Adjust the hole offset as the array has been shrunk.
      hole_end -= src_index;
      DCHECK_LE(hole_start, backing_store->length());
      DCHECK_LE(hole_end, backing_store->length());
    } else if (len != 0) {
      WriteBarrierMode mode =
          GetWriteBarrierMode(dst_elms, KindTraits::Kind, no_gc);
      dst_elms->MoveElements(isolate, dst_index, src_index, len, mode);
    }
    if (hole_start != hole_end) {
      dst_elms->FillWithHoles(hole_start, hole_end);
    }
    return backing_store;
  }

  static MaybeDirectHandle<Object> FillImpl(DirectHandle<JSObject> receiver,
                                            DirectHandle<Object> obj_value,
                                            size_t start, size_t end) {
    // Ensure indexes are within array bounds
    DCHECK_LE(0, start);
    DCHECK_LE(start, end);

    // Make sure COW arrays are copied.
    if (IsSmiOrObjectElementsKind(Subclass::kind())) {
      JSObject::EnsureWritableFastElements(receiver);
    }

    // Make sure we have enough space.
    DCHECK_LE(end, std::numeric_limits<uint32_t>::max());
    if (end > Subclass::GetCapacityImpl(*receiver, receiver->elements())) {
      MAYBE_RETURN_NULL(Subclass::GrowCapacityAndConvertImpl(
          receiver, static_cast<uint32_t>(end)));
      CHECK_EQ(Subclass::kind(), receiver->GetElementsKind());
    }
    DCHECK_LE(end, Subclass::GetCapacityImpl(*receiver, receiver->elements()));

    for (size_t index = start; index < end; ++index) {
      Subclass::SetImpl(receiver, InternalIndex(index), *obj_value);
    }
    return MaybeDirectHandle<Object>(receiver);
  }

  static Maybe<bool> IncludesValueImpl(Isolate* isolate,
                                       DirectHandle<JSObject> receiver,
                                       DirectHandle<Object> search_value,
                                       size_t start_from, size_t length) {
    DCHECK(JSObject::PrototypeHasNoElements(isolate, *receiver));
    DisallowGarbageCollection no_gc;
    Tagged<FixedArrayBase> elements_base = receiver->elements();
    Tagged<Object> the_hole = ReadOnlyRoots(isolate).the_hole_value();
    Tagged<Object> undefined = ReadOnlyRoots(isolate).undefined_value();
    Tagged<Object> value = *search_value;

    if (start_from >= length) return Just(false);

    // Elements beyond the capacity of the backing store treated as undefined.
    size_t elements_length = static_cast<size_t>(elements_base->length());
    if (value == undefined && elements_length < length) return Just(true);
    if (elements_length == 0) {
      DCHECK_NE(value, undefined);
      return Just(false);
    }

    length = std::min(elements_length, length);
    DCHECK_LE(length, std::numeric_limits<int>::max());

    if (!IsNumber(value)) {
      if (value == undefined) {
        // Search for `undefined` or The Hole. Even in the case of
        // PACKED_DOUBLE_ELEMENTS or PACKED_SMI_ELEMENTS, we might encounter The
        // Hole here, since the {length} used here can be larger than
        // JSArray::length.
        if (IsSmiOrObjectElementsKind(Subclass::kind()) ||
            IsAnyNonextensibleElementsKind(Subclass::kind())) {
          Tagged<FixedArray> elements = Cast<FixedArray>(receiver->elements());

          for (size_t k = start_from; k < length; ++k) {
            Tagged<Object> element_k = elements->get(static_cast<int>(k));

            if (element_k == the_hole || element_k == undefined) {
              return Just(true);
            }
          }
          return Just(false);
        } else {
          // Search for The Hole in HOLEY_DOUBLE_ELEMENTS or
          // PACKED_DOUBLE_ELEMENTS.
          DCHECK(IsDoubleElementsKind(Subclass::kind()));
          Tagged<FixedDoubleArray> elements =
              Cast<FixedDoubleArray>(receiver->elements());

          for (size_t k = start_from; k < length; ++k) {
            if (elements->is_the_hole(static_cast<int>(k))) return Just(true);
          }
          return Just(false);
        }
      } else if (!IsObjectElementsKind(Subclass::kind()) &&
                 !IsAnyNonextensibleElementsKind(Subclass::kind())) {
        // Search for non-number, non-Undefined value, with either
        // PACKED_SMI_ELEMENTS, PACKED_DOUBLE_ELEMENTS, HOLEY_SMI_ELEMENTS or
        // HOLEY_DOUBLE_ELEMENTS. Guaranteed to return false, since these
        // elements kinds can only contain Number values or undefined.
        return Just(false);
      } else {
        // Search for non-number, non-Undefined value with either
        // PACKED_ELEMENTS or HOLEY_ELEMENTS.
        DCHECK(IsObjectElementsKind(Subclass::kind()) ||
               IsAnyNonextensibleElementsKind(Subclass::kind()));
        Tagged<FixedArray> elements = Cast<FixedArray>(receiver->elements());

        for (size_t k = start_from; k < length; ++k) {
          Tagged<Object> element_k = elements->get(static_cast<int>(k));
          if (element_k == the_hole) continue;
          if (Object::SameValueZero(value, element_k)) return Just(true);
        }
        return Just(false);
      }
    } else {
      if (!IsNaN(value)) {
        double search_number = Object::NumberValue(value);
        if (IsDoubleElementsKind(Subclass::kind())) {
          // Search for non-NaN Number in PACKED_DOUBLE_ELEMENTS or
          // HOLEY_DOUBLE_ELEMENTS --- Skip TheHole, and trust UCOMISD or
          // similar operation for result.
          Tagged<FixedDoubleArray> elements =
              Cast<FixedDoubleArray>(receiver->elements());

          for (size_t k = start_from; k < length; ++k) {
            if (elements->is_the_hole(static_cast<int>(k))) continue;
            if (elements->get_scalar(static_cast<int>(k)) == search_number) {
              return Just(true);
            }
          }
          return Just(false);
        } else {
          // Search for non-NaN Number in PACKED_ELEMENTS, HOLEY_ELEMENTS,
          // PACKED_SMI_ELEMENTS or HOLEY_SMI_ELEMENTS --- Skip non-Numbers,
          // and trust UCOMISD or similar operation for result
          Tagged<FixedArray> elements = Cast<FixedArray>(receiver->elements());

          for (size_t k = start_from; k < length; ++k) {
            Tagged<Object> element_k = elements->get(static_cast<int>(k));
            if (IsNumber(element_k) &&
                Object::NumberValue(element_k) == search_number) {
              return Just(true);
            }
          }
          return Just(false);
        }
      } else {
        // Search for NaN --- NaN cannot be represented with Smi elements, so
        // abort if ElementsKind is PACKED_SMI_ELEMENTS or HOLEY_SMI_ELEMENTS
        if (IsSmiElementsKind(Subclass::kind())) return Just(false);

        if (IsDoubleElementsKind(Subclass::kind())) {
          // Search for NaN in PACKED_DOUBLE_ELEMENTS or
          // HOLEY_DOUBLE_ELEMENTS --- Skip The Hole and trust
          // std::isnan(elementK) for result
          Tagged<FixedDoubleArray> elements =
              Cast<FixedDoubleArray>(receiver->elements());

          for (size_t k = start_from; k < length; ++k) {
            if (elements->is_the_hole(static_cast<int>(k))) continue;
            if (std::isnan(elements->get_scalar(static_cast<int>(k)))) {
              return Just(true);
            }
          }
          return Just(false);
        } else {
          // Search for NaN in PACKED_ELEMENTS or HOLEY_ELEMENTS. Return true
          // if elementK->IsHeapNumber() && std::isnan(elementK->Number())
          DCHECK(IsObjectElementsKind(Subclass::kind()) ||
                 IsAnyNonextensibleElementsKind(Subclass::kind()));
          Tagged<FixedArray> elements = Cast<FixedArray>(receiver->elements());

          for (size_t k = start_from; k < length; ++k) {
            if (IsNaN(elements->get(static_cast<int>(k)))) return Just(true);
          }
          return Just(false);
        }
      }
    }
  }

  static Handle<FixedArray> CreateListFromArrayLikeImpl(
      Isolate* isolate, DirectHandle<JSObject> object, uint32_t length) {
    Handle<FixedArray> result = isolate->factory()->NewFixedArray(length);
    DirectHandle<FixedArrayBase> elements(object->elements(), isolate);
    for (uint32_t i = 0; i < length; i++) {
      InternalIndex entry(i);
      if (!Subclass::HasEntryImpl(isolate, *elements, entry)) continue;
      DirectHandle<Object> value;
      value = Subclass::GetImpl(isolate, *elements, entry);
      if (IsName(*value)) {
        value = isolate->factory()->InternalizeName(Cast<Name>(value));
      }
      result->set(i, *value);
    }
    return result;
  }

  static MaybeDirectHandle<Object> RemoveElement(DirectHandle<JSArray> receiver,
                                                 Where remove_position) {
    Isolate* isolate = receiver->GetIsolate();
    ElementsKind kind = KindTraits::Kind;
    if (IsSmiOrObjectElementsKind(kind)) {
      HandleScope scope(isolate);
      JSObject::EnsureWritableFastElements(receiver);
    }
    DirectHandle<FixedArrayBase> backing_store(receiver->elements(), isolate);
    uint32_t length = static_cast<uint32_t>(Smi::ToInt(receiver->length()));
    DCHECK_GT(length, 0);
    int new_length = length - 1;
    int remove_index = remove_position == AT_START ? 0 : new_length;
    DirectHandle<Object> result =
        Subclass::GetImpl(isolate, *backing_store, InternalIndex(remove_index));
    if (remove_position == AT_START) {
      backing_store = Subclass::MoveElements(isolate, receiver, backing_store,
                                             0, 1, new_length, 0, 0);
    }
    MAYBE_RETURN_NULL(
        Subclass::SetLengthImpl(isolate, receiver, new_length, backing_store));

    if (IsHoleyElementsKind(kind) && IsTheHole(*result, isolate)) {
      return isolate->factory()->undefined_value();
    }
    return MaybeDirectHandle<Object>(result);
  }

  static Maybe<uint32_t> AddArguments(
      DirectHandle<JSArray> receiver,
      DirectHandle<FixedArrayBase> backing_store, BuiltinArguments* args,
      uint32_t add_size, Where add_position) {
    uint32_t length = Smi::ToInt(receiver->length());
    DCHECK_LT(0, add_size);
    uint32_t elms_len = backing_store->length();
    // Check we do not overflow the new_length.
    DCHECK(add_size <= static_cast<uint32_t>(Smi::kMaxValue - length));
    uint32_t new_length = length + add_size;
    Isolate* isolate = receiver->GetIsolate();

    if (new_length > elms_len) {
      // New backing storage is needed.
      uint32_t capacity = JSObject::NewElementsCapacity(new_length);
      // If we add arguments to the start we have to shift the existing objects.
      int copy_dst_index = add_position == AT_START ? add_size : 0;
      // Copy over all objects to a new backing_store.
      ASSIGN_RETURN_ON_EXCEPTION_VALUE(
          isolate, backing_store,
          Subclass::ConvertElementsWithCapacity(receiver, backing_store,
                                                KindTraits::Kind, capacity, 0,
                                                copy_dst_index),
          Nothing<uint32_t>());
      receiver->set_elements(*backing_store);
    } else if (add_position == AT_START) {
      // If the backing store has enough capacity and we add elements to the
      // start we have to shift the existing objects.
      backing_store = Subclass::MoveElements(isolate, receiver, backing_store,
                                             add_size, 0, length, 0, 0);
    }

    int insertion_index = add_position == AT_START ? 0 : length;
    // Copy the arguments to the start.
    Subclass::CopyArguments(args, backing_store, add_size, 1, insertion_index);
    // Set the length.
    receiver->set_length(Smi::FromInt(new_length));
    return Just(new_length);
  }

  static void CopyArguments(BuiltinArguments* args,
                            DirectHandle<FixedArrayBase> dst_store,
                            uint32_t copy_size, uint32_t src_index,
                            uint32_t dst_index) {
    // Add the provided values.
    DisallowGarbageCollection no_gc;
    Tagged<FixedArrayBase> raw_backing_store = *dst_store;
    WriteBarrierMode mode = raw_backing_store->GetWriteBarrierMode(no_gc);
    for (uint32_t i = 0; i < copy_size; i++) {
      Tagged<Object> argument = (*args)|src_index + i];
      DCHECK(!IsTheHole(argument));
      Subclass::SetImpl(raw_backing_store, InternalIndex(dst_index + i),
                        argument, mode);
    }
  }
};

template <typename Subclass, typename KindTraits>
class FastSmiOrObjectElementsAccessor
    : public FastElementsAccessor<Subclass, KindTraits> {
 public:
  static inline void SetImpl(DirectHandle<JSObject> holder, InternalIndex entry,
                             Tagged<Object> value) {
    SetImpl(holder->elements(), entry, value);
  }

  static inline void SetImpl(Tagged<FixedArrayBase> backing_store,
                             InternalIndex entry, Tagged<Object> value) {
    Cast<FixedArray>(backing_store)->set(entry.as_int(), value);
  }

  static inline void SetImpl(Tagged<FixedArrayBase> backing_store,
                             InternalIndex entry, Tagged<Object> value,
                             WriteBarrierMode mode) {
    Cast<FixedArray>(backing_store)->set(entry.as_int(), value, mode);
  }

  static Tagged<Object> GetRaw(Tagged<FixedArray> backing_store,
                               InternalIndex entry) {
    return backing_store->get(entry.as_int());
  }

  // NOTE: this method violates the handlified function signature convention:
  // raw pointer parameters in the function that allocates.
  // See ElementsAccessor::CopyElements() for details.
  // This method could actually allocate if copying from double elements to
  // object elements.
  static void CopyElementsImpl(Isolate* isolate, Tagged<FixedArrayBase> from,
                               uint32_t from_start, Tagged<FixedArrayBase> to,
                               ElementsKind from_kind, uint32_t to_start,
                               int packed_size, int copy_size) {
    DisallowGarbageCollection no_gc;
    ElementsKind to_kind = KindTraits::Kind;
    switch (from_kind) {
      case PACKED_SMI_ELEMENTS:
      case HOLEY_SMI_ELEMENTS:
      case PACKED_ELEMENTS:
      case PACKED_FROZEN_ELEMENTS:
      case PACKED_SEALED_ELEMENTS:
      case PACKED_NONEXTENSIBLE_ELEMENTS:
      case HOLEY_ELEMENTS:
      case HOLEY_FROZEN_ELEMENTS:
      case HOLEY_SEALED_ELEMENTS:
      case HOLEY_NONEXTENSIBLE_ELEMENTS:
      case SHARED_ARRAY_ELEMENTS:
        CopyObjectToObjectElements(isolate, from, from_kind, from_start, to,
                                   to_kind, to_start, copy_size);
        break;
      case PACKED_DOUBLE_ELEMENTS:
      case HOLEY_DOUBLE_ELEMENTS: {
        AllowGarbageCollection allow_allocation;
        DCHECK(IsObjectElementsKind(to_kind));
        CopyDoubleToObjectElements(isolate, from, from_start, to, to_start,
                                   copy_size);
        break;
      }
      case DICTIONARY_ELEMENTS:
        CopyDictionaryToObjectElements(isolate, from, from_start, to, to_kind,
                                       to_start, copy_size);
        break;
      case FAST_SLOPPY_ARGUMENTS_ELEMENTS:
      case SLOW_SLOPPY_ARGUMENTS_ELEMENTS:
      case FAST_STRING_WRAPPER_ELEMENTS:
      case SLOW_STRING_WRAPPER_ELEMENTS:
#define TYPED_ARRAY_CASE(Type, type, TYPE, ctype) case TYPE##_ELEMENTS:
        TYPED_ARRAYS(TYPED_ARRAY_CASE)
        RAB_GSAB_TYPED_ARRAYS(TYPED_ARRAY_CASE)
#undef TYPED_ARRAY_CASE
      case WASM_ARRAY_ELEMENTS:
        // This function is currently only used for JSArrays with non-zero
        // length.
        UNREACHABLE();
      case NO_ELEMENTS:
        break;  // Nothing to do.
    }
  }

  static Maybe<bool> CollectValuesOrEntriesImpl(
      Isolate* isolate, DirectHandle<JSObject> object,
      DirectHandle<FixedArray> values_or_entries, bool get_entries,
      int* nof_items, PropertyFilter filter) {
    int count = 0;
    if (get_entries) {
      // Collecting entries needs to allocate, so this code must be handlified.
      DirectHandle<FixedArray> elements(Cast<FixedArray>(object->elements()),
                                        isolate);
      uint32_t length = elements->length();
      for (uint32_t index = 0; index < length; ++index) {
        InternalIndex entry(index);
        if (!Subclass::HasEntryImpl(isolate, *elements, entry)) continue;
        DirectHandle<Object> value =
            Subclass::GetImpl(isolate, *elements, entry);
        value = MakeEntryPair(isolate, index, value);
        values_or_entries->set(count++, *value);
      }
    } else {
      // No allocations here, so we can avoid handlification overhead.
      DisallowGarbageCollection no_gc;
      Tagged<FixedArray> elements = Cast<FixedArray>(object->elements());
      uint32_t length = elements->length();
      for (uint32_t index = 0; index < length; ++index) {
        InternalIndex entry(index);
        if (!Subclass::HasEntryImpl(isolate, elements, entry)) continue;
        Tagged<Object> value = GetRaw(elements, entry);
        values_or_entries->set(count++, value);
      }
    }
    *nof_items = count;
    return Just(true);
  }

  static Maybe<int64_t> IndexOfValueImpl(Isolate* isolate,
                                         DirectHandle<JSObject> receiver,
                                         DirectHandle<Object> search_value,
                                         size_t start_from, size_t length) {
    DCHECK(JSObject::PrototypeHasNoElements(isolate, *receiver));
    DisallowGarbageCollection no_gc;
    Tagged<FixedArrayBase> elements_base = receiver->elements();
    Tagged<Object> value = *search_value;

    if (start_from >= length) return Just<int64_t>(-1);

    length = std::min(static_cast<size_t>(elements_base->length()), length);

    // Only FAST_{,HOLEY_}ELEMENTS can store non-numbers.
    if (!IsNumber(value) && !IsObjectElementsKind(Subclass::kind()) &&
        !IsAnyNonextensibleElementsKind(Subclass::kind())) {
      return Just<int64_t>(-1);
    }
    // NaN can never be found by strict equality.
    if (IsNaN(value)) return Just<int64_t>(-1);

    // k can be greater than receiver->length() below, but it is bounded by
    // elements_base->length() so we never read out of bounds. This means that
    // elements->get(k) can return the hole, for which the StrictEquals will
    // always fail.
    Tagged<FixedArray> elements = Cast<FixedArray>(receiver->elements());
    static_assert(FixedArray::kMaxLength <=
                  std::numeric_limits<uint32_t>::max());
    for (size_t k = start_from; k < length; ++k) {
      if (Object::StrictEquals(value,
                               elements->get(static_cast<uint32_t>(k)))) {
        return Just<int64_t>(k);
      }
    }
    return Just<int64_t>(-1);
  }
};

class FastPackedSmiElementsAccessor
    : public FastSmiOrObjectElementsAccessor<
          FastPackedSmiElementsAccessor,
          ElementsKindTraits<PACKED_SMI_ELEMENTS>> {};

class FastHoleySmiElementsAccessor
    : public FastSmiOrObjectElementsAccessor<
          FastHoleySmiElementsAccessor,
          ElementsKindTraits<HOLEY_SMI_ELEMENTS>> {};

class FastPackedObjectElementsAccessor
    : public FastSmiOrObjectElementsAccessor<
          FastPackedObjectElementsAccessor,
          ElementsKindTraits<PACKED_ELEMENTS>> {};

template <typename Subclass, typename KindTraits>
class FastNonextensibleObjectElementsAccessor
    : public FastSmiOrObjectElementsAccessor<Subclass, KindTraits> {
 public:
  using BackingStore = typename KindTraits::BackingStore;

  static Maybe<uint32_t> PushImpl(DirectHandle<JSArray> receiver,
                                  BuiltinArguments* args, uint32_t push_size) {
    UNREACHABLE();
  }

  static Maybe<bool> AddImpl(DirectHandle<JSObject> object, uint32_t index,
                             DirectHandle<Object> value,
                             PropertyAttributes attributes,
                             uint32_t new_capacity) {
    UNREACHABLE();
  }

  // TODO(duongn): refactor this due to code duplication of sealed version.
  // Consider using JSObject::NormalizeElements(). Also consider follow the fast
  // element logic instead of changing to dictionary mode.
  static Maybe<bool> SetLengthImpl(Isolate* isolate,
                                   DirectHandle<JSArray> array, uint32_t length,
                                   DirectHandle<FixedArrayBase> backing_store) {
    uint32_t old_length = 0;
    CHECK(Object::ToArrayIndex(array->length(), &old_length));
    if (length == old_length) {
      // Do nothing.
      return Just(true);
    }

    // Transition to DICTIONARY_ELEMENTS.
    // Convert to dictionary mode.
    DirectHandle<NumberDictionary> new_element_dictionary =
        old_length == 0 ? isolate->factory()->empty_slow_element_dictionary()
                        : array->GetElementsAccessor()->Normalize(array);

    // Migrate map.
    DirectHandle<Map> new_map =
        Map::Copy(isolate, direct_handle(array->map(), isolate),
                  "SlowCopyForSetLengthImpl");
    new_map->set_is_extensible(false);
    new_map->set_elements_kind(DICTIONARY_ELEMENTS);
    JSObject::MigrateToMap(isolate, array, new_map);

    if (!new_element_dictionary.is_null()) {
      array->set_elements(*new_element_dictionary);
    }

    if (array->elements() !=
        ReadOnlyRoots(isolate).empty_slow_element_dictionary()) {
      DirectHandle<NumberDictionary> dictionary(array->element_dictionary(),
                                                isolate);
      // Make sure we never go back to the fast case
      array->RequireSlowElements(*dictionary);
      JSObject::ApplyAttributesToDictionary(isolate, ReadOnlyRoots(isolate),
                                            dictionary,
                                            PropertyAttributes::NONE);
    }

    // Set length.
    DirectHandle<FixedArrayBase> new_backing_store(array->elements(), isolate);
    return DictionaryElementsAccessor::SetLengthImpl(isolate, array, length,
                                                     new_backing_store);
  }
};

class FastPackedNonextensibleObjectElementsAccessor
    : public FastNonextensibleObjectElementsAccessor<
          FastPackedNonextensibleObjectElementsAccessor,
          ElementsKindTraits<PACKED_NONEXTENSIBLE_ELEMENTS>> {};

class FastHoleyNonextensibleObjectElementsAccessor
    : public FastNonextensibleObjectElementsAccessor<
          FastHoleyNonextensibleObjectElementsAccessor,
          ElementsKindTraits<HOLEY_NONEXTENSIBLE_ELEMENTS>> {};

template <typename Subclass, typename KindTraits>
class FastSealedObjectElementsAccessor
    : public FastSmiOrObjectElementsAccessor<Subclass, KindTraits> {
 public:
  using BackingStore = typename KindTraits::BackingStore;

  static DirectHandle<Object> RemoveElement(DirectHandle<JSArray> receiver,
                                            Where remove_position) {
    UNREACHABLE();
  }

  static void DeleteImpl(DirectHandle<JSObject> obj, InternalIndex entry) {
    UNREACHABLE();
  }

  static void DeleteAtEnd(DirectHandle<JSObject> obj,
                          DirectHandle<BackingStore> backing_store,
                          uint32_t entry) {
    UNREACHABLE();
  }

  static void DeleteCommon(DirectHandle<JSObject> obj, uint32_t entry,
                           DirectHandle<FixedArrayBase> store) {
    UNREACHABLE();
  }

  static MaybeDirectHandle<Object> PopImpl(DirectHandle<JSArray> receiver) {
    UNREACHABLE();
  }

  static Maybe<uint32_t> PushImpl(DirectHandle<JSArray> receiver,
                                  BuiltinArguments* args, uint32_t push_size) {
    UNREACHABLE();
  }

  static Maybe<bool> AddImpl(DirectHandle<JSObject> object, uint32_t index,
                             DirectHandle<Object> value,
                             PropertyAttributes attributes,
                             uint32_t new_capacity) {
    UNREACHABLE();
  }

  // TODO(duongn): refactor this due to code duplication of nonextensible
  // version. Consider using JSObject::NormalizeElements(). Also consider follow
  // the fast element logic instead of changing to dictionary mode.
  static Maybe<bool> SetLengthImpl(Isolate* isolate,
                                   DirectHandle<JSArray> array, uint32_t length,
                                   DirectHandle<FixedArrayBase> backing_store) {
    uint32_t old_length = 0;
    CHECK(Object::ToArrayIndex(array->length(), &old_length));
    if (length == old_length) {
      // Do nothing.
      return Just(true);
    }

    // Transition to DICTIONARY_ELEMENTS.
    // Convert to dictionary mode
    DirectHandle<NumberDictionary> new_element_dictionary =
        old_length == 0 ? isolate->factory()->empty_slow_element_dictionary()
                        : array->GetElementsAccessor()->Normalize(array);

    // Migrate map.
    DirectHandle<Map> new_map =
        Map::Copy(isolate, direct_handle(array->map(), isolate),
                  "SlowCopyForSetLengthImpl");
    new_map->set_is_extensible(false);
    new_map->set_elements_kind(DICTIONARY_ELEMENTS);
    JSObject::MigrateToMap(isolate, array, new_map);

    if (!new_element_dictionary.is_null()) {
      array->set_elements(*new_element_dictionary);
    }

    if (array->elements() !=
        ReadOnlyRoots(isolate).empty_slow_element_dictionary()) {
      DirectHandle<NumberDictionary> dictionary(array->element_dictionary(),
                                                isolate);
      // Make sure we never go back to the fast case
      array->RequireSlowElements(*dictionary);
      JSObject::ApplyAttributesToDictionary(isolate, ReadOnlyRoots(isolate),
                                            dictionary,
                                            PropertyAttributes::SEALED);
    }

    // Set length
    DirectHandle<FixedArrayBase> new_backing_store(array->elements(), isolate);
    return DictionaryElementsAccessor::SetLengthImpl(isolate, array, length,
                                                     new_backing_store);
  }
};

class FastPackedSealedObjectElementsAccessor
    : public FastSealedObjectElementsAccessor<
          FastPackedSealedObjectElementsAccessor,
          ElementsKindTraits<PACKED_SEALED_ELEMENTS>> {};

class SharedArrayElementsAccessor
    : public FastSealedObjectElementsAccessor<
          SharedArrayElementsAccessor,
          ElementsKindTraits<SHARED_ARRAY_ELEMENTS>> {
 public:
  static Handle<Object> GetAtomicInternalImpl(
      Isolate* isolate, Tagged<FixedArrayBase> backing_store,
      InternalIndex entry, SeqCstAccessTag tag) {
    return handle(Cast<BackingStore>(backing_store)->get(entry.as_int(), tag),
                  isolate);
  }

  static void SetAtomicInternalImpl(Tagged<FixedArrayBase> backing_store,
                                    InternalIndex entry, Tagged<Object> value,
                                    SeqCstAccessTag tag) {
    Cast<BackingStore>(backing_store)->set(entry.as_int(), value, tag);
  }
[Step 8: Duration 15.35 seconds| Input tokens: 217,655 | Output tokens: 3,065]
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ Step 9 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'init_rag_db' with arguments: {'id': 'v8_elements_inventory_v1'}                                                                                                         │
╰────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
Error executing tool 'init_rag_db' with arguments {'id': 'v8_elements_inventory_v1'}: NameError: name 'rag_db_id' is not defined
Please try again or use another tool
[Step 9: Duration 41.49 seconds| Input tokens: 314,380 | Output tokens: 5,655]
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ Step 10 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'init_rag_db' with arguments: {'id': 'v8_elements_inventory_v1'}                                                                                                         │
╰────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
Error executing tool 'init_rag_db' with arguments {'id': 'v8_elements_inventory_v1'}: NameError: name 'rag_db_id' is not defined
Please try again or use another tool
[Step 10: Duration 32.07 seconds| Input tokens: 411,181 | Output tokens: 7,477]
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ Step 11 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
╭────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Calling tool: 'init_rag_db' with arguments: {'id': 'v8_elements_inventory_v1'}                                                                                                         │
╰────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
Error executing tool 'init_rag_db' with arguments {'id': 'v8_elements_inventory_v1'}: NameError: name 'rag_db_id' is not defined
Please try again or use another tool
[Step 11: Duration 32.31 seconds| Input tokens: 508,054 | Output tokens: 9,299]
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ Step 12 ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
[Step 12: Duration 17.72 seconds]
[Step 3: Duration 220.73 seconds| Input tokens: 23,421 | Output tokens: 3,811]
[Step 3: Duration 687.16 seconds| Input tokens: 24,143 | Output tokens: 6,593]
Traceback (most recent call last):
  File "/Users/tarun/vrig/fuzzillai/Sources/Agentic_System/rises-the-fog.py", line 101, in <module>
    sys.exit(main())
             ~~~~^^
  File "/Users/tarun/vrig/fuzzillai/Sources/Agentic_System/rises-the-fog.py", line 95, in main
    a.system.start_system()
    ~~~~~~~~~~~~~~~~~~~~~^^
  File "/Users/tarun/vrig/fuzzillai/Sources/Agentic_System/agents/FoG.py", line 270, in start_system
    result = self.run_task(
        task_description="Initialize Root Manager orchestration",
    ...<5 lines>...
        }
    )
  File "/Users/tarun/vrig/fuzzillai/Sources/Agentic_System/agents/BaseAgent.py", line 323, in run_task
    agent_output = manager_agent.run(prompt)
  File "/Users/tarun/vrig/fuzzillai/Sources/Agentic_System/agents/BaseAgent.py", line 292, in _wrapped_run
    result = orig_run(prompt, *args, **kwargs)
  File "/Users/tarun/vrig/fuzzillai/.venv/lib/python3.14/site-packages/smolagents/agents.py", line 503, in run
    steps = list(self._run_stream(task=self.task, max_steps=max_steps, images=images))
  File "/Users/tarun/vrig/fuzzillai/.venv/lib/python3.14/site-packages/smolagents/agents.py", line 582, in _run_stream
    for output in self._step_stream(action_step):
                  ~~~~~~~~~~~~~~~~~^^^^^^^^^^^^^
  File "/Users/tarun/vrig/fuzzillai/.venv/lib/python3.14/site-packages/smolagents/agents.py", line 1322, in _step_stream
    for output in self.process_tool_calls(chat_message, memory_step):
                  ~~~~~~~~~~~~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Users/tarun/vrig/fuzzillai/.venv/lib/python3.14/site-packages/smolagents/agents.py", line 1407, in process_tool_calls
    tool_output = process_single_tool_call(tool_call)
  File "/Users/tarun/vrig/fuzzillai/.venv/lib/python3.14/site-packages/smolagents/agents.py", line 1376, in process_single_tool_call
    tool_call_result = self.execute_tool_call(tool_name, tool_arguments)
  File "/Users/tarun/vrig/fuzzillai/.venv/lib/python3.14/site-packages/smolagents/agents.py", line 1474, in execute_tool_call
    return tool(**arguments) if is_managed_agent else tool(**arguments, sanitize_inputs_outputs=True)
           ~~~~^^^^^^^^^^^^^
  File "/Users/tarun/vrig/fuzzillai/.venv/lib/python3.14/site-packages/smolagents/agents.py", line 877, in __call__
    result = self.run(full_task, **kwargs)
  File "/Users/tarun/vrig/fuzzillai/.venv/lib/python3.14/site-packages/smolagents/agents.py", line 503, in run
    steps = list(self._run_stream(task=self.task, max_steps=max_steps, images=images))
  File "/Users/tarun/vrig/fuzzillai/.venv/lib/python3.14/site-packages/smolagents/agents.py", line 582, in _run_stream
    for output in self._step_stream(action_step):
                  ~~~~~~~~~~~~~~~~~^^^^^^^^^^^^^
  File "/Users/tarun/vrig/fuzzillai/.venv/lib/python3.14/site-packages/smolagents/agents.py", line 1322, in _step_stream
    for output in self.process_tool_calls(chat_message, memory_step):
                  ~~~~~~~~~~~~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Users/tarun/vrig/fuzzillai/.venv/lib/python3.14/site-packages/smolagents/agents.py", line 1407, in process_tool_calls
    tool_output = process_single_tool_call(tool_call)
  File "/Users/tarun/vrig/fuzzillai/.venv/lib/python3.14/site-packages/smolagents/agents.py", line 1376, in process_single_tool_call
    tool_call_result = self.execute_tool_call(tool_name, tool_arguments)
  File "/Users/tarun/vrig/fuzzillai/.venv/lib/python3.14/site-packages/smolagents/agents.py", line 1474, in execute_tool_call
    return tool(**arguments) if is_managed_agent else tool(**arguments, sanitize_inputs_outputs=True)
           ~~~~^^^^^^^^^^^^^
  File "/Users/tarun/vrig/fuzzillai/.venv/lib/python3.14/site-packages/smolagents/agents.py", line 877, in __call__
    result = self.run(full_task, **kwargs)
  File "/Users/tarun/vrig/fuzzillai/.venv/lib/python3.14/site-packages/smolagents/agents.py", line 503, in run
    steps = list(self._run_stream(task=self.task, max_steps=max_steps, images=images))
  File "/Users/tarun/vrig/fuzzillai/.venv/lib/python3.14/site-packages/smolagents/agents.py", line 582, in _run_stream
    for output in self._step_stream(action_step):
                  ~~~~~~~~~~~~~~~~~^^^^^^^^^^^^^
  File "/Users/tarun/vrig/fuzzillai/.venv/lib/python3.14/site-packages/smolagents/agents.py", line 1290, in _step_stream
    chat_message: ChatMessage = self.model.generate(
                                ~~~~~~~~~~~~~~~~~~~^
        input_messages,
        ^^^^^^^^^^^^^^^
        stop_sequences=["Observation:", "Calling tools:"],
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        tools_to_call_from=self.tools_and_managed_agents,
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    )
    ^
  File "/Users/tarun/vrig/fuzzillai/.venv/lib/python3.14/site-packages/smolagents/models.py", line 1243, in generate
    response = self.client.completion(**completion_kwargs)
  File "/Users/tarun/vrig/fuzzillai/Sources/Agentic_System/agents/BaseAgent.py", line 164, in wrapped_completion
    result = original_completion(*args, **kwargs)
  File "/Users/tarun/vrig/fuzzillai/.venv/lib/python3.14/site-packages/litellm/utils.py", line 1244, in wrapper
    result = original_function(*args, **kwargs)
  File "/Users/tarun/vrig/fuzzillai/.venv/lib/python3.14/site-packages/litellm/main.py", line 2125, in completion
    response = openai_chat_completions.completion(
        model=model,
    ...<16 lines>...
        shared_session=shared_session,
    )
  File "/Users/tarun/vrig/fuzzillai/.venv/lib/python3.14/site-packages/litellm/llms/openai/openai.py", line 673, in completion
    ) = self.make_sync_openai_chat_completion_request(
        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^
        openai_client=openai_client,
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    ...<2 lines>...
        logging_obj=logging_obj,
        ^^^^^^^^^^^^^^^^^^^^^^^^
    )
    ^
  File "/Users/tarun/vrig/fuzzillai/.venv/lib/python3.14/site-packages/litellm/litellm_core_utils/logging_utils.py", line 237, in sync_wrapper
    result = func(*args, **kwargs)
  File "/Users/tarun/vrig/fuzzillai/.venv/lib/python3.14/site-packages/litellm/llms/openai/openai.py", line 471, in make_sync_openai_chat_completion_request
    raw_response = openai_client.chat.completions.with_raw_response.create(
        **data, timeout=timeout
    )
  File "/Users/tarun/vrig/fuzzillai/.venv/lib/python3.14/site-packages/openai/_legacy_response.py", line 364, in wrapped
    return cast(LegacyAPIResponse[R], func(*args, **kwargs))
                                      ~~~~^^^^^^^^^^^^^^^^^
  File "/Users/tarun/vrig/fuzzillai/.venv/lib/python3.14/site-packages/openai/_utils/_utils.py", line 286, in wrapper
    return func(*args, **kwargs)
  File "/Users/tarun/vrig/fuzzillai/.venv/lib/python3.14/site-packages/openai/resources/chat/completions/completions.py", line 1156, in create
    return self._post(
           ~~~~~~~~~~^
        "/chat/completions",
        ^^^^^^^^^^^^^^^^^^^^
    ...<46 lines>...
        stream_cls=Stream[ChatCompletionChunk],
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    )
    ^
  File "/Users/tarun/vrig/fuzzillai/.venv/lib/python3.14/site-packages/openai/_base_client.py", line 1259, in post
    return cast(ResponseT, self.request(cast_to, opts, stream=stream, stream_cls=stream_cls))
                           ~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Users/tarun/vrig/fuzzillai/.venv/lib/python3.14/site-packages/openai/_base_client.py", line 982, in request
    response = self._client.send(
        request,
        stream=stream or self._should_stream_response_body(request=request),
        **kwargs,
    )
  File "/Users/tarun/vrig/fuzzillai/.venv/lib/python3.14/site-packages/httpx/_client.py", line 914, in send
    response = self._send_handling_auth(
        request,
    ...<2 lines>...
        history=[],
    )
  File "/Users/tarun/vrig/fuzzillai/.venv/lib/python3.14/site-packages/httpx/_client.py", line 942, in _send_handling_auth
    response = self._send_handling_redirects(
        request,
        follow_redirects=follow_redirects,
        history=history,
    )
  File "/Users/tarun/vrig/fuzzillai/.venv/lib/python3.14/site-packages/httpx/_client.py", line 979, in _send_handling_redirects
    response = self._send_single_request(request)
  File "/Users/tarun/vrig/fuzzillai/.venv/lib/python3.14/site-packages/httpx/_client.py", line 1014, in _send_single_request
    response = transport.handle_request(request)
  File "/Users/tarun/vrig/fuzzillai/.venv/lib/python3.14/site-packages/httpx/_transports/default.py", line 250, in handle_request
    resp = self._pool.handle_request(req)
  File "/Users/tarun/vrig/fuzzillai/.venv/lib/python3.14/site-packages/httpcore/_sync/connection_pool.py", line 256, in handle_request
    raise exc from None
  File "/Users/tarun/vrig/fuzzillai/.venv/lib/python3.14/site-packages/httpcore/_sync/connection_pool.py", line 236, in handle_request
    response = connection.handle_request(
        pool_request.request
    )
  File "/Users/tarun/vrig/fuzzillai/.venv/lib/python3.14/site-packages/httpcore/_sync/connection.py", line 103, in handle_request
    return self._connection.handle_request(request)
           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^^^^^^^^^
  File "/Users/tarun/vrig/fuzzillai/.venv/lib/python3.14/site-packages/httpcore/_sync/http11.py", line 136, in handle_request
    raise exc
  File "/Users/tarun/vrig/fuzzillai/.venv/lib/python3.14/site-packages/httpcore/_sync/http11.py", line 106, in handle_request
    ) = self._receive_response_headers(**kwargs)
        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^^^^^^^^^^
  File "/Users/tarun/vrig/fuzzillai/.venv/lib/python3.14/site-packages/httpcore/_sync/http11.py", line 177, in _receive_response_headers
    event = self._receive_event(timeout=timeout)
  File "/Users/tarun/vrig/fuzzillai/.venv/lib/python3.14/site-packages/httpcore/_sync/http11.py", line 217, in _receive_event
    data = self._network_stream.read(
        self.READ_NUM_BYTES, timeout=timeout
    )
  File "/Users/tarun/vrig/fuzzillai/.venv/lib/python3.14/site-packages/httpcore/_backends/sync.py", line 128, in read
    return self._sock.recv(max_bytes)
           ~~~~~~~~~~~~~~~^^^^^^^^^^^
  File "/opt/homebrew/Cellar/python@3.14/3.14.0/Frameworks/Python.framework/Versions/3.14/lib/python3.14/ssl.py", line 1285, in recv
    return self.read(buflen)
           ~~~~~~~~~^^^^^^^^
  File "/opt/homebrew/Cellar/python@3.14/3.14.0/Frameworks/Python.framework/Versions/3.14/lib/python3.14/ssl.py", line 1140, in read
    return self._sslobj.read(len)
           ~~~~~~~~~~~~~~~~~^^^^^
KeyboardInterrupt
