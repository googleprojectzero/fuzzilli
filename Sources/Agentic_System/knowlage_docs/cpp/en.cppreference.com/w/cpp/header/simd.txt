Standard library header <simd> (C++26) - cppreference.com cppreference.com Create account Log in Namespaces Page Discussion Variants Views View Edit History Actions Standard library header <simd> (C++26) From cppreference.com < cpp ‎ | header C++ Compiler support Freestanding and hosted Language Standard library Standard library headers Named requirements Feature test macros (C++20) Language support library Concepts library (C++20) Diagnostics library Memory management library Metaprogramming library (C++11) General utilities library Containers library Iterators library Ranges library (C++20) Algorithms library Strings library Text processing library Numerics library Date and time library Input/output library Filesystem library (C++17) Concurrency support library (C++11) Execution control library (C++26) Technical specifications Symbols index External libraries [edit] Standard library headers Language support <cfloat> <climits> <compare> (C++20) <contracts> (C++26) <coroutine> (C++20) <csetjmp> <csignal> <cstdarg> <cstddef> <cstdint> (C++11) <cstdlib> <exception> <initializer_list> (C++11) <limits> <new> <source_location> (C++20) <stdfloat> (C++23) <typeinfo> <version> (C++20) Concepts <concepts> (C++20) Diagnostics <cassert> <cerrno> <debugging> (C++26) <stacktrace> (C++23) <stdexcept> <system_error> (C++11) Memory management <memory> <memory_resource> (C++17) <scoped_allocator> (C++11) Metaprogramming <type_traits> (C++11) <ratio> (C++11) General utilities <any> (C++17) <bitset> <bit> (C++20) <charconv> (C++17) <expected> (C++23) <format> (C++20) <functional> <optional> (C++17) <stdbit.h> (C++26) <tuple> (C++11) <typeindex> (C++11) <utility> <variant> (C++17) Containers <array> (C++11) <deque> <flat_map> (C++23) <flat_set> (C++23) <forward_list> (C++11) <hive> (C++26) <inplace_vector> (C++26) <list> <map> <mdspan> (C++23) <queue> <set> <span> (C++20) <stack> <unordered_map> (C++11) <unordered_set> (C++11) <vector> Iterators <iterator> Ranges <generator> (C++23) <ranges> (C++20) Algorithms <algorithm> <numeric> Strings <cctype> <cstring> <cuchar> (C++11) <cwchar> <cwctype> <string_view> (C++17) <string> Text processing <clocale> <codecvt> ( C++11/17/26* ) <locale> <regex> (C++11) <text_encoding> (C++26) Numerics <cfenv> (C++11) <cmath> <complex> <linalg> (C++26) <numbers> (C++20) <random> (C++11) <simd> (C++26) <stdckdint.h> (C++26) <valarray> Time <chrono> (C++11) <ctime> C compatibility <ccomplex> ( C++11/17/20* ) <ciso646> (until C++20) <cstdalign> ( C++11/17/20* ) <cstdbool> ( C++11/17/20* ) <ctgmath> ( C++11/17/20* ) Input/output <cinttypes> (C++11) <cstdio> <filesystem> (C++17) <fstream> <iomanip> <iosfwd> <iostream> <ios> <istream> <ostream> <print> (C++23) <spanstream> (C++23) <sstream> <streambuf> <strstream> ( C++98/26* ) <syncstream> (C++20) Concurrency support <atomic> (C++11) <barrier> (C++20) <condition_variable> (C++11) <future> (C++11) <hazard_pointer> (C++26) <latch> (C++20) <mutex> (C++11) <rcu> (C++26) <semaphore> (C++20) <shared_mutex> (C++14) <stdatomic.h> (C++23) <stop_token> (C++20) <thread> (C++11) Execution support <execution> (C++17) [edit] This header is part of the numeric library. Contents 1 Classes 2 Functions 3 Constants 4 Synopsis 4.1 Class template std::datapar::flags 4.2 Class template std::datapar::basic_simd 4.3 Class template std::datapar::basic_simd_mask Classes datapar::basic_simd (C++26) data-parallel vector type (class template) [edit] datapar::simd (C++26) convenience alias template for basic_simd that can specify its width (alias template) [edit] datapar::basic_simd_mask (C++26) data-parallel type with the element type bool (class template) [edit] datapar::simd_mask (C++26) convenience alias template for basic_simd_mask that can specify its width (alias template) [edit] datapar::flags (C++26) load and store flags for data-parallel types (class template) [edit] datapar::alignment (C++26) obtains an appropriate alignment for datapar::flag_aligned (class template) [edit] datapar::rebind (C++26) changes element type of the data-parallel type (class template) [edit] datapar::resize (C++26) changes the width of the data-parallel type (class template) [edit] Functions datapar::unchecked_load datapar::partial_load (C++26) loads elements from a contiguous range to basic_simd (function template) [edit] datapar::unchecked_store datapar::partial_store (C++26) stores elements from basic_simd to a contiguous range (function template) [edit] datapar::chunk (C++26) splits single data-parallel object to multiple ones (function template) [edit] datapar::cat (C++26) concatenates multiple data-parallel objects into a single one (function template) [edit] datapar::all_of datapar::any_of datapar::none_of (C++26) reductions of basic_simd_mask to bool (function template) [edit] datapar::reduce_count (C++26) reduction of basic_simd_mask to number of true values (function template) [edit] datapar::reduce_min_index datapar::reduce_max_index (C++26) reductions of basic_simd_mask to the index of first or last true value (function template) [edit] datapar::reduce datapar::reduce_min datapar::reduce_max (C++26) reduces all values in basic_simd over a specified binary operation to a single value (function template) [edit] datapar::min datapar::max datapar::minmax (C++26) element-wise min/max operations for basic_simd (function template) [edit] datapar::clamp (C++26) element-wise clamp operation for basic_simd (function template) [edit] datapar::select (C++26) element-wise selection using conditional operator (function template) [edit] Constants datapar::flag_default (C++26) default flag used on load and store operations (constant) [edit] datapar::flag_convert (C++26) flag enabling conversions that are not value-preserving on load and store operations (constant) [edit] datapar::flag_aligned (C++26) flag indicating alignment of the load-store address to some specified storage to the value of datapar::alignment (constant) [edit] datapar::flag_overaligned (C++26) flag indicating alignment of the load-store address to some specified storage to the specified alignment (variable template) [edit] [ edit ] Synopsis namespace std :: datapar { // simd type Traits template < class T, class U = typename T :: value_type > struct alignment ; template < class T, class U = typename T :: value_type > constexpr size_t alignment_v = alignment < T, U > :: value ; template < class T, class V > struct rebind { using type = /* see description */ ; } ; template < class T, class V > using rebind_t = typename rebind < T, V > :: type ; template < /*simd-size-type*/ N, class V > struct resize { using type = /* see description */ ; } ; template < /*simd-size-type*/ N, class V > using resize_t = typename resize < N, V > :: type ; // Load and store flags template < class ... Flags > struct flags ; inline constexpr flags <> flag_default { } ; inline constexpr flags < /*convert-flag*/ > flag_convert { } ; inline constexpr flags < /*aligned-flag*/ > flag_aligned { } ; template < size_t N > requires ( has_single_bit ( N ) ) constexpr flags < /*overaligned-flag*/ < N >> flag_overaligned { } ; // Class template basic_simd template < class T, class Abi = /*native-abi*/ < T >> class basic_simd ; template < class T, /*simd-size-type*/ N = /*simd-size-v*/ < T, /*native-abi*/ < T >>> using simd = basic_simd < T, /*deduce-abi-t*/ < T, N >> ; // Class template basic_simd_mask template < size_t Bytes, class Abi = /*native-abi*/ < /*integer-from*/ < Bytes >>> class basic_simd_mask ; template < class T, /*simd-size-type*/ N = /*simd-size-v*/ < T, /*native-abi*/ < T >>> using simd_mask = basic_simd_mask < sizeof ( T ) , /*deduce-abi-t*/ < T, N >> ; // basic_simd load and store functions template < class V = /* see description */ , ranges:: contiguous_range R, class ... Flags > requires ranges:: sized_range < R > constexpr V unchecked_load ( R && r, flags < Flags... > f = { } ) ; template < class V = /* see description */ , ranges:: contiguous_range R, class ... Flags > requires ranges:: sized_range < R > constexpr V unchecked_load ( R && r, const typename V :: mask_type & k, flags < Flags... > f = { } ) ; template < class V = /* see description */ , contiguous_iterator I, class ... Flags > constexpr V unchecked_load ( I first, iter_difference_t < I > n, flags < Flags... > f = { } ) ; template < class V = /* see description */ , contiguous_iterator I, class ... Flags > constexpr V unchecked_load ( I first, iter_difference_t < I > n, const typename V :: mask_type & k, flags < Flags... > f = { } ) ; template < class V = /* see description */ , contiguous_iterator I, sized_sentinel_for < I > S, class ... Flags > constexpr V unchecked_load ( I first, S last, flags < Flags... > f = { } ) ; template < class V = /* see description */ , contiguous_iterator I, sized_sentinel_for < I > S, class ... Flags > constexpr V unchecked_load ( I first, S last, const typename V :: mask_type & k, flags < Flags... > f = { } ) ; template < class V = /* see description */ , ranges:: contiguous_range R, class ... Flags > requires ranges:: sized_range < R > constexpr V partial_load ( R && r, flags < Flags... > f = { } ) ; template < class V = /* see description */ , ranges:: contiguous_range R, class ... Flags > requires ranges:: sized_range < R > constexpr V partial_load ( R && r, const typename V :: mask_type & k, flags < Flags... > f = { } ) ; template < class V = /* see description */ , contiguous_iterator I, class ... Flags > constexpr V partial_load ( I first, iter_difference_t < I > n, flags < Flags... > f = { } ) ; template < class V = /* see description */ , contiguous_iterator I, class ... Flags > constexpr V partial_load ( I first, iter_difference_t < I > n, const typename V :: mask_type & k, flags < Flags... > f = { } ) ; template < class V = /* see description */ , contiguous_iterator I, sized_sentinel_for < I > S, class ... Flags > constexpr V partial_load ( I first, S last, flags < Flags... > f = { } ) ; template < class V = /* see description */ , contiguous_iterator I, sized_sentinel_for < I > S, class ... Flags > constexpr V partial_load ( I first, S last, const typename V :: mask_type & k, flags < Flags... > f = { } ) ; template < class T, class Abi, ranges:: contiguous_range R, class ... Flags > requires ranges:: sized_range < R > && indirectly_writable < ranges:: iterator_t < R > , T > constexpr void unchecked_store ( const basic_simd < T, Abi > & v, R && r, flags < Flags... > f = { } ) ; template < class T, class Abi, ranges:: contiguous_range R, class ... Flags > requires ranges:: sized_range < R > && indirectly_writable < ranges:: iterator_t < R > , T > constexpr void unchecked_store ( const basic_simd < T, Abi > & v, R && r, const typename basic_simd < T, Abi > :: mask_type & mask, flags < Flags... > f = { } ) ; template < class T, class Abi, contiguous_iterator I, class ... Flags > requires indirectly_writable < I, T > constexpr void unchecked_store ( const basic_simd < T, Abi > & v, I first, iter_difference_t < I > n, flags < Flags... > f = { } ) ; template < class T, class Abi, contiguous_iterator I, class ... Flags > requires indirectly_writable < I, T > constexpr void unchecked_store ( const basic_simd < T, Abi > & v, I first, iter_difference_t < I > n, const typename basic_simd < T, Abi > :: mask_type & mask, flags < Flags... > f = { } ) ; template < class T, class Abi, contiguous_iterator I, sized_sentinel_for < I > S, class ... Flags > requires indirectly_writable < I, T > constexpr void unchecked_store ( const basic_simd < T, Abi > & v, I first, S last, flags < Flags... > f = { } ) ; template < class T, class Abi, contiguous_iterator I, sized_sentinel_for < I > S, class ... Flags > requires indirectly_writable < I, T > constexpr void unchecked_store ( const basic_simd < T, Abi > & v, I first, S last, const typename basic_simd < T, Abi > :: mask_type & mask, flags < Flags... > f = { } ) ; template < class T, class Abi, ranges:: contiguous_range R, class ... Flags > requires ranges:: sized_range < R > && indirectly_writable < ranges:: iterator_t < R > , T > constexpr void partial_store ( const basic_simd < T, Abi > & v, R && r, flags < Flags... > f = { } ) ; template < class T, class Abi, ranges:: contiguous_range R, class ... Flags > requires ranges:: sized_range < R > && indirectly_writable < ranges:: iterator_t < R > , T > constexpr void partial_store ( const basic_simd < T, Abi > & v, R && r, const typename basic_simd < T, Abi > :: mask_type & mask, flags < Flags... > f = { } ) ; template < class T, class Abi, contiguous_iterator I, class ... Flags > requires indirectly_writable < I, T > constexpr void partial_store ( const basic_simd < T, Abi > & v, I first, iter_difference_t < I > n, flags < Flags... > f = { } ) ; template < class T, class Abi, contiguous_iterator I, class ... Flags > requires indirectly_writable < I, T > constexpr void partial_store ( const basic_simd < T, Abi > & v, I first, iter_difference_t < I > n, const typename basic_simd < T, Abi > :: mask_type & mask, flags < Flags... > f = { } ) ; template < class T, class Abi, contiguous_iterator I, sized_sentinel_for < I > S, class ... Flags > requires indirectly_writable < I, T > constexpr void partial_store ( const basic_simd < T, Abi > & v, I first, S last, flags < Flags... > f = { } ) ; template < class T, class Abi, contiguous_iterator I, sized_sentinel_for < I > S, class ... Flags > requires indirectly_writable < I, T > constexpr void partial_store ( const basic_simd < T, Abi > & v, I first, S last, const typename basic_simd < T, Abi > :: mask_type & mask, flags < Flags... > f = { } ) ; // basic_simd and basic_simd_mask creation template < class T, class Abi > constexpr auto chunk ( const basic_simd < typename T :: value_type , Abi > & x ) noexcept ; template < class T, class Abi > constexpr auto chunk ( const basic_simd_mask < /*mask-element-size*/ < T > , Abi > & x ) noexcept ; template < size_t N, class T, class Abi > constexpr auto chunk ( const basic_simd < T, Abi > & x ) noexcept ; template < size_t N, size_t Bytes, class Abi > constexpr auto chunk ( const basic_simd_mask < Bytes, Abi > & x ) noexcept ; template < class T, class ... Abis > constexpr basic_simd < T, /*deduce-abi-t*/ < T, ( basic_simd < T, Abis > :: size ( ) + ... ) >> cat ( const basic_simd < T, Abis > & ... ) noexcept ; template < size_t Bytes, class ... Abis > constexpr basic_simd_mask < Bytes, /*deduce-abi-t*/ < /*integer-from*/ < Bytes > , ( basic_simd_mask < Bytes, Abis > :: size ( ) + ... ) >> cat ( const basic_simd_mask < Bytes, Abis > & ... ) noexcept ; // basic_simd_mask reductions template < size_t Bytes, class Abi > constexpr bool all_of ( const basic_simd_mask < Bytes, Abi > & ) noexcept ; template < size_t Bytes, class Abi > constexpr bool any_of ( const basic_simd_mask < Bytes, Abi > & ) noexcept ; template < size_t Bytes, class Abi > constexpr bool none_of ( const basic_simd_mask < Bytes, Abi > & ) noexcept ; template < size_t Bytes, class Abi > constexpr /*simd-size-type*/ reduce_count ( const basic_simd_mask < Bytes, Abi > & ) noexcept ; template < size_t Bytes, class Abi > constexpr /*simd-size-type*/ reduce_min_index ( const basic_simd_mask < Bytes, Abi > & ) ; template < size_t Bytes, class Abi > constexpr /*simd-size-type*/ reduce_max_index ( const basic_simd_mask < Bytes, Abi > & ) ; constexpr bool all_of ( same_as < bool > auto ) noexcept ; constexpr bool any_of ( same_as < bool > auto ) noexcept ; constexpr bool none_of ( same_as < bool > auto ) noexcept ; constexpr /*simd-size-type*/ reduce_count ( same_as < bool > auto ) noexcept ; constexpr /*simd-size-type*/ reduce_min_index ( same_as < bool > auto ) ; constexpr /*simd-size-type*/ reduce_max_index ( same_as < bool > auto ) ; // basic_simd reductions template < class T, class Abi, class BinaryOperation = plus <>> constexpr T reduce ( const basic_simd < T, Abi > & , BinaryOperation = { } ) ; template < class T, class Abi, class BinaryOperation = plus <>> constexpr T reduce ( const basic_simd < T, Abi > & x, const typename basic_simd < T, Abi > :: mask_type & mask, BinaryOperation binary_op = { } , type_identity_t < T > identity_element = /* see description */ ) ; template < class T, class Abi > constexpr T reduce_min ( const basic_simd < T, Abi > & ) noexcept ; template < class T, class Abi > constexpr T reduce_min ( const basic_simd < T, Abi > & , const typename basic_simd < T, Abi > :: mask_type & ) noexcept ; template < class T, class Abi > constexpr T reduce_max ( const basic_simd < T, Abi > & ) noexcept ; template < class T, class Abi > constexpr T reduce_max ( const basic_simd < T, Abi > & , const typename basic_simd < T, Abi > :: mask_type & ) noexcept ; // Algorithms template < class T, class Abi > constexpr basic_simd < T, Abi > min ( const basic_simd < T, Abi > & a, const basic_simd < T, Abi > & b ) noexcept ; template < class T, class Abi > constexpr basic_simd < T, Abi > max ( const basic_simd < T, Abi > & a, const basic_simd < T, Abi > & b ) noexcept ; template < class T, class Abi > constexpr pair < basic_simd < T, Abi > , basic_simd < T, Abi >> minmax ( const basic_simd < T, Abi > & a, const basic_simd < T, Abi > & b ) noexcept ; template < class T, class Abi > constexpr basic_simd < T, Abi > clamp ( const basic_simd < T, Abi > & v, const basic_simd < T, Abi > & lo, const basic_simd < T, Abi > & hi ) ; template < class T, class U > constexpr auto select ( bool c, const T & a, const U & b ) - > remove_cvref_t < decltype ( c ? a : b ) > ; template < size_t Bytes, class Abi, class T, class U > constexpr auto select ( const basic_simd_mask < Bytes, Abi > & c, const T & a, const U & b ) noexcept - > decltype ( /*simd-select-impl*/ ( c, a, b ) ) ; // Mathematical functions template < /*math-floating-point*/ V > constexpr /*deduced-simd-t*/ < V > acos ( const V & x ) ; template < /*math-floating-point*/ V > constexpr /*deduced-simd-t*/ < V > asin ( const V & x ) ; template < /*math-floating-point*/ V > constexpr /*deduced-simd-t*/ < V > atan ( const V & x ) ; template < class V0, class V1 > constexpr /*math-common-simd-t*/ < V0, V1 > atan2 ( const V0 & y, const V1 & x ) ; template < /*math-floating-point*/ V > constexpr /*deduced-simd-t*/ < V > cos ( const V & x ) ; template < /*math-floating-point*/ V > constexpr /*deduced-simd-t*/ < V > sin ( const V & x ) ; template < /*math-floating-point*/ V > constexpr /*deduced-simd-t*/ < V > tan ( const V & x ) ; template < /*math-floating-point*/ V > constexpr /*deduced-simd-t*/ < V > acosh ( const V & x ) ; template < /*math-floating-point*/ V > constexpr /*deduced-simd-t*/ < V > asinh ( const V & x ) ; template < /*math-floating-point*/ V > constexpr /*deduced-simd-t*/ < V > atanh ( const V & x ) ; template < /*math-floating-point*/ V > constexpr /*deduced-simd-t*/ < V > cosh ( const V & x ) ; template < /*math-floating-point*/ V > constexpr /*deduced-simd-t*/ < V > sinh ( const V & x ) ; template < /*math-floating-point*/ V > constexpr /*deduced-simd-t*/ < V > tanh ( const V & x ) ; template < /*math-floating-point*/ V > constexpr /*deduced-simd-t*/ < V > exp ( const V & x ) ; template < /*math-floating-point*/ V > constexpr /*deduced-simd-t*/ < V > exp2 ( const V & x ) ; template < /*math-floating-point*/ V > constexpr /*deduced-simd-t*/ < V > expm1 ( const V & x ) ; template < /*math-floating-point*/ V > constexpr /*deduced-simd-t*/ < V > frexp ( const V & value, rebind_t < int , /*deduced-simd-t*/ < V >> * exp ) ; template < /*math-floating-point*/ V > constexpr rebind_t < int , /*deduced-simd-t*/ < V >> ilogb ( const V & x ) ; template < /*math-floating-point*/ V > constexpr /*deduced-simd-t*/ < V > ldexp ( const V & x, const rebind_t < int , /*deduced-simd-t*/ < V >> & exp ) ; template < /*math-floating-point*/ V > constexpr /*deduced-simd-t*/ < V > log ( const V & x ) ; template < /*math-floating-point*/ V > constexpr /*deduced-simd-t*/ < V > log10 ( const V & x ) ; template < /*math-floating-point*/ V > constexpr /*deduced-simd-t*/ < V > log1p ( const V & x ) ; template < /*math-floating-point*/ V > constexpr /*deduced-simd-t*/ < V > log2 ( const V & x ) ; template < /*math-floating-point*/ V > constexpr /*deduced-simd-t*/ < V > logb ( const V & x ) ; template < class T, class Abi > constexpr basic_simd < T, Abi > modf ( const type_identity_t < basic_simd < T, Abi >> & value, basic_simd < T, Abi > * iptr ) ; template < /*math-floating-point*/ V > constexpr /*deduced-simd-t*/ < V > scalbn ( const V & x, const rebind_t < int , /*deduced-simd-t*/ < V >> & n ) ; template < /*math-floating-point*/ V > constexpr /*deduced-simd-t*/ < V > scalbln ( const V & x, const rebind_t < long int , /*deduced-simd-t*/ < V >> & n ) ; template < /*math-floating-point*/ V > constexpr /*deduced-simd-t*/ < V > cbrt ( const V & x ) ; template < signed_integral T, class Abi > constexpr basic_simd < T, Abi > abs ( const basic_simd < T, Abi > & j ) ; template < /*math-floating-point*/ V > constexpr /*deduced-simd-t*/ < V > abs ( const V & j ) ; template < /*math-floating-point*/ V > constexpr /*deduced-simd-t*/ < V > fabs ( const V & x ) ; template < class V0, class V1 > constexpr /*math-common-simd-t*/ < V0, V1 > hypot ( const V0 & x, const V1 & y ) ; template < class V0, class V1, class V2 > constexpr /*math-common-simd-t*/ < V0, V1, V2 > hypot ( const V0 & x, const V1 & y, const V2 & z ) ; template < class V0, class V1 > constexpr /*math-common-simd-t*/ < V0, V1 > pow ( const V0 & x, const V1 & y ) ; template < /*math-floating-point*/ V > constexpr /*deduced-simd-t*/ < V > sqrt ( const V & x ) ; template < /*math-floating-point*/ V > constexpr /*deduced-simd-t*/ < V > erf ( const V & x ) ; template < /*math-floating-point*/ V > constexpr /*deduced-simd-t*/ < V > erfc ( const V & x ) ; template < /*math-floating-point*/ V > constexpr /*deduced-simd-t*/ < V > lgamma ( const V & x ) ; template < /*math-floating-point*/ V > constexpr /*deduced-simd-t*/ < V > tgamma ( const V & x ) ; template < /*math-floating-point*/ V > constexpr /*deduced-simd-t*/ < V > ceil ( const V & x ) ; template < /*math-floating-point*/ V > constexpr /*deduced-simd-t*/ < V > floor ( const V & x ) ; template < /*math-floating-point*/ V > /*deduced-simd-t*/ < V > nearbyint ( const V & x ) ; template < /*math-floating-point*/ V > /*deduced-simd-t*/ < V > rint ( const V & x ) ; template < /*math-floating-point*/ V > rebind_t < long int , /*deduced-simd-t*/ < V >> lrint ( const V & x ) ; template < /*math-floating-point*/ V > rebind_t < long long int , V > llrint ( const /*deduced-simd-t*/ < V > & x ) ; template < /*math-floating-point*/ V > constexpr /*deduced-simd-t*/ < V > round ( const V & x ) ; template < /*math-floating-point*/ V > constexpr rebind_t < long int , /*deduced-simd-t*/ < V >> lround ( const V & x ) ; template < /*math-floating-point*/ V > constexpr rebind_t < long long int , /*deduced-simd-t*/ < V >> llround ( const V & x ) ; template < /*math-floating-point*/ V > constexpr /*deduced-simd-t*/ < V > trunc ( const V & x ) ; template < class V0, class V1 > constexpr /*math-common-simd-t*/ < V0, V1 > fmod ( const V0 & x, const V1 & y ) ; template < class V0, class V1 > constexpr /*math-common-simd-t*/ < V0, V1 > remainder ( const V0 & x, const V1 & y ) ; template < class V0, class V1 > constexpr /*math-common-simd-t*/ < V0, V1 > remquo ( const V0 & x, const V1 & y, rebind_t < int , /*math-common-simd-t*/ < V0, V1 >> * quo ) ; template < class V0, class V1 > constexpr /*math-common-simd-t*/ < V0, V1 > copysign ( const V0 & x, const V1 & y ) ; template < class V0, class V1 > constexpr /*math-common-simd-t*/ < V0, V1 > nextafter ( const V0 & x, const V1 & y ) ; template < class V0, class V1 > constexpr /*math-common-simd-t*/ < V0, V1 > fdim ( const V0 & x, const V1 & y ) ; template < class V0, class V1 > constexpr /*math-common-simd-t*/ < V0, V1 > fmax ( const V0 & x, const V1 & y ) ; template < class V0, class V1 > constexpr /*math-common-simd-t*/ < V0, V1 > fmin ( const V0 & x, const V1 & y ) ; template < class V0, class V1, class V2 > constexpr /*math-common-simd-t*/ < V0, V1, V2 > fma ( const V0 & x, const V1 & y, const V2 & z ) ; template < class V0, class V1, class V2 > constexpr /*math-common-simd-t*/ < V0, V1, V2 > lerp ( const V0 & a, const V1 & b, const V2 & t ) noexcept ; template < /*math-floating-point*/ V > constexpr rebind_t < int , /*deduced-simd-t*/ < V >> fpclassify ( const V & x ) ; template < /*math-floating-point*/ V > constexpr typename /*deduced-simd-t*/ < V > :: mask_type isfinite ( const V & x ) ; template < /*math-floating-point*/ V > constexpr typename /*deduced-simd-t*/ < V > :: mask_type isinf ( const V & x ) ; template < /*math-floating-point*/ V > constexpr typename /*deduced-simd-t*/ < V > :: mask_type isnan ( const V & x ) ; template < /*math-floating-point*/ V > constexpr typename /*deduced-simd-t*/ < V > :: mask_type isnormal ( const V & x ) ; template < /*math-floating-point*/ V > constexpr typename /*deduced-simd-t*/ < V > :: mask_type signbit ( const V & x ) ; template < class V0, class V1 > constexpr typename /*math-common-simd-t*/ < V0, V1 > :: mask_type isgreater ( const V0 & x, const V1 & y ) ; template < class V0, class V1 > constexpr typename /*math-common-simd-t*/ < V0, V1 > :: mask_type isgreaterequal ( const V0 & x, const V1 & y ) ; template < class V0, class V1 > constexpr typename /*math-common-simd-t*/ < V0, V1 > :: mask_type isless ( const V0 & x, const V1 & y ) ; template < class V0, class V1 > constexpr typename /*math-common-simd-t*/ < V0, V1 > :: mask_type islessequal ( const V0 & x, const V1 & y ) ; template < class V0, class V1 > constexpr typename /*math-common-simd-t*/ < V0, V1 > :: mask_type islessgreater ( const V0 & x, const V1 & y ) ; template < class V0, class V1 > constexpr typename /*math-common-simd-t*/ < V0, V1 > :: mask_type isunordered ( const V0 & x, const V1 & y ) ; template < /*math-floating-point*/ V > /*deduced-simd-t*/ < V > assoc_laguerre ( const rebind_t < unsigned , /*deduced-simd-t*/ < V >> & n, const rebind_t < unsigned , /*deduced-simd-t*/ < V >> & m, const V & x ) ; template < /*math-floating-point*/ V > /*deduced-simd-t*/ < V > assoc_legendre ( const rebind_t < unsigned , /*deduced-simd-t*/ < V >> & l, const rebind_t < unsigned , /*deduced-simd-t*/ < V >> & m, const V & x ) ; template < class V0, class V1 > /*math-common-simd-t*/ < V0, V1 > beta ( const V0 & x, const V1 & y ) ; template < /*math-floating-point*/ V > /*deduced-simd-t*/ < V > comp_ellint_1 ( const V & k ) ; template < /*math-floating-point*/ V > /*deduced-simd-t*/ < V > comp_ellint_2 ( const V & k ) ; template < class V0, class V1 > /*math-common-simd-t*/ < V0, V1 > comp_ellint_3 ( const V0 & k, const V1 & nu ) ; template < class V0, class V1 > /*math-common-simd-t*/ < V0, V1 > cyl_bessel_i ( const V0 & nu, const V1 & x ) ; template < class V0, class V1 > /*math-common-simd-t*/ < V0, V1 > cyl_bessel_j ( const V0 & nu, const V1 & x ) ; template < class V0, class V1 > /*math-common-simd-t*/ < V0, V1 > cyl_bessel_k ( const V0 & nu, const V1 & x ) ; template < class V0, class V1 > /*math-common-simd-t*/ < V0, V1 > cyl_neumann ( const V0 & nu, const V1 & x ) ; template < class V0, class V1 > /*math-common-simd-t*/ < V0, V1 > ellint_1 ( const V0 & k, const V1 & phi ) ; template < class V0, class V1 > /*math-common-simd-t*/ < V0, V1 > ellint_2 ( const V0 & k, const V1 & phi ) ; template < class V0, class V1, class V2 > /*math-common-simd-t*/ < V0, V1, V2 > ellint_3 ( const V0 & k, const V1 & nu, const V2 & phi ) ; template < /*math-floating-point*/ V > /*deduced-simd-t*/ < V > expint ( const V & x ) ; template < /*math-floating-point*/ V > /*deduced-simd-t*/ < V > hermite ( const rebind_t < unsigned , /*deduced-simd-t*/ < V >> & n, const V & x ) ; template < /*math-floating-point*/ V > /*deduced-simd-t*/ < V > laguerre ( const rebind_t < unsigned , /*deduced-simd-t*/ < V >> & n, const V & x ) ; template < /*math-floating-point*/ V > /*deduced-simd-t*/ < V > legendre ( const rebind_t < unsigned , /*deduced-simd-t*/ < V >> & l, const V & x ) ; template < /*math-floating-point*/ V > /*deduced-simd-t*/ < V > riemann_zeta ( const V & x ) ; template < /*math-floating-point*/ V > /*deduced-simd-t*/ < V > sph_bessel ( const rebind_t < unsigned , /*deduced-simd-t*/ < V >> & n, const V & x ) ; template < /*math-floating-point*/ V > /*deduced-simd-t*/ < V > sph_legendre ( const rebind_t < unsigned , /*deduced-simd-t*/ < V >> & l, const rebind_t < unsigned , /*deduced-simd-t*/ < V >> & m, const V & theta ) ; template < /*math-floating-point*/ V > /*deduced-simd-t*/ < V > sph_neumann ( const rebind_t < unsigned , /*deduced-simd-t*/ < V >> & n, const V & x ) ; // Bit manipulation template < /*simd-type*/ V > constexpr V byteswap ( const V & v ) noexcept ; template < /*simd-type*/ V > constexpr V bit_ceil ( const V & v ) noexcept ; template < /*simd-type*/ V > constexpr V bit_floor ( const V & v ) noexcept ; template < /*simd-type*/ V > constexpr typename V :: mask_type has_single_bit ( const V & v ) noexcept ; template < /*simd-type*/ V0, /*simd-type*/ V1 > constexpr V0 rotl ( const V0 & v, const V1 & s ) noexcept ; template < /*simd-type*/ V > constexpr V rotl ( const V & v, int s ) noexcept ; template < /*simd-type*/ V0, /*simd-type*/ V1 > constexpr V0 rotr ( const V0 & v, const V1 & s ) noexcept ; template < /*simd-type*/ V > constexpr V rotr ( const V & v, int s ) noexcept ; template < /*simd-type*/ V > constexpr rebind_t < make_signed_t < typename V :: value_type > , V > bit_width ( const V & v ) noexcept ; template < /*simd-type*/ V > constexpr rebind_t < make_signed_t < typename V :: value_type > , V > countl_zero ( const V & v ) noexcept ; template < /*simd-type*/ V > constexpr rebind_t < make_signed_t < typename V :: value_type > , V > countl_one ( const V & v ) noexcept ; template < /*simd-type*/ V > constexpr rebind_t < make_signed_t < typename V :: value_type > , V > countr_zero ( const V & v ) noexcept ; template < /*simd-type*/ V > constexpr rebind_t < make_signed_t < typename V :: value_type > , V > countr_one ( const V & v ) noexcept ; template < /*simd-type*/ V > constexpr rebind_t < make_signed_t < typename V :: value_type > , V > popcount ( const V & v ) noexcept ; // simd complex math template < /*simd-complex*/ V > constexpr < /*simd-complex-value-type*/ < V > , V > real ( const V & ) noexcept ; template < /*simd-complex*/ V > constexpr < /*simd-complex-value-type*/ < V > , V > imag ( const V & ) noexcept ; template < /*simd-complex*/ V > constexpr < /*simd-complex-value-type*/ < V > , V > abs ( const V & ) ; template < /*simd-complex*/ V > constexpr < /*simd-complex-value-type*/ < V > , V > arg ( const V & ) ; template < /*simd-complex*/ V > constexpr < /*simd-complex-value-type*/ < V > , V > norm ( const V & ) ; template < /*simd-complex*/ V > constexpr V conj ( const V & ) ; template < /*simd-complex*/ V > constexpr V proj ( const V & ) ; template < /*simd-complex*/ V > constexpr V exp ( const V & v ) ; template < /*simd-complex*/ V > constexpr V log ( const V & v ) ; template < /*simd-complex*/ V > constexpr V log10 ( const V & v ) ; template < /*simd-complex*/ V > constexpr V sqrt ( const V & v ) ; template < /*simd-complex*/ V > constexpr V sin ( const V & v ) ; template < /*simd-complex*/ V > constexpr V asin ( const V & v ) ; template < /*simd-complex*/ V > constexpr V cos ( const V & v ) ; template < /*simd-complex*/ V > constexpr V acos ( const V & v ) ; template < /*simd-complex*/ V > constexpr V tan ( const V & v ) ; template < /*simd-complex*/ V > constexpr V atan ( const V & v ) ; template < /*simd-complex*/ V > constexpr V sinh ( const V & v ) ; template < /*simd-complex*/ V > constexpr V asinh ( const V & v ) ; template < /*simd-complex*/ V > constexpr V cosh ( const V & v ) ; template < /*simd-complex*/ V > constexpr V acosh ( const V & v ) ; template < /*simd-complex*/ V > constexpr V tanh ( const V & v ) ; template < /*simd-complex*/ V > constexpr V atanh ( const V & v ) ; template < /*simd-floating-point*/ V > rebind_t < complex < typename V :: value_type > , V > polar ( const V & x, const V & y = { } ) ; template < /*simd-complex*/ V > constexpr V pow ( const V & x, const V & y ) ; } namespace std { // See Algorithms using datapar :: clamp ; using datapar :: max ; using datapar :: min ; using datapar :: minmax ; // See Mathematical functions using datapar :: abs ; using datapar :: acos ; using datapar :: acosh ; using datapar :: asin ; using datapar :: asinh ; using datapar :: assoc_laguerre ; using datapar :: assoc_legendre ; using datapar :: atan ; using datapar :: atan2 ; using datapar :: atanh ; using datapar :: beta ; using datapar :: cbrt ; using datapar :: ceil ; using datapar :: comp_ellint_1 ; using datapar :: comp_ellint_2 ; using datapar :: comp_ellint_3 ; using datapar :: copysign ; using datapar :: cos ; using datapar :: cosh ; using datapar :: cyl_bessel_i ; using datapar :: cyl_bessel_j ; using datapar :: cyl_bessel_k ; using datapar :: cyl_neumann ; using datapar :: ellint_1 ; using datapar :: ellint_2 ; using datapar :: ellint_3 ; using datapar :: erf ; using datapar :: erfc ; using datapar :: exp ; using datapar :: exp2 ; using datapar :: expint ; using datapar :: expm1 ; using datapar :: fabs ; using datapar :: fdim ; using datapar :: floor ; using datapar :: fma ; using datapar :: fmax ; using datapar :: fmin ; using datapar :: fmod ; using datapar :: fpclassify ; using datapar :: frexp ; using datapar :: hermite ; using datapar :: hypot ; using datapar :: ilogb ; using datapar :: isfinite ; using datapar :: isgreater ; using datapar :: isgreaterequal ; using datapar :: isinf ; using datapar :: isless ; using datapar :: islessequal ; using datapar :: islessgreater ; using datapar :: isnan ; using datapar :: isnormal ; using datapar :: isunordered ; using datapar :: laguerre ; using datapar :: ldexp ; using datapar :: legendre ; using datapar :: lerp ; using datapar :: lgamma ; using datapar :: llrint ; using datapar :: llround ; using datapar :: log ; using datapar :: log10 ; using datapar :: log1p ; using datapar :: log2 ; using datapar :: logb ; using datapar :: lrint ; using datapar :: lround ; using datapar :: modf ; using datapar :: nearbyint ; using datapar :: nextafter ; using datapar :: pow ; using datapar :: remainder ; using datapar :: remquo ; using datapar :: riemann_zeta ; using datapar :: rint ; using datapar :: round ; using datapar :: scalbln ; using datapar :: scalbn ; using datapar :: signbit ; using datapar :: sin ; using datapar :: sinh ; using datapar :: sph_bessel ; using datapar :: sph_legendre ; using datapar :: sph_neumann ; using datapar :: sqrt ; using datapar :: tan ; using datapar :: tanh ; using datapar :: tgamma ; using datapar :: trunc ; // See Bit manipulation using datapar :: bit_ceil ; using datapar :: bit_floor ; using datapar :: bit_width ; using datapar :: byteswap ; using datapar :: countl_one ; using datapar :: countl_zero ; using datapar :: countr_one ; using datapar :: countr_zero ; using datapar :: has_single_bit ; using datapar :: popcount ; using datapar :: rotl ; using datapar :: rotr ; // See simd complex math using datapar :: arg ; using datapar :: conj ; using datapar :: imag ; using datapar :: norm ; using datapar :: polar ; using datapar :: proj ; using datapar :: real ; } [ edit ] Class template std::datapar::flags namespace std :: datapar { template < class ... Flags > struct flags { // flags operators template < class ... Other > friend consteval auto operator | ( flags, flags < Other... > ) ; } ; } [ edit ] Class template std::datapar::basic_simd namespace std :: datapar { template < class T, class Abi > class basic_simd { public : using value_type = T ; using mask_type = basic_simd_mask < sizeof ( T ) , Abi > ; using abi_type = Abi ; static constexpr integral_constant < /*simd-size-type*/ , /*simd-size-v*/ < T, Abi >> size { } ; constexpr basic_simd ( ) noexcept = default ; // basic_simd constructors template < class U > constexpr explicit ( /* see description */ ) basic_simd ( U && value ) noexcept ; template < class U, class UAbi > constexpr explicit ( /* see description */ ) basic_simd ( const basic_simd < U, UAbi > & ) noexcept ; template < class G > constexpr explicit basic_simd ( G && gen ) noexcept ; template < class R, class ... Flags > constexpr basic_simd ( R && range, flags < Flags... > = { } ) ; template < class R, class ... Flags > constexpr basic_simd ( R && range, const mask_type & mask, flags < Flags... > = { } ) ; template < /*simd-floating-point*/ V > constexpr explicit ( /* see description */ ) basic_simd ( const V & reals, const V & imags = { } ) noexcept ; // basic_simd subscript operators constexpr value_type operator [ ] ( /*simd-size-type*/ ) const ; // basic_simd unary operators constexpr basic_simd & operator ++ ( ) noexcept ; constexpr basic_simd operator ++ ( int ) noexcept ; constexpr basic_simd & operator -- ( ) noexcept ; constexpr basic_simd operator -- ( int ) noexcept ; constexpr mask_type operator ! ( ) const noexcept ; constexpr basic_simd operator~ ( ) const noexcept ; constexpr basic_simd operator + ( ) const noexcept ; constexpr basic_simd operator - ( ) const noexcept ; // basic_simd binary operators friend constexpr basic_simd operator + ( const basic_simd & , const basic_simd & ) noexcept ; friend constexpr basic_simd operator - ( const basic_simd & , const basic_simd & ) noexcept ; friend constexpr basic_simd operator * ( const basic_simd & , const basic_simd & ) noexcept ; friend constexpr basic_simd operator / ( const basic_simd & , const basic_simd & ) noexcept ; friend constexpr basic_simd operator % ( const basic_simd & , const basic_simd & ) noexcept ; friend constexpr basic_simd operator & ( const basic_simd & , const basic_simd & ) noexcept ; friend constexpr basic_simd operator | ( const basic_simd & , const basic_simd & ) noexcept ; friend constexpr basic_simd operator ^ ( const basic_simd & , const basic_simd & ) noexcept ; friend constexpr basic_simd operator << ( const basic_simd & , const basic_simd & ) noexcept ; friend constexpr basic_simd operator >> ( const basic_simd & , const basic_simd & ) noexcept ; friend constexpr basic_simd operator << ( const basic_simd & , /*simd-size-type*/ ) noexcept ; friend constexpr basic_simd operator >> ( const basic_simd & , /*simd-size-type*/ ) noexcept ; // basic_simd compound assignment friend constexpr basic_simd & operator + = ( basic_simd & , const basic_simd & ) noexcept ; friend constexpr basic_simd & operator - = ( basic_simd & , const basic_simd & ) noexcept ; friend constexpr basic_simd & operator * = ( basic_simd & , const basic_simd & ) noexcept ; friend constexpr basic_simd & operator / = ( basic_simd & , const basic_simd & ) noexcept ; friend constexpr basic_simd & operator % = ( basic_simd & , const basic_simd & ) noexcept ; friend constexpr basic_simd & operator & = ( basic_simd & , const basic_simd & ) noexcept ; friend constexpr basic_simd & operator | = ( basic_simd & , const basic_simd & ) noexcept ; friend constexpr basic_simd & operator ^ = ( basic_simd & , const basic_simd & ) noexcept ; friend constexpr basic_simd & operator <<= ( basic_simd & , const basic_simd & ) noexcept ; friend constexpr basic_simd & operator >>= ( basic_simd & , const basic_simd & ) noexcept ; friend constexpr basic_simd & operator <<= ( basic_simd & , /*simd-size-type*/ ) noexcept ; friend constexpr basic_simd & operator >>= ( basic_simd & , /*simd-size-type*/ ) noexcept ; // basic_simd compare operators friend constexpr mask_type operator == ( const basic_simd & , const basic_simd & ) noexcept ; friend constexpr mask_type operator ! = ( const basic_simd & , const basic_simd & ) noexcept ; friend constexpr mask_type operator >= ( const basic_simd & , const basic_simd & ) noexcept ; friend constexpr mask_type operator <= ( const basic_simd & , const basic_simd & ) noexcept ; friend constexpr mask_type operator > ( const basic_simd & , const basic_simd & ) noexcept ; friend constexpr mask_type operator < ( const basic_simd & , const basic_simd & ) noexcept ; // basic_simd complex-value accessors constexpr auto real ( ) const noexcept ; constexpr auto imag ( ) const noexcept ; template < /*simd-floating-point*/ V > constexpr void real ( const V & v ) noexcept ; template < /*simd-floating-point*/ V > constexpr void imag ( const V & v ) noexcept ; // basic_simd exposition only conditional operators friend constexpr basic_simd /*simd-select-impl*/ ( // exposition only const mask_type & , const basic_simd & , const basic_simd & ) noexcept ; } ; template < class R, class ... Ts > basic_simd ( R && r, Ts... ) - > /* see description */ ; } [ edit ] Class template std::datapar::basic_simd_mask namespace std :: datapar { template < size_t Bytes, class Abi > class basic_simd_mask { public : using value_type = bool ; using abi_type = Abi ; static constexpr integral_constant < /*simd-size-type*/ , /*simd-size-v*/ < /*integer-from*/ < Bytes > , Abi >> size { } ; constexpr basic_simd_mask ( ) noexcept = default ; // basic_simd_mask constructors constexpr explicit basic_simd_mask ( value_type ) noexcept ; template < size_t UBytes, class UAbi > constexpr explicit basic_simd_mask ( const basic_simd_mask < UBytes, UAbi > & ) noexcept ; template < class G > constexpr explicit basic_simd_mask ( G && gen ) noexcept ; // basic_simd_mask subscript operators constexpr value_type operator [ ] ( /*simd-size-type*/ ) const ; // basic_simd_mask unary operators constexpr basic_simd_mask operator ! ( ) const noexcept ; constexpr basic_simd < /*integer-from*/ < Bytes > , Abi > operator + ( ) const noexcept ; constexpr basic_simd < /*integer-from*/ < Bytes > , Abi > operator - ( ) const noexcept ; constexpr basic_simd < /*integer-from*/ < Bytes > , Abi > operator~ ( ) const noexcept ; // basic_simd_mask conversion operators template < class U, class A > constexpr explicit ( sizeof ( U ) ! = Bytes ) operator basic_simd < U, A > ( ) const noexcept ; // basic_simd_mask binary operators friend constexpr basic_simd_mask operator && ( const basic_simd_mask & , const basic_simd_mask & ) noexcept ; friend constexpr basic_simd_mask operator || ( const basic_simd_mask & , const basic_simd_mask & ) noexcept ; friend constexpr basic_simd_mask operator & ( const basic_simd_mask & , const basic_simd_mask & ) noexcept ; friend constexpr basic_simd_mask operator | ( const basic_simd_mask & , const basic_simd_mask & ) noexcept ; friend constexpr basic_simd_mask operator ^ ( const basic_simd_mask & , const basic_simd_mask & ) noexcept ; // basic_simd_mask compound assignment friend constexpr basic_simd_mask & operator & = ( basic_simd_mask & , const basic_simd_mask & ) noexcept ; friend constexpr basic_simd_mask & operator | = ( basic_simd_mask & , const basic_simd_mask & ) noexcept ; friend constexpr basic_simd_mask & operator ^ = ( basic_simd_mask & , const basic_simd_mask & ) noexcept ; // basic_simd_mask comparisons friend constexpr basic_simd_mask operator == ( const basic_simd_mask & , const basic_simd_mask & ) noexcept ; friend constexpr basic_simd_mask operator ! = ( const basic_simd_mask & , const basic_simd_mask & ) noexcept ; friend constexpr basic_simd_mask operator >= ( const basic_simd_mask & , const basic_simd_mask & ) noexcept ; friend constexpr basic_simd_mask operator <= ( const basic_simd_mask & , const basic_simd_mask & ) noexcept ; friend constexpr basic_simd_mask operator > ( const basic_simd_mask & , const basic_simd_mask & ) noexcept ; friend constexpr basic_simd_mask operator < ( const basic_simd_mask & , const basic_simd_mask & ) noexcept ; // basic_simd_mask exposition only conditional operators friend constexpr basic_simd_mask /*simd-select-impl*/ ( // exposition only const basic_simd_mask & , const basic_simd_mask & , const basic_simd_mask & ) noexcept ; friend constexpr basic_simd_mask /*simd-select-impl*/ ( // exposition only const basic_simd_mask & , same_as < bool > auto , same_as < bool > auto ) noexcept ; template < class T0, class T1 > friend constexpr simd < /* see description */ , size ( ) > /*simd-select-impl*/ ( const basic_simd_mask & , const T0 & , const T1 & ) noexcept ; // exposition only } ; } Retrieved from " https://en.cppreference.com/mwiki/index.php?title=cpp/header/simd&oldid=182171 " Navigation Support us Recent changes FAQ Offline version Toolbox What links here Related changes Upload file Special pages Printable version Permanent link Page information In other languages Español 日本語 中文 This page was last modified on 23 March 2025, at 02:35. Privacy policy About cppreference.com Disclaimers