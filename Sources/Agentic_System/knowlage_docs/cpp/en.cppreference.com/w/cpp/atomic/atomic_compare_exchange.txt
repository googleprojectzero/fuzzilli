std::atomic_compare_exchange_weak, std::atomic_compare_exchange_strong, std::atomic_compare_exchange_weak_explicit, std::atomic_compare_exchange_strong_explicit - cppreference.com cppreference.com Create account Log in Namespaces Page Discussion Variants Views View Edit History Actions std:: atomic_compare_exchange_weak, std:: atomic_compare_exchange_strong, std:: atomic_compare_exchange_weak_explicit, std:: atomic_compare_exchange_strong_explicit From cppreference.com < cpp ‎ | atomic C++ Compiler support Freestanding and hosted Language Standard library Standard library headers Named requirements Feature test macros (C++20) Language support library Concepts library (C++20) Diagnostics library Memory management library Metaprogramming library (C++11) General utilities library Containers library Iterators library Ranges library (C++20) Algorithms library Strings library Text processing library Numerics library Date and time library Input/output library Filesystem library (C++17) Concurrency support library (C++11) Execution control library (C++26) Technical specifications Symbols index External libraries [edit] Concurrency support library Threads thread (C++11) jthread (C++20) hardware_destructive_interference_size hardware_constructive_interference_size (C++17) (C++17) this_thread namespace get_id (C++11) yield (C++11) sleep_for (C++11) sleep_until (C++11) Cooperative cancellation stop_token (C++20) inplace_stop_token (C++26) never_stop_token (C++26) stop_source (C++20) inplace_stop_source (C++26) stop_callback (C++20) inplace_stop_callback (C++26) stop_callback_for_t (C++26) stoppable_token (C++26) unstoppable_token (C++26) stoppable-source (C++26) stoppable-callback-for (C++26) Mutual exclusion mutex (C++11) recursive_mutex (C++11) shared_mutex (C++17) timed_mutex (C++11) recursive_timed_mutex (C++11) shared_timed_mutex (C++14) Generic lock management lock (C++11) lock_guard (C++11) scoped_lock (C++17) unique_lock (C++11) shared_lock (C++14) once_flag (C++11) call_once (C++11) try_lock (C++11) defer_lock try_to_lock adopt_lock defer_lock_t try_to_lock_t adopt_lock_t (C++11) (C++11) (C++11) (C++11) (C++11) (C++11) Condition variables condition_variable (C++11) condition_variable_any (C++11) notify_all_at_thread_exit (C++11) cv_status (C++11) Semaphores counting_semaphore binary_semaphore (C++20) (C++20) Latches and Barriers latch (C++20) barrier (C++20) Futures promise (C++11) future (C++11) shared_future (C++11) packaged_task (C++11) async (C++11) launch (C++11) future_status (C++11) future_error (C++11) future_category (C++11) future_errc (C++11) Safe reclamation rcu_obj_base (C++26) rcu_domain (C++26) rcu_default_domain (C++26) rcu_synchronize (C++26) rcu_barrier (C++26) rcu_retire (C++26) Hazard pointers hazard_pointer_obj_base (C++26) hazard_pointer (C++26) make_hazard_pointer (C++26) Atomic types atomic (C++11) atomic_ref (C++20) atomic_flag (C++11) Initialization of atomic types atomic_init (C++11) (deprecated in C++20) ATOMIC_VAR_INIT (C++11) (deprecated in C++20) ATOMIC_FLAG_INIT (C++11) Memory ordering memory_order (C++11) kill_dependency (C++11) (deprecated in C++26) atomic_thread_fence (C++11) atomic_signal_fence (C++11) Free functions for atomic operations atomic_store atomic_store_explicit (C++11) (C++11) atomic_load atomic_load_explicit (C++11) (C++11) atomic_exchange atomic_exchange_explicit (C++11) (C++11) atomic_compare_exchange_weak atomic_compare_exchange_weak_explicit atomic_compare_exchange_strong atomic_compare_exchange_strong_explicit (C++11) (C++11) (C++11) (C++11) atomic_fetch_add atomic_fetch_add_explicit (C++11) (C++11) atomic_fetch_sub atomic_fetch_sub_explicit (C++11) (C++11) atomic_fetch_and atomic_fetch_and_explicit (C++11) (C++11) atomic_fetch_or atomic_fetch_or_explicit (C++11) (C++11) atomic_fetch_xor atomic_fetch_xor_explicit (C++11) (C++11) atomic_fetch_max atomic_fetch_max_explicit (C++26) (C++26) atomic_fetch_min atomic_fetch_min_explicit (C++26) (C++26) atomic_is_lock_free (C++11) atomic_wait atomic_wait_explicit (C++20) (C++20) atomic_notify_one (C++20) atomic_notify_all (C++20) Free functions for atomic flags atomic_flag_test_and_set atomic_flag_test_and_set_explicit (C++11) (C++11) atomic_flag_clear atomic_flag_clear_explicit (C++11) (C++11) atomic_flag_test atomic_flag_test_explicit (C++20) (C++20) atomic_flag_wait atomic_flag_wait_explicit (C++20) (C++20) atomic_flag_notify_one (C++20) atomic_flag_notify_all (C++20) [edit] Defined in header <atomic> template < class T > bool atomic_compare_exchange_weak ( std:: atomic < T > * obj, typename std:: atomic < T > :: value_type * expected, typename std:: atomic < T > :: value_type desired ) noexcept ; (1) (since C++11) template < class T > bool atomic_compare_exchange_weak ( volatile std:: atomic < T > * obj, typename std:: atomic < T > :: value_type * expected, typename std:: atomic < T > :: value_type desired ) noexcept ; (2) (since C++11) template < class T > bool atomic_compare_exchange_strong ( std:: atomic < T > * obj, typename std:: atomic < T > :: value_type * expected, typename std:: atomic < T > :: value_type desired ) noexcept ; (3) (since C++11) template < class T > bool atomic_compare_exchange_strong ( volatile std:: atomic < T > * obj, typename std:: atomic < T > :: value_type * expected, typename std:: atomic < T > :: value_type desired ) noexcept ; (4) (since C++11) template < class T > bool atomic_compare_exchange_weak_explicit ( std:: atomic < T > * obj, typename std:: atomic < T > :: value_type * expected, typename std:: atomic < T > :: value_type desired, std:: memory_order success, std:: memory_order failure ) noexcept ; (5) (since C++11) template < class T > bool atomic_compare_exchange_weak_explicit ( volatile std:: atomic < T > * obj, typename std:: atomic < T > :: value_type * expected, typename std:: atomic < T > :: value_type desired, std:: memory_order success, std:: memory_order failure ) noexcept ; (6) (since C++11) template < class T > bool atomic_compare_exchange_strong_explicit ( std:: atomic < T > * obj, typename std:: atomic < T > :: value_type * expected, typename std:: atomic < T > :: value_type desired, std:: memory_order success, std:: memory_order failure ) noexcept ; (7) (since C++11) template < class T > bool atomic_compare_exchange_strong_explicit ( volatile std:: atomic < T > * obj, typename std:: atomic < T > :: value_type * expected, typename std:: atomic < T > :: value_type desired, std:: memory_order success, std:: memory_order failure ) noexcept ; (8) (since C++11) Atomically compares the object representation (until C++20) value representation (since C++20) of the object pointed to by obj with that of the object pointed to by expected , and if those are bitwise-equal, replaces the former with desired (performs read-modify-write operation). Otherwise, loads the actual value pointed to by obj into * expected (performs load operation). Overloads Memory model for read‑modify‑write operation load operation (1-4) std:: memory_order_seq_cst std:: memory_order_seq_cst (5-8) success failure These functions are defined in terms of member functions of std::atomic : 1,2) obj - > compare_exchange_weak ( * expected, desired ) 3,4) obj - > compare_exchange_strong ( * expected, desired ) 5,6) obj - > compare_exchange_weak ( * expected, desired, success, failure ) 7,8) obj - > compare_exchange_strong ( * expected, desired, success, failure ) If failure is stronger than success or (until C++17) is one of std:: memory_order_release and std:: memory_order_acq_rel , the behavior is undefined. Contents 1 Parameters 2 Return value 3 Notes 4 Example 5 Defect reports 6 See also [ edit ] Parameters obj - pointer to the atomic object to test and modify expected - pointer to the value expected to be found in the atomic object desired - the value to store in the atomic object if it is as expected success - the memory synchronization ordering for the read-modify-write operation if the comparison succeeds failure - the memory synchronization ordering for the load operation if the comparison fails [ edit ] Return value The result of the comparison: true if * obj was equal to * expected , false otherwise. [ edit ] Notes std::atomic_compare_exchange_weak and std::atomic_compare_exchange_weak_explicit (the weak versions) are allowed to fail spuriously, that is, act as if * obj ! = * expected even if they are equal. When a compare-and-exchange is in a loop, they will yield better performance on some platforms. When a weak compare-and-exchange would require a loop and a strong one would not, the strong one is preferable unless the object representation of T may include padding bits, (until C++20) trap bits, or offers multiple object representations for the same value (e.g. floating-point NaN). In those cases, weak compare-and-exchange typically works because it quickly converges on some stable object representation. For a union with bits that participate in the value representations of some members but not the others, compare-and-exchange might always fail because such padding bits have indeterminate values when they do not participate in the value representation of the active member. Padding bits that never participate in an object's value representation are ignored. (since C++20) [ edit ] Example Compare and exchange operations are often used as basic building blocks of lockfree data structures. Run this code #include <atomic> template < class T > struct node { T data ; node * next ; node ( const T & data ) : data ( data ) , next ( nullptr ) { } } ; template < class T > class stack { std:: atomic < node < T > * > head ; public : void push ( const T & data ) { node < T > * new_node = new node < T > ( data ) ; // put the current value of head into new_node->next new_node - > next = head. load ( std:: memory_order_relaxed ) ; // now make new_node the new head, but if the head // is no longer what's stored in new_node->next // (some other thread must have inserted a node just now) // then put that new head into new_node->next and try again while ( ! std :: atomic_compare_exchange_weak_explicit ( & head, & new_node - > next, new_node, std:: memory_order_release , std:: memory_order_relaxed ) ) ; // the body of the loop is empty // note: the above loop is not thread-safe in at least // GCC prior to 4.8.3 (bug 60272), clang prior to 2014-05-05 (bug 18899) // MSVC prior to 2014-03-17 (bug 819819). See member function version for workaround } } ; int main ( ) { stack < int > s ; s. push ( 1 ) ; s. push ( 2 ) ; s. push ( 3 ) ; } [ edit ] Defect reports The following behavior-changing defect reports were applied retroactively to previously published C++ standards. DR Applied to Behavior as published Correct behavior P0558R1 C++11 exact type match was required because T was deduced from multiple arguments T is only deduced from obj [ edit ] See also compare_exchange_weak compare_exchange_strong atomically compares the value of the atomic object with non-atomic argument and performs atomic exchange if equal or atomic load if not (public member function of std::atomic<T> ) [edit] atomic_exchange atomic_exchange_explicit (C++11) (C++11) atomically replaces the value of the atomic object with non-atomic argument and returns the old value of the atomic (function template) [edit] std::atomic_compare_exchange_weak (std::shared_ptr) std::atomic_compare_exchange_strong (std::shared_ptr) (deprecated in C++20) (removed in C++26) specializes atomic operations for std::shared_ptr (function template) C documentation for atomic_compare_exchange , atomic_compare_exchange_explicit Retrieved from " https://en.cppreference.com/mwiki/index.php?title=cpp/atomic/atomic_compare_exchange&oldid=171255 " Navigation Support us Recent changes FAQ Offline version Toolbox What links here Related changes Upload file Special pages Printable version Permanent link Page information In other languages Deutsch Español Français Italiano 日本語 Português Русский 中文 This page was last modified on 24 April 2024, at 06:26. Privacy policy About cppreference.com Disclaimers