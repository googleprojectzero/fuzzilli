std::atomic_is_lock_free, ATOMIC_xxx_LOCK_FREE - cppreference.com cppreference.com Create account Log in Namespaces Page Discussion Variants Views View Edit History Actions std:: atomic_is_lock_free, ATOMIC_xxx_LOCK_FREE From cppreference.com < cpp ‎ | atomic C++ Compiler support Freestanding and hosted Language Standard library Standard library headers Named requirements Feature test macros (C++20) Language support library Concepts library (C++20) Diagnostics library Memory management library Metaprogramming library (C++11) General utilities library Containers library Iterators library Ranges library (C++20) Algorithms library Strings library Text processing library Numerics library Date and time library Input/output library Filesystem library (C++17) Concurrency support library (C++11) Execution control library (C++26) Technical specifications Symbols index External libraries [edit] Concurrency support library Threads thread (C++11) jthread (C++20) hardware_destructive_interference_size hardware_constructive_interference_size (C++17) (C++17) this_thread namespace get_id (C++11) yield (C++11) sleep_for (C++11) sleep_until (C++11) Cooperative cancellation stop_token (C++20) inplace_stop_token (C++26) never_stop_token (C++26) stop_source (C++20) inplace_stop_source (C++26) stop_callback (C++20) inplace_stop_callback (C++26) stop_callback_for_t (C++26) stoppable_token (C++26) unstoppable_token (C++26) stoppable-source (C++26) stoppable-callback-for (C++26) Mutual exclusion mutex (C++11) recursive_mutex (C++11) shared_mutex (C++17) timed_mutex (C++11) recursive_timed_mutex (C++11) shared_timed_mutex (C++14) Generic lock management lock (C++11) lock_guard (C++11) scoped_lock (C++17) unique_lock (C++11) shared_lock (C++14) once_flag (C++11) call_once (C++11) try_lock (C++11) defer_lock try_to_lock adopt_lock defer_lock_t try_to_lock_t adopt_lock_t (C++11) (C++11) (C++11) (C++11) (C++11) (C++11) Condition variables condition_variable (C++11) condition_variable_any (C++11) notify_all_at_thread_exit (C++11) cv_status (C++11) Semaphores counting_semaphore binary_semaphore (C++20) (C++20) Latches and Barriers latch (C++20) barrier (C++20) Futures promise (C++11) future (C++11) shared_future (C++11) packaged_task (C++11) async (C++11) launch (C++11) future_status (C++11) future_error (C++11) future_category (C++11) future_errc (C++11) Safe reclamation rcu_obj_base (C++26) rcu_domain (C++26) rcu_default_domain (C++26) rcu_synchronize (C++26) rcu_barrier (C++26) rcu_retire (C++26) Hazard pointers hazard_pointer_obj_base (C++26) hazard_pointer (C++26) make_hazard_pointer (C++26) Atomic types atomic (C++11) atomic_ref (C++20) atomic_flag (C++11) Initialization of atomic types atomic_init (C++11) (deprecated in C++20) ATOMIC_VAR_INIT (C++11) (deprecated in C++20) ATOMIC_FLAG_INIT (C++11) Memory ordering memory_order (C++11) kill_dependency (C++11) (deprecated in C++26) atomic_thread_fence (C++11) atomic_signal_fence (C++11) Free functions for atomic operations atomic_store atomic_store_explicit (C++11) (C++11) atomic_load atomic_load_explicit (C++11) (C++11) atomic_exchange atomic_exchange_explicit (C++11) (C++11) atomic_compare_exchange_weak atomic_compare_exchange_weak_explicit atomic_compare_exchange_strong atomic_compare_exchange_strong_explicit (C++11) (C++11) (C++11) (C++11) atomic_fetch_add atomic_fetch_add_explicit (C++11) (C++11) atomic_fetch_sub atomic_fetch_sub_explicit (C++11) (C++11) atomic_fetch_and atomic_fetch_and_explicit (C++11) (C++11) atomic_fetch_or atomic_fetch_or_explicit (C++11) (C++11) atomic_fetch_xor atomic_fetch_xor_explicit (C++11) (C++11) atomic_fetch_max atomic_fetch_max_explicit (C++26) (C++26) atomic_fetch_min atomic_fetch_min_explicit (C++26) (C++26) atomic_is_lock_free (C++11) atomic_wait atomic_wait_explicit (C++20) (C++20) atomic_notify_one (C++20) atomic_notify_all (C++20) Free functions for atomic flags atomic_flag_test_and_set atomic_flag_test_and_set_explicit (C++11) (C++11) atomic_flag_clear atomic_flag_clear_explicit (C++11) (C++11) atomic_flag_test atomic_flag_test_explicit (C++20) (C++20) atomic_flag_wait atomic_flag_wait_explicit (C++20) (C++20) atomic_flag_notify_one (C++20) atomic_flag_notify_all (C++20) [edit] Defined in header <atomic> template < class T > bool atomic_is_lock_free ( const volatile std:: atomic < T > * obj ) noexcept ; (1) (since C++11) template < class T > bool atomic_is_lock_free ( const std:: atomic < T > * obj ) noexcept ; (2) (since C++11) #define ATOMIC_BOOL_LOCK_FREE /* unspecified */ #define ATOMIC_CHAR_LOCK_FREE /* unspecified */ #define ATOMIC_CHAR16_T_LOCK_FREE /* unspecified */ #define ATOMIC_CHAR32_T_LOCK_FREE /* unspecified */ #define ATOMIC_WCHAR_T_LOCK_FREE /* unspecified */ #define ATOMIC_SHORT_LOCK_FREE /* unspecified */ #define ATOMIC_INT_LOCK_FREE /* unspecified */ #define ATOMIC_LONG_LOCK_FREE /* unspecified */ #define ATOMIC_LLONG_LOCK_FREE /* unspecified */ #define ATOMIC_POINTER_LOCK_FREE /* unspecified */ (3) (since C++11) #define ATOMIC_CHAR8_T_LOCK_FREE /* unspecified */ (4) (since C++20) 1,2) Determines if the atomic object pointed to by obj is implemented lock-free, as if by calling obj - > is_lock_free ( ) . In any given program execution, the result of the lock-free query is the same for all atomic objects of the same type. 3,4) Expands to an integer constant expression with value ​ 0 ​ for the built-in atomic types that are never lock-free, 1 for the built-in atomic types that are sometimes lock-free, 2 for the built-in atomic types that are always lock-free. Contents 1 Parameters 2 Return value 3 Notes 4 Example 5 Defect reports 6 See also [ edit ] Parameters obj - pointer to the atomic object to examine [ edit ] Return value true if * obj is a lock-free atomic, false otherwise. [ edit ] Notes All atomic types except for std::atomic_flag may be implemented using mutexes or other locking operations, rather than using the lock-free atomic CPU instructions. Atomic types are also allowed to be sometimes lock-free: for example, if only some sub-architectures support lock-free atomic access for a given type (such as the CMPXCHG16B instruction on x86-64), whether atomics are lock-free may not be known until runtime. The C++ standard recommends (but does not require) that lock-free atomic operations are also address-free, that is, suitable for communication between processes using shared memory. [ edit ] Example Run this code #include <atomic> #include <iostream> #include <utility> struct A { int a [ 4 ] ; } ; struct B { int x, y ; } ; int main ( ) { std:: atomic < A > a ; std:: atomic < B > b ; std:: cout << std:: boolalpha << "std::atomic<A> is lock free? " << std :: atomic_is_lock_free ( & a ) << ' \n ' << "std::atomic<B> is lock free? " << std :: atomic_is_lock_free ( & b ) << ' \n ' ; } Possible output: std::atomic<A> is lock free? false std::atomic<B> is lock free? true [ edit ] Defect reports The following behavior-changing defect reports were applied retroactively to previously published C++ standards. DR Applied to Behavior as published Correct behavior LWG 3249 C++11 atomic_is_lock_free was specified via pointers, which was ambiguous and might accept invalid pointer values specified via atomic objects [ edit ] See also is_lock_free checks if the atomic object is lock-free (public member function of std::atomic<T> ) [edit] atomic_flag (C++11) the lock-free boolean atomic type (class) [edit] is_always_lock_free [static] (C++17) indicates that the type is always lock-free (public static member constant of std::atomic<T> ) [edit] std::atomic_is_lock_free (std::shared_ptr) (deprecated in C++20) (removed in C++26) specializes atomic operations for std::shared_ptr (function template) C documentation for atomic_is_lock_free C documentation for ATOMIC_*_LOCK_FREE Retrieved from " https://en.cppreference.com/mwiki/index.php?title=cpp/atomic/atomic_is_lock_free&oldid=181989 " Navigation Support us Recent changes FAQ Offline version Toolbox What links here Related changes Upload file Special pages Printable version Permanent link Page information In other languages Deutsch Español Français Italiano 日本語 Português Русский 中文 This page was last modified on 17 March 2025, at 12:06. Privacy policy About cppreference.com Disclaimers