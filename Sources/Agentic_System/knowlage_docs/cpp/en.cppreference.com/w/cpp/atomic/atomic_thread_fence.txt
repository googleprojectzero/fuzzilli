std::atomic_thread_fence - cppreference.com cppreference.com Create account Log in Namespaces Page Discussion Variants Views View Edit History Actions std:: atomic_thread_fence From cppreference.com < cpp ‎ | atomic C++ Compiler support Freestanding and hosted Language Standard library Standard library headers Named requirements Feature test macros (C++20) Language support library Concepts library (C++20) Diagnostics library Memory management library Metaprogramming library (C++11) General utilities library Containers library Iterators library Ranges library (C++20) Algorithms library Strings library Text processing library Numerics library Date and time library Input/output library Filesystem library (C++17) Concurrency support library (C++11) Execution control library (C++26) Technical specifications Symbols index External libraries [edit] Concurrency support library Threads thread (C++11) jthread (C++20) hardware_destructive_interference_size hardware_constructive_interference_size (C++17) (C++17) this_thread namespace get_id (C++11) yield (C++11) sleep_for (C++11) sleep_until (C++11) Cooperative cancellation stop_token (C++20) inplace_stop_token (C++26) never_stop_token (C++26) stop_source (C++20) inplace_stop_source (C++26) stop_callback (C++20) inplace_stop_callback (C++26) stop_callback_for_t (C++26) stoppable_token (C++26) unstoppable_token (C++26) stoppable-source (C++26) stoppable-callback-for (C++26) Mutual exclusion mutex (C++11) recursive_mutex (C++11) shared_mutex (C++17) timed_mutex (C++11) recursive_timed_mutex (C++11) shared_timed_mutex (C++14) Generic lock management lock (C++11) lock_guard (C++11) scoped_lock (C++17) unique_lock (C++11) shared_lock (C++14) once_flag (C++11) call_once (C++11) try_lock (C++11) defer_lock try_to_lock adopt_lock defer_lock_t try_to_lock_t adopt_lock_t (C++11) (C++11) (C++11) (C++11) (C++11) (C++11) Condition variables condition_variable (C++11) condition_variable_any (C++11) notify_all_at_thread_exit (C++11) cv_status (C++11) Semaphores counting_semaphore binary_semaphore (C++20) (C++20) Latches and Barriers latch (C++20) barrier (C++20) Futures promise (C++11) future (C++11) shared_future (C++11) packaged_task (C++11) async (C++11) launch (C++11) future_status (C++11) future_error (C++11) future_category (C++11) future_errc (C++11) Safe reclamation rcu_obj_base (C++26) rcu_domain (C++26) rcu_default_domain (C++26) rcu_synchronize (C++26) rcu_barrier (C++26) rcu_retire (C++26) Hazard pointers hazard_pointer_obj_base (C++26) hazard_pointer (C++26) make_hazard_pointer (C++26) Atomic types atomic (C++11) atomic_ref (C++20) atomic_flag (C++11) Initialization of atomic types atomic_init (C++11) (deprecated in C++20) ATOMIC_VAR_INIT (C++11) (deprecated in C++20) ATOMIC_FLAG_INIT (C++11) Memory ordering memory_order (C++11) kill_dependency (C++11) (deprecated in C++26) atomic_thread_fence (C++11) atomic_signal_fence (C++11) Free functions for atomic operations atomic_store atomic_store_explicit (C++11) (C++11) atomic_load atomic_load_explicit (C++11) (C++11) atomic_exchange atomic_exchange_explicit (C++11) (C++11) atomic_compare_exchange_weak atomic_compare_exchange_weak_explicit atomic_compare_exchange_strong atomic_compare_exchange_strong_explicit (C++11) (C++11) (C++11) (C++11) atomic_fetch_add atomic_fetch_add_explicit (C++11) (C++11) atomic_fetch_sub atomic_fetch_sub_explicit (C++11) (C++11) atomic_fetch_and atomic_fetch_and_explicit (C++11) (C++11) atomic_fetch_or atomic_fetch_or_explicit (C++11) (C++11) atomic_fetch_xor atomic_fetch_xor_explicit (C++11) (C++11) atomic_fetch_max atomic_fetch_max_explicit (C++26) (C++26) atomic_fetch_min atomic_fetch_min_explicit (C++26) (C++26) atomic_is_lock_free (C++11) atomic_wait atomic_wait_explicit (C++20) (C++20) atomic_notify_one (C++20) atomic_notify_all (C++20) Free functions for atomic flags atomic_flag_test_and_set atomic_flag_test_and_set_explicit (C++11) (C++11) atomic_flag_clear atomic_flag_clear_explicit (C++11) (C++11) atomic_flag_test atomic_flag_test_explicit (C++20) (C++20) atomic_flag_wait atomic_flag_wait_explicit (C++20) (C++20) atomic_flag_notify_one (C++20) atomic_flag_notify_all (C++20) [edit] Defined in header <atomic> extern "C" void atomic_thread_fence ( std:: memory_order order ) noexcept ; (since C++11) Establishes memory synchronization ordering of non-atomic and relaxed atomic accesses, as instructed by order , without an associated atomic operation. Note however, that at least one atomic operation is required to set up the synchronization, as described below. Contents 1 Fence-atomic synchronization 2 Atomic-fence synchronization 3 Fence-fence synchronization 4 Parameters 5 Notes 6 Example 7 See also [ edit ] Fence-atomic synchronization A release fence F in thread A synchronizes-with atomic acquire operation Y in thread B , if there exists an atomic store X (with any memory order), Y reads the value written by X (or the value would be written by release sequence headed by X if X were a release operation), F is sequenced-before X in thread A . In this case, all non-atomic and relaxed atomic stores that are sequenced-before F in thread A will happen-before all non-atomic and relaxed atomic loads from the same locations made in thread B after Y . [ edit ] Atomic-fence synchronization An atomic release operation X in thread A synchronizes-with an acquire fence F in thread B , if there exists an atomic read Y (with any memory order), Y reads the value written by X (or by the release sequence headed by X ), Y is sequenced-before F in thread B . In this case, all non-atomic and relaxed atomic stores that are sequenced-before X in thread A will happen-before all non-atomic and relaxed atomic loads from the same locations made in thread B after F . [ edit ] Fence-fence synchronization A release fence FA in thread A synchronizes-with an acquire fence FB in thread B , if there exists an atomic object M , there exists an atomic write X (with any memory order) that modifies M in thread A , FA is sequenced-before X in thread A , there exists an atomic read Y (with any memory order) in thread B , Y reads the value written by X (or the value would be written by release sequence headed by X if X were a release operation), Y is sequenced-before FB in thread B . In this case, all non-atomic and relaxed atomic stores that are sequenced-before FA in thread A will happen-before all non-atomic and relaxed atomic loads from the same locations made in thread B after FB . Depending on the value of the order parameter, the effects of this call are: When order == std:: memory_order_relaxed , there are no effects. When order == std:: memory_order_acquire or order == std:: memory_order_consume , is an acquire fence. When order == std:: memory_order_release , is a release fence. When order == std:: memory_order_acq_rel , is both a release fence and an acquire fence. When order == std:: memory_order_seq_cst , is a sequentially-consistent ordering acquire fence and release fence. [ edit ] Parameters order - the memory ordering executed by this fence [ edit ] Notes On x86 (including x86-64), atomic_thread_fence functions issue no CPU instructions and only affect compile-time code motion, except for std :: atomic_thread_fence ( std:: memory_order_seq_cst ) . atomic_thread_fence imposes stronger synchronization constraints than an atomic store operation with the same std::memory_order . While an atomic store-release operation prevents all preceding reads and writes from moving past the store-release, an atomic_thread_fence with std:: memory_order_release ordering prevents all preceding reads and writes from moving past all subsequent stores. Fence-fence synchronization can be used to add synchronization to a sequence of several relaxed atomic operations, for example: // Global std:: string computation ( int ) ; void print ( std:: string ) ; std:: atomic < int > arr [ 3 ] = { - 1 , - 1 , - 1 } ; std:: string data [ 1000 ] ; //non-atomic data // Thread A, compute 3 values. void ThreadA ( int v0, int v1, int v2 ) { // assert(0 <= v0, v1, v2 < 1000); data [ v0 ] = computation ( v0 ) ; data [ v1 ] = computation ( v1 ) ; data [ v2 ] = computation ( v2 ) ; std :: atomic_thread_fence ( std:: memory_order_release ) ; std:: atomic_store_explicit ( & arr [ 0 ] , v0, std:: memory_order_relaxed ) ; std:: atomic_store_explicit ( & arr [ 1 ] , v1, std:: memory_order_relaxed ) ; std:: atomic_store_explicit ( & arr [ 2 ] , v2, std:: memory_order_relaxed ) ; } // Thread B, prints between 0 and 3 values already computed. void ThreadB ( ) { int v0 = std:: atomic_load_explicit ( & arr [ 0 ] , std:: memory_order_relaxed ) ; int v1 = std:: atomic_load_explicit ( & arr [ 1 ] , std:: memory_order_relaxed ) ; int v2 = std:: atomic_load_explicit ( & arr [ 2 ] , std:: memory_order_relaxed ) ; std :: atomic_thread_fence ( std:: memory_order_acquire ) ; // v0, v1, v2 might turn out to be -1, some or all of them. // Otherwise it is safe to read the non-atomic data because of the fences: if ( v0 ! = - 1 ) print ( data [ v0 ] ) ; if ( v1 ! = - 1 ) print ( data [ v1 ] ) ; if ( v2 ! = - 1 ) print ( data [ v2 ] ) ; } [ edit ] Example Scan an array of mailboxes, and process only the ones intended for us, without unnecessary synchronization. This example uses atomic-fence synchronization. const int num_mailboxes = 32 ; std:: atomic < int > mailbox_receiver [ num_mailboxes ] ; std:: string mailbox_data [ num_mailboxes ] ; // The writer threads update non-atomic shared data // and then update mailbox_receiver[i] as follows: mailbox_data [ i ] = ... ; std:: atomic_store_explicit ( & mailbox_receiver [ i ] , receiver_id, std:: memory_order_release ) ; // Reader thread needs to check all mailbox[i], but only needs to sync with one. for ( int i = 0 ; i < num_mailboxes ; ++ i ) if ( std:: atomic_load_explicit ( & mailbox_receiver [ i ] , std:: memory_order_relaxed ) == my_id ) { // synchronize with just one writer std :: atomic_thread_fence ( std:: memory_order_acquire ) ; // guaranteed to observe everything done in the writer thread // before the atomic_store_explicit() do_work ( mailbox_data [ i ] ) ; } [ edit ] See also memory_order (C++11) defines memory ordering constraints for the given atomic operation (enum) [edit] atomic_signal_fence (C++11) fence between a thread and a signal handler executed in the same thread (function) [edit] C documentation for atomic_thread_fence Retrieved from " https://en.cppreference.com/mwiki/index.php?title=cpp/atomic/atomic_thread_fence&oldid=183355 " Navigation Support us Recent changes FAQ Offline version Toolbox What links here Related changes Upload file Special pages Printable version Permanent link Page information In other languages Deutsch Español Français Italiano 日本語 Português Русский 中文 This page was last modified on 20 May 2025, at 14:04. Privacy policy About cppreference.com Disclaimers