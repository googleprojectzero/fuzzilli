C++ Operator Precedence - cppreference.com cppreference.com Create account Log in Namespaces Page Discussion Variants Views View Edit History Actions C++ Operator Precedence From cppreference.com < cpp ‎ | language C++ Compiler support Freestanding and hosted Language Standard library Standard library headers Named requirements Feature test macros (C++20) Language support library Concepts library (C++20) Diagnostics library Memory management library Metaprogramming library (C++11) General utilities library Containers library Iterators library Ranges library (C++20) Algorithms library Strings library Text processing library Numerics library Date and time library Input/output library Filesystem library (C++17) Concurrency support library (C++11) Execution control library (C++26) Technical specifications Symbols index External libraries [edit] C++ language General topics Preprocessor Comments Keywords Escape sequences Flow control Conditional execution statements if switch Iteration statements (loops) for range- for (C++11) while do-while Jump statements continue - break goto - return Functions Function declaration Lambda function expression inline specifier Dynamic exception specifications ( until C++17* ) noexcept specifier (C++11) Exceptions throw -expression try block catch handler Namespaces Namespace declaration Namespace aliases Types Fundamental types Enumeration types Function types Class/struct types Union types Specifiers const / volatile decltype (C++11) auto (C++11) constexpr (C++11) consteval (C++20) constinit (C++20) Storage duration specifiers Initialization Default-initialization Value-initialization Zero-initialization Copy-initialization Direct-initialization Aggregate initialization List-initialization (C++11) Constant initialization Reference initialization Expressions Value categories Order of evaluation Operators Operator precedence Alternative representations Literals Boolean - Integer - Floating-point Character - String - nullptr (C++11) User-defined (C++11) Utilities Attributes (C++11) Types typedef declaration Type alias declaration (C++11) Casts Implicit conversions static_cast const_cast Explicit conversions dynamic_cast reinterpret_cast Memory allocation new expression delete expression Classes Class declaration Constructors this pointer Access specifiers friend specifier Class-specific function properties Virtual function override specifier (C++11) final specifier (C++11) explicit (C++11) static Special member functions Default constructor Copy constructor Move constructor (C++11) Copy assignment Move assignment (C++11) Destructor Templates Class template Function template Template specialization Parameter packs (C++11) Miscellaneous Inline assembly History of C++ [edit] Expressions General Value categories Order of evaluation Constant expressions Primary expressions Lambda expressions (C++11) Requires expressions (C++20) Pack indexing expression (C++26) Potentially-evaluated expressions Literals Integer literals Floating-point literals Boolean literals Character literals Escape sequences String literals Null pointer literal (C++11) User-defined literal (C++11) Operators Assignment operators Increment and decrement Arithmetic operators Logical operators Comparison operators Member access operators Other operators new -expression delete -expression throw -expression alignof sizeof sizeof... (C++11) typeid noexcept (C++11) Fold expressions (C++17) Alternative representations of operators Precedence and associativity Operator overloading Default comparisons (C++20) Conversions Implicit conversions Explicit conversions Usual arithmetic conversions User-defined conversion const_cast static_cast dynamic_cast reinterpret_cast [edit] The following table lists the precedence and associativity of C++ operators. Operators are listed top to bottom, in descending precedence. a , b and c are operands. Precedence Operator Description Associativity 1 a :: b Scope resolution Left-to-right → 2 a ++ a -- Suffix/postfix increment and decrement type ( a ) type { a } Functional cast a ( ) Function call a [ ] Subscript a. b a - > b Member access 3 ++ a -- a Prefix increment and decrement Right-to-left ← + a - a Unary plus and minus ! a ~a Logical NOT and bitwise NOT ( type ) a C-style cast * a Indirection (dereference) & a Address-of sizeof Size-of [note 1] co_await await-expression (C++20) new – new[] Dynamic memory allocation delete – delete[] Dynamic memory deallocation 4 a. * b a - > * b Pointer-to-member Left-to-right → 5 a * b a / b a % b Multiplication, division, and remainder 6 a + b a - b Addition and subtraction 7 a << b a >> b Bitwise left shift and right shift 8 a <=> b Three-way comparison operator (since C++20) 9 a < b a <= b a > b a >= b For relational operators < and <= and > and >= respectively 10 a == b a ! = b For equality operators = and != respectively 11 a & b Bitwise AND 12 a ^ b Bitwise XOR (exclusive or) 13 a | b Bitwise OR (inclusive or) 14 a && b Logical AND 15 a || b Logical OR 16 a ? b : c Ternary conditional [note 2] Right-to-left ← throw throw operator co_yield yield-expression (C++20) a = b Direct assignment (provided by default for C++ classes) a + = b a - = b Compound assignment by sum and difference a * = b a / = b a % = b Compound assignment by product, quotient, and remainder a <<= b a >>= b Compound assignment by bitwise left shift and right shift a & = b a ^ = b a | = b Compound assignment by bitwise AND, XOR, and OR 17 a, b Comma Left-to-right → ↑ The operand of sizeof cannot be a C-style type cast: the expression sizeof ( int ) * p is unambiguously interpreted as ( sizeof ( int ) ) * p , but not sizeof ( ( int ) * p ) . ↑ The expression in the middle of the conditional operator (between ? and : ) is parsed as if parenthesized: its precedence relative to ?: is ignored. When parsing an expression, an operator which is listed on some row of the table above with a precedence will be bound tighter (as if by parentheses) to its arguments than any operator that is listed on a row further below it with a lower precedence. For example, the expressions std:: cout << a & b and * p ++ are parsed as ( std:: cout << a ) & b and * ( p ++ ) , and not as std:: cout << ( a & b ) or ( * p ) ++ . Operators that have the same precedence are bound to their arguments in the direction of their associativity. For example, the expression a = b = c is parsed as a = ( b = c ) , and not as ( a = b ) = c because of right-to-left associativity of assignment, but a + b - c is parsed ( a + b ) - c and not a + ( b - c ) because of left-to-right associativity of addition and subtraction. Associativity specification is redundant for unary operators and is only shown for completeness: unary prefix operators always associate right-to-left ( delete ++* p is delete ( ++ ( * p ) ) ) and unary postfix operators always associate left-to-right ( a [ 1 ] [ 2 ] ++ is ( ( a [ 1 ] ) [ 2 ] ) ++ ). Note that the associativity is meaningful for member access operators, even though they are grouped with unary postfix operators: a. b ++ is parsed ( a. b ) ++ and not a. ( b ++ ) . Operator precedence is unaffected by operator overloading . For example, std:: cout << a ? b : c ; parses as ( std:: cout << a ) ? b : c ; because the precedence of arithmetic left shift is higher than the conditional operator. [ edit ] Notes Precedence and associativity are compile-time concepts and are independent from order of evaluation , which is a runtime concept. The standard itself doesn't specify precedence levels. They are derived from the grammar. const_cast , static_cast , dynamic_cast , reinterpret_cast , typeid , sizeof... , noexcept and alignof are not included since they are never ambiguous. Some of the operators have alternate spellings (e.g., and for && , or for || , not for ! , etc.). In C, the ternary conditional operator has higher precedence than assignment operators. Therefore, the expression e = a < d ? a ++ : a = d , which is parsed in C++ as e = ( ( a < d ) ? ( a ++ ) : ( a = d ) ) , will fail to compile in C due to grammatical or semantic constraints in C. See the corresponding C page for details. [ edit ] See also Common operators assignment increment decrement arithmetic logical comparison member access other a = b a + = b a - = b a * = b a / = b a % = b a & = b a | = b a ^ = b a <<= b a >>= b ++ a -- a a ++ a -- + a - a a + b a - b a * b a / b a % b ~a a & b a | b a ^ b a << b a >> b ! a a && b a || b a == b a ! = b a < b a > b a <= b a >= b a <=> b a [ ... ] * a & a a - > b a. b a - > * b a. * b function call a ( ... ) comma a, b conditional a ? b : c Special operators static_cast converts one type to another related type dynamic_cast converts within inheritance hierarchies const_cast adds or removes cv -qualifiers reinterpret_cast converts type to unrelated type C-style cast converts one type to another by a mix of static_cast , const_cast , and reinterpret_cast new creates objects with dynamic storage duration delete destructs objects previously created by the new expression and releases obtained memory area sizeof queries the size of a type sizeof... queries the size of a pack (since C++11) typeid queries the type information of a type noexcept checks if an expression can throw an exception (since C++11) alignof queries alignment requirements of a type (since C++11) C documentation for C operator precedence Retrieved from " https://en.cppreference.com/mwiki/index.php?title=cpp/language/operator_precedence&oldid=178769 " Navigation Support us Recent changes FAQ Offline version Toolbox What links here Related changes Upload file Special pages Printable version Permanent link Page information In other languages العربية Česky Deutsch Español Français Italiano 日本語 한국어 Português Русский Türkçe 中文 This page was last modified on 24 December 2024, at 20:20. Privacy policy About cppreference.com Disclaimers