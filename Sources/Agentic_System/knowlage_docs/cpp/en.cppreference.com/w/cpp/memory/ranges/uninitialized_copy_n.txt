std::ranges::uninitialized_copy_n, std::ranges::uninitialized_copy_n_result - cppreference.com cppreference.com Create account Log in Namespaces Page Discussion Variants Views View Edit History Actions std::ranges:: uninitialized_copy_n, std::ranges:: uninitialized_copy_n_result From cppreference.com < cpp ‚Äé | memory C++ Compiler support Freestanding and hosted Language Standard library Standard library headers Named requirements Feature test macros (C++20) Language support library Concepts library (C++20) Diagnostics library Memory management library Metaprogramming library (C++11) General utilities library Containers library Iterators library Ranges library (C++20) Algorithms library Strings library Text processing library Numerics library Date and time library Input/output library Filesystem library (C++17) Concurrency support library (C++11) Execution control library (C++26) Technical specifications Symbols index External libraries [edit] Memory management library voidify ( exposition only* ) Allocators allocator allocator_traits (C++11) allocation_result (C++23) scoped_allocator_adaptor (C++11) pmr::polymorphic_allocator (C++17) allocator_arg (C++11) uses_allocator (C++11) uses_allocator_construction_args (C++20) make_obj_using_allocator (C++20) uninitialized_construct_using_allocator (C++20) Uninitialized memory algorithms uninitialized_copy uninitialized_fill uninitialized_move (C++17) uninitialized_copy_n (C++11) uninitialized_fill_n uninitialized_move_n (C++17) construct_at (C++20) uninitialized_default_construct (C++17) uninitialized_value_construct (C++17) destroy (C++17) uninitialized_default_construct_n (C++17) uninitialized_value_construct_n (C++17) destroy_n (C++17) destroy_at (C++17) Constrained uninitialized memory algorithms ranges::uninitialized_copy (C++20) ranges::uninitialized_fill (C++20) ranges::uninitialized_move (C++20) ranges::uninitialized_copy_n (C++20) ranges::uninitialized_fill_n (C++20) ranges::uninitialized_move_n (C++20) ranges::construct_at (C++20) ranges::uninitialized_default_construct (C++20) ranges::uninitialized_value_construct (C++20) ranges::destroy (C++20) ranges::uninitialized_default_construct_n (C++20) ranges::uninitialized_value_construct_n (C++20) ranges::destroy_n (C++20) ranges::destroy_at (C++20) Memory resources pmr::memory_resource (C++17) pmr::get_default_resource (C++17) pmr::set_default_resource (C++17) pmr::new_delete_resource (C++17) pmr::pool_options (C++17) pmr::null_memory_resource (C++17) pmr::synchronized_pool_resource (C++17) pmr::unsynchronized_pool_resource (C++17) pmr::monotonic_buffer_resource (C++17) Explicit lifetime management start_lifetime_as (C++23) start_lifetime_as_array (C++23) Types for composite class design indirect (C++26) polymorphic (C++26) Uninitialized storage (until C++20) raw_storage_iterator ( until C++20* ) get_temporary_buffer ( until C++20* ) return_temporary_buffer ( until C++20* ) Garbage collector support (until C++23) declare_reachable (C++11) (until C++23) declare_no_pointers (C++11) (until C++23) pointer_safety (C++11) (until C++23) undeclare_reachable (C++11) (until C++23) undeclare_no_pointers (C++11) (until C++23) get_pointer_safety (C++11) (until C++23) Low level memory management operator new operator new[] operator delete operator delete[] nothrow_t nothrow new_handler set_new_handler get_new_handler (C++11) bad_alloc bad_array_new_length (C++11) align_val_t (C++17) destroying_delete_t (C++20) launder (C++17) Smart pointers unique_ptr (C++11) shared_ptr (C++11) weak_ptr (C++11) auto_ptr ( until C++17* ) owner_less (C++11) owner_less<void> (C++17) owner_hash (C++26) owner_equal (C++26) enable_shared_from_this (C++11) bad_weak_ptr (C++11) default_delete (C++11) out_ptr_t (C++23) inout_ptr_t (C++23) Miscellaneous pointer_traits (C++11) to_address (C++20) addressof (C++11) align (C++11) assume_aligned (C++20) is_sufficiently_aligned (C++26) C Library malloc calloc realloc free aligned_alloc (C++17) [edit] Defined in header <memory> Call signature template < std:: input_iterator I, no-throw-input-iterator O, no - throw - sentinel - for < O > S > requires std:: constructible_from < std:: iter_value_t < O > , std:: iter_reference_t < I >> uninitialized_copy_n_result < I, O > uninitialized_copy_n ( I ifirst, std:: iter_difference_t < I > count, O ofirst, S olast ) ; (1) (since C++20) (constexpr since C++26) Helper types template < class I, class O > using uninitialized_copy_n_result = ranges:: in_out_result < I, O > ; (2) (since C++20) Let \(\scriptsize N\) N be ranges:: min ( count, ranges:: distance ( ofirst, olast ) ) . Copies \(\scriptsize N\) N elements from the range beginning at ifirst to an uninitialized memory area [ ofirst , olast ) as if by auto ret = ranges:: uninitialized_copy ( std:: counted_iterator ( std :: move ( ifirst ) , count ) , std:: default_sentinel , ofirst, olast ) ; return { std :: move ( ret. in ) . base ( ) , ret. out } ; If an exception is thrown during the initialization, the objects already constructed are destroyed in an unspecified order. If [ ofirst , olast ) overlaps with ifirst + [ ‚Äã 0 ‚Äã , count ) , the behavior is undefined. The function-like entities described on this page are algorithm function objects (informally known as niebloids ), that is: Explicit template argument lists cannot be specified when calling any of them. None of them are visible to argument-dependent lookup . When any of them are found by normal unqualified lookup as the name to the left of the function-call operator, argument-dependent lookup is inhibited. Contents 1 Parameters 2 Return value 3 Complexity 4 Exceptions 5 Notes 6 Possible implementation 7 Example 8 See also [ edit ] Parameters ifirst - the beginning of the range of elements to copy from count - the number of elements to copy ofirst, olast - the iterator-sentinel pair defining the destination range of elements [ edit ] Return value As described above. [ edit ] Complexity \(\scriptsize\mathcal{O}(N)\) ùìû(N) . [ edit ] Exceptions Any exception thrown on construction of the elements in the destination range. [ edit ] Notes An implementation may improve the efficiency of the ranges::uninitialized_copy_n , by using e.g. ranges::copy_n , if the value type of the output range is TrivialType . Feature-test macro Value Std Feature __cpp_lib_raw_memory_algorithms 202411L (C++26) constexpr for specialized memory algorithms , ( 1 ) [ edit ] Possible implementation struct uninitialized_copy_n_fn { template < std:: input_iterator I, no-throw-input-iterator O, no - throw - sentinel - for < O > S > requires std:: constructible_from < std:: iter_value_t < O > , std:: iter_reference_t < I >> constexpr ranges :: uninitialized_copy_n_result < I, O > operator ( ) ( I ifirst, std:: iter_difference_t < I > count, O ofirst, S olast ) const { auto iter = std:: counted_iterator ( std :: move ( ifirst ) , count ) ; auto ret = ranges:: uninitialized_copy ( iter, std:: default_sentinel , ofirst, olast ) ; return { std :: move ( ret. in ) . base ( ) , ret. out } ; } } ; inline constexpr uninitialized_copy_n_fn uninitialized_copy_n { } ; [ edit ] Example Run this code #include <iomanip> #include <iostream> #include <memory> #include <string> int main ( ) { const char * stars [ ] { "Procyon" , "Spica" , "Pollux" , "Deneb" , "Polaris" } ; constexpr int n { 4 } ; alignas ( alignof ( std:: string ) ) char out [ n * sizeof ( std:: string ) ] ; try { auto first { reinterpret_cast < std:: string * > ( out ) } ; auto last { first + n } ; auto ret { std :: ranges :: uninitialized_copy_n ( std:: begin ( stars ) , n, first, last ) } ; std:: cout << '{' ; for ( auto it { first } ; it ! = ret. out ; ++ it ) std:: cout << ( it == first ? "" : ", " ) << std:: quoted ( * it ) ; std:: cout << "}; \n " ; std :: ranges:: destroy ( first, last ) ; } catch ( ... ) { std:: cout << "uninitialized_copy_n exception \n " ; } } Output: {"Procyon", "Spica", "Pollux", "Deneb"}; [ edit ] See also ranges::uninitialized_copy (C++20) copies a range of objects to an uninitialized area of memory (algorithm function object) [edit] uninitialized_copy_n (C++11) copies a number of objects to an uninitialized area of memory (function template) [edit] Retrieved from " https://en.cppreference.com/mwiki/index.php?title=cpp/memory/ranges/uninitialized_copy_n&oldid=180691 " Navigation Support us Recent changes FAQ Offline version Toolbox What links here Related changes Upload file Special pages Printable version Permanent link Page information In other languages Deutsch Espa√±ol Fran√ßais Italiano Êó•Êú¨Ë™û Portugu√™s –†—É—Å—Å–∫–∏–π ‰∏≠Êñá This page was last modified on 15 February 2025, at 00:45. Privacy policy About cppreference.com Disclaimers