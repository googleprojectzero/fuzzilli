std::raw_storage_iterator - cppreference.com cppreference.com Create account Log in Namespaces Page Discussion Variants Views View Edit History Actions std:: raw_storage_iterator From cppreference.com < cpp ‎ | memory C++ Compiler support Freestanding and hosted Language Standard library Standard library headers Named requirements Feature test macros (C++20) Language support library Concepts library (C++20) Diagnostics library Memory management library Metaprogramming library (C++11) General utilities library Containers library Iterators library Ranges library (C++20) Algorithms library Strings library Text processing library Numerics library Date and time library Input/output library Filesystem library (C++17) Concurrency support library (C++11) Execution control library (C++26) Technical specifications Symbols index External libraries [edit] Memory management library voidify ( exposition only* ) Allocators allocator allocator_traits (C++11) allocation_result (C++23) scoped_allocator_adaptor (C++11) pmr::polymorphic_allocator (C++17) allocator_arg (C++11) uses_allocator (C++11) uses_allocator_construction_args (C++20) make_obj_using_allocator (C++20) uninitialized_construct_using_allocator (C++20) Uninitialized memory algorithms uninitialized_copy uninitialized_fill uninitialized_move (C++17) uninitialized_copy_n (C++11) uninitialized_fill_n uninitialized_move_n (C++17) construct_at (C++20) uninitialized_default_construct (C++17) uninitialized_value_construct (C++17) destroy (C++17) uninitialized_default_construct_n (C++17) uninitialized_value_construct_n (C++17) destroy_n (C++17) destroy_at (C++17) Constrained uninitialized memory algorithms ranges::uninitialized_copy (C++20) ranges::uninitialized_fill (C++20) ranges::uninitialized_move (C++20) ranges::uninitialized_copy_n (C++20) ranges::uninitialized_fill_n (C++20) ranges::uninitialized_move_n (C++20) ranges::construct_at (C++20) ranges::uninitialized_default_construct (C++20) ranges::uninitialized_value_construct (C++20) ranges::destroy (C++20) ranges::uninitialized_default_construct_n (C++20) ranges::uninitialized_value_construct_n (C++20) ranges::destroy_n (C++20) ranges::destroy_at (C++20) Memory resources pmr::memory_resource (C++17) pmr::get_default_resource (C++17) pmr::set_default_resource (C++17) pmr::new_delete_resource (C++17) pmr::pool_options (C++17) pmr::null_memory_resource (C++17) pmr::synchronized_pool_resource (C++17) pmr::unsynchronized_pool_resource (C++17) pmr::monotonic_buffer_resource (C++17) Explicit lifetime management start_lifetime_as (C++23) start_lifetime_as_array (C++23) Types for composite class design indirect (C++26) polymorphic (C++26) Uninitialized storage (until C++20) raw_storage_iterator ( until C++20* ) get_temporary_buffer ( until C++20* ) return_temporary_buffer ( until C++20* ) Garbage collector support (until C++23) declare_reachable (C++11) (until C++23) declare_no_pointers (C++11) (until C++23) pointer_safety (C++11) (until C++23) undeclare_reachable (C++11) (until C++23) undeclare_no_pointers (C++11) (until C++23) get_pointer_safety (C++11) (until C++23) Low level memory management operator new operator new[] operator delete operator delete[] nothrow_t nothrow new_handler set_new_handler get_new_handler (C++11) bad_alloc bad_array_new_length (C++11) align_val_t (C++17) destroying_delete_t (C++20) launder (C++17) Smart pointers unique_ptr (C++11) shared_ptr (C++11) weak_ptr (C++11) auto_ptr ( until C++17* ) owner_less (C++11) owner_less<void> (C++17) owner_hash (C++26) owner_equal (C++26) enable_shared_from_this (C++11) bad_weak_ptr (C++11) default_delete (C++11) out_ptr_t (C++23) inout_ptr_t (C++23) Miscellaneous pointer_traits (C++11) to_address (C++20) addressof (C++11) align (C++11) assume_aligned (C++20) is_sufficiently_aligned (C++26) C Library malloc calloc realloc free aligned_alloc (C++17) [edit] std::raw_storage_iterator Member functions raw_storage_iterator::raw_storage_iterator raw_storage_iterator::operator= raw_storage_iterator::operator* raw_storage_iterator::base (C++17) raw_storage_iterator::operator++ raw_storage_iterator::operator++(int) [edit] Defined in header <memory> template < class OutputIt, class T > class raw_storage_iterator : public std:: iterator < std:: output_iterator_tag , void , void , void , void > ; (until C++17) template < class OutputIt, class T > class raw_storage_iterator ; (since C++17) (deprecated in C++17) (removed in C++20) The output iterator std::raw_storage_iterator makes it possible for standard algorithms to store results in uninitialized memory. Whenever the algorithm writes an object of type T to the dereferenced iterator, the object is copy-constructed into the location in the uninitialized storage pointed to by the iterator. The template parameter OutputIt is any type that meets the requirements of LegacyOutputIterator and has operator * defined to return an object, for which operator & returns an object of type T* . Usually, the type T* is used as OutputIt . Contents 1 Type requirements 2 Member functions 3 Member types 4 Note 5 Example 6 See also [ edit ] Type requirements - OutputIt must meet the requirements of LegacyOutputIterator . [ edit ] Member functions (constructor) creates a new raw_storage_iterator (public member function) [edit] operator= constructs an object at the pointed-to location in the buffer (public member function) [edit] operator* dereferences the iterator (public member function) [edit] operator++ operator++ (int) advances the iterator (public member function) [edit] base (since C++17) provides access to the wrapped iterator (public member function) [edit] [ edit ] Member types Member type Definition iterator_category std:: output_iterator_tag value_type void difference_type void (until C++20) std::ptrdiff_t (since C++20) pointer void reference void Member types iterator_category , value_type , difference_type , pointer and reference are required to be obtained by inheriting from std:: iterator < std:: output_iterator_tag , void , void , void , void > . (until C++17) [ edit ] Note std::raw_storage_iterator was deprecated primarily because of its exception-unsafe behavior. Unlike std::uninitialized_copy , it doesn't handle exceptions during operations like std::copy safely, potentially leading to resource leaks due to a lack of tracking the number of successfully constructed objects and their proper destruction in the presence of exceptions. [ edit ] Example Run this code #include <algorithm> #include <iostream> #include <memory> #include <string> int main ( ) { const std:: string s [ ] = { "This" , "is" , "a" , "test" , "." } ; std:: string * p = std:: allocator < std:: string > ( ) . allocate ( 5 ) ; std:: copy ( std:: begin ( s ) , std:: end ( s ) , std :: raw_storage_iterator < std:: string * , std:: string > ( p ) ) ; for ( std:: string * i = p ; i ! = p + 5 ; ++ i ) { std:: cout << * i << ' \n ' ; i - > ~basic_string < char > ( ) ; } std:: allocator < std:: string > ( ) . deallocate ( p, 5 ) ; } Output: This is a test . [ edit ] See also allocator_traits (C++11) provides information about allocator types (class template) [edit] scoped_allocator_adaptor (C++11) implements multi-level allocator for multi-level containers (class template) [edit] uses_allocator (C++11) checks if the specified type supports uses-allocator construction (class template) [edit] Retrieved from " https://en.cppreference.com/mwiki/index.php?title=cpp/memory/raw_storage_iterator&oldid=161197 " Navigation Support us Recent changes FAQ Offline version Toolbox What links here Related changes Upload file Special pages Printable version Permanent link Page information In other languages Deutsch Español Français Italiano 日本語 Português Русский 中文 This page was last modified on 23 October 2023, at 02:09. Privacy policy About cppreference.com Disclaimers