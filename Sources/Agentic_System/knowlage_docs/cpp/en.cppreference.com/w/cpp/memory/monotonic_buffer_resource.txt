std::pmr::monotonic_buffer_resource - cppreference.com cppreference.com Create account Log in Namespaces Page Discussion Variants Views View Edit History Actions std::pmr:: monotonic_buffer_resource From cppreference.com < cpp ‎ | memory C++ Compiler support Freestanding and hosted Language Standard library Standard library headers Named requirements Feature test macros (C++20) Language support library Concepts library (C++20) Diagnostics library Memory management library Metaprogramming library (C++11) General utilities library Containers library Iterators library Ranges library (C++20) Algorithms library Strings library Text processing library Numerics library Date and time library Input/output library Filesystem library (C++17) Concurrency support library (C++11) Execution control library (C++26) Technical specifications Symbols index External libraries [edit] Memory management library voidify ( exposition only* ) Allocators allocator allocator_traits (C++11) allocation_result (C++23) scoped_allocator_adaptor (C++11) pmr::polymorphic_allocator (C++17) allocator_arg (C++11) uses_allocator (C++11) uses_allocator_construction_args (C++20) make_obj_using_allocator (C++20) uninitialized_construct_using_allocator (C++20) Uninitialized memory algorithms uninitialized_copy uninitialized_fill uninitialized_move (C++17) uninitialized_copy_n (C++11) uninitialized_fill_n uninitialized_move_n (C++17) construct_at (C++20) uninitialized_default_construct (C++17) uninitialized_value_construct (C++17) destroy (C++17) uninitialized_default_construct_n (C++17) uninitialized_value_construct_n (C++17) destroy_n (C++17) destroy_at (C++17) Constrained uninitialized memory algorithms ranges::uninitialized_copy (C++20) ranges::uninitialized_fill (C++20) ranges::uninitialized_move (C++20) ranges::uninitialized_copy_n (C++20) ranges::uninitialized_fill_n (C++20) ranges::uninitialized_move_n (C++20) ranges::construct_at (C++20) ranges::uninitialized_default_construct (C++20) ranges::uninitialized_value_construct (C++20) ranges::destroy (C++20) ranges::uninitialized_default_construct_n (C++20) ranges::uninitialized_value_construct_n (C++20) ranges::destroy_n (C++20) ranges::destroy_at (C++20) Memory resources pmr::memory_resource (C++17) pmr::get_default_resource (C++17) pmr::set_default_resource (C++17) pmr::new_delete_resource (C++17) pmr::pool_options (C++17) pmr::null_memory_resource (C++17) pmr::synchronized_pool_resource (C++17) pmr::unsynchronized_pool_resource (C++17) pmr::monotonic_buffer_resource (C++17) Explicit lifetime management start_lifetime_as (C++23) start_lifetime_as_array (C++23) Types for composite class design indirect (C++26) polymorphic (C++26) Uninitialized storage (until C++20) raw_storage_iterator ( until C++20* ) get_temporary_buffer ( until C++20* ) return_temporary_buffer ( until C++20* ) Garbage collector support (until C++23) declare_reachable (C++11) (until C++23) declare_no_pointers (C++11) (until C++23) pointer_safety (C++11) (until C++23) undeclare_reachable (C++11) (until C++23) undeclare_no_pointers (C++11) (until C++23) get_pointer_safety (C++11) (until C++23) Low level memory management operator new operator new[] operator delete operator delete[] nothrow_t nothrow new_handler set_new_handler get_new_handler (C++11) bad_alloc bad_array_new_length (C++11) align_val_t (C++17) destroying_delete_t (C++20) launder (C++17) Smart pointers unique_ptr (C++11) shared_ptr (C++11) weak_ptr (C++11) auto_ptr ( until C++17* ) owner_less (C++11) owner_less<void> (C++17) owner_hash (C++26) owner_equal (C++26) enable_shared_from_this (C++11) bad_weak_ptr (C++11) default_delete (C++11) out_ptr_t (C++23) inout_ptr_t (C++23) Miscellaneous pointer_traits (C++11) to_address (C++20) addressof (C++11) align (C++11) assume_aligned (C++20) is_sufficiently_aligned (C++26) C Library malloc calloc realloc free aligned_alloc (C++17) [edit] std::pmr::monotonic_buffer_resource monotonic_buffer_resource::monotonic_buffer_resource monotonic_buffer_resource::~monotonic_buffer_resource Public member functions monotonic_buffer_resource::release monotonic_buffer_resource::upstream_resource Protected member functions monotonic_buffer_resource::do_allocate monotonic_buffer_resource::do_deallocate monotonic_buffer_resource::do_is_equal [edit] Defined in header <memory_resource> class monotonic_buffer_resource : public std:: pmr :: memory_resource ; (since C++17) The class std::pmr::monotonic_buffer_resource is a special-purpose memory resource class that releases the allocated memory only when the resource is destroyed. It is intended for very fast memory allocations in situations where memory is used to build up a few objects and then is released all at once. monotonic_buffer_resource can be constructed with an initial buffer. If there is no initial buffer, or if the buffer is exhausted, additional buffers are obtained from an upstream memory resource supplied at construction. The size of buffers obtained follows a geometric progression. monotonic_buffer_resource is not thread-safe. Contents 1 Member functions 1.1 Public member functions 1.2 Protected member functions 2 Example [ edit ] Member functions (constructor) constructs a monotonic_buffer_resource (public member function) [edit] (destructor) [virtual] destroys a monotonic_buffer_resource , releasing all allocated memory (virtual public member function) [edit] operator= [deleted] copy assignment operator is deleted. monotonic_buffer_resource is not copy assignable (public member function) [edit] Public member functions release release all allocated memory (public member function) [edit] upstream_resource returns a pointer to the upstream memory resource (public member function) [edit] Protected member functions do_allocate [virtual] allocate memory (virtual protected member function) [edit] do_deallocate [virtual] no-op (virtual protected member function) [edit] do_is_equal [virtual] compare for equality with another std::pmr::memory_resource (virtual protected member function) [edit] [ edit ] Example The program measures the time of creating huge double-linked lists using the following allocators: default standard allocator, default pmr allocator, pmr allocator with monotonic resource but without explicit memory buffer, pmr allocator with monotonic resource and external memory buffer (on stack). Run this code #include <array> #include <chrono> #include <cstddef> #include <iomanip> #include <iostream> #include <list> #include <memory_resource> template < typename Func > auto benchmark ( Func test_func, int iterations ) { const auto start = std:: chrono :: system_clock :: now ( ) ; while ( iterations -- > 0 ) test_func ( ) ; const auto stop = std:: chrono :: system_clock :: now ( ) ; const auto secs = std:: chrono :: duration < double > ( stop - start ) ; return secs. count ( ) ; } int main ( ) { constexpr int iterations { 100 } ; constexpr int total_nodes { 2 '00' 000 } ; auto default_std_alloc = [ total_nodes ] { std:: list < int > list ; for ( int i { } ; i ! = total_nodes ; ++ i ) list. push_back ( i ) ; } ; auto default_pmr_alloc = [ total_nodes ] { std:: pmr :: list < int > list ; for ( int i { } ; i ! = total_nodes ; ++ i ) list. push_back ( i ) ; } ; auto pmr_alloc_no_buf = [ total_nodes ] { std :: pmr :: monotonic_buffer_resource mbr ; std:: pmr :: polymorphic_allocator < int > pa { & mbr } ; std:: pmr :: list < int > list { pa } ; for ( int i { } ; i ! = total_nodes ; ++ i ) list. push_back ( i ) ; } ; auto pmr_alloc_and_buf = [ total_nodes ] { std:: array < std:: byte , total_nodes * 32 > buffer ; // enough to fit in all nodes std :: pmr :: monotonic_buffer_resource mbr { buffer. data ( ) , buffer. size ( ) } ; std:: pmr :: polymorphic_allocator < int > pa { & mbr } ; std:: pmr :: list < int > list { pa } ; for ( int i { } ; i ! = total_nodes ; ++ i ) list. push_back ( i ) ; } ; const double t1 = benchmark ( default_std_alloc, iterations ) ; const double t2 = benchmark ( default_pmr_alloc, iterations ) ; const double t3 = benchmark ( pmr_alloc_no_buf , iterations ) ; const double t4 = benchmark ( pmr_alloc_and_buf, iterations ) ; std:: cout << std:: fixed << std:: setprecision ( 3 ) << "t1 (default std alloc): " << t1 << " sec; t1/t1: " << t1 / t1 << ' \n ' << "t2 (default pmr alloc): " << t2 << " sec; t1/t2: " << t1 / t2 << ' \n ' << "t3 (pmr alloc no buf): " << t3 << " sec; t1/t3: " << t1 / t3 << ' \n ' << "t4 (pmr alloc and buf): " << t4 << " sec; t1/t4: " << t1 / t4 << ' \n ' ; } Possible output: t1 (default std alloc): 0.720 sec; t1/t1: 1.000 t2 (default pmr alloc): 0.915 sec; t1/t2: 0.787 t3 (pmr alloc no buf): 0.370 sec; t1/t3: 1.945 t4 (pmr alloc and buf): 0.247 sec; t1/t4: 2.914 Retrieved from " https://en.cppreference.com/mwiki/index.php?title=cpp/memory/monotonic_buffer_resource&oldid=152966 " Navigation Support us Recent changes FAQ Offline version Toolbox What links here Related changes Upload file Special pages Printable version Permanent link Page information In other languages Deutsch Español 日本語 Русский 中文 This page was last modified on 8 June 2023, at 00:21. Privacy policy About cppreference.com Disclaimers