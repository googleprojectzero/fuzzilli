std::pointer_traits - cppreference.com cppreference.com Create account Log in Namespaces Page Discussion Variants Views View Edit History Actions std:: pointer_traits From cppreference.com < cpp ‎ | memory C++ Compiler support Freestanding and hosted Language Standard library Standard library headers Named requirements Feature test macros (C++20) Language support library Concepts library (C++20) Diagnostics library Memory management library Metaprogramming library (C++11) General utilities library Containers library Iterators library Ranges library (C++20) Algorithms library Strings library Text processing library Numerics library Date and time library Input/output library Filesystem library (C++17) Concurrency support library (C++11) Execution control library (C++26) Technical specifications Symbols index External libraries [edit] Memory management library voidify ( exposition only* ) Allocators allocator allocator_traits (C++11) allocation_result (C++23) scoped_allocator_adaptor (C++11) pmr::polymorphic_allocator (C++17) allocator_arg (C++11) uses_allocator (C++11) uses_allocator_construction_args (C++20) make_obj_using_allocator (C++20) uninitialized_construct_using_allocator (C++20) Uninitialized memory algorithms uninitialized_copy uninitialized_fill uninitialized_move (C++17) uninitialized_copy_n (C++11) uninitialized_fill_n uninitialized_move_n (C++17) construct_at (C++20) uninitialized_default_construct (C++17) uninitialized_value_construct (C++17) destroy (C++17) uninitialized_default_construct_n (C++17) uninitialized_value_construct_n (C++17) destroy_n (C++17) destroy_at (C++17) Constrained uninitialized memory algorithms ranges::uninitialized_copy (C++20) ranges::uninitialized_fill (C++20) ranges::uninitialized_move (C++20) ranges::uninitialized_copy_n (C++20) ranges::uninitialized_fill_n (C++20) ranges::uninitialized_move_n (C++20) ranges::construct_at (C++20) ranges::uninitialized_default_construct (C++20) ranges::uninitialized_value_construct (C++20) ranges::destroy (C++20) ranges::uninitialized_default_construct_n (C++20) ranges::uninitialized_value_construct_n (C++20) ranges::destroy_n (C++20) ranges::destroy_at (C++20) Memory resources pmr::memory_resource (C++17) pmr::get_default_resource (C++17) pmr::set_default_resource (C++17) pmr::new_delete_resource (C++17) pmr::pool_options (C++17) pmr::null_memory_resource (C++17) pmr::synchronized_pool_resource (C++17) pmr::unsynchronized_pool_resource (C++17) pmr::monotonic_buffer_resource (C++17) Explicit lifetime management start_lifetime_as (C++23) start_lifetime_as_array (C++23) Types for composite class design indirect (C++26) polymorphic (C++26) Uninitialized storage (until C++20) raw_storage_iterator ( until C++20* ) get_temporary_buffer ( until C++20* ) return_temporary_buffer ( until C++20* ) Garbage collector support (until C++23) declare_reachable (C++11) (until C++23) declare_no_pointers (C++11) (until C++23) pointer_safety (C++11) (until C++23) undeclare_reachable (C++11) (until C++23) undeclare_no_pointers (C++11) (until C++23) get_pointer_safety (C++11) (until C++23) Low level memory management operator new operator new[] operator delete operator delete[] nothrow_t nothrow new_handler set_new_handler get_new_handler (C++11) bad_alloc bad_array_new_length (C++11) align_val_t (C++17) destroying_delete_t (C++20) launder (C++17) Smart pointers unique_ptr (C++11) shared_ptr (C++11) weak_ptr (C++11) auto_ptr ( until C++17* ) owner_less (C++11) owner_less<void> (C++17) owner_hash (C++26) owner_equal (C++26) enable_shared_from_this (C++11) bad_weak_ptr (C++11) default_delete (C++11) out_ptr_t (C++23) inout_ptr_t (C++23) Miscellaneous pointer_traits (C++11) to_address (C++20) addressof (C++11) align (C++11) assume_aligned (C++20) is_sufficiently_aligned (C++26) C Library malloc calloc realloc free aligned_alloc (C++17) [edit] std::pointer_traits Member functions pointer_traits::pointer_to (C++11) pointer_traits::to_address (C++20) (optional) [edit] Defined in header <memory> template < class Ptr > struct pointer_traits ; (1) (since C++11) template < class T > struct pointer_traits < T * > ; (2) (since C++11) The pointer_traits class template provides the standardized way to access certain properties of pointer-like types ( fancy pointers , such as boost::interprocess::offset_ptr ). The standard template std::allocator_traits relies on pointer_traits to determine the defaults for various typedefs required by Allocator . 1) The non-specialized pointer_traits conditionally declares the following members: Let /*element-type-of*/ < Ptr > be Ptr :: element_type if present; otherwise, T if Ptr is a class template specialization Template < T, Args... > , where Args... is zero or more type arguments; otherwise, not defined. If /*element-type-of*/ < Ptr > is not defined, the primary template has no members specified in this page. Contents 1 Member types 2 Member alias templates 3 Member functions 4 Member types 5 Member alias templates 6 Member functions 7 Optional member functions of program-defined specializations 8 Notes 9 Example 10 Defect reports 11 See also [ edit ] Member types Type Definition pointer Ptr element_type /*element-type-of*/ < Ptr > difference_type Ptr :: difference_type if present, otherwise std::ptrdiff_t [ edit ] Member alias templates Template Definition template < class U > using rebind Ptr :: rebind < U > if exists, otherwise Template < U, Args... > if Ptr is a template specialization Template < T, Args... > [ edit ] Member functions pointer_to [static] obtains a dereferenceable pointer to its argument (public static member function) [edit] 2) A specialization is provided for pointer types, T * , which declares the following members: [ edit ] Member types Type Definition pointer T * element_type T difference_type std::ptrdiff_t [ edit ] Member alias templates Template Definition template < class U > using rebind U * [ edit ] Member functions pointer_to [static] obtains a dereferenceable pointer to its argument (public static member function) [edit] [ edit ] Optional member functions of program-defined specializations to_address [static] (C++20) (optional) obtains a raw pointer from a fancy pointer (inverse of pointer_to ) (public static member function) [edit] [ edit ] Notes The rebind member template alias makes it possible, given a pointer-like type that points to T , to obtain the same pointer-like type that points to U . For example, using another_pointer = std :: pointer_traits < std:: shared_ptr < int >> :: rebind < double > ; static_assert ( std:: is_same < another_pointer, std:: shared_ptr < double >> :: value ) ; A specialization for user-defined fancy pointer types may provide an additional static member function to_address to customize the behavior of std::to_address . (since C++20) Feature-test macro Value Std Feature __cpp_lib_constexpr_memory 201811L (C++20) constexpr in std::pointer_traits [ edit ] Example Run this code #include <iostream> #include <memory> template < class Ptr > struct BlockList { // Predefine a memory block struct block ; // Define a pointer to a memory block from the kind of pointer Ptr s // If Ptr is any kind of T*, block_ptr_t is block* // If Ptr is smart_ptr<T>, block_ptr_t is smart_ptr<block> using block_ptr_t = typename std :: pointer_traits < Ptr > :: template rebind < block > ; struct block { std:: size_t size { } ; block_ptr_t next_block { } ; } ; block_ptr_t free_blocks ; } ; int main ( ) { [ [ maybe_unused ] ] BlockList < int * > bl1 ; // The type of bl1.free_blocks is BlockList<int*>:: block* BlockList < std:: shared_ptr < char >> bl2 ; // The type of bl2.free_blocks is // std::shared_ptr<BlockList<std::shared_ptr<char>>::block> std:: cout << bl2. free_blocks . use_count ( ) << ' \n ' ; } Output: ​0​ [ edit ] Defect reports The following behavior-changing defect reports were applied retroactively to previously published C++ standards. DR Applied to Behavior as published Correct behavior LWG 3545 C++11 primary template caused hard error when element_type is invalid made SFINAE-friendly [ edit ] See also allocator_traits (C++11) provides information about allocator types (class template) [edit] addressof (C++11) obtains actual address of an object, even if the & operator is overloaded (function template) [edit] Retrieved from " https://en.cppreference.com/mwiki/index.php?title=cpp/memory/pointer_traits&oldid=160243 " Navigation Support us Recent changes FAQ Offline version Toolbox What links here Related changes Upload file Special pages Printable version Permanent link Page information In other languages Deutsch Español Français Italiano 日本語 Português Русский 中文 This page was last modified on 6 October 2023, at 23:54. Privacy policy About cppreference.com Disclaimers