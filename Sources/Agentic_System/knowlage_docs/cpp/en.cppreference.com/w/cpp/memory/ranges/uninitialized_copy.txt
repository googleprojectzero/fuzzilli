std::ranges::uninitialized_copy, std::ranges::uninitialized_copy_result - cppreference.com cppreference.com Create account Log in Namespaces Page Discussion Variants Views View Edit History Actions std::ranges:: uninitialized_copy, std::ranges:: uninitialized_copy_result From cppreference.com < cpp ‚Äé | memory C++ Compiler support Freestanding and hosted Language Standard library Standard library headers Named requirements Feature test macros (C++20) Language support library Concepts library (C++20) Diagnostics library Memory management library Metaprogramming library (C++11) General utilities library Containers library Iterators library Ranges library (C++20) Algorithms library Strings library Text processing library Numerics library Date and time library Input/output library Filesystem library (C++17) Concurrency support library (C++11) Execution control library (C++26) Technical specifications Symbols index External libraries [edit] Memory management library voidify ( exposition only* ) Allocators allocator allocator_traits (C++11) allocation_result (C++23) scoped_allocator_adaptor (C++11) pmr::polymorphic_allocator (C++17) allocator_arg (C++11) uses_allocator (C++11) uses_allocator_construction_args (C++20) make_obj_using_allocator (C++20) uninitialized_construct_using_allocator (C++20) Uninitialized memory algorithms uninitialized_copy uninitialized_fill uninitialized_move (C++17) uninitialized_copy_n (C++11) uninitialized_fill_n uninitialized_move_n (C++17) construct_at (C++20) uninitialized_default_construct (C++17) uninitialized_value_construct (C++17) destroy (C++17) uninitialized_default_construct_n (C++17) uninitialized_value_construct_n (C++17) destroy_n (C++17) destroy_at (C++17) Constrained uninitialized memory algorithms ranges::uninitialized_copy (C++20) ranges::uninitialized_fill (C++20) ranges::uninitialized_move (C++20) ranges::uninitialized_copy_n (C++20) ranges::uninitialized_fill_n (C++20) ranges::uninitialized_move_n (C++20) ranges::construct_at (C++20) ranges::uninitialized_default_construct (C++20) ranges::uninitialized_value_construct (C++20) ranges::destroy (C++20) ranges::uninitialized_default_construct_n (C++20) ranges::uninitialized_value_construct_n (C++20) ranges::destroy_n (C++20) ranges::destroy_at (C++20) Memory resources pmr::memory_resource (C++17) pmr::get_default_resource (C++17) pmr::set_default_resource (C++17) pmr::new_delete_resource (C++17) pmr::pool_options (C++17) pmr::null_memory_resource (C++17) pmr::synchronized_pool_resource (C++17) pmr::unsynchronized_pool_resource (C++17) pmr::monotonic_buffer_resource (C++17) Explicit lifetime management start_lifetime_as (C++23) start_lifetime_as_array (C++23) Types for composite class design indirect (C++26) polymorphic (C++26) Uninitialized storage (until C++20) raw_storage_iterator ( until C++20* ) get_temporary_buffer ( until C++20* ) return_temporary_buffer ( until C++20* ) Garbage collector support (until C++23) declare_reachable (C++11) (until C++23) declare_no_pointers (C++11) (until C++23) pointer_safety (C++11) (until C++23) undeclare_reachable (C++11) (until C++23) undeclare_no_pointers (C++11) (until C++23) get_pointer_safety (C++11) (until C++23) Low level memory management operator new operator new[] operator delete operator delete[] nothrow_t nothrow new_handler set_new_handler get_new_handler (C++11) bad_alloc bad_array_new_length (C++11) align_val_t (C++17) destroying_delete_t (C++20) launder (C++17) Smart pointers unique_ptr (C++11) shared_ptr (C++11) weak_ptr (C++11) auto_ptr ( until C++17* ) owner_less (C++11) owner_less<void> (C++17) owner_hash (C++26) owner_equal (C++26) enable_shared_from_this (C++11) bad_weak_ptr (C++11) default_delete (C++11) out_ptr_t (C++23) inout_ptr_t (C++23) Miscellaneous pointer_traits (C++11) to_address (C++20) addressof (C++11) align (C++11) assume_aligned (C++20) is_sufficiently_aligned (C++26) C Library malloc calloc realloc free aligned_alloc (C++17) [edit] Defined in header <memory> Call signature template < std:: input_iterator I, std:: sentinel_for < I > S1, no-throw-forward-iterator O, no - throw - sentinel - for < O > S2 > requires std:: constructible_from < std:: iter_value_t < O > , std:: iter_reference_t < I >> uninitialized_copy_result < I, O > uninitialized_copy ( I ifirst, S1 ilast, O ofirst, S2 olast ) ; (1) (since C++20) (constexpr since C++26) template < ranges:: input_range IR, no-throw-forward-range OR > requires std:: constructible_from < ranges:: range_value_t < OR > , ranges:: range_reference_t < IR >> uninitialized_copy_result < ranges:: borrowed_iterator_t < IR > , ranges:: borrowed_iterator_t < OR >> uninitialized_copy ( IR && in_range, OR && out_range ) ; (2) (since C++20) (constexpr since C++26) Helper types template < class I, class O > using uninitialized_copy_result = ranges:: in_out_result < I, O > ; (3) (since C++20) Let \(\scriptsize N\) N be ranges:: min ( ranges:: distance ( ifirst, ilast ) , ranges:: distance ( ofirst, olast ) ) . 1) Constructs \(\scriptsize N\) N elements elements from the range [ ifirst , ilast ) to an uninitialized memory area [ ofirst , olast ) as if by for ( ; ifirst ! = ilast && ofirst ! = olast ; ++ ofirst, ( void ) ++ ifirst ) :: new ( voidify ( * ofirst ) ) std:: remove_reference_t < std:: iter_reference_t < O >> ( * ifirst ) ; return { std :: move ( ifirst ) , ofirst } ; If an exception is thrown during the initialization, the objects already constructed are destroyed in an unspecified order. If [ ofirst , olast ) overlaps with [ ifirst , ilast ) , the behavior is undefined. 2) Equivalent to return ranges :: uninitialized_copy ( ranges:: begin ( in_range ) , ranges:: end ( in_range ) , ranges:: begin ( out_range ) , ranges:: end ( out_range ) ) ; . The function-like entities described on this page are algorithm function objects (informally known as niebloids ), that is: Explicit template argument lists cannot be specified when calling any of them. None of them are visible to argument-dependent lookup . When any of them are found by normal unqualified lookup as the name to the left of the function-call operator, argument-dependent lookup is inhibited. Contents 1 Parameters 2 Return value 3 Complexity 4 Exceptions 5 Notes 6 Possible implementation 7 Example 8 Defect reports 9 See also [ edit ] Parameters ifirst, ilast - the iterator-sentinel pair defining the source range of elements to copy from in_range - the range of elements to copy from ofirst, olast - the iterator-sentinel pair defining the destination range of elements out_range - the destination range [ edit ] Return value As described above. [ edit ] Complexity \(\scriptsize\mathcal{O}(N)\) ùìû(N) . [ edit ] Exceptions Any exception thrown on construction of the elements in the destination range. [ edit ] Notes An implementation may improve the efficiency of ranges::uninitialized_copy if the value type of the output range is TrivialType . Feature-test macro Value Std Feature __cpp_lib_raw_memory_algorithms 202411L (C++26) constexpr for specialized memory algorithms , ( 1,2 ) [ edit ] Possible implementation struct uninitialized_copy_fn { template < std:: input_iterator I, std:: sentinel_for < I > S1, no-throw-forward-iterator O, no - throw - sentinel - for < O > S2 > requires std:: constructible_from < std:: iter_value_t < O > , std:: iter_reference_t < I >> constexpr ranges :: uninitialized_copy_result < I, O > operator ( ) ( I ifirst, S1 ilast, O ofirst, S2 olast ) const { O current { ofirst } ; try { for ( ; ! ( ifirst == ilast or current == olast ) ; ++ ifirst, ++ current ) ranges:: construct_at ( std:: addressof ( * current ) , * ifirst ) ; return { std :: move ( ifirst ) , std :: move ( current ) } ; } catch ( ... ) // rollback: destroy constructed elements { for ( ; ofirst ! = current ; ++ ofirst ) ranges:: destroy_at ( std:: addressof ( * ofirst ) ) ; throw ; } } template < ranges:: input_range IR, no-throw-forward-range OR > requires std:: constructible_from < ranges:: range_value_t < OR > , constexpr ranges:: range_reference_t < IR >> ranges :: uninitialized_copy_result < ranges:: borrowed_iterator_t < IR > , ranges:: borrowed_iterator_t < OR >> operator ( ) ( IR && in_range, OR && out_range ) const { return ( * this ) ( ranges:: begin ( in_range ) , ranges:: end ( in_range ) , ranges:: begin ( out_range ) , ranges:: end ( out_range ) ) ; } } ; inline constexpr uninitialized_copy_fn uninitialized_copy { } ; [ edit ] Example Run this code #include <cstdlib> #include <iomanip> #include <iostream> #include <memory> #include <string> int main ( ) { const char * v [ ] { "This" , "is" , "an" , "example" } ; if ( const auto sz { std:: size ( v ) } ; void * pbuf = std:: aligned_alloc ( alignof ( std:: string ) , sizeof ( std:: string ) * sz ) ) { try { auto first { static_cast < std:: string * > ( pbuf ) } ; auto last { first + sz } ; std :: ranges :: uninitialized_copy ( std:: begin ( v ) , std:: end ( v ) , first, last ) ; std:: cout << "{" ; for ( auto it { first } ; it ! = last ; ++ it ) std:: cout << ( it == first ? "" : ", " ) << std:: quoted ( * it ) ; std:: cout << "}; \n " ; std :: ranges:: destroy ( first, last ) ; } catch ( ... ) { std:: cout << "uninitialized_copy exception \n " ; } std:: free ( pbuf ) ; } } Output: {"This", "is", "an", "example"}; [ edit ] Defect reports The following behavior-changing defect reports were applied retroactively to previously published C++ standards. DR Applied to Behavior as published Correct behavior LWG 3870 C++20 this algorithm might create objects on a const storage kept disallowed [ edit ] See also ranges::uninitialized_copy_n (C++20) copies a number of objects to an uninitialized area of memory (algorithm function object) [edit] uninitialized_copy copies a range of objects to an uninitialized area of memory (function template) [edit] Retrieved from " https://en.cppreference.com/mwiki/index.php?title=cpp/memory/ranges/uninitialized_copy&oldid=180692 " Navigation Support us Recent changes FAQ Offline version Toolbox What links here Related changes Upload file Special pages Printable version Permanent link Page information In other languages Deutsch Espa√±ol Fran√ßais Italiano Êó•Êú¨Ë™û Portugu√™s –†—É—Å—Å–∫–∏–π ‰∏≠Êñá This page was last modified on 15 February 2025, at 00:50. Privacy policy About cppreference.com Disclaimers