std::start_lifetime_as, std::start_lifetime_as_array - cppreference.com cppreference.com Create account Log in Namespaces Page Discussion Variants Views View Edit History Actions std:: start_lifetime_as, std:: start_lifetime_as_array From cppreference.com < cpp ‎ | memory C++ Compiler support Freestanding and hosted Language Standard library Standard library headers Named requirements Feature test macros (C++20) Language support library Concepts library (C++20) Diagnostics library Memory management library Metaprogramming library (C++11) General utilities library Containers library Iterators library Ranges library (C++20) Algorithms library Strings library Text processing library Numerics library Date and time library Input/output library Filesystem library (C++17) Concurrency support library (C++11) Execution control library (C++26) Technical specifications Symbols index External libraries [edit] Memory management library voidify ( exposition only* ) Allocators allocator allocator_traits (C++11) allocation_result (C++23) scoped_allocator_adaptor (C++11) pmr::polymorphic_allocator (C++17) allocator_arg (C++11) uses_allocator (C++11) uses_allocator_construction_args (C++20) make_obj_using_allocator (C++20) uninitialized_construct_using_allocator (C++20) Uninitialized memory algorithms uninitialized_copy uninitialized_fill uninitialized_move (C++17) uninitialized_copy_n (C++11) uninitialized_fill_n uninitialized_move_n (C++17) construct_at (C++20) uninitialized_default_construct (C++17) uninitialized_value_construct (C++17) destroy (C++17) uninitialized_default_construct_n (C++17) uninitialized_value_construct_n (C++17) destroy_n (C++17) destroy_at (C++17) Constrained uninitialized memory algorithms ranges::uninitialized_copy (C++20) ranges::uninitialized_fill (C++20) ranges::uninitialized_move (C++20) ranges::uninitialized_copy_n (C++20) ranges::uninitialized_fill_n (C++20) ranges::uninitialized_move_n (C++20) ranges::construct_at (C++20) ranges::uninitialized_default_construct (C++20) ranges::uninitialized_value_construct (C++20) ranges::destroy (C++20) ranges::uninitialized_default_construct_n (C++20) ranges::uninitialized_value_construct_n (C++20) ranges::destroy_n (C++20) ranges::destroy_at (C++20) Memory resources pmr::memory_resource (C++17) pmr::get_default_resource (C++17) pmr::set_default_resource (C++17) pmr::new_delete_resource (C++17) pmr::pool_options (C++17) pmr::null_memory_resource (C++17) pmr::synchronized_pool_resource (C++17) pmr::unsynchronized_pool_resource (C++17) pmr::monotonic_buffer_resource (C++17) Explicit lifetime management start_lifetime_as (C++23) start_lifetime_as_array (C++23) Types for composite class design indirect (C++26) polymorphic (C++26) Uninitialized storage (until C++20) raw_storage_iterator ( until C++20* ) get_temporary_buffer ( until C++20* ) return_temporary_buffer ( until C++20* ) Garbage collector support (until C++23) declare_reachable (C++11) (until C++23) declare_no_pointers (C++11) (until C++23) pointer_safety (C++11) (until C++23) undeclare_reachable (C++11) (until C++23) undeclare_no_pointers (C++11) (until C++23) get_pointer_safety (C++11) (until C++23) Low level memory management operator new operator new[] operator delete operator delete[] nothrow_t nothrow new_handler set_new_handler get_new_handler (C++11) bad_alloc bad_array_new_length (C++11) align_val_t (C++17) destroying_delete_t (C++20) launder (C++17) Smart pointers unique_ptr (C++11) shared_ptr (C++11) weak_ptr (C++11) auto_ptr ( until C++17* ) owner_less (C++11) owner_less<void> (C++17) owner_hash (C++26) owner_equal (C++26) enable_shared_from_this (C++11) bad_weak_ptr (C++11) default_delete (C++11) out_ptr_t (C++23) inout_ptr_t (C++23) Miscellaneous pointer_traits (C++11) to_address (C++20) addressof (C++11) align (C++11) assume_aligned (C++20) is_sufficiently_aligned (C++26) C Library malloc calloc realloc free aligned_alloc (C++17) [edit] Defined in header <memory> std::start_lifetime_as template < class T > T * start_lifetime_as ( void * p ) noexcept ; (1) (since C++23) template < class T > const T * start_lifetime_as ( const void * p ) noexcept ; (2) (since C++23) template < class T > volatile T * start_lifetime_as ( volatile void * p ) noexcept ; (3) (since C++23) template < class T > const volatile T * start_lifetime_as ( const volatile void * p ) noexcept ; (4) (since C++23) std::start_lifetime_as_array template < class T > T * start_lifetime_as_array ( void * p, std:: size_t n ) noexcept ; (5) (since C++23) template < class T > const T * start_lifetime_as_array ( const void * p, std:: size_t n ) noexcept ; (6) (since C++23) template < class T > volatile T * start_lifetime_as_array ( volatile void * p, std:: size_t n ) noexcept ; (7) (since C++23) template < class T > const volatile T * start_lifetime_as_array ( const volatile void * p, std:: size_t n ) noexcept ; (8) (since C++23) 1-4) Implicitly creates a complete object of type T (whose address is p ) and objects nested within it. The value of each created object obj of TriviallyCopyable type U is determined in the same manner as for a call to std:: bit_cast < U > ( E ) except that the storage is not actually accessed, where E is the lvalue of type U denoting obj . Otherwise, the values of such created objects are unspecified. T shall be an ImplicitLifetimeType and shall be a complete type . Otherwise, the program is ill-formed. The behavior is undefined if: [ p , ( char * ) p + sizeof ( T ) ) does not denote a region of allocated storage that is a subset of the region of storage reachable through p , or the region is not suitably aligned for the T . Note that the unspecified value can be indeterminate. 5-8) Implicitly creates an array with element type T and length n . To be precise, if n > 0 is true , it is equivalent to std :: start_lifetime_as < U > ( p ) where U is the type "array of n T s". Otherwise, the function has no effects. T shall be a complete type . Otherwise, the program is ill-formed. The behavior is undefined if: Non-null p is not suitably aligned for an array of T , or n <= std:: size_t ( - 1 ) / sizeof ( T ) is false , or n > 0 and [ ( char * ) p , ( char * ) p + ( n * sizeof ( T ) ) ) does not denote a region of allocated storage that is a subset of the region of storage reachable through p . Contents 1 Parameters 2 Return value 3 Notes 4 Example 5 References 6 See also [ edit ] Parameters p - the address of the region consisting objects n - the number of the element of the array to be created [ edit ] Return value 1-4) A pointer to the complete object as described above. 5-8) A pointer to the first element of the created array, if any; otherwise, a pointer that compares equal to p . [ edit ] Notes new ( void_ptr ) unsigned char [ size ] or new ( void_ptr ) std:: byte [ size ] works as an untyped version of std::start_lifetime_as , but it does not keep the object representation. std :: start_lifetime_as handles non-array types as well as arrays of known bound, while std :: start_lifetime_as_array handles arrays of unknown bound. Feature-test macro Value Std Feature __cpp_lib_start_lifetime_as 202207L (C++23) Explicit lifetime management [ edit ] Example Run this code #include <complex> #include <iostream> #include <memory> int main ( ) { alignas ( std:: complex < float > ) unsigned char network_data [ sizeof ( std:: complex < float > ) ] { 0xcd , 0xcc , 0xcc , 0x3d , 0xcd , 0xcc , 0x4c , 0x3e } ; // auto d = *reinterpret_cast<std::complex<float>*>(network_data); // std::cout << d << '\n'; // UB: network_data does not point to a complex<float> // auto d1 = *std::launder(reinterpret_cast<std::complex<float>*>(network_data)); // std::cout << d1 << '\n'; // UB: implicitly created objects have dynamic storage // duration and have indeterminate value initially, // even when an array which provides storage for // them has determinate bytes. // See also CWG2721. auto d2 = * std :: start_lifetime_as < std:: complex < float >> ( network_data ) ; std:: cout << d2 << ' \n ' ; // OK } Possible output: (0.1,0.2) [ edit ] References C++23 standard (ISO/IEC 14882:2024): 20.2.6 Explicit lifetime management [obj.lifetime] [ edit ] See also bit_cast (C++20) reinterpret the object representation of one type as that of another (function template) [edit] as_bytes as_writable_bytes (C++20) converts a span into a view of its underlying bytes (function template) [edit] Retrieved from " https://en.cppreference.com/mwiki/index.php?title=cpp/memory/start_lifetime_as&oldid=179469 " Navigation Support us Recent changes FAQ Offline version Toolbox What links here Related changes Upload file Special pages Printable version Permanent link Page information In other languages العربية Deutsch Español Français Italiano 日本語 Polski Português Русский 中文 This page was last modified on 10 January 2025, at 10:38. Privacy policy About cppreference.com Disclaimers