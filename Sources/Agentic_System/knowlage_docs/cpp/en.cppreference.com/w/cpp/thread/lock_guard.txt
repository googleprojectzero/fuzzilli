std::lock_guard - cppreference.com cppreference.com Create account Log in Namespaces Page Discussion Variants Views View Edit History Actions std:: lock_guard From cppreference.com < cpp ‎ | thread C++ Compiler support Freestanding and hosted Language Standard library Standard library headers Named requirements Feature test macros (C++20) Language support library Concepts library (C++20) Diagnostics library Memory management library Metaprogramming library (C++11) General utilities library Containers library Iterators library Ranges library (C++20) Algorithms library Strings library Text processing library Numerics library Date and time library Input/output library Filesystem library (C++17) Concurrency support library (C++11) Execution control library (C++26) Technical specifications Symbols index External libraries [edit] Concurrency support library Threads thread (C++11) jthread (C++20) hardware_destructive_interference_size hardware_constructive_interference_size (C++17) (C++17) this_thread namespace get_id (C++11) yield (C++11) sleep_for (C++11) sleep_until (C++11) Cooperative cancellation stop_token (C++20) inplace_stop_token (C++26) never_stop_token (C++26) stop_source (C++20) inplace_stop_source (C++26) stop_callback (C++20) inplace_stop_callback (C++26) stop_callback_for_t (C++26) stoppable_token (C++26) unstoppable_token (C++26) stoppable-source (C++26) stoppable-callback-for (C++26) Mutual exclusion mutex (C++11) recursive_mutex (C++11) shared_mutex (C++17) timed_mutex (C++11) recursive_timed_mutex (C++11) shared_timed_mutex (C++14) Generic lock management lock (C++11) lock_guard (C++11) scoped_lock (C++17) unique_lock (C++11) shared_lock (C++14) once_flag (C++11) call_once (C++11) try_lock (C++11) defer_lock try_to_lock adopt_lock defer_lock_t try_to_lock_t adopt_lock_t (C++11) (C++11) (C++11) (C++11) (C++11) (C++11) Condition variables condition_variable (C++11) condition_variable_any (C++11) notify_all_at_thread_exit (C++11) cv_status (C++11) Semaphores counting_semaphore binary_semaphore (C++20) (C++20) Latches and Barriers latch (C++20) barrier (C++20) Futures promise (C++11) future (C++11) shared_future (C++11) packaged_task (C++11) async (C++11) launch (C++11) future_status (C++11) future_error (C++11) future_category (C++11) future_errc (C++11) Safe reclamation rcu_obj_base (C++26) rcu_domain (C++26) rcu_default_domain (C++26) rcu_synchronize (C++26) rcu_barrier (C++26) rcu_retire (C++26) Hazard pointers hazard_pointer_obj_base (C++26) hazard_pointer (C++26) make_hazard_pointer (C++26) Atomic types atomic (C++11) atomic_ref (C++20) atomic_flag (C++11) Initialization of atomic types atomic_init (C++11) (deprecated in C++20) ATOMIC_VAR_INIT (C++11) (deprecated in C++20) ATOMIC_FLAG_INIT (C++11) Memory ordering memory_order (C++11) kill_dependency (C++11) (deprecated in C++26) atomic_thread_fence (C++11) atomic_signal_fence (C++11) Free functions for atomic operations atomic_store atomic_store_explicit (C++11) (C++11) atomic_load atomic_load_explicit (C++11) (C++11) atomic_exchange atomic_exchange_explicit (C++11) (C++11) atomic_compare_exchange_weak atomic_compare_exchange_weak_explicit atomic_compare_exchange_strong atomic_compare_exchange_strong_explicit (C++11) (C++11) (C++11) (C++11) atomic_fetch_add atomic_fetch_add_explicit (C++11) (C++11) atomic_fetch_sub atomic_fetch_sub_explicit (C++11) (C++11) atomic_fetch_and atomic_fetch_and_explicit (C++11) (C++11) atomic_fetch_or atomic_fetch_or_explicit (C++11) (C++11) atomic_fetch_xor atomic_fetch_xor_explicit (C++11) (C++11) atomic_fetch_max atomic_fetch_max_explicit (C++26) (C++26) atomic_fetch_min atomic_fetch_min_explicit (C++26) (C++26) atomic_is_lock_free (C++11) atomic_wait atomic_wait_explicit (C++20) (C++20) atomic_notify_one (C++20) atomic_notify_all (C++20) Free functions for atomic flags atomic_flag_test_and_set atomic_flag_test_and_set_explicit (C++11) (C++11) atomic_flag_clear atomic_flag_clear_explicit (C++11) (C++11) atomic_flag_test atomic_flag_test_explicit (C++20) (C++20) atomic_flag_wait atomic_flag_wait_explicit (C++20) (C++20) atomic_flag_notify_one (C++20) atomic_flag_notify_all (C++20) [edit] std::lock_guard Member functions lock_guard::lock_guard lock_guard::~lock_guard [edit] Defined in header <mutex> template < class Mutex > class lock_guard ; (since C++11) The class lock_guard is a mutex wrapper that provides a convenient RAII-style mechanism for owning a mutex for the duration of a scoped block. When a lock_guard object is created, it attempts to take ownership of the mutex it is given. When control leaves the scope in which the lock_guard object was created, the lock_guard is destructed and the mutex is released. The lock_guard class is non-copyable. Contents 1 Template parameters 2 Member types 3 Member functions 4 Notes 5 Example 6 Defect reports 7 See also [ edit ] Template parameters Mutex - the type of the mutex to lock. The type must meet the BasicLockable requirements [ edit ] Member types Member type Definition mutex_type Mutex [ edit ] Member functions (constructor) constructs a lock_guard , optionally locking the given mutex (public member function) [edit] (destructor) destructs the lock_guard object, unlocks the underlying mutex (public member function) [edit] operator= [deleted] not copy-assignable (public member function) [edit] [ edit ] Notes A common beginner error is to forget to give a lock_guard variable a name, such as by std :: lock_guard { mtx } . This constructs a prvalue object that is immediately destroyed, thereby not actually constructing a lock that holds a mutex for the rest of the scope. std::scoped_lock offers an alternative for lock_guard that provides the ability to lock multiple mutexes using a deadlock avoidance algorithm. (since C++17) [ edit ] Example Demonstrates safe and unsafe increments of a volatile variable by two threads. Run this code #include <iostream> #include <mutex> #include <string_view> #include <syncstream> #include <thread> volatile int g_i = 0 ; std:: mutex g_i_mutex ; // protects g_i void safe_increment ( int iterations ) { const std :: lock_guard < std:: mutex > lock ( g_i_mutex ) ; while ( iterations -- > 0 ) g_i = g_i + 1 ; std:: cout << "thread #" << std:: this_thread :: get_id ( ) << ", g_i: " << g_i << ' \n ' ; // g_i_mutex is automatically released when lock goes out of scope } void unsafe_increment ( int iterations ) { while ( iterations -- > 0 ) g_i = g_i + 1 ; std:: osyncstream ( std:: cout ) << "thread #" << std:: this_thread :: get_id ( ) << ", g_i: " << g_i << ' \n ' ; } int main ( ) { auto test = [ ] ( std:: string_view fun_name, auto fun ) { g_i = 0 ; std:: cout << fun_name << ": \n before, g_i: " << g_i << ' \n ' ; { std:: jthread t1 ( fun, 1 '000' 000 ) ; std:: jthread t2 ( fun, 1 '000' 000 ) ; } std:: cout << "after, g_i: " << g_i << " \n \n " ; } ; test ( "safe_increment" , safe_increment ) ; test ( "unsafe_increment" , unsafe_increment ) ; } Possible output: safe_increment: before, g_i: 0 thread #140121493231360, g_i: 1000000 thread #140121484838656, g_i: 2000000 after, g_i: 2000000 unsafe_increment: before, g_i: 0 thread #140121484838656, g_i: 1028945 thread #140121493231360, g_i: 1034337 after, g_i: 1034337 [ edit ] Defect reports The following behavior-changing defect reports were applied retroactively to previously published C++ standards. DR Applied to Behavior as published Correct behavior LWG 2981 C++17 redundant deduction guide from lock_guard<Mutex> was provided removed [ edit ] See also unique_lock (C++11) implements movable mutex ownership wrapper (class template) [edit] scoped_lock (C++17) deadlock-avoiding RAII wrapper for multiple mutexes (class template) [edit] Retrieved from " https://en.cppreference.com/mwiki/index.php?title=cpp/thread/lock_guard&oldid=182795 " Navigation Support us Recent changes FAQ Offline version Toolbox What links here Related changes Upload file Special pages Printable version Permanent link Page information In other languages Deutsch Español Français Italiano 日本語 Português Русский 中文 This page was last modified on 21 April 2025, at 03:47. Privacy policy About cppreference.com Disclaimers