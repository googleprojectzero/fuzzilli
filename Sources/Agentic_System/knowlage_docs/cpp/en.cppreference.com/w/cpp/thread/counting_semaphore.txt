std::counting_semaphore, std::binary_semaphore - cppreference.com cppreference.com Create account Log in Namespaces Page Discussion Variants Views View Edit History Actions std:: counting_semaphore, std:: binary_semaphore From cppreference.com < cpp ‎ | thread C++ Compiler support Freestanding and hosted Language Standard library Standard library headers Named requirements Feature test macros (C++20) Language support library Concepts library (C++20) Diagnostics library Memory management library Metaprogramming library (C++11) General utilities library Containers library Iterators library Ranges library (C++20) Algorithms library Strings library Text processing library Numerics library Date and time library Input/output library Filesystem library (C++17) Concurrency support library (C++11) Execution control library (C++26) Technical specifications Symbols index External libraries [edit] Concurrency support library Threads thread (C++11) jthread (C++20) hardware_destructive_interference_size hardware_constructive_interference_size (C++17) (C++17) this_thread namespace get_id (C++11) yield (C++11) sleep_for (C++11) sleep_until (C++11) Cooperative cancellation stop_token (C++20) inplace_stop_token (C++26) never_stop_token (C++26) stop_source (C++20) inplace_stop_source (C++26) stop_callback (C++20) inplace_stop_callback (C++26) stop_callback_for_t (C++26) stoppable_token (C++26) unstoppable_token (C++26) stoppable-source (C++26) stoppable-callback-for (C++26) Mutual exclusion mutex (C++11) recursive_mutex (C++11) shared_mutex (C++17) timed_mutex (C++11) recursive_timed_mutex (C++11) shared_timed_mutex (C++14) Generic lock management lock (C++11) lock_guard (C++11) scoped_lock (C++17) unique_lock (C++11) shared_lock (C++14) once_flag (C++11) call_once (C++11) try_lock (C++11) defer_lock try_to_lock adopt_lock defer_lock_t try_to_lock_t adopt_lock_t (C++11) (C++11) (C++11) (C++11) (C++11) (C++11) Condition variables condition_variable (C++11) condition_variable_any (C++11) notify_all_at_thread_exit (C++11) cv_status (C++11) Semaphores counting_semaphore binary_semaphore (C++20) (C++20) Latches and Barriers latch (C++20) barrier (C++20) Futures promise (C++11) future (C++11) shared_future (C++11) packaged_task (C++11) async (C++11) launch (C++11) future_status (C++11) future_error (C++11) future_category (C++11) future_errc (C++11) Safe reclamation rcu_obj_base (C++26) rcu_domain (C++26) rcu_default_domain (C++26) rcu_synchronize (C++26) rcu_barrier (C++26) rcu_retire (C++26) Hazard pointers hazard_pointer_obj_base (C++26) hazard_pointer (C++26) make_hazard_pointer (C++26) Atomic types atomic (C++11) atomic_ref (C++20) atomic_flag (C++11) Initialization of atomic types atomic_init (C++11) (deprecated in C++20) ATOMIC_VAR_INIT (C++11) (deprecated in C++20) ATOMIC_FLAG_INIT (C++11) Memory ordering memory_order (C++11) kill_dependency (C++11) (deprecated in C++26) atomic_thread_fence (C++11) atomic_signal_fence (C++11) Free functions for atomic operations atomic_store atomic_store_explicit (C++11) (C++11) atomic_load atomic_load_explicit (C++11) (C++11) atomic_exchange atomic_exchange_explicit (C++11) (C++11) atomic_compare_exchange_weak atomic_compare_exchange_weak_explicit atomic_compare_exchange_strong atomic_compare_exchange_strong_explicit (C++11) (C++11) (C++11) (C++11) atomic_fetch_add atomic_fetch_add_explicit (C++11) (C++11) atomic_fetch_sub atomic_fetch_sub_explicit (C++11) (C++11) atomic_fetch_and atomic_fetch_and_explicit (C++11) (C++11) atomic_fetch_or atomic_fetch_or_explicit (C++11) (C++11) atomic_fetch_xor atomic_fetch_xor_explicit (C++11) (C++11) atomic_fetch_max atomic_fetch_max_explicit (C++26) (C++26) atomic_fetch_min atomic_fetch_min_explicit (C++26) (C++26) atomic_is_lock_free (C++11) atomic_wait atomic_wait_explicit (C++20) (C++20) atomic_notify_one (C++20) atomic_notify_all (C++20) Free functions for atomic flags atomic_flag_test_and_set atomic_flag_test_and_set_explicit (C++11) (C++11) atomic_flag_clear atomic_flag_clear_explicit (C++11) (C++11) atomic_flag_test atomic_flag_test_explicit (C++20) (C++20) atomic_flag_wait atomic_flag_wait_explicit (C++20) (C++20) atomic_flag_notify_one (C++20) atomic_flag_notify_all (C++20) [edit] std::counting_semaphore Member functions counting_semaphore::counting_semaphore counting_semaphore::~counting_semaphore Operations counting_semaphore::release counting_semaphore::acquire counting_semaphore::try_acquire counting_semaphore::try_acquire_for counting_semaphore::try_acquire_until Constants counting_semaphore::max [edit] Defined in header <semaphore> template < std:: ptrdiff_t LeastMaxValue = /* implementation-defined */ > class counting_semaphore ; (1) (since C++20) using binary_semaphore = std :: counting_semaphore < 1 > ; (2) (since C++20) 1) A counting_semaphore is a lightweight synchronization primitive that can control access to a shared resource. Unlike a std::mutex , a counting_semaphore allows more than one concurrent access to the same resource, for at least LeastMaxValue concurrent accessors. The program is ill-formed if LeastMaxValue is negative. 2) binary_semaphore is an alias for specialization of std::counting_semaphore with LeastMaxValue being 1 . Implementations may implement binary_semaphore more efficiently than the default implementation of std::counting_semaphore . A counting_semaphore contains an internal counter initialized by the constructor. This counter is decremented by calls to acquire() and related methods, and is incremented by calls to release() . When the counter is zero, acquire() blocks until the counter is incremented, but try_acquire() does not block; try_acquire_for() and try_acquire_until() block until the counter is incremented or a timeout is reached. Similar to std::condition_variable::wait() , counting_semaphore 's try_acquire() can spuriously fail. Specializations of std::counting_semaphore are not DefaultConstructible , CopyConstructible , MoveConstructible , CopyAssignable , or MoveAssignable . Contents 1 Data Members 2 Member functions 2.1 Operations 2.2 Constants 3 Notes 4 Example [ edit ] Data Members Member name Definition counter (private) The internal counter of type std::ptrdiff_t . ( exposition-only member object* ) [ edit ] Member functions (constructor) constructs a counting_semaphore (public member function) [edit] (destructor) destructs the counting_semaphore (public member function) [edit] operator= [deleted] counting_semaphore is not assignable (public member function) [edit] Operations release increments the internal counter and unblocks acquirers (public member function) [edit] acquire decrements the internal counter or blocks until it can (public member function) [edit] try_acquire tries to decrement the internal counter without blocking (public member function) [edit] try_acquire_for tries to decrement the internal counter, blocking for up to a duration time (public member function) [edit] try_acquire_until tries to decrement the internal counter, blocking until a point in time (public member function) [edit] Constants max [static] returns the maximum possible value of the internal counter (public static member function) [edit] [ edit ] Notes As its name indicates, the LeastMaxValue is the minimum max value, not the actual max value. Thus max() can yield a number larger than LeastMaxValue . Unlike std::mutex a counting_semaphore is not tied to threads of execution - acquiring a semaphore can occur on a different thread than releasing the semaphore, for example. All operations on counting_semaphore can be performed concurrently and without any relation to specific threads of execution, with the exception of the destructor which cannot be performed concurrently but can be performed on a different thread. Semaphores are also often used for the semantics of signaling/notifying rather than mutual exclusion, by initializing the semaphore with ​ 0 ​ and thus blocking the receiver(s) that try to acquire() , until the notifier "signals" by invoking release ( n ) . In this respect semaphores can be considered alternatives to std::condition_variable s, often with better performance. Feature-test macro Value Std Feature __cpp_lib_semaphore 201907L (C++20) std::counting_semaphore , std::binary_semaphore [ edit ] Example Run this code #include <chrono> #include <iostream> #include <semaphore> #include <thread> // global binary semaphore instances // object counts are set to zero // objects are in non-signaled state std :: binary_semaphore smphSignalMainToThread { 0 } , smphSignalThreadToMain { 0 } ; void ThreadProc ( ) { // wait for a signal from the main proc // by attempting to decrement the semaphore smphSignalMainToThread. acquire ( ) ; // this call blocks until the semaphore's count // is increased from the main proc std:: cout << "[thread] Got the signal \n " ; // response message // wait for 3 seconds to imitate some work // being done by the thread using namespace std :: literals ; std:: this_thread :: sleep_for ( 3s ) ; std:: cout << "[thread] Send the signal \n " ; // message // signal the main proc back smphSignalThreadToMain. release ( ) ; } int main ( ) { // create some worker thread std:: thread thrWorker ( ThreadProc ) ; std:: cout << "[main] Send the signal \n " ; // message // signal the worker thread to start working // by increasing the semaphore's count smphSignalMainToThread. release ( ) ; // wait until the worker thread is done doing the work // by attempting to decrement the semaphore's count smphSignalThreadToMain. acquire ( ) ; std:: cout << "[main] Got the signal \n " ; // response message thrWorker. join ( ) ; } Output: [main] Send the signal [thread] Got the signal [thread] Send the signal [main] Got the signal Retrieved from " https://en.cppreference.com/mwiki/index.php?title=cpp/thread/counting_semaphore&oldid=171868 " Navigation Support us Recent changes FAQ Offline version Toolbox What links here Related changes Upload file Special pages Printable version Permanent link Page information In other languages Español 日本語 Русский 中文 This page was last modified on 19 May 2024, at 13:13. Privacy policy About cppreference.com Disclaimers