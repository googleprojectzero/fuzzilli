std::apply - cppreference.com cppreference.com Create account Log in Namespaces Page Discussion Variants Views View Edit History Actions std:: apply From cppreference.com < cpp ‎ | utility C++ Compiler support Freestanding and hosted Language Standard library Standard library headers Named requirements Feature test macros (C++20) Language support library Concepts library (C++20) Diagnostics library Memory management library Metaprogramming library (C++11) General utilities library Containers library Iterators library Ranges library (C++20) Algorithms library Strings library Text processing library Numerics library Date and time library Input/output library Filesystem library (C++17) Concurrency support library (C++11) Execution control library (C++26) Technical specifications Symbols index External libraries [edit] Utilities library Language support Type support (basic types, RTTI) Library feature-test macros (C++20) Program utilities Variadic functions initializer_list (C++11) is_constant_evaluated (C++20) is_within_lifetime (C++26) source_location (C++20) Coroutine support (C++20) Contract support (C++26) Three-way comparison three_way_comparable three_way_comparable_with (C++20) (C++20) strong_ordering (C++20) weak_ordering (C++20) partial_ordering (C++20) common_comparison_category (C++20) compare_three_way_result (C++20) compare_three_way (C++20) strong_order (C++20) weak_order (C++20) partial_order (C++20) compare_strong_order_fallback (C++20) compare_weak_order_fallback (C++20) compare_partial_order_fallback (C++20) is_eq is_lt is_lteq (C++20) (C++20) (C++20) is_neq is_gt is_gteq (C++20) (C++20) (C++20) General utilities Function objects Bit manipulation (C++20) C-style bit manipulation (C++26) bitset hash (C++11) Relational operators (deprecated in C++20) rel_ops::operator!= rel_ops::operator> rel_ops::operator<= rel_ops::operator>= Integer comparison functions cmp_equal cmp_less cmp_less_than (C++20) (C++20) (C++20) cmp_not_equal cmp_greater cmp_greater_than (C++20) (C++20) (C++20) in_range (C++20) Swap and type operations swap ranges::swap (C++20) exchange (C++14) declval (C++11) to_underlying (C++23) forward (C++11) forward_like (C++23) move (C++11) move_if_noexcept (C++11) as_const (C++17) Common vocabulary types pair tuple (C++11) optional (C++17) any (C++17) variant (C++17) tuple_size (C++11) tuple_element (C++11) apply (C++17) make_from_tuple (C++17) expected (C++23) [edit] Defined in header <tuple> template < class F, class Tuple > constexpr decltype ( auto ) apply ( F && f, Tuple && t ) ; (since C++17) (until C++23) template < class F, tuple - like Tuple > constexpr decltype ( auto ) apply ( F && f, Tuple && t ) noexcept ( /* see below */ ) ; (since C++23) Invoke the Callable object f with the elements of t as arguments. Given the exposition-only function apply-impl defined as follows: template < class F, class Tuple, std:: size_t ... I > constexpr decltype ( auto ) apply-impl ( F && f, Tuple && t, std:: index_sequence < I... > ) // exposition only { return INVOKE ( std:: forward < F > ( f ) , std :: get < I > ( std:: forward < Tuple > ( t ) ) ... ) ; } The effect is equivalent to: return apply-impl ( std:: forward < F > ( f ) , std:: forward < Tuple > ( t ) , std:: make_index_sequence < std:: tuple_size_v < std:: decay_t < Tuple >>> { } ) ; . Contents 1 Parameters 2 Return value 3 Exceptions 4 Notes 5 Example 6 See also [ edit ] Parameters f - Callable object to be invoked t - tuple whose elements to be used as arguments to f [ edit ] Return value The value returned by f . [ edit ] Exceptions (none) (until C++23) noexcept specification: noexcept ( noexcept ( std:: invoke ( std:: forward < F > ( f ) , std :: get < Is > ( std:: forward < Tuple > ( t ) ) ... ) ) ) where Is... denotes the pack : 0 , 1 , ..., std:: tuple_size_v < std:: remove_reference_t < Tuple >> - 1 . (since C++23) [ edit ] Notes Tuple need not be std::tuple , and instead may be anything that supports std::get and std::tuple_size ; in particular, std::array and std::pair may be used. (until C++23) Tuple is constrained to be tuple-like, i.e. each type therein is required to be a specialization of std::tuple or another type (such as std::array and std::pair ) that models tuple-like . (since C++23) Feature-test macro Value Std Feature __cpp_lib_apply 201603L (C++17) std::apply [ edit ] Example Run this code #include <iostream> #include <tuple> #include <utility> int add ( int first, int second ) { return first + second ; } template < typename T > T add_generic ( T first, T second ) { return first + second ; } auto add_lambda = [ ] ( auto first, auto second ) { return first + second ; } ; template < typename ... Ts > std:: ostream & operator << ( std:: ostream & os, std:: tuple < Ts... > const & theTuple ) { std :: apply ( [ & os ] ( Ts const & ... tupleArgs ) { os << '[' ; std:: size_t n { 0 } ; ( ( os << tupleArgs << ( ++ n ! = sizeof... ( Ts ) ? ", " : "" ) ) , ... ) ; os << ']' ; } , theTuple ) ; return os ; } int main ( ) { // OK std:: cout << std :: apply ( add, std:: pair ( 1 , 2 ) ) << ' \n ' ; // Error: can't deduce the function type // std::cout << std::apply(add_generic, std::make_pair(2.0f, 3.0f)) << '\n'; // OK std:: cout << std :: apply ( add_lambda, std:: pair ( 2.0f , 3.0f ) ) << ' \n ' ; // advanced example std:: tuple myTuple { 25 , "Hello" , 9.31f , 'c' } ; std:: cout << myTuple << ' \n ' ; } Output: 3 5 [25, Hello, 9.31, c] [ edit ] See also make_tuple (C++11) creates a tuple object of the type defined by the argument types (function template) [edit] forward_as_tuple (C++11) creates a tuple of forwarding references (function template) [edit] make_from_tuple (C++17) construct an object with a tuple of arguments (function template) [edit] invoke invoke_r (C++17) (C++23) invokes any Callable object with given arguments and possibility to specify return type (since C++23) (function template) [edit] Retrieved from " https://en.cppreference.com/mwiki/index.php?title=cpp/utility/apply&oldid=178488 " Category : conditionally noexcept Navigation Support us Recent changes FAQ Offline version Toolbox What links here Related changes Upload file Special pages Printable version Permanent link Page information In other languages Español 日本語 Русский 中文 This page was last modified on 19 December 2024, at 06:30. Privacy policy About cppreference.com Disclaimers