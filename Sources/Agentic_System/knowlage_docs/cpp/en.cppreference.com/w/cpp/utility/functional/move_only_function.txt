std::move_only_function - cppreference.com cppreference.com Create account Log in Namespaces Page Discussion Variants Views View Edit History Actions std:: move_only_function From cppreference.com < cpp ‎ | utility ‎ | functional C++ Compiler support Freestanding and hosted Language Standard library Standard library headers Named requirements Feature test macros (C++20) Language support library Concepts library (C++20) Diagnostics library Memory management library Metaprogramming library (C++11) General utilities library Containers library Iterators library Ranges library (C++20) Algorithms library Strings library Text processing library Numerics library Date and time library Input/output library Filesystem library (C++17) Concurrency support library (C++11) Execution control library (C++26) Technical specifications Symbols index External libraries [edit] Utilities library Language support Type support (basic types, RTTI) Library feature-test macros (C++20) Program utilities Variadic functions initializer_list (C++11) is_constant_evaluated (C++20) is_within_lifetime (C++26) source_location (C++20) Coroutine support (C++20) Contract support (C++26) Three-way comparison three_way_comparable three_way_comparable_with (C++20) (C++20) strong_ordering (C++20) weak_ordering (C++20) partial_ordering (C++20) common_comparison_category (C++20) compare_three_way_result (C++20) compare_three_way (C++20) strong_order (C++20) weak_order (C++20) partial_order (C++20) compare_strong_order_fallback (C++20) compare_weak_order_fallback (C++20) compare_partial_order_fallback (C++20) is_eq is_lt is_lteq (C++20) (C++20) (C++20) is_neq is_gt is_gteq (C++20) (C++20) (C++20) General utilities Function objects Bit manipulation (C++20) C-style bit manipulation (C++26) bitset hash (C++11) Relational operators (deprecated in C++20) rel_ops::operator!= rel_ops::operator> rel_ops::operator<= rel_ops::operator>= Integer comparison functions cmp_equal cmp_less cmp_less_than (C++20) (C++20) (C++20) cmp_not_equal cmp_greater cmp_greater_than (C++20) (C++20) (C++20) in_range (C++20) Swap and type operations swap ranges::swap (C++20) exchange (C++14) declval (C++11) to_underlying (C++23) forward (C++11) forward_like (C++23) move (C++11) move_if_noexcept (C++11) as_const (C++17) Common vocabulary types pair tuple (C++11) optional (C++17) any (C++17) variant (C++17) tuple_size (C++11) tuple_element (C++11) apply (C++17) make_from_tuple (C++17) expected (C++23) [edit] Function objects Function wrappers function (C++11) move_only_function (C++23) copyable_function (C++26) function_ref (C++26) mem_fn (C++11) bad_function_call (C++11) Partial function application bind_front bind_back (C++20) (C++23) bind (C++11) is_bind_expression (C++11) is_placeholder (C++11) _1, _2, _3, ... (C++11) Function invocation invoke invoke_r (C++17) (C++23) Identity function object identity (C++20) Reference wrappers reference_wrapper (C++11) ref cref (C++11) (C++11) unwrap_reference unwrap_ref_decay (C++20) (C++20) Operator wrappers plus minus negate multiplies divides modulus bit_and bit_or bit_not (C++14) bit_xor equal_to not_equal_to greater less greater_equal less_equal logical_and logical_or logical_not Transparent operator wrappers plus <> (C++14) minus <> (C++14) negate <> (C++14) multiplies <> (C++14) divides <> (C++14) modulus <> (C++14) bit_and <> (C++14) bit_or <> (C++14) bit_not <> (C++14) bit_xor <> (C++14) equal_to <> (C++14) not_equal_to <> (C++14) greater <> (C++14) less <> (C++14) greater_equal <> (C++14) less_equal <> (C++14) logical_and <> (C++14) logical_or <> (C++14) logical_not <> (C++14) Negators not_fn (C++17) Searchers default_searcher (C++17) boyer_moore_searcher (C++17) boyer_moore_horspool_searcher (C++17) Constrained comparators ranges::equal_to (C++20) ranges::not_equal_to (C++20) ranges::greater (C++20) ranges::less (C++20) ranges::greater_equal (C++20) ranges::less_equal (C++20) compare_three_way (C++20) Old binders and adaptors unary_function ( until C++17* ) binary_function ( until C++17* ) ptr_fun ( until C++17* ) pointer_to_unary_function ( until C++17* ) pointer_to_binary_function ( until C++17* ) mem_fun ( until C++17* ) mem_fun_t mem_fun1_t const_mem_fun_t const_mem_fun1_t ( until C++17* ) ( until C++17* ) ( until C++17* ) ( until C++17* ) not1 ( until C++20* ) not2 ( until C++20* ) binder1st binder2nd ( until C++17* ) ( until C++17* ) bind1st bind2nd ( until C++17* ) ( until C++17* ) mem_fun_ref ( until C++17* ) mem_fun_ref_t mem_fun1_ref_t const_mem_fun_ref_t const_mem_fun1_ref_t ( until C++17* ) ( until C++17* ) ( until C++17* ) ( until C++17* ) unary_negate ( until C++20* ) binary_negate ( until C++20* ) [edit] std::move_only_function Member functions move_only_function::move_only_function move_only_function::~move_only_function move_only_function::operator= move_only_function::swap move_only_function::operator bool move_only_function::operator() Non-member functions operator== swap (std::move_only_function) [edit] Defined in header <functional> template < class ... > class move_only_function ; // not defined (1) (since C++23) template < class R, class ... Args > class move_only_function < R ( Args... ) > ; template < class R, class ... Args > class move_only_function < R ( Args... ) noexcept > ; template < class R, class ... Args > class move_only_function < R ( Args... ) & > ; template < class R, class ... Args > class move_only_function < R ( Args... ) & noexcept > ; template < class R, class ... Args > class move_only_function < R ( Args... ) && > ; template < class R, class ... Args > class move_only_function < R ( Args... ) && noexcept > ; template < class R, class ... Args > class move_only_function < R ( Args... ) const > ; template < class R, class ... Args > class move_only_function < R ( Args... ) const noexcept > ; template < class R, class ... Args > class move_only_function < R ( Args... ) const & > ; template < class R, class ... Args > class move_only_function < R ( Args... ) const & noexcept > ; template < class R, class ... Args > class move_only_function < R ( Args... ) const && > ; template < class R, class ... Args > class move_only_function < R ( Args... ) const && noexcept > ; (2) (since C++23) Class template std::move_only_function is a general-purpose polymorphic function wrapper. std::move_only_function objects can store and invoke any constructible (not required to be move constructible) Callable target — functions, lambda expressions , bind expressions , or other function objects, as well as pointers to member functions and pointers to member objects. The stored callable object is called the target of std::move_only_function . If a std::move_only_function contains no target, it is called empty . Unlike std::function , invoking an empty std::move_only_function results in undefined behavior. std::move_only_function s supports every possible combination of cv-qualifiers (not including volatile ), ref-qualifiers , and noexcept-specifiers provided in its template parameter. These qualifiers and specifier (if any) are added to its operator() . std::move_only_function satisfies the requirements of MoveConstructible and MoveAssignable , but does not satisfy CopyConstructible or CopyAssignable . Contents 1 Member types 2 Member functions 3 Non-member functions 4 Notes 5 Example 6 See also [ edit ] Member types Type Definition result_type R [ edit ] Member functions (constructor) constructs a new std::move_only_function object (public member function) [edit] (destructor) destroys a std::move_only_function object (public member function) [edit] operator= replaces or destroys the target (public member function) [edit] swap swaps the targets of two std::move_only_function objects (public member function) [edit] operator bool checks if the std::move_only_function has a target (public member function) [edit] operator() invokes the target (public member function) [edit] [ edit ] Non-member functions swap (std::move_only_function) (C++23) specializes the std::swap algorithm (function) [edit] operator== (C++23) compares a std::move_only_function with nullptr (function) [edit] [ edit ] Notes Implementations may store a callable object of small size within the std::move_only_function object. Such small object optimization is effectively required for function pointers and std::reference_wrapper specializations, and can only be applied to types T for which std:: is_nothrow_move_constructible_v < T > is true . If a std::move_only_function returning a reference is initialized from a function or function object returning a prvalue (including a lambda expression without a trailing-return-type), the program is ill-formed because binding the returned reference to a temporary object is forbidden. See also std::function Notes. Feature-test macro Value Std Feature __cpp_lib_move_only_function 202110L (C++23) std::move_only_function [ edit ] Example Run this code #include <functional> #include <future> #include <iostream> int main ( ) { std:: packaged_task < double ( ) > packaged_task ( [ ] ( ) { return 3.14159 ; } ) ; std:: future < double > future = packaged_task. get_future ( ) ; auto lambda = [ task = std :: move ( packaged_task ) ] ( ) mutable { task ( ) ; } ; // std::function<void()> function = std::move(lambda); // Error std :: move_only_function < void ( ) > function = std :: move ( lambda ) ; // OK function ( ) ; std:: cout << future. get ( ) ; } Output: 3.14159 [ edit ] See also function (C++11) copyable wrapper of any copy constructible callable object (class template) [edit] function_ref (C++26) non-owning wrapper of any callable object (class template) [edit] copyable_function (C++26) copyable wrapper of any copy constructible callable object that supports qualifiers in a given call signature (class template) [edit] Retrieved from " https://en.cppreference.com/mwiki/index.php?title=cpp/utility/functional/move_only_function&oldid=178279 " Navigation Support us Recent changes FAQ Offline version Toolbox What links here Related changes Upload file Special pages Printable version Permanent link Page information In other languages Deutsch Español Français Italiano 日本語 Português Русский 中文 This page was last modified on 9 December 2024, at 17:31. Privacy policy About cppreference.com Disclaimers