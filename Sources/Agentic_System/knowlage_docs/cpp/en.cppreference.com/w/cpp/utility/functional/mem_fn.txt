std::mem_fn - cppreference.com cppreference.com Create account Log in Namespaces Page Discussion Variants Views View Edit History Actions std:: mem_fn From cppreference.com < cpp ‎ | utility ‎ | functional C++ Compiler support Freestanding and hosted Language Standard library Standard library headers Named requirements Feature test macros (C++20) Language support library Concepts library (C++20) Diagnostics library Memory management library Metaprogramming library (C++11) General utilities library Containers library Iterators library Ranges library (C++20) Algorithms library Strings library Text processing library Numerics library Date and time library Input/output library Filesystem library (C++17) Concurrency support library (C++11) Execution control library (C++26) Technical specifications Symbols index External libraries [edit] Utilities library Language support Type support (basic types, RTTI) Library feature-test macros (C++20) Program utilities Variadic functions initializer_list (C++11) is_constant_evaluated (C++20) is_within_lifetime (C++26) source_location (C++20) Coroutine support (C++20) Contract support (C++26) Three-way comparison three_way_comparable three_way_comparable_with (C++20) (C++20) strong_ordering (C++20) weak_ordering (C++20) partial_ordering (C++20) common_comparison_category (C++20) compare_three_way_result (C++20) compare_three_way (C++20) strong_order (C++20) weak_order (C++20) partial_order (C++20) compare_strong_order_fallback (C++20) compare_weak_order_fallback (C++20) compare_partial_order_fallback (C++20) is_eq is_lt is_lteq (C++20) (C++20) (C++20) is_neq is_gt is_gteq (C++20) (C++20) (C++20) General utilities Function objects Bit manipulation (C++20) C-style bit manipulation (C++26) bitset hash (C++11) Relational operators (deprecated in C++20) rel_ops::operator!= rel_ops::operator> rel_ops::operator<= rel_ops::operator>= Integer comparison functions cmp_equal cmp_less cmp_less_than (C++20) (C++20) (C++20) cmp_not_equal cmp_greater cmp_greater_than (C++20) (C++20) (C++20) in_range (C++20) Swap and type operations swap ranges::swap (C++20) exchange (C++14) declval (C++11) to_underlying (C++23) forward (C++11) forward_like (C++23) move (C++11) move_if_noexcept (C++11) as_const (C++17) Common vocabulary types pair tuple (C++11) optional (C++17) any (C++17) variant (C++17) tuple_size (C++11) tuple_element (C++11) apply (C++17) make_from_tuple (C++17) expected (C++23) [edit] Function objects Function wrappers function (C++11) move_only_function (C++23) copyable_function (C++26) function_ref (C++26) mem_fn (C++11) bad_function_call (C++11) Partial function application bind_front bind_back (C++20) (C++23) bind (C++11) is_bind_expression (C++11) is_placeholder (C++11) _1, _2, _3, ... (C++11) Function invocation invoke invoke_r (C++17) (C++23) Identity function object identity (C++20) Reference wrappers reference_wrapper (C++11) ref cref (C++11) (C++11) unwrap_reference unwrap_ref_decay (C++20) (C++20) Operator wrappers plus minus negate multiplies divides modulus bit_and bit_or bit_not (C++14) bit_xor equal_to not_equal_to greater less greater_equal less_equal logical_and logical_or logical_not Transparent operator wrappers plus <> (C++14) minus <> (C++14) negate <> (C++14) multiplies <> (C++14) divides <> (C++14) modulus <> (C++14) bit_and <> (C++14) bit_or <> (C++14) bit_not <> (C++14) bit_xor <> (C++14) equal_to <> (C++14) not_equal_to <> (C++14) greater <> (C++14) less <> (C++14) greater_equal <> (C++14) less_equal <> (C++14) logical_and <> (C++14) logical_or <> (C++14) logical_not <> (C++14) Negators not_fn (C++17) Searchers default_searcher (C++17) boyer_moore_searcher (C++17) boyer_moore_horspool_searcher (C++17) Constrained comparators ranges::equal_to (C++20) ranges::not_equal_to (C++20) ranges::greater (C++20) ranges::less (C++20) ranges::greater_equal (C++20) ranges::less_equal (C++20) compare_three_way (C++20) Old binders and adaptors unary_function ( until C++17* ) binary_function ( until C++17* ) ptr_fun ( until C++17* ) pointer_to_unary_function ( until C++17* ) pointer_to_binary_function ( until C++17* ) mem_fun ( until C++17* ) mem_fun_t mem_fun1_t const_mem_fun_t const_mem_fun1_t ( until C++17* ) ( until C++17* ) ( until C++17* ) ( until C++17* ) not1 ( until C++20* ) not2 ( until C++20* ) binder1st binder2nd ( until C++17* ) ( until C++17* ) bind1st bind2nd ( until C++17* ) ( until C++17* ) mem_fun_ref ( until C++17* ) mem_fun_ref_t mem_fun1_ref_t const_mem_fun_ref_t const_mem_fun1_ref_t ( until C++17* ) ( until C++17* ) ( until C++17* ) ( until C++17* ) unary_negate ( until C++20* ) binary_negate ( until C++20* ) [edit] Defined in header <functional> template < class M, class T > /* unspecified */ mem_fn ( M T :: * pm ) noexcept ; (since C++11) (constexpr since C++20) Function template std::mem_fn generates wrapper objects for pointers to members, which can store, copy, and invoke a pointer to member . Both references and pointers (including smart pointers) to an object can be used when invoking a std::mem_fn . Contents 1 Parameters 2 Return value 3 std::mem_fn return type 3.1 Member types 3.2 Member function 3.3 Example 3.4 Defect reports 3.5 See also [ edit ] Parameters pm - pointer to member that will be wrapped [ edit ] Return value std::mem_fn returns a call wrapper fn of unspecified type that has the following members: std::mem_fn return type Member types type definition result_type (deprecated in C++17) the return type of pm if pm is a pointer to member function, not defined for pointer to member object argument_type (deprecated in C++17) T* , possibly cv-qualified, if pm is a pointer to member function taking no arguments first_argument_type (deprecated in C++17) T* if pm is a pointer to member function taking one argument second_argument_type (deprecated in C++17) T1 if pm is a pointer to member function taking one argument of type T1 (until C++20) Member function template < class ... Args > /* see below */ operator ( ) ( Args && ... args ) /* cvref-qualifiers */ noexcept ( /* see below */ ) ; (constexpr since C++20) The expression fn ( args ) is equivalent to INVOKE ( pmd, args ) , where pmd is the Callable object held by fn , it is of type M T::* and is direct-non-list-initialized with pm . Thus, the return type of operator ( ) is std:: result_of < decltype ( pm ) ( Args && ... ) > :: type or equivalently std:: invoke_result_t < decltype ( pm ) , Args && ... > , and the value in noexcept specifier is equal to std:: is_nothrow_invocable_v < decltype ( pm ) , Args && ... > ) (since C++17) . Each argument in args is perfectly forwarded, as if by std:: forward < Args > ( args ) ... . [ edit ] Example Use std::mem_fn to store and execute a member function and a member object: Run this code #include <functional> #include <iostream> #include <memory> struct Foo { void display_greeting ( ) { std:: cout << "Hello, world. \n " ; } void display_number ( int i ) { std:: cout << "number: " << i << ' \n ' ; } int add_xy ( int x, int y ) { return data + x + y ; } template < typename ... Args > int add_many ( Args... args ) { return data + ( args + ... ) ; } auto add_them ( auto ... args ) // C++20 required { return data + ( args + ... ) ; } int data = 7 ; } ; int main ( ) { auto f = Foo { } ; auto greet = std :: mem_fn ( & Foo :: display_greeting ) ; greet ( f ) ; auto print_num = std :: mem_fn ( & Foo :: display_number ) ; print_num ( f, 42 ) ; auto access_data = std :: mem_fn ( & Foo :: data ) ; std:: cout << "data: " << access_data ( f ) << ' \n ' ; auto add_xy = std :: mem_fn ( & Foo :: add_xy ) ; std:: cout << "add_xy: " << add_xy ( f, 1 , 2 ) << ' \n ' ; auto u = std:: make_unique < Foo > ( ) ; std:: cout << "access_data(u): " << access_data ( u ) << ' \n ' ; std:: cout << "add_xy(u, 1, 2): " << add_xy ( u, 1 , 2 ) << ' \n ' ; auto add_many = std :: mem_fn ( & Foo :: add_many < short , int , long > ) ; std:: cout << "add_many(u, ...): " << add_many ( u, 1 , 2 , 3 ) << ' \n ' ; auto add_them = std :: mem_fn ( & Foo :: add_them < short , int , float , double > ) ; std:: cout << "add_them(u, ...): " << add_them ( u, 5 , 7 , 10.0f , 13.0 ) << ' \n ' ; } Output: Hello, world. number: 42 data: 7 add_xy: 10 access_data(u): 7 add_xy(u, 1, 2): 10 add_many(u, ...): 13 add_them(u, ...): 42 [ edit ] Defect reports The following behavior-changing defect reports were applied retroactively to previously published C++ standards. DR Applied to Behavior as published Correct behavior LWG 2048 C++11 unnecessary overloads provided removed LWG 2489 C++11 noexcept not required required [ edit ] See also function (C++11) copyable wrapper of any copy constructible callable object (class template) [edit] move_only_function (C++23) move-only wrapper of any callable object that supports qualifiers in a given call signature (class template) [edit] bind (C++11) binds one or more arguments to a function object (function template) [edit] Retrieved from " https://en.cppreference.com/mwiki/index.php?title=cpp/utility/functional/mem_fn&oldid=173613 " Navigation Support us Recent changes FAQ Offline version Toolbox What links here Related changes Upload file Special pages Printable version Permanent link Page information In other languages Deutsch Español Français Italiano 日本語 Português Русский 中文 This page was last modified on 13 July 2024, at 21:35. Privacy policy About cppreference.com Disclaimers