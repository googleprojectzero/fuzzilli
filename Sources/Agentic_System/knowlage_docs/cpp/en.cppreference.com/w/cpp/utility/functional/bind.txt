std::bind - cppreference.com cppreference.com Create account Log in Namespaces Page Discussion Variants Views View Edit History Actions std:: bind From cppreference.com < cpp ‎ | utility ‎ | functional C++ Compiler support Freestanding and hosted Language Standard library Standard library headers Named requirements Feature test macros (C++20) Language support library Concepts library (C++20) Diagnostics library Memory management library Metaprogramming library (C++11) General utilities library Containers library Iterators library Ranges library (C++20) Algorithms library Strings library Text processing library Numerics library Date and time library Input/output library Filesystem library (C++17) Concurrency support library (C++11) Execution control library (C++26) Technical specifications Symbols index External libraries [edit] Utilities library Language support Type support (basic types, RTTI) Library feature-test macros (C++20) Program utilities Variadic functions initializer_list (C++11) is_constant_evaluated (C++20) is_within_lifetime (C++26) source_location (C++20) Coroutine support (C++20) Contract support (C++26) Three-way comparison three_way_comparable three_way_comparable_with (C++20) (C++20) strong_ordering (C++20) weak_ordering (C++20) partial_ordering (C++20) common_comparison_category (C++20) compare_three_way_result (C++20) compare_three_way (C++20) strong_order (C++20) weak_order (C++20) partial_order (C++20) compare_strong_order_fallback (C++20) compare_weak_order_fallback (C++20) compare_partial_order_fallback (C++20) is_eq is_lt is_lteq (C++20) (C++20) (C++20) is_neq is_gt is_gteq (C++20) (C++20) (C++20) General utilities Function objects Bit manipulation (C++20) C-style bit manipulation (C++26) bitset hash (C++11) Relational operators (deprecated in C++20) rel_ops::operator!= rel_ops::operator> rel_ops::operator<= rel_ops::operator>= Integer comparison functions cmp_equal cmp_less cmp_less_than (C++20) (C++20) (C++20) cmp_not_equal cmp_greater cmp_greater_than (C++20) (C++20) (C++20) in_range (C++20) Swap and type operations swap ranges::swap (C++20) exchange (C++14) declval (C++11) to_underlying (C++23) forward (C++11) forward_like (C++23) move (C++11) move_if_noexcept (C++11) as_const (C++17) Common vocabulary types pair tuple (C++11) optional (C++17) any (C++17) variant (C++17) tuple_size (C++11) tuple_element (C++11) apply (C++17) make_from_tuple (C++17) expected (C++23) [edit] Function objects Function wrappers function (C++11) move_only_function (C++23) copyable_function (C++26) function_ref (C++26) mem_fn (C++11) bad_function_call (C++11) Partial function application bind_front bind_back (C++20) (C++23) bind (C++11) is_bind_expression (C++11) is_placeholder (C++11) _1, _2, _3, ... (C++11) Function invocation invoke invoke_r (C++17) (C++23) Identity function object identity (C++20) Reference wrappers reference_wrapper (C++11) ref cref (C++11) (C++11) unwrap_reference unwrap_ref_decay (C++20) (C++20) Operator wrappers plus minus negate multiplies divides modulus bit_and bit_or bit_not (C++14) bit_xor equal_to not_equal_to greater less greater_equal less_equal logical_and logical_or logical_not Transparent operator wrappers plus <> (C++14) minus <> (C++14) negate <> (C++14) multiplies <> (C++14) divides <> (C++14) modulus <> (C++14) bit_and <> (C++14) bit_or <> (C++14) bit_not <> (C++14) bit_xor <> (C++14) equal_to <> (C++14) not_equal_to <> (C++14) greater <> (C++14) less <> (C++14) greater_equal <> (C++14) less_equal <> (C++14) logical_and <> (C++14) logical_or <> (C++14) logical_not <> (C++14) Negators not_fn (C++17) Searchers default_searcher (C++17) boyer_moore_searcher (C++17) boyer_moore_horspool_searcher (C++17) Constrained comparators ranges::equal_to (C++20) ranges::not_equal_to (C++20) ranges::greater (C++20) ranges::less (C++20) ranges::greater_equal (C++20) ranges::less_equal (C++20) compare_three_way (C++20) Old binders and adaptors unary_function ( until C++17* ) binary_function ( until C++17* ) ptr_fun ( until C++17* ) pointer_to_unary_function ( until C++17* ) pointer_to_binary_function ( until C++17* ) mem_fun ( until C++17* ) mem_fun_t mem_fun1_t const_mem_fun_t const_mem_fun1_t ( until C++17* ) ( until C++17* ) ( until C++17* ) ( until C++17* ) not1 ( until C++20* ) not2 ( until C++20* ) binder1st binder2nd ( until C++17* ) ( until C++17* ) bind1st bind2nd ( until C++17* ) ( until C++17* ) mem_fun_ref ( until C++17* ) mem_fun_ref_t mem_fun1_ref_t const_mem_fun_ref_t const_mem_fun1_ref_t ( until C++17* ) ( until C++17* ) ( until C++17* ) ( until C++17* ) unary_negate ( until C++20* ) binary_negate ( until C++20* ) [edit] Defined in header <functional> template < class F, class ... Args > /* unspecified */ bind ( F && f, Args && ... args ) ; (1) (since C++11) (constexpr since C++20) template < class R, class F, class ... Args > /* unspecified */ bind ( F && f, Args && ... args ) ; (2) (since C++11) (constexpr since C++20) The function template std::bind generates a forwarding call wrapper for f . Calling this wrapper is equivalent to invoking f with some of its arguments bound to args . If std:: is_constructible < std:: decay < F > :: type , F > :: value is false , or std:: is_constructible < std:: decay < Arg_i > :: type , Arg_i > :: value is false for any type Arg_i in Args , the program is ill-formed. If std:: decay < Ti > :: type or any type in Args is not MoveConstructible or Destructible , the behavior is undefined. Contents 1 Parameters 2 Return value 3 std::bind return type 3.1 Member objects 3.2 Constructors 3.3 Member type result_type 3.4 Member function operator() 3.5 Bound arguments 3.5.1 Case 1: reference wrappers 3.5.2 Case 2: bind expressions 3.5.3 Case 3: placeholders 3.5.4 Case 4: ordinary arguments 3.6 Exceptions 3.7 Notes 3.8 Example 3.9 Defect reports 3.10 See also [ edit ] Parameters f - Callable object (function object, pointer to function, reference to function, pointer to member function, or pointer to data member) that will be bound to some arguments args - list of arguments to bind, with the unbound arguments replaced by the placeholders _1 , _2 , _3 ... of namespace std::placeholders [ edit ] Return value A function object g of unspecified type T , for which std:: is_bind_expression < T > :: value is true . It has the following members: std::bind return type Member objects The return type of std::bind holds a member object of type std:: decay < F > :: type constructed from std:: forward < F > ( f ) , and one object per each of args... , of type std:: decay < Arg_i > :: type , similarly constructed from std:: forward < Arg_i > ( arg_i ) . Constructors The return type of std::bind is CopyConstructible if all of its member objects (specified above) are CopyConstructible, and is MoveConstructible otherwise. The type defines the following members: Member type result_type 1) (deprecated in C++17) If F is a pointer to function or a pointer to member function, result_type is the return type of F . If F is a class type with nested typedef result_type , then result_type is F::result_type . Otherwise no result_type is defined. 2) (deprecated in C++17) result_type is exactly R . (until C++20) Member function operator() When g is invoked in a function call expression g ( u1, u2, ... uM ) , an invocation of the stored object takes place, as if by 1) INVOKE ( fd, std:: forward < V1 > ( v1 ) , std:: forward < V2 > ( v2 ) , ..., std:: forward < VN > ( vN ) ) , or 2) INVOKE<R> ( fd, std:: forward < V1 > ( v1 ) , std:: forward < V2 > ( v2 ) , ..., std:: forward < VN > ( vN ) ) , where fd is a value of type std:: decay < F > :: type , the values and types of the bound arguments v1 , v2 , ..., vN are determined as specified below . If some of the arguments that are supplied in the call to g ( ) are not matched by any placeholders stored in g , the unused arguments are evaluated and discarded. An invocation of operator ( ) is non-throwing or is a constant subexpression (since C++20) if and only if so is the underlying INVOKE operation. operator ( ) participates in overload resolution only if the INVOKE operation is well-formed when treated as an unevaluated operand. If g is volatile -qualified, the program is ill-formed. If INVOKE ( fd, w1, w2, ..., wN ) can never be a valid expression for any possible values w1 , w2 , ..., wN , the behavior is undefined. [ edit ] Bound arguments For each stored argument arg_i , the corresponding bound argument v_i in the INVOKE or INVOKE<R> operation is determined as follows: [ edit ] Case 1: reference wrappers If arg_i is of type std:: reference_wrapper < T > (for example, std::ref or std::cref was used in the initial call to std::bind ), then v_i is arg_i. get ( ) and its type V_i is T& : the stored argument is passed by reference into the invoked function object. [ edit ] Case 2: bind expressions If arg_i is of type T for which std:: is_bind_expression < T > :: value is true (for example, another std::bind expression was passed directly into the initial call to std::bind ), then std::bind performs function composition: instead of passing the function object that the bind subexpression would return, the subexpression is invoked eagerly, and its return value is passed to the outer invokable object. If the bind subexpression has any placeholder arguments, they are shared with the outer bind (picked out of u1 , u2 , ... ). Specifically, v_i is arg_i ( std:: forward < Uj > ( uj ) ... ) and its type V_i is std:: result_of < T cv ﻿ & ( Uj && ... ) > :: type && (until C++17) std:: invoke_result_t < T cv ﻿ & , Uj && ... > && (since C++17) (cv-qualification is the same as that of g ). [ edit ] Case 3: placeholders If arg_i is of type T , for which std:: is_placeholder < T > :: value is not ​ 0 ​ (meaning, a placeholder such as std::placeholders::_1, _2, _3, ... was used as the argument to the initial call to std::bind ), then the argument indicated by the placeholder ( u1 for _1 , u2 for _2 , etc) is passed to the invokable object: v_i is std:: forward < Uj > ( uj ) and its type V_i is Uj&& . [ edit ] Case 4: ordinary arguments Otherwise, arg_i is passed to the invokable object as lvalue argument: v_i is simply arg_i and its type V_i is T cv ﻿ & , where cv is the same cv-qualification as that of g . [ edit ] Exceptions Only throws if construction of std:: decay < F > :: type from std:: forward < F > ( f ) throws, or any of the constructors for std:: decay < Arg_i > :: type from the corresponding std:: forward < Arg_i > ( arg_i ) throws where Arg_i is the ith type and arg_i is the ith argument in Args... args . [ edit ] Notes As described in Callable , when invoking a pointer to non-static member function or pointer to non-static data member, the first argument has to be a reference or pointer (including, possibly, smart pointer such as std::shared_ptr and std::unique_ptr ) to an object whose member will be accessed. The arguments to bind are copied or moved, and are never passed by reference unless wrapped in std::ref or std::cref . Duplicate placeholders in the same bind expression (multiple _1 's for example) are allowed, but the results are only well defined if the corresponding argument ( u1 ) is an lvalue or non-movable rvalue. [ edit ] Example Run this code #include <functional> #include <iostream> #include <memory> #include <random> void f ( int n1, int n2, int n3, const int & n4, int n5 ) { std:: cout << n1 << ' ' << n2 << ' ' << n3 << ' ' << n4 << ' ' << n5 << ' \n ' ; } int g ( int n1 ) { return n1 ; } struct Foo { void print_sum ( int n1, int n2 ) { std:: cout << n1 + n2 << ' \n ' ; } int data = 10 ; } ; int main ( ) { using namespace std:: placeholders ; // for _1, _2, _3... std:: cout << "1) argument reordering and pass-by-reference: " ; int n = 7 ; // (_1 and _2 are from std::placeholders, and represent future // arguments that will be passed to f1) auto f1 = std :: bind ( f, _2, 42 , _1, std:: cref ( n ) , n ) ; n = 10 ; f1 ( 1 , 2 , 1001 ) ; // 1 is bound by _1, 2 is bound by _2, 1001 is unused // makes a call to f(2, 42, 1, n, 7) std:: cout << "2) achieving the same effect using a lambda: " ; n = 7 ; auto lambda = [ & ncref = n, n ] ( auto a, auto b, auto /*unused*/ ) { f ( b, 42 , a, ncref, n ) ; } ; n = 10 ; lambda ( 1 , 2 , 1001 ) ; // same as a call to f1(1, 2, 1001) std:: cout << "3) nested bind subexpressions share the placeholders: " ; auto f2 = std :: bind ( f, _3, std :: bind ( g, _3 ) , _3, 4 , 5 ) ; f2 ( 10 , 11 , 12 ) ; // makes a call to f(12, g(12), 12, 4, 5); std:: cout << "4) bind a RNG with a distribution: " ; std:: default_random_engine e ; std:: uniform_int_distribution <> d ( 0 , 10 ) ; auto rnd = std :: bind ( d, e ) ; // a copy of e is stored in rnd for ( int n = 0 ; n < 10 ; ++ n ) std:: cout << rnd ( ) << ' ' ; std:: cout << ' \n ' ; std:: cout << "5) bind to a pointer to member function: " ; Foo foo ; auto f3 = std :: bind ( & Foo :: print_sum , & foo, 95 , _1 ) ; f3 ( 5 ) ; std:: cout << "6) bind to a mem_fn that is a pointer to member function: " ; auto ptr_to_print_sum = std:: mem_fn ( & Foo :: print_sum ) ; auto f4 = std :: bind ( ptr_to_print_sum, & foo, 95 , _1 ) ; f4 ( 5 ) ; std:: cout << "7) bind to a pointer to data member: " ; auto f5 = std :: bind ( & Foo :: data , _1 ) ; std:: cout << f5 ( foo ) << ' \n ' ; std:: cout << "8) bind to a mem_fn that is a pointer to data member: " ; auto ptr_to_data = std:: mem_fn ( & Foo :: data ) ; auto f6 = std :: bind ( ptr_to_data, _1 ) ; std:: cout << f6 ( foo ) << ' \n ' ; std:: cout << "9) use smart pointers to call members of the referenced objects: " ; std:: cout << f6 ( std:: make_shared < Foo > ( foo ) ) << ' ' << f6 ( std:: make_unique < Foo > ( foo ) ) << ' \n ' ; } Output: 1) argument reordering and pass-by-reference: 2 42 1 10 7 2) achieving the same effect using a lambda: 2 42 1 10 7 3) nested bind subexpressions share the placeholders: 12 12 12 4 5 4) bind a RNG with a distribution: 0 1 8 5 5 2 0 7 7 10 5) bind to a pointer to member function: 100 6) bind to a mem_fn that is a pointer to member function: 100 7) bind to a pointer to data member: 10 8) bind to a mem_fn that is a pointer to data member: 10 9) use smart pointers to call members of the referenced objects: 10 10 [ edit ] Defect reports The following behavior-changing defect reports were applied retroactively to previously published C++ standards. DR Applied to Behavior as published Correct behavior LWG 2021 C++11 1. the bounded arguments were not forwarded to fd 2. in case 2, the type of V_i was std:: result_of < T cv ﻿ ( Uj... ) > :: type 1. forwarded 2. changed to std:: result_of < T cv ﻿ & ( Uj && ... ) > :: type && [ edit ] See also bind_front bind_back (C++20) (C++23) bind a variable number of arguments, in order, to a function object (function template) [edit] _1, _2, _3, _4, ... (C++11) placeholders for the unbound arguments in a std::bind expression (constant) [edit] mem_fn (C++11) creates a function object out of a pointer to a member (function template) [edit] Retrieved from " https://en.cppreference.com/mwiki/index.php?title=cpp/utility/functional/bind&oldid=173615 " Navigation Support us Recent changes FAQ Offline version Toolbox What links here Related changes Upload file Special pages Printable version Permanent link Page information In other languages Deutsch Español Français Italiano 日本語 Português Русский 中文 This page was last modified on 13 July 2024, at 21:47. Privacy policy About cppreference.com Disclaimers