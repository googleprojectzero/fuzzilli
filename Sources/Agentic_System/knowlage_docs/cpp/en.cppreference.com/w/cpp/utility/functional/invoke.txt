std::invoke, std::invoke_r - cppreference.com cppreference.com Create account Log in Namespaces Page Discussion Variants Views View Edit History Actions std:: invoke, std:: invoke_r From cppreference.com < cpp ‎ | utility ‎ | functional C++ Compiler support Freestanding and hosted Language Standard library Standard library headers Named requirements Feature test macros (C++20) Language support library Concepts library (C++20) Diagnostics library Memory management library Metaprogramming library (C++11) General utilities library Containers library Iterators library Ranges library (C++20) Algorithms library Strings library Text processing library Numerics library Date and time library Input/output library Filesystem library (C++17) Concurrency support library (C++11) Execution control library (C++26) Technical specifications Symbols index External libraries [edit] Utilities library Language support Type support (basic types, RTTI) Library feature-test macros (C++20) Program utilities Variadic functions initializer_list (C++11) is_constant_evaluated (C++20) is_within_lifetime (C++26) source_location (C++20) Coroutine support (C++20) Contract support (C++26) Three-way comparison three_way_comparable three_way_comparable_with (C++20) (C++20) strong_ordering (C++20) weak_ordering (C++20) partial_ordering (C++20) common_comparison_category (C++20) compare_three_way_result (C++20) compare_three_way (C++20) strong_order (C++20) weak_order (C++20) partial_order (C++20) compare_strong_order_fallback (C++20) compare_weak_order_fallback (C++20) compare_partial_order_fallback (C++20) is_eq is_lt is_lteq (C++20) (C++20) (C++20) is_neq is_gt is_gteq (C++20) (C++20) (C++20) General utilities Function objects Bit manipulation (C++20) C-style bit manipulation (C++26) bitset hash (C++11) Relational operators (deprecated in C++20) rel_ops::operator!= rel_ops::operator> rel_ops::operator<= rel_ops::operator>= Integer comparison functions cmp_equal cmp_less cmp_less_than (C++20) (C++20) (C++20) cmp_not_equal cmp_greater cmp_greater_than (C++20) (C++20) (C++20) in_range (C++20) Swap and type operations swap ranges::swap (C++20) exchange (C++14) declval (C++11) to_underlying (C++23) forward (C++11) forward_like (C++23) move (C++11) move_if_noexcept (C++11) as_const (C++17) Common vocabulary types pair tuple (C++11) optional (C++17) any (C++17) variant (C++17) tuple_size (C++11) tuple_element (C++11) apply (C++17) make_from_tuple (C++17) expected (C++23) [edit] Function objects Function wrappers function (C++11) move_only_function (C++23) copyable_function (C++26) function_ref (C++26) mem_fn (C++11) bad_function_call (C++11) Partial function application bind_front bind_back (C++20) (C++23) bind (C++11) is_bind_expression (C++11) is_placeholder (C++11) _1, _2, _3, ... (C++11) Function invocation invoke invoke_r (C++17) (C++23) Identity function object identity (C++20) Reference wrappers reference_wrapper (C++11) ref cref (C++11) (C++11) unwrap_reference unwrap_ref_decay (C++20) (C++20) Operator wrappers plus minus negate multiplies divides modulus bit_and bit_or bit_not (C++14) bit_xor equal_to not_equal_to greater less greater_equal less_equal logical_and logical_or logical_not Transparent operator wrappers plus <> (C++14) minus <> (C++14) negate <> (C++14) multiplies <> (C++14) divides <> (C++14) modulus <> (C++14) bit_and <> (C++14) bit_or <> (C++14) bit_not <> (C++14) bit_xor <> (C++14) equal_to <> (C++14) not_equal_to <> (C++14) greater <> (C++14) less <> (C++14) greater_equal <> (C++14) less_equal <> (C++14) logical_and <> (C++14) logical_or <> (C++14) logical_not <> (C++14) Negators not_fn (C++17) Searchers default_searcher (C++17) boyer_moore_searcher (C++17) boyer_moore_horspool_searcher (C++17) Constrained comparators ranges::equal_to (C++20) ranges::not_equal_to (C++20) ranges::greater (C++20) ranges::less (C++20) ranges::greater_equal (C++20) ranges::less_equal (C++20) compare_three_way (C++20) Old binders and adaptors unary_function ( until C++17* ) binary_function ( until C++17* ) ptr_fun ( until C++17* ) pointer_to_unary_function ( until C++17* ) pointer_to_binary_function ( until C++17* ) mem_fun ( until C++17* ) mem_fun_t mem_fun1_t const_mem_fun_t const_mem_fun1_t ( until C++17* ) ( until C++17* ) ( until C++17* ) ( until C++17* ) not1 ( until C++20* ) not2 ( until C++20* ) binder1st binder2nd ( until C++17* ) ( until C++17* ) bind1st bind2nd ( until C++17* ) ( until C++17* ) mem_fun_ref ( until C++17* ) mem_fun_ref_t mem_fun1_ref_t const_mem_fun_ref_t const_mem_fun1_ref_t ( until C++17* ) ( until C++17* ) ( until C++17* ) ( until C++17* ) unary_negate ( until C++20* ) binary_negate ( until C++20* ) [edit] Defined in header <functional> template < class F, class ... Args > std:: invoke_result_t < F, Args... > invoke ( F && f, Args && ... args ) noexcept ( /* see below */ ) ; (1) (since C++17) (constexpr since C++20) template < class R, class F, class ... Args > constexpr R invoke_r ( F && f, Args && ... args ) noexcept ( /* see below */ ) ; (2) (since C++23) 1) Invoke the Callable object f with the parameters args as by INVOKE ( std:: forward < F > ( f ) , std:: forward < Args > ( args ) ... ) . This overload participates in overload resolution only if std:: is_invocable_v < F, Args... > is true . 2) Invoke the Callable object f with the parameters args as by INVOKE<R> ( std:: forward < F > ( f ) , std:: forward < Args > ( args ) ... ) . This overload participates in overload resolution only if std:: is_invocable_r_v < R, F, Args... > is true . Contents 1 Parameters 2 Return value 3 Exceptions 4 Possible implementation 5 Notes 6 Example 7 See also [ edit ] Parameters f - Callable object to be invoked args - arguments to pass to f [ edit ] Return value 1) The value returned by f . 2) The value returned by f , implicitly converted to R , if R is not (possibly cv-qualified ) void . None otherwise. [ edit ] Exceptions 1) noexcept specification: noexcept ( std:: is_nothrow_invocable_v < F, Args... > ) 2) noexcept specification: noexcept ( std:: is_nothrow_invocable_r_v < R, F, Args... > ) [ edit ] Possible implementation invoke (1) namespace detail { template < class > constexpr bool is_reference_wrapper_v = false ; template < class U > constexpr bool is_reference_wrapper_v < std:: reference_wrapper < U >> = true ; template < class T > using remove_cvref_t = std:: remove_cv_t < std:: remove_reference_t < T >> ; template < class C, class Pointed, class Object, class ... Args > constexpr decltype ( auto ) invoke_memptr ( Pointed C :: * member, Object && object, Args && ... args ) { using object_t = remove_cvref_t < Object > ; constexpr bool is_member_function = std:: is_function_v < Pointed > ; constexpr bool is_wrapped = is_reference_wrapper_v < object_t > ; constexpr bool is_derived_object = std:: is_same_v < C, object_t > || std:: is_base_of_v < C, object_t > ; if constexpr ( is_member_function ) { if constexpr ( is_derived_object ) return ( std:: forward < Object > ( object ) . * member ) ( std:: forward < Args > ( args ) ... ) ; else if constexpr ( is_wrapped ) return ( object. get ( ) . * member ) ( std:: forward < Args > ( args ) ... ) ; else return ( ( * std:: forward < Object > ( object ) ) . * member ) ( std:: forward < Args > ( args ) ... ) ; } else { static_assert ( std:: is_object_v < Pointed > && sizeof... ( args ) == 0 ) ; if constexpr ( is_derived_object ) return std:: forward < Object > ( object ) . * member ; else if constexpr ( is_wrapped ) return object. get ( ) . * member ; else return ( * std:: forward < Object > ( object ) ) . * member ; } } } // namespace detail template < class F, class ... Args > constexpr std:: invoke_result_t < F, Args... > invoke ( F && f, Args && ... args ) noexcept ( std:: is_nothrow_invocable_v < F, Args... > ) { if constexpr ( std:: is_member_pointer_v < detail :: remove_cvref_t < F >> ) return detail :: invoke_memptr ( f, std:: forward < Args > ( args ) ... ) ; else return std:: forward < F > ( f ) ( std:: forward < Args > ( args ) ... ) ; } invoke_r (2) template < class R, class F, class ... Args > requires std:: is_invocable_r_v < R, F, Args... > constexpr R invoke_r ( F && f, Args && ... args ) noexcept ( std:: is_nothrow_invocable_r_v < R, F, Args... > ) { if constexpr ( std:: is_void_v < R > ) std :: invoke ( std:: forward < F > ( f ) , std:: forward < Args > ( args ) ... ) ; else return std :: invoke ( std:: forward < F > ( f ) , std:: forward < Args > ( args ) ... ) ; } [ edit ] Notes Feature-test macro Value Std Feature __cpp_lib_invoke 201411L (C++17) std::invoke , ( 1 ) __cpp_lib_invoke_r 202106L (C++23) std::invoke_r , ( 2 ) [ edit ] Example Run this code #include <functional> #include <iostream> #include <type_traits> struct Foo { Foo ( int num ) : num_ ( num ) { } void print_add ( int i ) const { std:: cout << num_ + i << ' \n ' ; } int num_ ; } ; void print_num ( int i ) { std:: cout << i << ' \n ' ; } struct PrintNum { void operator ( ) ( int i ) const { std:: cout << i << ' \n ' ; } } ; int main ( ) { std:: cout << "invoke a free function: " ; std :: invoke ( print_num, - 9 ) ; std:: cout << "invoke a lambda: " ; std :: invoke ( [ ] ( ) { print_num ( 42 ) ; } ) ; std:: cout << "invoke a member function: " ; const Foo foo ( 314159 ) ; std :: invoke ( & Foo :: print_add , foo, 1 ) ; std:: cout << "invoke (i.e., access) a data member num_: " << std :: invoke ( & Foo :: num_ , foo ) << ' \n ' ; std:: cout << "invoke a function object: " ; std :: invoke ( PrintNum ( ) , 18 ) ; #if defined(__cpp_lib_invoke_r) auto add = [ ] ( int x, int y ) { return x + y ; } ; std:: cout << "invoke a lambda converting result to float: " ; auto ret = std :: invoke_r < float > ( add, 11 , 22 ) ; static_assert ( std:: is_same < decltype ( ret ) , float > ( ) ) ; std:: cout << std:: fixed << ret << " \n invoke print_num: " ; std :: invoke_r < void > ( print_num, 44 ) ; #endif } Possible output: invoke a free function: -9 invoke a lambda: 42 invoke a member function: 314160 invoke (i.e., access) a data member num_: 314159 invoke a function object: 18 invoke a lambda converting result to float: 33.000000 invoke print_num: 44 [ edit ] See also mem_fn (C++11) creates a function object out of a pointer to a member (function template) [edit] result_of invoke_result (C++11) (removed in C++20) (C++17) deduces the result type of invoking a callable object with a set of arguments (class template) [edit] is_invocable is_invocable_r is_nothrow_invocable is_nothrow_invocable_r (C++17) checks if a type can be invoked (as if by std::invoke ) with the given argument types (class template) [edit] apply (C++17) calls a function with a tuple of arguments (function template) [edit] Retrieved from " https://en.cppreference.com/mwiki/index.php?title=cpp/utility/functional/invoke&oldid=169675 " Category : conditionally noexcept Navigation Support us Recent changes FAQ Offline version Toolbox What links here Related changes Upload file Special pages Printable version Permanent link Page information In other languages Español 日本語 Русский 中文 This page was last modified on 8 February 2024, at 22:01. Privacy policy About cppreference.com Disclaimers