std::erase_if (std::unordered_multimap) - cppreference.com cppreference.com Create account Log in Namespaces Page Discussion Variants Views View Edit History Actions std:: erase_if (std::unordered_multimap) From cppreference.com < cpp ‎ | container ‎ | unordered multimap [edit template] C++ Compiler support Freestanding and hosted Language Standard library Standard library headers Named requirements Feature test macros (C++20) Language support library Concepts library (C++20) Diagnostics library Memory management library Metaprogramming library (C++11) General utilities library Containers library Iterators library Ranges library (C++20) Algorithms library Strings library Text processing library Numerics library Date and time library Input/output library Filesystem library (C++17) Concurrency support library (C++11) Execution control library (C++26) Technical specifications Symbols index External libraries [edit] Containers library node-handle (C++17) Sequence array (C++11) vector vector <bool> inplace_vector (C++26) hive (C++26) deque forward_list (C++11) list Associative set multiset map multimap Unordered associative unordered_set (C++11) unordered_multiset (C++11) unordered_map (C++11) unordered_multimap (C++11) Adaptors stack queue priority_queue flat_set (C++23) flat_multiset (C++23) flat_map (C++23) flat_multimap (C++23) Views span (C++20) mdspan (C++23) Tables Iterator invalidation Member function table Non-member function table [edit] std::unordered_multimap Member types Member functions unordered_multimap::unordered_multimap unordered_multimap::~unordered_multimap unordered_multimap::operator= unordered_multimap::get_allocator Iterators unordered_multimap::begin unordered_multimap::cbegin unordered_multimap::end unordered_multimap::cend Capacity unordered_multimap::size unordered_multimap::max_size unordered_multimap::empty Modifiers unordered_multimap::clear unordered_multimap::insert unordered_multimap::insert_range (C++23) unordered_multimap::emplace unordered_multimap::emplace_hint unordered_multimap::erase unordered_multimap::swap unordered_multimap::extract (C++17) unordered_multimap::merge (C++17) Lookup unordered_multimap::count unordered_multimap::find unordered_multimap::contains (C++20) unordered_multimap::equal_range Bucket interface unordered_multimap::begin (size_type) unordered_multimap::cbegin (size_type) unordered_multimap::end (size_type) unordered_multimap::cend (size_type) unordered_multimap::bucket_count unordered_multimap::max_bucket_count unordered_multimap::bucket_size unordered_multimap::bucket Hash policy unordered_multimap::load_factor unordered_multimap::max_load_factor unordered_multimap::rehash unordered_multimap::reserve Observers unordered_multimap::hash_function unordered_multimap::key_eq Non-member functions std::swap (std::unordered_multimap) erase_if (std::unordered_multimap) (C++20) operator== operator!= (until C++20) Deduction guides (C++17) [edit] Defined in header <unordered_map> template < class Key, class T, class Hash, class KeyEqual, class Alloc, class Pred > std:: unordered_multimap < Key, T, Hash, KeyEqual, Alloc > :: size_type erase_if ( std:: unordered_multimap < Key, T, Hash, KeyEqual, Alloc > & c, Pred pred ) ; (since C++20) (constexpr since C++26) Erases all elements that satisfy the predicate pred from c . Equivalent to auto old_size = c. size ( ) ; for ( auto first = c. begin ( ) , last = c. end ( ) ; first ! = last ; ) { if ( pred ( * first ) ) first = c. erase ( first ) ; else ++ first ; } return old_size - c. size ( ) ; Contents 1 Parameters 2 Return value 3 Complexity 4 Example 5 See also [ edit ] Parameters c - container from which to erase pred - predicate that returns true if the element should be erased [ edit ] Return value The number of erased elements. [ edit ] Complexity Linear. [ edit ] Example Run this code #include <iostream> #include <unordered_map> void println ( auto rem, const auto & container ) { std:: cout << rem << '{' ; for ( char sep [ ] { 0 , ' ' , 0 } ; const auto & [ key, value ] : container ) std:: cout << sep << '{' << key << ", " << value << '}' , * sep = ',' ; std:: cout << "} \n " ; } int main ( ) { std:: unordered_multimap < int , char > data { { 1 , 'a' } , { 2 , 'b' } , { 3 , 'c' } , { 4 , 'd' } , { 5 , 'e' } , { 4 , 'f' } , { 5 , 'g' } , { 5 , 'g' } , } ; println ( "Original: \n " , data ) ; const auto count = std:: erase_if ( data, [ ] ( const auto & item ) { const auto & [ key, value ] = item ; return ( key & 1 ) == 1 ; } ) ; println ( "Erase items with odd keys: \n " , data ) ; std:: cout << count << " items removed. \n " ; } Possible output: Original: {{5, g}, {5, g}, {5, e}, {4, f}, {4, d}, {3, c}, {2, b}, {1, a}} Erase items with odd keys: {{4, f}, {4, d}, {2, b}} 5 items removed. [ edit ] See also remove remove_if removes elements satisfying specific criteria (function template) [edit] ranges::remove ranges::remove_if (C++20) (C++20) removes elements satisfying specific criteria (algorithm function object) [edit] Retrieved from " https://en.cppreference.com/mwiki/index.php?title=cpp/container/unordered_multimap/erase_if&oldid=135910 " Navigation Support us Recent changes FAQ Offline version Toolbox What links here Related changes Upload file Special pages Printable version Permanent link Page information In other languages Deutsch Español 日本語 Русский 中文 This page was last modified on 29 November 2021, at 15:39. Privacy policy About cppreference.com Disclaimers