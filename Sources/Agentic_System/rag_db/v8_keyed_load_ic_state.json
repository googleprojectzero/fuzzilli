{
  "body": "IC state and invalidation mechanics relevant to keyed element loads in ic/ic.cc:\n- IC::UpdateState(object,name): when state is MONOMORPHIC or POLYMORPHIC and object is not null/undefined, may mark RECOMPUTE_HANDLER if ShouldRecomputeHandler(name) => recompute on prototype changes. It updates lookup_start_object_map.\n- IC::ShouldRecomputeHandler(name): triggers recompute when moving to a different map not yet handled, deprecations, or more general ElementsKind transition.\n- IC::SetCache(name, handler): drives transition among UNINITIALIZED -> MONOMORPHIC; MONOMORPHIC/POLYMORPHIC -> try UpdatePolymorphicIC, else CopyICToMegamorphicCache and set MEGAMORPHIC.\n- IC::UpdateMegamorphicCache(map,name,handler): stores in stub caches. Keyed ICs have distinct load/store stub caches; see IC::stub_cache.\n- IC::UpdatePolymorphicIC(name, handler): Maintains a vector of (map,handler), filters deprecated maps, allows overwriting existing map entries on prototype failures or transitions, otherwise grows until max_valid_polymorphic_map_count then falls back to megamorphic. Special-cases MEGADOM for LoadIC.\n- Prototype checks and proxies/interceptors: LoadElementHandler early-outs proxies and indexed interceptors; AccessorAssembler::HandleLoadICProtoHandler and CheckPrototypeValidityCell enforce Map::kPrototypeValidityCell for proto handlers. BranchIfPrototypesHaveNoElements used to allow hole/OOB -> undefined in element loads, guarded by the NoElements protector.\n- Feedback consumption by TurboFan/Maglev: tiering_manager()->NotifyICChanged in IC::OnFeedbackChanged; feedback vectors carry smi handlers and weak refs; optimizing compilers read FeedbackNexus slots and key load-mode bits via LoadHandler::GetKeyedAccessLoadMode and map/handler arrays for polymorphism. This is where optimizing compilers use the IC state to specialize keyed element loads.\n",
  "context": [
    "v8_keyedload_handler",
    "v8_accessor_assembler_element_load",
    "v8_keyedload_ic_entrypoints",
    "v8_elements_kind_lattice"
  ],
  "explanation": "Summarizes how keyed ICs transition states, how handlers are invalidated or recomputed on map/prototype changes, how proxies and interceptors force slow or special handlers, and how feedback changes trigger tiering. This provides the cross-cutting control logic around KeyedLoadIC.",
  "file_line": "ic/ic.cc:200-208,396-447,494-543,632-705,725-782,816-851"
}