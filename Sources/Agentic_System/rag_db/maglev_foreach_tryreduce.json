{
  "body": "// src/maglev/maglev-graph-builder.cc (excerpt)\nReduceResult MaglevGraphBuilder::TryReduceArrayForEach(\n    compiler::JSFunctionRef target, CallArguments& args) {\n  if (!CanSpeculateCall()) return ReduceResult::Fail();\n  ValueNode* receiver = args.receiver();\n  if (!receiver) return ReduceResult::Fail();\n  if (args.count() < 1) { ... return ReduceResult::Fail(); }\n\n  auto node_info = known_node_aspects().TryGetInfoFor(receiver);\n  if (!node_info || !node_info->possible_maps_are_known()) { ... return ReduceResult::Fail(); }\n\n  ElementsKind elements_kind;\n  if (!CanInlineArrayIteratingBuiltin(broker(), node_info->possible_maps(),\n                                      &elements_kind)) { ... return ReduceResult::Fail(); }\n\n  if (!broker()->dependencies()->DependOnNoElementsProtector()) { ... return ReduceResult::Fail(); }\n\n  ValueNode* callback = args[0];\n  if (!callback->is_tagged()) return ReduceResult::Fail();\n  ValueNode* this_arg = args.count() > 1 ? args[1] : GetRootConstant(RootIndex::kUndefinedValue);\n\n  ValueNode* original_length = BuildLoadJSArrayLength(receiver);\n\n  // Elide callable check if already known callable; otherwise wrap in lazy deopt.\n  EnsureType(callback, NodeType::kCallable, [&](NodeType old_type) {\n    DeoptFrameScope lazy_deopt_scope(\n        this, Builtin::kArrayForEachLoopLazyDeoptContinuation, target,\n        base::VectorOf<ValueNode*>({receiver, callback, this_arg,\n                                    GetSmiConstant(0), original_length}));\n    AddNewNode<ThrowIfNotCallable>({callback});\n  });\n\n  ValueNode* original_length_int32 = GetInt32(original_length);\n\n  bool receiver_maps_were_unstable = node_info->possible_maps_are_unstable();\n  PossibleMaps receiver_maps_before_loop(node_info->possible_maps());\n\n  // Build subgraph and loop variables (index, length)\n  MaglevSubGraphBuilder sub_builder(this, 2);\n  MaglevSubGraphBuilder::Variable var_index(0);\n  MaglevSubGraphBuilder::Variable var_length(1);\n  MaglevSubGraphBuilder::Label loop_end(&sub_builder, 1);\n\n  sub_builder.set(var_index, GetSmiConstant(0));\n  sub_builder.set(var_length, original_length);\n  MaglevSubGraphBuilder::LoopLabel loop_header =\n      sub_builder.BeginLoop({&var_index, &var_length});\n\n  // Reset known receiver maps and cached length for first-iteration semantics\n  if (receiver_maps_were_unstable) {\n    node_info->SetPossibleMaps(receiver_maps_before_loop, receiver_maps_were_unstable,\n                               NodeType::kUnknown, broker());\n    known_node_aspects().any_map_for_any_node_is_unstable = true;\n  }\n  RecordKnownProperty(receiver, broker()->length_string(),\n                      sub_builder.get(var_length), false,\n                      compiler::AccessMode::kLoad);\n\n  // Loop condition: index < original_length\n  Phi* index_tagged = sub_builder.get(var_index)->Cast<Phi>();\n  EnsureType(index_tagged, NodeType::kSmi);\n  ValueNode* index_int32 = GetInt32(index_tagged);\n  sub_builder.GotoIfFalse<BranchIfInt32Compare>(\n      &loop_end, {index_int32, original_length_int32}, Operation::kLessThan);\n\n  // Index increment with eager deopt continuation in case of overflow\n  ValueNode* next_index_int32 = nullptr;\n  {\n    DeoptFrameScope eager_deopt_scope(\n        this, Builtin::kArrayForEachLoopEagerDeoptContinuation, target,\n        base::VectorOf<ValueNode*>({receiver, callback, this_arg,\n                                    index_int32, original_length}));\n    next_index_int32 = AddNewNode<Int32IncrementWithOverflow>({index_int32});\n    EnsureType(next_index_int32, NodeType::kSmi);\n  }\n\n  // Load elements and array element at index, specialized by elements_kind\n  ValueNode* elements = BuildLoadElements(receiver);\n  ValueNode* element;\n  if (IsDoubleElementsKind(elements_kind)) {\n    element = BuildLoadFixedDoubleArrayElement(elements, index_int32);\n  } else {\n    element = BuildLoadFixedArrayElement(elements, index_int32);\n  }\n\n  // Optional hole check to skip call on HOLEY kinds\n  std::optional<MaglevSubGraphBuilder::Label> skip_call;\n  if (IsHoleyElementsKind(elements_kind)) {\n    skip_call.emplace(&sub_builder, 2, {&var_length});\n    if (elements_kind == HOLEY_DOUBLE_ELEMENTS) {\n      sub_builder.GotoIfTrue<BranchIfFloat64IsHole>(&*skip_call, {element});\n    } else {\n      sub_builder.GotoIfTrue<BranchIfRootConstant>(&*skip_call, {element},\n                                                   RootIndex::kTheHoleValue);\n    }\n  }\n\n  // Make the callback call under lazy deopt continuation to preserve stack\n  ReduceResult result;\n  {\n    DeoptFrameScope lazy_deopt_scope(\n        this, Builtin::kArrayForEachLoopLazyDeoptContinuation, target,\n        base::VectorOf<ValueNode*>({receiver, callback, this_arg,\n                                    next_index_int32, original_length}));\n\n    CallArguments call_args =\n        args.count() < 2\n            ? CallArguments(ConvertReceiverMode::kNullOrUndefined,\n                            {element, index_tagged, receiver})\n            : CallArguments(ConvertReceiverMode::kAny,\n                            {this_arg, element, index_tagged, receiver});\n    SaveCallSpeculationScope saved(this);\n    result = ReduceCall(callback, call_args, saved.value());\n  }\n\n  // After call, re-check maps if unstable and array length for deopt\n  if (!result.IsDoneWithAbort()) {\n    bool recheck_maps_after_call = receiver_maps_were_unstable;\n    if (recheck_maps_after_call) {\n      if (auto receiver_info_after_call = known_node_aspects().TryGetInfoFor(receiver)) {\n        if (receiver_info_after_call->possible_maps_are_known()) {\n          recheck_maps_after_call = !receiver_maps_before_loop.contains(\n              receiver_info_after_call->possible_maps());\n        }\n      }\n    }\n\n    DeoptFrameScope eager_deopt_scope(\n        this, Builtin::kArrayForEachLoopEagerDeoptContinuation, target,\n        base::VectorOf<ValueNode*>({receiver, callback, this_arg,\n                                    next_index_int32, original_length}));\n\n    if (recheck_maps_after_call) {\n      bool emit_check_with_migration = std::any_of(\n          receiver_maps_before_loop.begin(), receiver_maps_before_loop.end(),\n          [](compiler::MapRef map) { return map.is_migration_target(); });\n      if (emit_check_with_migration) {\n        AddNewNode<CheckMapsWithMigration>({receiver}, receiver_maps_before_loop,\n                                           CheckType::kOmitHeapObjectCheck);\n      } else {\n        AddNewNode<CheckMaps>({receiver}, receiver_maps_before_loop,\n                              CheckType::kOmitHeapObjectCheck);\n      }\n    }\n\n    // Deopt if Array length changed\n    ValueNode* current_length = BuildLoadJSArrayLength(receiver);\n    sub_builder.set(var_length, current_length);\n    if (current_length != original_length) {\n      RETURN_IF_ABORT(TryBuildCheckInt32Condition(original_length_int32, current_length,\n                                      AssertCondition::kUnsignedLessThanEqual,\n                                      DeoptimizeReason::kArrayLengthChanged));\n    }\n  }\n\n  if (skip_call.has_value()) { sub_builder.GotoOrTrim(&*skip_call); sub_builder.Bind(&*skip_call); }\n\n  sub_builder.set(var_index, next_index_int32);\n  sub_builder.EndLoop(&loop_header);\n  sub_builder.Bind(&loop_end);\n\n  return GetRootConstant(RootIndex::kUndefinedValue);\n}\n\n// Helpers referenced in TryReduceArrayForEach region\nnamespace {\nbool CanInlineArrayIteratingBuiltin(compiler::JSHeapBroker* broker,\n                                    const PossibleMaps& maps,\n                                    ElementsKind* kind_return) { ... }\n}\n\nValueNode* MaglevGraphBuilder::BuildLoadJSArrayLength(ValueNode* js_array, NodeType length_type=NodeType::kSmi);\nValueNode* MaglevGraphBuilder::BuildLoadElements(ValueNode* object);\n// MaglevSubGraphBuilder, BranchIfInt32Compare, Int32IncrementWithOverflow,\n// BranchIfFloat64IsHole, CheckMaps, CheckMapsWithMigration, etc are defined in maglev-ir.h/.cc and used here.",
  "context": [
    "maglev_foreach_deopt",
    "maglev_foreach_loop",
    "maglev_throw_if_not_callable",
    "maglev_elements_kind",
    "maglev_length_changed"
  ],
  "explanation": "This code block shows MaglevGraphBuilder::TryReduceArrayForEach lowering Array.prototype.forEach into a Maglev loop. It captures: (1) eligibility checks (fast array maps, NoElementsProtector), (2) throwing if callback is not callable wrapped in a lazy deopt continuation to preserve stack, (3) constructing a subgraph loop with index and length phis and a BranchIfInt32Compare for loop condition, (4) index increment via Int32IncrementWithOverflow under an eager deopt continuation, (5) element load specialized for FixedArray vs FixedDoubleArray and hole checks for HOLEY kinds, (6) making the callback call under a lazy deopt continuation, (7) after-call map rechecks and length check using CheckInt32Condition with UnsignedLessThanEqual and deopt reason ArrayLengthChanged, and (8) subgraph loop plumbing. It references helpers such as BuildLoadJSArrayLength, BuildLoadElements, and ElementsKind specialization.",
  "file_line": "maglev/maglev-graph-builder.cc:8061-8345"
}