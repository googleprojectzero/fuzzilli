{
  "body": "File: compiler/bytecode-graph-builder.cc\nFunctions and snippets:\n- void BytecodeGraphBuilder::VisitLdaLookupSlot() { BuildLdaLookupSlot(TypeofMode::kNotInside); }\n- void BytecodeGraphBuilder::VisitLdaLookupSlotInsideTypeof() { BuildLdaLookupSlot(TypeofMode::kInside); }\n- void BytecodeGraphBuilder::VisitStaLookupSlot() { ... const Operator* op = javascript()->CallRuntime(is_strict(language_mode) ? Runtime::kStoreLookupSlot_Strict : lookup_hoisting_mode == LookupHoistingMode::kLegacySloppy ? Runtime::kStoreLookupSlot_SloppyHoisting : Runtime::kStoreLookupSlot_Sloppy); Node* store = NewNode(op, name, value); environment()->BindAccumulator(store, Environment::kAttachFrameState); }\n- void BytecodeGraphBuilder::VisitPushContext() { Node* new_context = environment()->LookupAccumulator(); environment()->BindRegister(bytecode_iterator().GetRegisterOperand(0), environment()->Context()); environment()->SetContext(new_context); }\n- void BytecodeGraphBuilder::VisitPopContext() { Node* context = environment()->LookupRegister(bytecode_iterator().GetRegisterOperand(0)); environment()->SetContext(context); }\n- void BytecodeGraphBuilder::VisitCreateWithContext() { Node* object = environment()->LookupRegister(bytecode_iterator().GetRegisterOperand(0)); ScopeInfoRef scope_info = MakeRefForConstantForIndexOperand<ScopeInfo>(1); const Operator* op = javascript()->CreateWithContext(scope_info); Node* context = NewNode(op, object); environment()->BindAccumulator(context); }\n- void BytecodeGraphBuilder::BuildLdaLookupSlot(TypeofMode typeof_mode) { PrepareEagerCheckpoint(); Node* name = jsgraph()->ConstantNoHole(MakeRefForConstantForIndexOperand(0), broker()); const Operator* op = javascript()->CallRuntime(typeof_mode == TypeofMode::kNotInside ? Runtime::kLoadLookupSlot : Runtime::kLoadLookupSlotInsideTypeof); Node* value = NewNode(op, name); environment()->BindAccumulator(value, Environment::kAttachFrameState); }\n- void BytecodeGraphBuilder::BuildLdaLookupContextSlot(ContextKind context_kind, TypeofMode typeof_mode) { uint32_t depth = bytecode_iterator().GetUnsignedImmediateOperand(2); Environment* slow_environment = CheckContextExtensions(depth); { uint32_t slot_index = bytecode_iterator().GetIndexOperand(1); const Operator* op = context_kind == ContextKind::kScriptContext ? javascript()->LoadScriptContext(depth, slot_index) : javascript()->LoadContext(depth, slot_index, false); environment()->BindAccumulator(NewNode(op)); } if (!slow_environment) return; NewMerge(); Environment* fast_environment = environment(); set_environment(slow_environment); { Node* name = jsgraph()->ConstantNoHole(MakeRefForConstantForIndexOperand(0), broker()); const Operator* op = javascript()->CallRuntime(typeof_mode == TypeofMode::kNotInside ? Runtime::kLoadLookupSlot : Runtime::kLoadLookupSlotInsideTypeof); Node* value = NewNode(op, name); environment()->BindAccumulator(value, Environment::kAttachFrameState); } fast_environment->Merge(environment(), bytecode_analysis().GetOutLivenessFor(bytecode_iterator().current_offset())); set_environment(fast_environment); mark_as_needing_eager_checkpoint(true); }\n- void BytecodeGraphBuilder::BuildLdaLookupGlobalSlot(TypeofMode typeof_mode) { uint32_t depth = bytecode_iterator().GetUnsignedImmediateOperand(2); Environment* slow_environment = CheckContextExtensions(depth); { PrepareEagerCheckpoint(); NameRef name = MakeRefForConstantForIndexOperand<Name>(0); uint32_t feedback_slot_index = bytecode_iterator().GetIndexOperand(1); Node* node = BuildLoadGlobal(name, feedback_slot_index, typeof_mode); environment()->BindAccumulator(node, Environment::kAttachFrameState); } if (!slow_environment) return; NewMerge(); Environment* fast_environment = environment(); set_environment(slow_environment); { Node* name = jsgraph()->ConstantNoHole(MakeRefForConstantForIndexOperand<Name>(0), broker()); const Operator* op = javascript()->CallRuntime(typeof_mode == TypeofMode::kNotInside ? Runtime::kLoadLookupSlot : Runtime::kLoadLookupSlotInsideTypeof); Node* value = NewNode(op, name); environment()->BindAccumulator(value, Environment::kAttachFrameState); } fast_environment->Merge(environment(), bytecode_analysis().GetOutLivenessFor(bytecode_iterator().current_offset())); set_environment(fast_environment); mark_as_needing_eager_checkpoint(true); }\n- Context extension fast/slow gating helpers:\n  * Environment* BytecodeGraphBuilder::CheckContextExtensions(uint32_t depth): consults TryGetScopeInfo(); loops up to depth-1, using HasContextExtensionSlot and dependencies; emits dynamic check branches via CheckContextExtensionAtDepth when needed. If scope info unavailable, falls back to CheckContextExtensionsSlowPath.\n  * OptionalScopeInfoRef BytecodeGraphBuilder::TryGetScopeInfo(): inspects current context node opcode (JSCreateFunctionContext/JSCreateBlock/Catch/With, Parameter) to resolve ScopeInfo; else returns nullopt.\n  * Environment* BytecodeGraphBuilder::CheckContextExtensionsSlowPath(uint32_t depth): emits JSHasContextExtension(depth) tests with branches; merges fast path; sets eager checkpoint needed.\n  * Environment* BytecodeGraphBuilder::CheckContextExtensionAtDepth(Environment* slow_environment,uint32_t depth): loads context[EXTENSION_INDEX] at given depth; compares to undefined; false branch contributes to slow path env merge.\n- Global load fast path uses feedback: Node* BytecodeGraphBuilder::BuildLoadGlobal(NameRef name, uint32_t feedback_slot_index, TypeofMode typeof_mode) { FeedbackSource feedback = CreateFeedbackSource(feedback_slot_index); const Operator* op = javascript()->LoadGlobal(name, feedback, typeof_mode); return NewNode(op, feedback_vector_node()); }\n- VisitToObject(): BuildCastOperator(javascript()->ToObject());\n- VisitLdaLookupContextSlot/ScriptContext/...InsideTypeof and VisitLdaLookupGlobalSlot variants call the above Build* helpers.\n",
  "context": [
    "js_generic_lowering_with",
    "js_ops_with_lookup",
    "ignition_with_lookup",
    "runtime_scopes_lookup",
    "bgb_with_lookup_visitors"
  ],
  "explanation": "This entry documents all relevant BytecodeGraphBuilder visitors for with-scope and lookup-slot handling, along with the core helpers implementing fast/slow paths, context extension checks, and global fast-path with feedback. It includes function names and exact snippets demonstrating how Ignition bytecodes map to runtime calls or fast loads and how gating via context extensions is implemented.",
  "file_line": "compiler/bytecode-graph-builder.cc:1796,1800,2041,2294,2301,2359; plus helpers: around 1808-2010"
}