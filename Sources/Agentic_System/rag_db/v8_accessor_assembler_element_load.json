{
  "body": "Keyed element load fast-path logic in AccessorAssembler:\n1) Smi handler dispatch for elements, strings, and properties:\nvoid AccessorAssembler::HandleLoadICSmiHandlerCase(..., ElementSupport support_elements, LoadAccessMode access_mode) {\n  ...\n  if (support_elements == kSupportElements) {\n    Label if_element(this), if_indexed_string(this), if_property(this), if_hole(this), unimplemented_elements_kind(this), if_oob(this,...), try_string_to_array_index(this), emit_element_load(this);\n    ...\n    BIND(&if_element) {\n      // Convert key to intptr index; try string-to-array-index fallback.\n      TVARIABLE(IntPtrT, var_intptr_index);\n      TNode<IntPtrT> intptr_index = TryToIntptr(p->name(), &try_string_to_array_index, &var_instance_type);\n      var_intptr_index = intptr_index; Goto(&emit_element_load);\n      BIND(&try_string_to_array_index) { ... var_intptr_index = ChangeInt32ToIntPtr(result); Goto(&emit_element_load); }\n      BIND(&emit_element_load) {\n        TNode<BoolT> is_jsarray_condition = IsSetWord32<LoadHandler::IsJsArrayBits>(handler_word);\n        TNode<Uint32T> elements_kind = DecodeWord32<LoadHandler::ElementsKindBits>(handler_word);\n        EmitElementLoad(CAST(holder), elements_kind, var_intptr_index.value(), is_jsarray_condition, &if_hole, &rebox_double, &var_double_value, &unimplemented_elements_kind, &if_oob, miss, exit_point, access_mode);\n      }\n    }\n    BIND(&if_oob) { // Out-of-bounds policy gate\n      TNode<BoolT> allow_out_of_bounds = IsSetWord32<LoadHandler::AllowOutOfBoundsBits>(handler_word);\n      GotoIfNot(allow_out_of_bounds, miss);\n      // Typed arrays: directly return undefined; for JSObjects, guard index range and prototypes have no elements.\n      GotoIf(IsJSTypedArray(CAST(holder)), &return_undefined);\n      ... BranchIfPrototypesHaveNoElements(LoadMap(CAST(holder)), &return_undefined, miss);\n      exit_point->Return(access_mode == kHas ? FalseConstant() : UndefinedConstant());\n    }\n    BIND(&if_hole) { // Convert hole to undefined gated by flags + NoElements protector\n      GotoIfNot(IsSetWord32<LoadHandler::AllowHandlingHole>(handler_word), miss);\n      GotoIf(IsNoElementsProtectorCellInvalid(), miss);\n      exit_point->Return(access_mode == kHas ? FalseConstant() : UndefinedConstant());\n    }\n    if (access_mode != kHas) { BIND(&if_indexed_string) { // String indexing fast-path\n      ... bounds check then StringCharCodeAt -> StringFromSingleCharCode else OOB policy similar to arrays using AllowOutOfBoundsBits and NoElementsProtector.\n    }}\n    BIND(&if_property); // fallthrough to named property path\n  }\n  ...\n}\n\n2) Elements-kind switching and loads:\nvoid AccessorAssembler::EmitElementLoad(TNode<HeapObject> object, TNode<Word32T> elements_kind, TNode<IntPtrT> index, TNode<BoolT> is_jsarray_condition, Label* if_hole, Label* rebox_double, TVariable<Float64T>* var_double_value, Label* unimplemented_elements_kind, Label* out_of_bounds, Label* miss, ExitPoint* exit_point, LoadAccessMode access_mode) {\n  Label if_rab_gsab_typed_array, if_typed_array, if_fast, if_fast_packed, if_fast_holey, if_fast_double, if_fast_holey_double, if_nonfast, if_dictionary;\n  Branch(Int32GreaterThan(elements_kind, Int32Constant(LAST_ANY_NONEXTENSIBLE_ELEMENTS_KIND)), &if_nonfast, &if_fast);\n  BIND(&if_fast) {\n    TNode<FixedArrayBase> elements = LoadJSObjectElements(CAST(object));\n    EmitFastElementsBoundsCheck(CAST(object), elements, index, is_jsarray_condition, out_of_bounds);\n    // Packed SMI/OBJECT and nonextensible/sealed/frozen -> direct element load; for HOLEY variants, check TheHole then jump to if_hole; double variants load as Float64 then rebox via rebox_double.\n    Switch(elements_kind, unimplemented_elements_kind,\n      kinds={PACKED_SMI_ELEMENTS, PACKED_ELEMENTS, PACKED_NONEXTENSIBLE_ELEMENTS, PACKED_SEALED_ELEMENTS, PACKED_FROZEN_ELEMENTS, SHARED_ARRAY_ELEMENTS, HOLEY_SMI_ELEMENTS, HOLEY_ELEMENTS, HOLEY_NONEXTENSIBLE_ELEMENTS, HOLEY_FROZEN_ELEMENTS, HOLEY_SEALED_ELEMENTS, PACKED_DOUBLE_ELEMENTS, HOLEY_DOUBLE_ELEMENTS},\n      labels={&if_fast_packed, ..., &if_fast_holey, ..., &if_fast_double, &if_fast_holey_double});\n    BIND(&if_fast_packed) { exit_point->Return(access_mode==kHas? TrueConstant(): UnsafeLoadFixedArrayElement(CAST(elements), index)); }\n    BIND(&if_fast_holey) { TNode<Object> element = UnsafeLoadFixedArrayElement(CAST(elements), index); GotoIf(TaggedEqual(element, TheHoleConstant()), if_hole); exit_point->Return(access_mode==kHas? TrueConstant(): element); }\n    BIND(&if_fast_double) { if (access_mode==kHas) Return(TrueConstant()); else { *var_double_value = LoadFixedDoubleArrayElement(CAST(elements), index); Goto(rebox_double);} }\n    BIND(&if_fast_holey_double) { TNode<Float64T> value = LoadFixedDoubleArrayElement(CAST(elements), index, if_hole); if (access_mode==kHas) Return(TrueConstant()); else { *var_double_value = value; Goto(rebox_double);} }\n  }\n  BIND(&if_nonfast) {\n    // Dictionary elements\n    GotoIf(Word32Equal(elements_kind, Int32Constant(DICTIONARY_ELEMENTS)), &if_dictionary);\n    // TypedArrays (fixed and RAB/GSAB): check (detached) buffer, bounds, then load with raw memory ops by element size; bigint kinds return BigInt values; float kinds go through rebox_double.\n    // RAB/GSAB TypedArray path uses LoadVariableLengthJSTypedArrayLength and LoadJSTypedArrayDataPtr.\n    ...\n    BIND(&if_dictionary) { TNode<FixedArrayBase> elements = LoadJSObjectElements(CAST(object)); TNode<Object> value = BasicLoadNumberDictionaryElement(CAST(elements), index, miss, if_hole); exit_point->Return(access_mode==kHas? TrueConstant(): value); }\n  }\n}\n\n3) Generic element fallback used by megamorphic/generic path:\nvoid AccessorAssembler::GenericElementLoad(TNode<HeapObject> lookup_start_object, TNode<Map> map, TNode<Int32T> instance_type, TNode<IntPtrT> index, Label* slow) {\n  // Skip custom receivers (interceptors, access checks, strings, proxies) -> slow\n  // Switch by elements kind and call EmitElementLoad; OOB: typed arrays return undefined unconditionally; positive OOB falls back to hole handling; negative keys become slow; prototype chain checked via BranchIfPrototypesHaveNoElements to return undefined.\n}\n",
  "context": [
    "v8_keyedload_ic_entrypoints",
    "v8_keyedload_handler",
    "v8_elements_kind_lattice",
    "v8_keyed_load_ic_state"
  ],
  "explanation": "This captures the CSA/builtins-level element fast paths for KeyedLoadIC. It shows: converting the key to index; selecting ElementsKind (Smi/Object/Double, packed vs holey, sealed/frozen/nonextensible); dictionary and TypedArray branches; handling of hole-to-undefined and OOB via flags and NoElements protector; and required prototype checks. This is the concrete handler-side that runs for kElement Smi handlers and the generic megamorphic path.",
  "file_line": "ic/accessor-assembler.cc:1123-1367,2471-2777,2777-2871"
}