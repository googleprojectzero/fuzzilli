{
  "body": "Wrapper cache for Wasm imports (Wasm\u2192JS):\n- src/wasm/wasm-import-wrapper-cache.h/.cc\n  - class WasmImportWrapperCache: per-process shared cache for wasm-to-js import wrappers. Lazily initializes private WasmCodeAllocator with its own code space, stores compiled wrappers and generic wrappers, supports refcounting and logging.\n    \u2022 struct CacheKey { ImportCallKind kind; CanonicalTypeIndex type_index; int expected_arity; Suspend suspend; } with hash and equality; used in entry_map_.\n    \u2022 class ModificationScope: RAII mutex guard to mutate cache; operator[](CacheKey) to read existing, AddWrapper(CacheKey, WasmCompilationResult, WasmCode::Kind) to install compiled wrapper into code space, relocate, flush icache, construct WasmCode with metadata, set refcount behavior, insert into entry maps, maintain codes_ map by instruction_start.\n    \u2022 LazyInitialize(Isolate*): allocate code space via WasmCodeManager with retries and memory pressure notifications; initialize WasmCodeAllocator and code range.\n    \u2022 WasmCode* CompileWasmImportCallWrapper(Isolate*, ImportCallKind, const CanonicalSig*, CanonicalTypeIndex, bool source_positions, int expected_arity, Suspend): compiles via compiler::CompileWasmImportCallWrapper, then AddWrapper; increments counters and logs via WasmEngine.\n    \u2022 WasmCode* MaybeGet(ImportCallKind, CanonicalTypeIndex, int expected_arity, Suspend) const: thread-safe lookup and AddRef for WasmCodeRefScope.\n    \u2022 WasmCode* FindWrapper(WasmCodePointer call_target): find wrapper by CPT entry address using process-wide WasmCodePointerTable.\n    \u2022 void Free(vector<WasmCode*>& wrappers): bulk free and clean entry maps.\n    \u2022 WasmCode* Lookup(Address pc) const: map from instruction address to code; used by disassembler.\n    \u2022 size_t EstimateCurrentMemoryConsumption() const.\n- Integration with dispatch tables / objects:\n  - WasmDispatchTableData in wasm-objects.h tracks wrapper entries owned via CodePointerTable, and manages refcounts; WasmDispatchTable::SetForWrapper installs wrapper targets (generic or compiled) with signature hash.\n  - ImportedFunctionEntry::SetCompiledWasmToJs uses wrapper cache to install wrapper and CodePointer target in instance's imports table.\n",
  "context": [
    "wasm_wrappers_entry_points",
    "wasm_objects",
    "wasm_dispatch_table",
    "wasm_import_wrapper_cache_source"
  ],
  "explanation": "Covers item (2): wrapper cache implementations for imports (Wasm\u2192JS). Details how wrappers are compiled and cached, the key structure, allocator/code space setup, and connectivity to dispatch tables and imports.",
  "file_line": "wasm/wasm-import-wrapper-cache.h:1-; wasm/wasm-import-wrapper-cache.cc:1-"
}