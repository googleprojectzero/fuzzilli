{
  "body": "// builtins/set-union.tq - Torque builtin for Set.prototype.union\n// (file content captured from repo)\nnamespace collections {\n\n// https://tc39.es/proposal-set-methods/#sec-set.prototype.union\n@incrementUseCounter('v8::Isolate::kSetMethods')\ntransitioning javascript builtin SetPrototypeUnion(\n    js-implicit context: NativeContext, receiver: JSAny)(other: JSAny): JSSet {\n  const methodName: constexpr string = 'Set.prototype.union';\n  const fastIteratorResultMap = GetIteratorResultMap();\n\n  // 1. Let O be the this value.\n  // 2. Perform ? RequireInternalSlot(O, [[SetData]]).\n  const o = Cast<JSSet>(receiver) otherwise\n  ThrowTypeError(\n      MessageTemplate::kIncompatibleMethodReceiver, methodName, receiver);\n\n  // 3. Let otherRec be ? GetSetRecord(other).\n  let otherRec = GetSetRecord(other, methodName);\n\n  let table = NewStableBackingTableWitness(o);\n\n  let resultSetData: OrderedHashSet;\n\n  try {\n    typeswitch (other) {\n      case (otherSet: JSSetWithNoCustomIteration): {\n        CheckSetRecordHasJSSetMethods(otherRec) otherwise SlowPath;\n\n        const otherTable = NewStableBackingTableWitness(otherSet);\n\n        let otherIterator = collections::NewUnmodifiedOrderedHashSetIterator(\n            otherTable.GetTable());\n\n        resultSetData = Cast<OrderedHashSet>(CloneFixedArray(\n            table.GetTable(), ExtractFixedArrayFlag::kFixedArrays))\n            otherwise unreachable;\n\n        while (true) {\n          const nextValue =\n              otherIterator.Next() otherwise goto Done(resultSetData);\n          resultSetData = AddToSetTable(resultSetData, nextValue, methodName);\n        }\n      }\n      case (otherMap: JSMapWithNoCustomIteration): {\n        CheckSetRecordHasJSMapMethods(otherRec) otherwise SlowPath;\n\n        const otherTable = NewStableBackingTableWitness(otherMap);\n\n        let otherIterator = collections::NewUnmodifiedOrderedHashMapIterator(\n            otherTable.GetTable());\n\n        resultSetData = Cast<OrderedHashSet>(CloneFixedArray(\n            table.GetTable(), ExtractFixedArrayFlag::kFixedArrays))\n            otherwise unreachable;\n\n        while (true) {\n          const nextValue =\n              otherIterator.Next() otherwise goto Done(resultSetData);\n          resultSetData =\n              AddToSetTable(resultSetData, nextValue.key, methodName);\n        }\n      }\n      case (JSAny): {\n        goto SlowPath;\n      }\n    }\n  } label SlowPath {\n    // 4. Let keysIter be ? GetKeysIterator(otherRec).\n    let keysIter =\n        GetKeysIterator(otherRec.object, UnsafeCast<Callable>(otherRec.keys));\n\n    table.ReloadTable();\n    // 5. Let resultSetData be a copy of O.[[SetData]].\n    resultSetData = Cast<OrderedHashSet>(\n        CloneFixedArray(table.GetTable(), ExtractFixedArrayFlag::kFixedArrays))\n        otherwise unreachable;\n\n    // 6. Let next be true.\n    let nextRecord: JSReceiver;\n    // 7. Repeat, while next is not false,\n    while (true) {\n      //  a. Set next to ? IteratorStep(keysIter).\n      nextRecord = iterator::IteratorStep(keysIter, fastIteratorResultMap)\n          otherwise goto Done(resultSetData);\n\n      //  b. If next is not false, then\n      //      i. Let nextValue be ? IteratorValue(next).\n      const nextValue =\n          iterator::IteratorValue(nextRecord, fastIteratorResultMap);\n\n      //      ii. If nextValue is -0\ud835\udd3d, set nextValue to +0\ud835\udd3d.\n      //      iii. If SetDataHas(resultSetData, nextValue) is false, then\n      //          1. Append nextValue to resultSetData.\n      resultSetData = AddToSetTable(resultSetData, nextValue, methodName);\n    }\n  } label Done(resultSetData: OrderedHashSet) {\n    // 8. Let result be\n    // OrdinaryObjectCreate(%Set.prototype%, \u00ab [[SetData]]\u00bb).\n    // 9. Set result.[[SetData]] to resultSetData.\n    // 10. Return result.\n    return new JSSet{\n      map: *NativeContextSlot(ContextSlot::JS_SET_MAP_INDEX),\n      properties_or_hash: kEmptyFixedArray,\n      elements: kEmptyFixedArray,\n      table: resultSetData\n    };\n  }\n  unreachable;\n}\n}",
  "context": [
    "collections_set_intersection_tq",
    "collections_set_difference_tq",
    "collections_set_symmetric_difference_tq"
  ],
  "explanation": "Captures the full Torque implementation for Set.prototype.union as found in src/builtins/set-union.tq. This includes type checks, fast-paths for JSSet/JSMap with no custom iteration, the slow-path iterator handling, usage of OrderedHashSet, and helper macros like AddToSetTable and CloneFixedArray.",
  "file_line": "builtins/set-union.tq:1-200"
}