{
  "body": "File: src/runtime/runtime-scopes.cc\nKey runtime handlers for lookup slots and with contexts:\n\n- PushWithContext (context creation for with-statement)\nRUNTIME_FUNCTION(Runtime_PushWithContext) {\n  DirectHandle<JSReceiver> extension_object = args.at<JSReceiver>(0);\n  DirectHandle<ScopeInfo> scope_info = args.at<ScopeInfo>(1);\n  DirectHandle<Context> current(isolate->context(), isolate);\n  return *isolate->factory()->NewWithContext(current, scope_info, extension_object);\n}\n\n- LoadLookupSlot (and InsideTypeof, ForCall)\nstatic MaybeHandle<Object> LoadLookupSlot(Isolate* isolate, Handle<String> name, ShouldThrow should_throw, Handle<Object>* receiver_return = nullptr) {\n  int index; PropertyAttributes attributes; InitializationFlag flag; VariableMode mode;\n  Handle<Context> context(isolate->context(), isolate);\n  Handle<Object> holder = Context::Lookup(context, name, FOLLOW_CHAINS, &index, &attributes, &flag, &mode);\n  if (isolate->has_exception()) return MaybeHandle<Object>();\n  if (!holder.is_null() && IsSourceTextModule(*holder)) { ... return SourceTextModule::LoadVariable(...); }\n  if (index != Context::kNotFound) {\n    Handle<Object> receiver = isolate->factory()->undefined_value();\n    DirectHandle<Context> holder_context = Cast<Context>(holder);\n    Handle<Object> value = handle(holder_context->get(index), isolate);\n    if (flag == kNeedsInitialization && IsTheHole(*value, isolate)) {\n      THROW_NEW_ERROR(isolate, NewReferenceError(MessageTemplate::kNotDefined, name));\n    }\n    if (receiver_return) *receiver_return = receiver;\n    if (v8_flags.script_context_mutable_heap_number && holder_context->IsScriptContext()) {\n      return handle(*Context::LoadScriptContextElement(holder_context, index, value, isolate), isolate);\n    }\n    return value;\n  }\n  // Otherwise holder may be context extension object, with-subject, or global object.\n  if (!holder.is_null()) {\n    Handle<Object> value; ASSIGN_RETURN_ON_EXCEPTION(isolate, value, Object::GetProperty(isolate, Cast<JSAny>(holder), name));\n    if (receiver_return) {\n      *receiver_return = (IsJSGlobalObject(*holder) || IsJSContextExtensionObject(*holder)) ? Cast<Object>(isolate->factory()->undefined_value()) : holder;\n    }\n    return value;\n  }\n  if (should_throw == kThrowOnError) {\n    THROW_NEW_ERROR(isolate, NewReferenceError(MessageTemplate::kNotDefined, name));\n  }\n  if (receiver_return) *receiver_return = isolate->factory()->undefined_value();\n  return isolate->factory()->undefined_value();\n}\n\nRUNTIME_FUNCTION(Runtime_LoadLookupSlot) { ... RETURN_RESULT_OR_FAILURE(isolate, LoadLookupSlot(isolate, name, kThrowOnError)); }\nRUNTIME_FUNCTION(Runtime_LoadLookupSlotInsideTypeof) { ... RETURN_RESULT_OR_FAILURE(isolate, LoadLookupSlot(isolate, name, kDontThrow)); }\nRUNTIME_FUNCTION_RETURN_PAIR(Runtime_LoadLookupSlotForCall) { ... LoadLookupSlot(..., &receiver) returns value and receiver pair; }\n\n- StoreLookupSlot (strict/sloppy/hoisting)\nstatic MaybeHandle<Object> StoreLookupSlot(Isolate* isolate, Handle<Context> context, Handle<String> name, Handle<Object> value, LanguageMode language_mode, ContextLookupFlags flags = FOLLOW_CHAINS) {\n  int index; PropertyAttributes attributes; InitializationFlag flag; VariableMode mode; bool is_sloppy_function_name;\n  Handle<Object> holder = Context::Lookup(context, name, flags, &index, &attributes, &flag, &mode, &is_sloppy_function_name);\n  if (holder.is_null()) { if (isolate->has_exception()) return MaybeHandle<Object>(); }\n  else if (IsSourceTextModule(*holder)) { if ((attributes & READ_ONLY) == 0) { SourceTextModule::StoreVariable(...); } else { THROW_NEW_ERROR(isolate, NewTypeError(MessageTemplate::kConstAssign, name)); } return value; }\n  if (index != Context::kNotFound) {\n    auto holder_context = Cast<Context>(holder);\n    if (flag == kNeedsInitialization && IsTheHole(holder_context->get(index), isolate)) {\n      THROW_NEW_ERROR(isolate, NewReferenceError(MessageTemplate::kNotDefined, name));\n    }\n    if ((attributes & READ_ONLY) == 0) {\n      if ((v8_flags.script_context_mutable_heap_number || v8_flags.const_tracking_let) && holder_context->IsScriptContext()) {\n        Context::StoreScriptContextAndUpdateSlotProperty(holder_context, index, value, isolate);\n      } else {\n        Cast<Context>(holder)->set(index, *value);\n      }\n    } else if (!is_sloppy_function_name || is_strict(language_mode)) {\n      THROW_NEW_ERROR(isolate, NewTypeError(MessageTemplate::kConstAssign, name));\n    }\n    return value;\n  }\n  // Slow case: holder is context extension, with subject, or global object.\n  DirectHandle<JSReceiver> object;\n  if (attributes != ABSENT) {\n    object = Cast<JSReceiver>(holder);\n  } else if (is_strict(language_mode)) {\n    THROW_NEW_ERROR(isolate, NewReferenceError(MessageTemplate::kNotDefined, name));\n  } else {\n    object = direct_handle(context->global_object(), isolate);\n  }\n  ASSIGN_RETURN_ON_EXCEPTION(isolate, value, Object::SetProperty(isolate, object, name, value));\n  return value;\n}\n\nRUNTIME_FUNCTION(Runtime_StoreLookupSlot_Sloppy) { ... StoreLookupSlot(..., LanguageMode::kSloppy); }\nRUNTIME_FUNCTION(Runtime_StoreLookupSlot_Strict) { ... StoreLookupSlot(..., LanguageMode::kStrict); }\nRUNTIME_FUNCTION(Runtime_StoreLookupSlot_SloppyHoisting) { const ContextLookupFlags lookup_flags = DONT_FOLLOW_CHAINS; Handle<Context> declaration_context(isolate->context()->declaration_context(), isolate); return StoreLookupSlot(isolate, declaration_context, name, value, LanguageMode::kSloppy, lookup_flags); }\n\n- DeleteLookupSlot(name)\nRUNTIME_FUNCTION(Runtime_DeleteLookupSlot) { Context::Lookup(...); if holder not found -> true; if holder is context/module -> false; else delete property (JSReceiver::DeleteProperty). }\n\nNotes:\n- Scope chain walking performed by Context::Lookup, FOLLOW_CHAINS or DONT_FOLLOW_CHAINS.\n- Uninitialized TDZ checks (kNeedsInitialization and TheHole) throw ReferenceError for loads/stores.\n- Module imports/exports handled specially.\n- Strict mode: create/overwrite rules differ; sloppy may create globals.\n- Receiver determination for calls via LoadLookupSlotForCall.\n",
  "context": [
    "runtime_impl_scopes",
    "lookup_load_store_semantics",
    "strict_vs_sloppy",
    "typeof_mode_behavior",
    "with_context_rt"
  ],
  "explanation": "This captures the slow-path runtime implementations that Ignition and TurboFan use for with-scope lookup operations. It details scope chain lookup, TDZ checks, module handling, strict vs sloppy handling, global creation on sloppy stores, and the dedicated ForCall variant returning receiver. It also includes the PushWithContext runtime used by CreateWithContext.",
  "file_line": "runtime/runtime-scopes.cc:755-1026 (selected functions); PushWithContext earlier in file."
}