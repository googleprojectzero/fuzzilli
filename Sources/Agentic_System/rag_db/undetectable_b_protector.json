{
  "body": "CompilationDependencies::DependOnNoUndetectableObjectsProtector and ProtectorDependency\n\nSymbols:\n- CompilationDependencies::DependOnNoUndetectableObjectsProtector\n- CompilationDependencies::DependOnProtector\n- ProtectorDependency (class in compilation-dependencies.cc)\n\nFiles/paths:\n- src/compiler/compilation-dependencies.cc (function DependOnNoUndetectableObjectsProtector, class ProtectorDependency)\n- src/compiler/compilation-dependencies.h (declaration)\n- src/execution/protectors.h (Protectors enumerations)\n\nSummary of relevant code behavior:\n- DependOnNoUndetectableObjectsProtector() calls DependOnProtector() with the factory's no_undetectable_objects_protector PropertyCellRef. DependOnProtector caches the cell as a protector via cell.CacheAsProtector(broker_) and checks if cell.value(broker_).AsSmi() == Protectors::kProtectorValid. If valid, RecordDependency(zone_->New<ProtectorDependency>(cell)) is invoked and true returned; otherwise false.\n- ProtectorDependency::IsValid checks that the PropertyCell's value equals Protectors::kProtectorValid. ProtectorDependency::Install registers the PropertyCell handle with DependentCode::kPropertyCellChangedGroup so that code depending on this protector will be invalidated when the cell changes to the hole.\n\nWhy important: This shows how the NoUndetectableObjects protector is recorded as a compilation dependency, via ProtectorDependency, so that later installation will create a dependent code entry. This is the object that TurboFan/TurboShaft/Maglev lowerings must call to ensure their use of undetectable assumptions are invalidated appropriately.\n",
  "context": [
    "undetectable_a_jstypedlowering",
    "undetectable_c_turboshaft"
  ],
  "explanation": "Records the protector dependency handling and how DependOnNoUndetectableObjectsProtector maps to ProtectorDependency being recorded and validated.",
  "file_line": "compiler/compilation-dependencies.cc: ProtectorDependency class / DependOnNoUndetectableObjectsProtector"
}