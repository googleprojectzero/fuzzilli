{
  "body": "Where the ElementsKind-specific fast paths for a[i] are implemented and how:\n\n1) IC handler selection and load-mode computation (hole/OOB):\n- src/ic/ic.cc\n  - static KeyedAccessLoadMode GetNewKeyedLoadMode(Isolate*, HeapObject receiver, size_t index, bool is_found): decides between kInBounds, kHandleHoles, kHandleOOB, kHandleOOBAndHoles based on elements kind, prototype guards (NoElements protector), typed arrays vs JSArray, and whether the access found a value or hole (lines ~1318-1379).\n  - static KeyedAccessLoadMode GetUpdatedLoadModeForMap(Isolate*, Map, KeyedAccessLoadMode): refines the mode per receiver map (lines ~1379-1409).\n  - void KeyedLoadIC::UpdateLoadElement(HeapObject receiver, KeyedAccessLoadMode new_mode): updates feedback and installs element LoadHandlers, handles mono/poly transitions and load modes (lines ~1180-1443).\n  - Handle<Object> KeyedLoadIC::LoadElementHandler(Map receiver_map, KeyedAccessLoadMode new_mode): chooses handler for elements kinds: interceptors; string indexing; proxies; sloppy arguments; DICTIONARY_ELEMENTS; fast elements (packed/holey SMI/OBJECT/DOUBLE and nonextensible/sealed/frozen); typed arrays and RAB/GSAB, and returns a LoadHandler/DataHandler or builtin Code to handle it (lines ~1381-1438 and below ~1450-1547).\n\n2) AccessorAssembler element load emission and fast-path logic:\n- src/ic/accessor-assembler.cc\n  - void AccessorAssembler::HandleLoadICSmiHandlerCase(..., ElementSupport kSupportElements): decodes Smi handler for LoadHandler::Kind::kElement and routes to EmitElementLoad with bounds/hole/OOB handling, and to kIndexedString for string index reads (lines ~585-745, ~1012-1150 plus use-sites around ~608-704 for element path).\n  - void AccessorAssembler::EmitElementLoad(HeapObject object, Word32T elements_kind, IntPtrT index, BoolT is_jsarray_condition, Label* if_hole, Label* rebox_double, ..., Label* out_of_bounds, Label* miss, ExitPoint*, LoadAccessMode): the core fast-path for keyed element loads. Switches on ElementsKind to:\n    \u2022 Fast packed elements: PACKED_{SMI,OBJECT,NONEXTENSIBLE,SEALED,FROZEN}, SHARED_ARRAY_ELEMENTS -> direct element read; HAS returns true; LOAD returns element.\n    \u2022 Fast holey elements: HOLEY_{SMI,OBJECT,NONEXTENSIBLE,SEALED,FROZEN} -> load slot; if the-hole then go to if_hole (which returns undefined or false depending on access_mode, guarded by NoElements protector if needed); otherwise return element.\n    \u2022 Packed double elements: PACKED_DOUBLE_ELEMENTS -> load double, rebox to HeapNumber for LOAD, true for HAS.\n    \u2022 Holey double elements: HOLEY_DOUBLE_ELEMENTS -> load with hole check label.\n    \u2022 Dictionary elements: DICTIONARY_ELEMENTS path calls BasicLoadNumberDictionaryElement with hole/miss handling.\n    \u2022 TypedArray elements: FIRST_FIXED_TYPED_ARRAY_ELEMENTS_KIND..LAST..., including RAB_GSAB variants: check detached/bounds or variable length, then load raw element, rebox if needed.\n    \u2022 Sloppy arguments and interceptors are handled earlier in IC.cc handler selection.\n    Also performs bounds checks via EmitFastElementsBoundsCheck, and prototype-chain element absence check via BranchIfPrototypesHaveNoElements for OOB case.\n\n  - Labels if_hole, if_oob behavior in Keyed path: in AccessorAssembler::HandleLoadICSmiHandlerCase, if_hole path: checks LoadHandler::AllowHandlingHole and NoElements protector, and returns undefined or false (for Has) (lines ~704-745). OOB path: if AllowOutOfBounds and prototype chain has no elements, return undefined/false; else miss (lines ~715-745).\n\n3) Elements-kind lattice and transitions influence:\n- src/objects/elements-kind.{h,cc}: defines ElementsKind enum and helpers such as IsFastElementsKind, IsHoleyElementsKind, IsDoubleElementsKind, IsTypedArrayOrRabGsabTypedArrayElementsKind, etc. These predicates are used by IC and AccessorAssembler switching.\n- src/ic/ic.cc: IC::IsMoreGeneralElementsKindTransition and KeyedLoadIC::UpdateLoadElement handle transitions from packed->holey, smi->object, to double kinds, and upgrade load modes; LoadElementPolymorphicHandlers generalize across seen maps while respecting prototype validity.\n\n4) Prototype-chain guards and invalidations:\n- AccessorAssembler::HandleLoadICProtoHandler and HandleProtoHandler perform prototype validity cell checks and optional dictionary lookup on lookup_start_object. AccessorAssembler::BranchIfPrototypesHaveNoElements walks prototypes to ensure no elements before returning undefined on OOB/hole conversion (lines ~5285-5339 and ~5311-5364 for Has; BranchIfPrototypesHaveNoElements ~5348-5385).\n- NoElements protector and Prototype validity cell guards are checked before converting holes to undefined (HandleLoadICSmiHandlerCase) and in GenericElementLoad.\n\n5) Special receivers that force misses/slow paths: proxies/interceptors/typed arrays and strings are explicitly handled:\n- KeyedLoadIC::LoadElementHandler returns interceptor and string indexed handlers; Proxies return LoadHandler::LoadProxy.\n- EmitElementLoad has dedicated typed array handling with detached buffer check and RAB/GSAB variable-length logic. Strings are handled via Keyed string path or GenericElementLoad fallbacks.\n\n6) Feedback consumption by optimizing compilers:\n- Maglev: maglev-ir.cc calls __ CallBuiltin<Builtin::kKeyedLoadIC> or KeyedLoadIC_Megamorphic; maglev-graph-builder uses handler-configuration headers and ElementsKind in heuristics (maglev-graph-builder.cc includes elements-kind.h and feedback-vector.h and emits builtin calls at sites ~6394).\n- TurboFan: compiler/js-generic-lowering.cc lowers JSLoadProperty/JSLoadElement to Builtin::kKeyedLoadIC{Trampoline,_Megamorphic} depending on megamorphic state (lines ~285-326). The FeedbackNexus kinds for KeyedLoadIC are in objects/feedback-vector.h and used by the brokers. The optimizing pipelines retrieve elements kinds and maps from the broker and use ElementsKind-aware lowering in access-info.cc and js-native-context-specialization.cc.\n\n7) Allocation site mementos and array literals:\n- StoreInArrayLiteralIC in accessor-assembler.cc implements the IC for array literal element initialization, using feedback like KeyedStoreIC and transitions, and ultimately calls StoreOwnElement; allocation sites/mementos influence literal element kinds in objects/literal-objects and allocation-site, and TurboFan brokers (compiler/js-heap-broker.cc, heap-refs.cc) read AllocationSite to specialize array literal element kinds, but keyed load fast paths are mostly independent; array literal writes are handled through KeyedStore and StoreInArrayLiteralIC paths not Load.\n",
  "context": [
    "v8_elements_emit",
    "v8_ic_elements_mode",
    "v8_noelements_protector",
    "v8_typedarray_paths",
    "maglev_keyedload_use",
    "tf_keyedload_lowering",
    "array_literal_store_ic"
  ],
  "explanation": "This aggregates the exact locations and functions implementing keyed elements fast paths: the AccessorAssembler::EmitElementLoad logic per ElementsKind, how holes and OOB are handled and guarded, and the handler-selection logic that produces LoadHandler/DataHandler encodings consumed by the stub. It also points to how transitions, prototype guards, proxies/interceptors, and typed arrays alter the path, and where Maglev and TurboFan consume the feedback and call into these ICs.",
  "file_line": "ic/ic.cc:1180-1443, 1318-1410; ic/accessor-assembler.cc:585-745, 1012-1150, 5416-5729; ic/accessor-assembler.cc:5600-5674 (BranchIfPrototypesHaveNoElements); compiler/js-generic-lowering.cc:285-326; maglev/maglev-ir.cc:4220,4699-4713"
}