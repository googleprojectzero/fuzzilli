{
  "body": "Runtime slow paths and helpers for lookup slots and with-scope contexts in runtime-scopes.cc:\n\nCore runtime APIs:\n- RUNTIME_FUNCTION(Runtime_LoadLookupSlot): calls helper LoadLookupSlot(isolate, name, kThrowOnError)\n- RUNTIME_FUNCTION(Runtime_LoadLookupSlotInsideTypeof): uses kDontThrow semantics\n- RUNTIME_FUNCTION_RETURN_PAIR(Runtime_LoadLookupSlotForCall): returns pair (value, receiver); also _Baseline variant fills two stack slots.\n- RUNTIME_FUNCTION(Runtime_StoreLookupSlot_Sloppy)\n- RUNTIME_FUNCTION(Runtime_StoreLookupSlot_Strict)\n- RUNTIME_FUNCTION(Runtime_StoreLookupSlot_SloppyHoisting)\n- RUNTIME_FUNCTION(Runtime_DeleteLookupSlot)\n\nHelper: MaybeHandle<Object> LoadLookupSlot(Isolate* isolate, Handle<String> name, ShouldThrow should_throw, Handle<Object>* receiver_return = nullptr)\n- Looks up a variable name along the context chain: Context::Lookup(context, name, FOLLOW_CHAINS, ...)\n- Handles ScriptContext, Module bindings (SourceTextModule::LoadVariable)\n- If found in context slot: checks kNeedsInitialization and TheHole -> throw ReferenceError; if script context with mutable heap-number tracking, uses Context::LoadScriptContextElement for immutable read barrier.\n- If holder is context extension / with-subject / global: Object::GetProperty on holder; sets receiver appropriately (undefined for global/extension).\n- If absent: throw in kThrowOnError else return undefined\n\nHelper: MaybeHandle<Object> StoreLookupSlot(Isolate* isolate, Handle<Context> context, Handle<String> name, Handle<Object> value, LanguageMode language_mode, ContextLookupFlags flags = FOLLOW_CHAINS)\n- Performs Context::Lookup; handles module export write via SourceTextModule::StoreVariable\n- If context slot: check uninitialized; then if writable (attributes & READ_ONLY == 0) set value, with special handling:\n  - if (v8_flags.script_context_mutable_heap_number || v8_flags.const_tracking_let) and ScriptContext then Context::StoreScriptContextAndUpdateSlotProperty\n  - else holder->set(index, *value)\n- If read-only and either not sloppy function name or strict mode, throw TypeError(ConstAssign)\n- Otherwise, resolve to object receiver: found holder or global (for sloppy when absent); do Object::SetProperty.\n\nWith-context creation:\n- RUNTIME_FUNCTION(Runtime_PushWithContext): NewWithContext(current, scope_info, extension_object)\n- RUNTIME_FUNCTION(Runtime_PushCatchContext): NewCatchContext(...)\n- RUNTIME_FUNCTION(Runtime_PushBlockContext): NewBlockContext(...)\n\nGlobal/module helpers also show DeclareEvalVar/Function and DeclareGlobals using DeclareGlobal which checks script context table for lexical conflicts, JSGlobalObject property semantics, etc.\n\nDeleteLookupSlot: Locates via Context::Lookup; if found in Context or Module returns false; else deletes via JSReceiver::DeleteProperty.\n",
  "context": [
    "v8_with_lookup_and_withscope",
    "runtime_scopes_lookup",
    "interpreter_lookup_handlers"
  ],
  "explanation": "Details how the runtime implements dynamic lookup and with-context creation. It defines the behavior used by Ignition and TurboFan slow paths, including uninitialized-let/const handling, module bindings, receiver determination for calls, and strict vs sloppy store semantics.",
  "file_line": "runtime/runtime-scopes.cc:724-1026, 755-923"
}