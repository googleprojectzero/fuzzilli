{
  "body": "// src/maglev/maglev-graph-builder.cc (excerpts for deopt scopes and continuations)\n// Registration of deopt continuations in graph builder switch\n// case Builtin::kArrayForEachLoopLazyDeoptContinuation: ...\n// Within TryReduceArrayForEach:\n// 1) Wrap ThrowIfNotCallable in a lazy deopt continuation so thrown TypeError has correct stack\nDeoptFrameScope lazy_deopt_scope(\n    this, Builtin::kArrayForEachLoopLazyDeoptContinuation, target,\n    base::VectorOf<ValueNode*>({receiver, callback, this_arg,\n                                GetSmiConstant(0), original_length}));\nAddNewNode<ThrowIfNotCallable>({callback});\n\n// 2) Eager deopt around index increment overflow and after-call checks\nDeoptFrameScope eager_deopt_scope(\n    this, Builtin::kArrayForEachLoopEagerDeoptContinuation, target,\n    base::VectorOf<ValueNode*>({receiver, callback, this_arg,\n                                index_int32, original_length}));\nnext_index_int32 = AddNewNode<Int32IncrementWithOverflow>({index_int32});\n\n// 3) Lazy deopt for the callback invocation to preserve stack then ToBoolean etc as needed\nDeoptFrameScope lazy_deopt_scope(\n    this, Builtin::kArrayForEachLoopLazyDeoptContinuation, target,\n    base::VectorOf<ValueNode*>({receiver, callback, this_arg,\n                                next_index_int32, original_length}));\nReduceResult result = ReduceCall(callback, call_args, saved.value());\n\n// 4) Post-call eager deopt continuation ensures deopt can resume after loop check and map checks\nDeoptFrameScope eager_deopt_scope(\n    this, Builtin::kArrayForEachLoopEagerDeoptContinuation, target,\n    base::VectorOf<ValueNode*>({receiver, callback, this_arg,\n                                next_index_int32, original_length}));\n// Recheck maps, check length, possibly deopt with reason kArrayLengthChanged.\n\n// The DeoptFrameScope type and its IsLazyDeoptContinuationFrame logic:\nclass V8_NODISCARD MaglevGraphBuilder::DeoptFrameScope {\n public:\n  DeoptFrameScope(MaglevGraphBuilder* builder, Builtin continuation, ...);\n  ...\n  bool IsLazyDeoptContinuationFrame() const {\n    if (data_.tag() != DeoptFrame::FrameType::kBuiltinContinuationFrame) return false;\n    switch (data_.get<...>().builtin_id) {\n      case Builtin::kGetIteratorWithFeedbackLazyDeoptContinuation:\n      case Builtin::kCallIteratorWithFeedbackLazyDeoptContinuation:\n      case Builtin::kArrayForEachLoopLazyDeoptContinuation:\n      case Builtin::kGenericLazyDeoptContinuation:\n      case Builtin::kToBooleanLazyDeoptContinuation:\n        return true;\n      default:\n        return false;\n    }\n  }\n};\n\n// Torque builtins defining continuations used by Maglev ArrayForEach:\n// src/builtins/array-foreach.tq\ntransitioning javascript builtin ArrayForEachLoopEagerDeoptContinuation(...)\n  return ArrayForEachLoopContinuation(...);\ntransitioning javascript builtin ArrayForEachLoopLazyDeoptContinuation(...)\n  return ArrayForEachLoopContinuation(...);\ntransitioning builtin ArrayForEachLoopContinuation(... for k from initialK; k < len; k++)\n  ...\n",
  "context": [
    "maglev_foreach_tryreduce",
    "torque_array_foreach",
    "maglev_deopt_scope_class",
    "maglev_throw_if_not_callable"
  ],
  "explanation": "This item documents how Maglev wires deopt continuation frames for the inlined Array.prototype.forEach loop. It shows DeoptFrameScope use sites: lazy continuations around ThrowIfNotCallable and callback call, and eager continuations around the index increment and post-call checks. It also records DeoptFrameScope::IsLazyDeoptContinuationFrame and ties them to the Torque-defined ArrayForEachLoopEagerDeoptContinuation and ArrayForEachLoopLazyDeoptContinuation builtins in builtins/array-foreach.tq.",
  "file_line": "maglev/maglev-graph-builder.cc:8127-8345; maglev/maglev-graph-builder.cc:339-427; builtins/array-foreach.tq:6-40,94-140"
}