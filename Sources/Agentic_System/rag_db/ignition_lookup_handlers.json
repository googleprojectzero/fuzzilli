{
  "body": "File: src/interpreter/interpreter-generator.cc (selected handlers)\n\n// CreateWithContext <register> <scope_info_idx>\nIGNITION_HANDLER(CreateWithContext, InterpreterAssembler) {\n  TNode<Object> object = LoadRegisterAtOperandIndex(0);\n  TNode<ScopeInfo> scope_info = CAST(LoadConstantPoolEntryAtOperandIndex(1));\n  TNode<Context> context = GetContext();\n  SetAccumulator(\n      CallRuntime(Runtime::kPushWithContext, context, object, scope_info));\n  Dispatch();\n}\n\n// PushContext <context>\nIGNITION_HANDLER(PushContext, InterpreterAssembler) {\n  TNode<Context> new_context = CAST(GetAccumulator());\n  TNode<Context> old_context = GetContext();\n  StoreRegisterAtOperandIndex(old_context, 0);\n  SetContext(new_context);\n  Dispatch();\n}\n\n// PopContext <context>\nIGNITION_HANDLER(PopContext, InterpreterAssembler) {\n  TNode<Context> context = CAST(LoadRegisterAtOperandIndex(0));\n  SetContext(context);\n  Dispatch();\n}\n\n// LdaLookupSlot\nIGNITION_HANDLER(LdaLookupSlot, InterpreterAssembler) {\n  TNode<Name> name = CAST(LoadConstantPoolEntryAtOperandIndex(0));\n  TNode<Context> context = GetContext();\n  TNode<Object> result = CallRuntime(Runtime::kLoadLookupSlot, context, name);\n  SetAccumulator(result);\n  Dispatch();\n}\n\n// LdaLookupSlotInsideTypeof\nIGNITION_HANDLER(LdaLookupSlotInsideTypeof, InterpreterAssembler) {\n  TNode<Name> name = CAST(LoadConstantPoolEntryAtOperandIndex(0));\n  TNode<Context> context = GetContext();\n  TNode<Object> result =\n      CallRuntime(Runtime::kLoadLookupSlotInsideTypeof, context, name);\n  SetAccumulator(result);\n  Dispatch();\n}\n\n// Context-level lookup with fast path based on context extensions\nclass InterpreterLookupContextSlotAssembler : public InterpreterAssembler {\n  ...\n  void LookupContextSlot(Runtime::FunctionId function_id, ContextKind kind) {\n    TNode<Context> context = GetContext();\n    TNode<IntPtrT> slot_index = Signed(BytecodeOperandIdx(1));\n    TNode<Uint32T> depth = BytecodeOperandUImm(2);\n\n    Label slowpath(this, Label::kDeferred);\n\n    // Check for context extensions to allow the fast path.\n    TNode<Context> slot_context =\n        GotoIfHasContextExtensionUpToDepth(context, depth, &slowpath);\n\n    // Fast path does a normal load context.\n    {\n      TNode<Object> result =\n          (kind == ContextKind::kScriptContext)\n              ? LoadScriptContextElement(slot_context, slot_index)\n              : LoadContextElement(slot_context, slot_index);\n      SetAccumulator(result);\n      Dispatch();\n    }\n\n    // Slow path when we have to call out to the runtime.\n    BIND(&slowpath);\n    {\n      TNode<Name> name = CAST(LoadConstantPoolEntryAtOperandIndex(0));\n      TNode<Object> result = CallRuntime(function_id, context, name);\n      SetAccumulator(result);\n      Dispatch();\n    }\n  }\n};\n\n// LdaLookupContextSlot(+Script)\nIGNITION_HANDLER(LdaLookupContextSlot, InterpreterLookupContextSlotAssembler) {\n  LookupContextSlot(Runtime::kLoadLookupSlot, ContextKind::kDefault);\n}\nIGNITION_HANDLER(LdaLookupScriptContextSlot, InterpreterLookupContextSlotAssembler) {\n  LookupContextSlot(Runtime::kLoadLookupSlot, ContextKind::kScriptContext);\n}\nIGNITION_HANDLER(LdaLookupContextSlotInsideTypeof, InterpreterLookupContextSlotAssembler) {\n  LookupContextSlot(Runtime::kLoadLookupSlotInsideTypeof, ContextKind::kDefault);\n}\nIGNITION_HANDLER(LdaLookupScriptContextSlotInsideTypeof, InterpreterLookupContextSlotAssembler) {\n  LookupContextSlot(Runtime::kLoadLookupSlotInsideTypeof, ContextKind::kScriptContext);\n}\n\n// Global-level lookup with fast path based on context extensions and feedback vector loads\nclass InterpreterLookupGlobalAssembler : public InterpreterLoadGlobalAssembler {\n  ...\n  void LookupGlobalSlot(Runtime::FunctionId function_id) {\n    TNode<Context> context = GetContext();\n    TNode<Uint32T> depth = BytecodeOperandUImm(2);\n\n    Label slowpath(this, Label::kDeferred);\n\n    // Check for context extensions to allow the fast path\n    GotoIfHasContextExtensionUpToDepth(context, depth, &slowpath);\n\n    // Fast path does a normal load global\n    {\n      static const int kNameOperandIndex = 0;\n      static const int kSlotOperandIndex = 1;\n      TypeofMode typeof_mode = function_id == Runtime::kLoadLookupSlotInsideTypeof ? TypeofMode::kInside : TypeofMode::kNotInside;\n      LdaGlobal(kSlotOperandIndex, kNameOperandIndex, typeof_mode);\n    }\n\n    // Slow path runtime\n    BIND(&slowpath);\n    {\n      TNode<Name> name = CAST(LoadConstantPoolEntryAtOperandIndex(0));\n      TNode<Object> result = CallRuntime(function_id, context, name);\n      SetAccumulator(result);\n      Dispatch();\n    }\n  }\n};\n\nIGNITION_HANDLER(LdaLookupGlobalSlot, InterpreterLookupGlobalAssembler) {\n  LookupGlobalSlot(Runtime::kLoadLookupSlot);\n}\nIGNITION_HANDLER(LdaLookupGlobalSlotInsideTypeof, InterpreterLookupGlobalAssembler) {\n  LookupGlobalSlot(Runtime::kLoadLookupSlotInsideTypeof);\n}\n\n// StaLookupSlot\nIGNITION_HANDLER(StaLookupSlot, InterpreterAssembler) {\n  TNode<Object> value = GetAccumulator();\n  TNode<Name> name = CAST(LoadConstantPoolEntryAtOperandIndex(0));\n  TNode<Uint32T> bytecode_flags = BytecodeOperandFlag8(1);\n  TNode<Context> context = GetContext();\n  TVARIABLE(Object, var_result);\n  Label sloppy(this), strict(this), end(this);\n  Branch(IsSetWord32<StoreLookupSlotFlags::LanguageModeBit>(bytecode_flags),\n         &strict, &sloppy);\n  ... // Calls into Runtime::kStoreLookupSlot_{Strict,Sloppy,SloppyHoisting}\n  SetAccumulator(var_result.value());\n  Dispatch();\n}\n\n// ToObject\nIGNITION_HANDLER(ToObject, InterpreterAssembler) {\n  TNode<Object> accumulator = GetAccumulator();\n  TNode<Context> context = GetContext();\n  TNode<Object> result = CallBuiltin(Builtin::kToObject, context, accumulator);\n  StoreRegisterAtOperandIndex(result, 0);\n  Dispatch();\n}\n",
  "context": [
    "bgb_lookup_paths",
    "bgb_lookup_fastpaths"
  ],
  "explanation": "Ignition handlers for with-context creation, push/pop of context, lookup loads/stores with slow runtime fallbacks and extension-gated fast paths, and ToObject conversion are shown. These map to the same runtime and IC semantics used by TurboFan.",
  "file_line": "interpreter/interpreter-generator.cc: multiple ranges"
}