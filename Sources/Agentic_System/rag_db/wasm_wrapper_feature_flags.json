{
  "body": "Feature flags and behavior toggles impacting wrappers:\n- i64/BigInt interop:\n  - Wrappers convert JS BigInt <-> wasm i64 via builtins and call descriptors:\n    \u2022 wrappers.cc: BuildChangeBigIntToInt64 uses WasmCallDescriptors::GetBigIntToI64Descriptor(needs_frame_state) and Builtin::kBigIntToI64 (or kBigIntToI32Pair on 32-bit). ToJS uses BuildChangeInt64ToBigInt with StubCallMode::kCallBuiltinPointer.\n  - The presence of i64 in signatures disables fast-path conversion (QualifiesForFastTransform returns false if kI64 seen).\n- Ref types and Strings:\n  - wrappers.cc and wasm-compiler.cc handle ref types explicitly in ToJS/FromJS. For kRef/kRefNull(kString), BuildCheckString enforces JS String instance check; externref passes through; funcref maps through WasmInternalFunction externalization; others delegate to Runtime::kWasmJSToWasmObject which depends on module and feature flags (imported strings flag is handled in compiler paths for typing, see comments around enabled_features_.has_imported_strings()).\n- Generic vs specialized wrappers:\n  - wasm-objects.h: bool UseGenericWasmToJSWrapper(ImportCallKind kind, const CanonicalSig* sig, Suspend suspend); decision point for using generic wrapper which calls CallTrampoline or compiled specialized wrapper via WasmImportWrapperCache. Generic wrapper installed with signature hash; compiled wrapper cached per (kind, sig_index, expected_arity, suspend).\n  - wasm/wasm-objects and wasm/wasm-import-wrapper-cache glue allow switching from generic to compiled wrapper when available (WasmDispatchTable::InstallCompiledWrapper updates CPT entry), no explicit runtime flag but architecture allows this fallback/upgrade.\n- JITless / 32-bit considerations:\n  - On 32-bit, wrappers choose Builtin::kBigIntToI32Pair target and WasmCallDescriptors lowered version.\n  - In jitless (V8_ENABLE_DRUMBRAKE), dispatch tables store function index instead of target pointer; wrappers and tables have conditional fields (#if V8_ENABLE_DRUMBRAKE blocks). Also affects suspension handling and interpreter support fields in WasmTrustedInstanceData.\n- Trap handler and thread_in_wasm flag:\n  - Wrappers conditionally set thread_in_wasm_flag only if trap handler is enabled (trap_handler::IsTrapHandlerEnabled()), via ModifyThreadInWasmFlagScope; this affects behavior on platforms/flags toggling trap handler.\n- Promise integration / stack switching:\n  - Suspend parameter controls whether wasm-to-js wrappers enable promise-based suspension (kSuspend) with Builtin::kWasmSuspend and central stack switching (stress_wasm_stack_switching also influences error checks in BuildSuspend).\n- Fast-path conversion toggle:\n  - Fast path engaged only if do_conversion=true and signature qualifies (i32/f32/f64 only) and argument runtime checks pass (Smi or HeapNumber). Otherwise slow default path uses builtins for conversion, potentially with frame state.\n",
  "context": [
    "wasm_wrappers_entry_points",
    "wasm_objects_core",
    "wasm_tiering_and_budgets"
  ],
  "explanation": "Addresses item (5): enumerates flags and toggles that impact wrapper behavior: BigInt/i64, ref types, generic vs specialized wrapper policy, jitless and 32-bit paths, trap handler dependent thread_in_wasm flag, promise suspension, and fast-path conversion. Provides concrete code anchor descriptions.",
  "file_line": "wasm/wrappers.cc: BuildChangeBigIntToInt64, ToJS/FromJS; compiler/wasm-compiler.cc: analogous; wasm/wasm-objects.h: UseGenericWasmToJSWrapper; conditional blocks with V8_ENABLE_DRUMBRAKE; trap handler checks in ModifyThreadInWasmFlagScope"
}