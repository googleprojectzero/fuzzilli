{
  "body": "File: src/compiler/bytecode-graph-builder.cc\nKey functions and snippets related to with-scopes and lookup slots:\n\n1) Declarations and helpers\n- void BuildLdaLookupSlot(TypeofMode typeof_mode);\n- void BuildLdaLookupContextSlot(ContextKind context_kind, TypeofMode typeof_mode);\n- void BuildLdaLookupGlobalSlot(TypeofMode typeof_mode);\n- void VisitLdaLookupSlot();\n- void VisitLdaLookupSlotInsideTypeof();\n- void VisitLdaLookupContextSlot();\n- void VisitLdaLookupScriptContextSlot();\n- void VisitLdaLookupContextSlotInsideTypeof();\n- void VisitLdaLookupScriptContextSlotInsideTypeof();\n- void VisitLdaLookupGlobalSlot();\n- void VisitLdaLookupGlobalSlotInsideTypeof();\n- void VisitStaLookupSlot();\n- OptionalScopeInfoRef TryGetScopeInfo();\n- Environment* CheckContextExtensions(uint32_t depth);\n- Environment* CheckContextExtensionsSlowPath(uint32_t depth);\n- Environment* CheckContextExtensionAtDepth(Environment* slow_environment, uint32_t depth);\n\n2) Creation of WithContext (VisitCreateWithContext)\nvoid BytecodeGraphBuilder::VisitCreateWithContext() {\n  Node* object = environment()->LookupRegister(bytecode_iterator().GetRegisterOperand(0));\n  ScopeInfoRef scope_info = MakeRefForConstantForIndexOperand<ScopeInfo>(1);\n  const Operator* op = javascript()->CreateWithContext(scope_info);\n  Node* context = NewNode(op, object);\n  environment()->BindAccumulator(context);\n}\n\nJS op for CreateWithContext: JSOperatorBuilder::CreateWithContext(ScopeInfoRef)\n- Defined in src/compiler/js-operator.{h,cc}\n- IrOpcode: kJSCreateWithContext\n\n3) LdaLookupSlot and variants\n- BuildLdaLookupSlot(TypeofMode typeof_mode) performs a JSCallRuntime to Runtime::kLoadLookupSlot (or InsideTypeof) with name constant, binds accumulator and attaches frame state.\n\nvoid BytecodeGraphBuilder::BuildLdaLookupSlot(TypeofMode typeof_mode) {\n  PrepareEagerCheckpoint();\n  Node* name = jsgraph()->ConstantNoHole(MakeRefForConstantForIndexOperand(0), broker());\n  const Operator* op = javascript()->CallRuntime(typeof_mode == TypeofMode::kNotInside\n                                    ? Runtime::kLoadLookupSlot\n                                    : Runtime::kLoadLookupSlotInsideTypeof);\n  Node* value = NewNode(op, name);\n  environment()->BindAccumulator(value, Environment::kAttachFrameState);\n}\n\n- VisitLdaLookupSlot/VisitLdaLookupSlotInsideTypeof forward to BuildLdaLookupSlot with correct TypeofMode.\n\n4) Context/global fast-path with extension checks and slow runtime fallback\n- For LdaLookupContextSlot*, BytecodeGraphBuilder implements a fast-path via LoadContext/LoadScriptContext if no context extensions are present up to given depth; otherwise, branches to a slow path that calls Runtime::LoadLookupSlot (or InsideTypeof). This uses:\n  - OptionalScopeInfoRef TryGetScopeInfo(): inspects current context node opcode (JSCreateFunctionContext/JSCreateBlockContext/JSCreateCatchContext/JSCreateWithContext/Parameter) to derive current ScopeInfo.\n  - CheckContextExtensions(uint32_t depth): leverage dependencies on EmptyContextExtension if possible; otherwise emit dynamic checks per depth via CheckContextExtensionAtDepth.\n  - CheckContextExtensionsSlowPath: generic HasContextExtension(d) checks.\n\nBuildLdaLookupContextSlot(ContextKind context_kind, TypeofMode typeof_mode) {\n  uint32_t depth = bytecode_iterator().GetUnsignedImmediateOperand(2);\n  Environment* slow_environment = CheckContextExtensions(depth);\n  // Fast path: Load(Script)Context(...)\n  { uint32_t slot_index = bytecode_iterator().GetIndexOperand(1);\n    const Operator* op = context_kind == ContextKind::kScriptContext\n      ? javascript()->LoadScriptContext(depth, slot_index)\n      : javascript()->LoadContext(depth, slot_index, false);\n    environment()->BindAccumulator(NewNode(op));\n  }\n  if (!slow_environment) return; // fully replaced by deps\n  NewMerge();\n  Environment* fast_environment = environment();\n  set_environment(slow_environment);\n  // Slow path runtime\n  Node* name = jsgraph()->ConstantNoHole(MakeRefForConstantForIndexOperand(0), broker());\n  const Operator* op = javascript()->CallRuntime(typeof_mode == TypeofMode::kNotInside ? Runtime::kLoadLookupSlot : Runtime::kLoadLookupSlotInsideTypeof);\n  Node* value = NewNode(op, name);\n  environment()->BindAccumulator(value, Environment::kAttachFrameState);\n  fast_environment->Merge(environment(), bytecode_analysis().GetOutLivenessFor(bytecode_iterator().current_offset()));\n  set_environment(fast_environment);\n  mark_as_needing_eager_checkpoint(true);\n}\n\n- Equivalent pattern exists for BuildLdaLookupGlobalSlot(TypeofMode), where the fast path is LoadGlobal with feedback and slow path runtime LoadLookupSlot.\n\n5) StaLookupSlot\n- Calls runtime based on flags:\nvoid BytecodeGraphBuilder::VisitStaLookupSlot() {\n  PrepareEagerCheckpoint();\n  Node* value = environment()->LookupAccumulator();\n  Node* name = jsgraph()->ConstantNoHole(MakeRefForConstantForIndexOperand(0), broker());\n  int bytecode_flags = bytecode_iterator().GetFlag8Operand(1);\n  LanguageMode language_mode = static_cast<LanguageMode>(interpreter::StoreLookupSlotFlags::LanguageModeBit::decode(bytecode_flags));\n  LookupHoistingMode lookup_hoisting_mode = static_cast<LookupHoistingMode>(interpreter::StoreLookupSlotFlags::LookupHoistingModeBit::decode(bytecode_flags));\n  const Operator* op = javascript()->CallRuntime(\n      is_strict(language_mode) ? Runtime::kStoreLookupSlot_Strict\n      : lookup_hoisting_mode == LookupHoistingMode::kLegacySloppy ? Runtime::kStoreLookupSlot_SloppyHoisting\n      : Runtime::kStoreLookupSlot_Sloppy);\n  Node* store = NewNode(op, name, value);\n  environment()->BindAccumulator(store, Environment::kAttachFrameState);\n}\n\n6) PushContext/PopContext\n- Interpreter bytecodes are handled at ignition level; in TF builder, context is already tracked in Environment and dedicated visitors exist:\nvoid BytecodeGraphBuilder::VisitPushContext() {\n  Node* new_context = environment()->LookupAccumulator();\n  environment()->BindRegister(bytecode_iterator().GetRegisterOperand(0), environment()->Context());\n  environment()->SetContext(new_context);\n}\nvoid BytecodeGraphBuilder::VisitPopContext() {\n  Node* context = environment()->LookupRegister(bytecode_iterator().GetRegisterOperand(0));\n  environment()->SetContext(context);\n}\n\n7) Feedback vector usage with lookup globals\n- BuildLdaLookupGlobalSlot(TypeofMode) uses BuildLoadGlobal(name, feedback_slot_index, typeof_mode), which creates a JSLoadGlobal operator with feedback (feedback_vector_node()). Fast path merges with slow runtime fallback when context extensions might shadow.\n\n8) Exception edges / checks\n- Frame states are attached around runtime calls via PrepareEagerCheckpoint and Environment::kAttachFrameState semantics.\n- TypeofMode controls whether ReferenceError is thrown (LoadLookupSlot vs LoadLookupSlotInsideTypeof).\n\nLocations:\n- Declarations around line ~238\n- VisitLdaLookupSlot at ~1796-1801\n- VisitStaLookupSlot at ~2041-2061\n- With-context creation VisitCreateWithContext at ~2359-2365\n- Context extension checks and TryGetScopeInfo at ~1860-1950\n- Lookup context/global slow/fast logic at ~1950-2030\n- Push/PopContext at ~... VisitPushContext/VisitPopContext near later part (~?)\n",
  "context": [
    "jsop_with_context",
    "rt_lookup_slots",
    "ignition_handlers_lookup",
    "js_generic_lowering_lookup",
    "bytecode_feedback_globals"
  ],
  "explanation": "This entry summarizes how the BytecodeGraphBuilder handles with-scope creation and lookup slot bytecodes in TurboFan graph building. It shows the JS operators emitted (JSCreateWithContext, JSCallRuntime to Load/StoreLookupSlot), fast-paths with context extension checks, slow runtime fallbacks, and how PushContext/PopContext are wired. It also points to feedback usage for lookup globals and frame state/exception behavior control via TypeofMode.",
  "file_line": "compiler/bytecode-graph-builder.cc:1784-2065; 2359-2365; ~1860-2030; VisitPushContext/PopContext near end."
}