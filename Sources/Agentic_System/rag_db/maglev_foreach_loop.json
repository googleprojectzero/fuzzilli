{
  "body": "// MaglevSubGraphBuilder loop construction, conditions, and arithmetic used by forEach lowering\n// src/maglev/maglev-graph-builder.cc (selected helpers and snippets)\n// MaglevSubGraphBuilder::BeginLoop, EndLoop, labels, and branching helpers:\nclass MaglevGraphBuilder::MaglevSubGraphBuilder {\n  LoopLabel BeginLoop(std::initializer_list<Variable*> loop_vars);\n  void EndLoop(LoopLabel* loop_label);\n  void GotoIfFalse<BranchIfInt32Compare>(Label* false_target, {lhs, rhs}, Operation op);\n  void GotoIfTrue<BranchIfFloat64IsHole>(Label* true_target, {value});\n  void GotoIfTrue<BranchIfRootConstant>(Label* true_target, {value}, RootIndex);\n  // Label, Variable plumbing; Select/Branch combinators, etc.\n};\n\n// Integer comparison branch used for the loop guard (index < length)\nclass BranchIfInt32Compare : public BranchControlNodeT<2, BranchIfInt32Compare> {\n  Operation operation() const; // e.g. kLessThan\n  void GenerateCode(...); // emits CompareInt32 and branches\n};\n\n// Index arithmetic node with overflow trapping (eager deopt continuation guards)\nclass Int32IncrementWithOverflow : public ValueNodeT<Int32IncrementWithOverflow> { ... };\n\n// Example usage in forEach lowering (simplified):\nsub_builder.set(var_index, GetSmiConstant(0));\nsub_builder.set(var_length, original_length);\nMaglevSubGraphBuilder::LoopLabel loop_header =\n    sub_builder.BeginLoop({&var_index, &var_length});\nPhi* index_tagged = sub_builder.get(var_index)->Cast<Phi>();\nEnsureType(index_tagged, NodeType::kSmi);\nValueNode* index_int32 = GetInt32(index_tagged);\nsub_builder.GotoIfFalse<BranchIfInt32Compare>(&loop_end,\n    {index_int32, original_length_int32}, Operation::kLessThan);\nValueNode* next_index_int32 = AddNewNode<Int32IncrementWithOverflow>({index_int32});\nsub_builder.set(var_index, next_index_int32);\nsub_builder.EndLoop(&loop_header);\n\n// UnsafeSmiUntag helper used by other paths (array push/pop) and by generic untag\nValueNode* MaglevGraphBuilder::BuildSmiUntag(ValueNode* node) {\n  if (EnsureType(node, NodeType::kSmi)) return AddNewNode<UnsafeSmiUntag>({node});\n  else return AddNewNode<CheckedSmiUntag>({node});\n}\n\n// CheckInt32Condition node used for deopt checks, such as ArrayLengthChanged\nclass CheckInt32Condition : public FixedInputNodeT<2, CheckInt32Condition> {\n  AssertCondition condition() const; // e.g., kUnsignedLessThanEqual\n  DeoptimizeReason reason() const;   // e.g., kArrayLengthChanged\n  void GenerateCode(...);            // emits CompareInt32 and deopt on fail\n};\n",
  "context": [
    "maglev_foreach_tryreduce",
    "maglev_length_changed"
  ],
  "explanation": "This RAG item collects the loop construction mechanics used by Maglev for lowering Array.prototype.forEach: sub-graph loop API, label/phi handling, the index guard using BranchIfInt32Compare, arithmetic with Int32IncrementWithOverflow, and the CheckInt32Condition node used for post-call deopt validations. It references BuildSmiUntag as part of integer handling and ties to the previously stored forEach lowering and ArrayLengthChanged entries.",
  "file_line": "maglev/maglev-graph-builder.cc: (BeginLoop) ~ lines 3150-3270; TryReduceArrayForEach: ~8061-8345; maglev/maglev-ir.h: Branch/Int32/Check classes"
}