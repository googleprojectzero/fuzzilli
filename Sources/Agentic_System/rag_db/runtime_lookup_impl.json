{
  "body": "File: src/runtime/runtime-scopes.cc (selected)\n\n// Entry points used by Ignition and TF slow paths\nRUNTIME_FUNCTION(Runtime_LoadLookupSlot) {\n  HandleScope scope(isolate);\n  DCHECK_EQ(1, args.length());\n  Handle<String> name = args.at<String>(0);\n  RETURN_RESULT_OR_FAILURE(isolate,\n                           LoadLookupSlot(isolate, name, kThrowOnError));\n}\n\nRUNTIME_FUNCTION(Runtime_LoadLookupSlotInsideTypeof) {\n  HandleScope scope(isolate);\n  DCHECK_EQ(1, args.length());\n  Handle<String> name = args.at<String>(0);\n  RETURN_RESULT_OR_FAILURE(isolate, LoadLookupSlot(isolate, name, kDontThrow));\n}\n\nRUNTIME_FUNCTION_RETURN_PAIR(Runtime_LoadLookupSlotForCall) { ... }\n\n// Store variants according to language mode / hoisting\nRUNTIME_FUNCTION(Runtime_StoreLookupSlot_Sloppy) {\n  HandleScope scope(isolate);\n  DCHECK_EQ(2, args.length());\n  Handle<String> name = args.at<String>(0);\n  Handle<Object> value = args.at(1);\n  Handle<Context> context(isolate->context(), isolate);\n  RETURN_RESULT_OR_FAILURE(\n      isolate,\n      StoreLookupSlot(isolate, context, name, value, LanguageMode::kSloppy));\n}\nRUNTIME_FUNCTION(Runtime_StoreLookupSlot_Strict) { ... LanguageMode::kStrict }\nRUNTIME_FUNCTION(Runtime_StoreLookupSlot_SloppyHoisting) { ... DONT_FOLLOW_CHAINS }\n\n// With context creation\nRUNTIME_FUNCTION(Runtime_PushWithContext) {\n  HandleScope scope(isolate);\n  DCHECK_EQ(2, args.length());\n  DirectHandle<JSReceiver> extension_object = args.at<JSReceiver>(0);\n  DirectHandle<ScopeInfo> scope_info = args.at<ScopeInfo>(1);\n  DirectHandle<Context> current(isolate->context(), isolate);\n  return *isolate->factory()->NewWithContext(current, scope_info,\n                                             extension_object);\n}\n\n// Delete lookup slot\nRUNTIME_FUNCTION(Runtime_DeleteLookupSlot) { ... JSReceiver::DeleteProperty }\n\n// Helper search\nMaybeHandle<Object> LoadLookupSlot(Isolate* isolate, Handle<String> name,\n                                   ShouldThrow should_throw,\n                                   Handle<Object>* receiver_return) {\n  int index; PropertyAttributes attributes; InitializationFlag flag; VariableMode mode;\n  Handle<Context> context(isolate->context(), isolate);\n  Handle<Object> holder = Context::Lookup(context, name, FOLLOW_CHAINS, &index,\n                                          &attributes, &flag, &mode);\n  if (isolate->has_exception()) return MaybeHandle<Object>();\n\n  if (!holder.is_null() && IsSourceTextModule(*holder)) {\n    Handle<Object> receiver = isolate->factory()->undefined_value();\n    if (receiver_return) *receiver_return = receiver;\n    return SourceTextModule::LoadVariable(isolate, Cast<SourceTextModule>(holder), index);\n  }\n  if (index != Context::kNotFound) {\n    auto holder_context = Cast<Context>(holder);\n    Handle<Object> receiver = isolate->factory()->undefined_value();\n    Handle<Object> value = handle(holder_context->get(index), isolate);\n    if (flag == kNeedsInitialization && IsTheHole(*value, isolate)) {\n      THROW_NEW_ERROR(isolate, NewReferenceError(MessageTemplate::kNotDefined, name));\n    }\n    if (receiver_return) *receiver_return = receiver;\n    if (v8_flags.script_context_mutable_heap_number && holder_context->IsScriptContext()) {\n      return handle(*Context::LoadScriptContextElement(holder_context, index, value, isolate), isolate);\n    }\n    return value;\n  }\n  // else holder is a JSReceiver (context extension, with subject, or global)\n  if (!holder.is_null()) {\n    Handle<Object> value;\n    ASSIGN_RETURN_ON_EXCEPTION(\n        isolate, value, Object::GetProperty(isolate, Cast<JSAny>(holder), name));\n    if (receiver_return) {\n      *receiver_return = (IsJSGlobalObject(*holder) || IsJSContextExtensionObject(*holder))\n          ? Cast<Object>(isolate->factory()->undefined_value())\n          : holder;\n    }\n    return value;\n  }\n  if (should_throw == kThrowOnError) { THROW_NEW_ERROR(isolate, NewReferenceError(MessageTemplate::kNotDefined, name)); }\n  if (receiver_return) *receiver_return = isolate->factory()->undefined_value();\n  return isolate->factory()->undefined_value();\n}\n\n// Store helper\nMaybeHandle<Object> StoreLookupSlot(Isolate* isolate, Handle<Context> context,\n                                    Handle<String> name, Handle<Object> value,\n                                    LanguageMode language_mode,\n                                    ContextLookupFlags flags = FOLLOW_CHAINS) {\n  int index; PropertyAttributes attributes; InitializationFlag flag; VariableMode mode; bool is_sloppy_function_name;\n  Handle<Object> holder = Context::Lookup(context, name, flags, &index, &attributes, &flag, &mode, &is_sloppy_function_name);\n  if (holder.is_null()) { if (isolate->has_exception()) return MaybeHandle<Object>(); }\n  else if (IsSourceTextModule(*holder)) { ... handle module store ... }\n  if (index != Context::kNotFound) {\n    auto holder_context = Cast<Context>(holder);\n    if (flag == kNeedsInitialization && IsTheHole(holder_context->get(index), isolate)) {\n      THROW_NEW_ERROR(isolate, NewReferenceError(MessageTemplate::kNotDefined, name));\n    }\n    if ((attributes & READ_ONLY) == 0) {\n      if ((v8_flags.script_context_mutable_heap_number || v8_flags.const_tracking_let) && holder_context->IsScriptContext()) {\n        Context::StoreScriptContextAndUpdateSlotProperty(holder_context, index, value, isolate);\n      } else {\n        holder_context->set(index, *value);\n      }\n    } else if (!is_sloppy_function_name || is_strict(language_mode)) {\n      THROW_NEW_ERROR(isolate, NewTypeError(MessageTemplate::kConstAssign, name));\n    }\n    return value;\n  }\n  DirectHandle<JSReceiver> object;\n  if (attributes != ABSENT) { object = Cast<JSReceiver>(holder); }\n  else if (is_strict(language_mode)) { THROW_NEW_ERROR(isolate, NewReferenceError(MessageTemplate::kNotDefined, name)); }\n  else { object = direct_handle(context->global_object(), isolate); }\n  ASSIGN_RETURN_ON_EXCEPTION(isolate, value, Object::SetProperty(isolate, object, name, value));\n  return value;\n}\n",
  "context": [
    "bgb_lookup_paths",
    "ignition_lookup_handlers"
  ],
  "explanation": "Runtime semantics for dynamic name lookup loads/stores. Explains behavior for context slots, module bindings, with/extension/global fallback, and error behavior. PushWithContext allocates with-contexts. These are the slow-path targets used by TF and Ignition.",
  "file_line": "runtime-scopes.cc: various ranges"
}