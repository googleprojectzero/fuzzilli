{
  "body": "Feedback vector usage and context-extension gating across tiers\n\n1) TurboFan bytecode builder global loads (src/compiler/bytecode-graph-builder.cc):\n\nNode* BytecodeGraphBuilder::BuildLoadGlobal(NameRef name,\n                                            uint32_t feedback_slot_index,\n                                            TypeofMode typeof_mode) {\n  FeedbackSource feedback = CreateFeedbackSource(feedback_slot_index);\n  DCHECK(IsLoadGlobalICKind(broker()->GetFeedbackSlotKind(feedback)));\n  const Operator* op = javascript()->LoadGlobal(name, feedback, typeof_mode);\n  DCHECK(IrOpcode::IsFeedbackCollectingOpcode(op->opcode()));\n  return NewNode(op, feedback_vector_node());\n}\n\nvoid BytecodeGraphBuilder::BuildLdaLookupGlobalSlot(TypeofMode typeof_mode) {\n  uint32_t depth = bytecode_iterator().GetUnsignedImmediateOperand(2);\n  Environment* slow_environment = CheckContextExtensions(depth);\n  {\n    PrepareEagerCheckpoint();\n    NameRef name = MakeRefForConstantForIndexOperand<Name>(0);\n    uint32_t feedback_slot_index = bytecode_iterator().GetIndexOperand(1);\n    Node* node = BuildLoadGlobal(name, feedback_slot_index, typeof_mode);\n    environment()->BindAccumulator(node, Environment::kAttachFrameState);\n  }\n  if (!slow_environment) return;  // fully replaced by deps\n  NewMerge();\n  Environment* fast_environment = environment();\n  set_environment(slow_environment);\n  {\n    Node* name = jsgraph()->ConstantNoHole(\n        MakeRefForConstantForIndexOperand<Name>(0), broker());\n    const Operator* op = javascript()->CallRuntime(\n        typeof_mode == TypeofMode::kNotInside ? Runtime::kLoadLookupSlot\n                                              : Runtime::kLoadLookupSlotInsideTypeof);\n    Node* value = NewNode(op, name);\n    environment()->BindAccumulator(value, Environment::kAttachFrameState);\n  }\n  fast_environment->Merge(environment(), ...);\n  set_environment(fast_environment);\n  mark_as_needing_eager_checkpoint(true);\n}\n\n// Context extension gating helpers (same file):\nOptionalScopeInfoRef TryGetScopeInfo();\nEnvironment* CheckContextExtensions(uint32_t depth); // uses HasContextExtension(size_t)\nEnvironment* CheckContextExtensionsSlowPath(uint32_t depth);\nEnvironment* CheckContextExtensionAtDepth(Environment*, uint32_t);\n\n2) Generic lowering for globals (src/compiler/js-generic-lowering.cc):\n\nvoid JSGenericLowering::LowerJSLoadGlobal(Node* node) {\n  JSLoadGlobalNode n(node);\n  const LoadGlobalParameters& p = n.Parameters();\n  CallDescriptor::Flags flags = FrameStateFlagForCall(node);\n  FrameState frame_state = n.frame_state();\n  Node* outer_state = frame_state.outer_frame_state();\n  static_assert(n.FeedbackVectorIndex() == 0);\n  if (outer_state->opcode() != IrOpcode::kFrameState) {\n    n->RemoveInput(n.FeedbackVectorIndex());\n    node->InsertInput(zone(), 0, jsgraph()->ConstantNoHole(p.name(), broker()));\n    node->InsertInput(zone(), 1,\n                      jsgraph()->TaggedIndexConstant(p.feedback().index()));\n    Callable callable = CodeFactory::LoadGlobalIC(isolate(), p.typeof_mode());\n    ReplaceWithBuiltinCall(node, callable, flags);\n  } else {\n    node->InsertInput(zone(), 0, jsgraph()->ConstantNoHole(p.name(), broker()));\n    node->InsertInput(zone(), 1,\n                      jsgraph()->TaggedIndexConstant(p.feedback().index()));\n    Callable callable =\n        CodeFactory::LoadGlobalICInOptimizedCode(isolate(), p.typeof_mode());\n    ReplaceWithBuiltinCall(node, callable, flags);\n  }\n}\n\n3) Ignition global load (src/interpreter/interpreter-generator.cc):\n\nclass InterpreterLoadGlobalAssembler : public InterpreterAssembler {\n  void LdaGlobal(int slot_operand_index, int name_operand_index,\n                 TypeofMode typeof_mode) {\n    TNode<HeapObject> maybe_feedback_vector = LoadFeedbackVector();\n    AccessorAssembler accessor_asm(state());\n    ExitPoint exit_point(this, [=, this](TNode<Object> result) {\n      SetAccumulator(result);\n      Dispatch();\n    });\n    LazyNode<TaggedIndex> lazy_slot = [=, this] {\n      return BytecodeOperandIdxTaggedIndex(slot_operand_index);\n    };\n    LazyNode<Context> lazy_context = [=, this] { return GetContext(); };\n    LazyNode<Name> lazy_name = [=, this] {\n      TNode<Name> name = CAST(LoadConstantPoolEntryAtOperandIndex(name_operand_index));\n      return name;\n    };\n    accessor_asm.LoadGlobalIC(maybe_feedback_vector, lazy_slot, lazy_context,\n                              lazy_name, typeof_mode, &exit_point);\n  }\n};\n\n4) Context-extension gating in Ignition (src/interpreter/interpreter-generator.cc):\n- Both InterpreterLookupContextSlotAssembler::LookupContextSlot and InterpreterLookupGlobalAssembler::LookupGlobalSlot call:\n  TNode<Context> slot_context = GotoIfHasContextExtensionUpToDepth(context, depth, &slowpath);\n- If any extension is found, fall back to runtime (Runtime::kLoadLookupSlot or InsideTypeof). Otherwise use LoadContext/LoadScriptContext or LdaGlobal fast path with feedback.\n\n5) ScopeInfo and flags (src/objects/scope-info.cc/h):\n- ScopeInfo::HasContextExtensionSlot() bit indicates whether contexts of this scope type may have a dynamic extension, gating whether checks/dependencies are needed.\n\nSummary: Global name loads/stores use ICs with feedback vectors in all tiers when context-extension checks allow. When any context in [0, depth) may have an extension (dynamic with/emulated eval var extension), TF emits JSHasContextExtension branches (or relies on EmptyContextExtension dependencies) and merges a slow runtime path; Ignition uses GotoIfHasContextExtensionUpToDepth to direct to runtime. Feedback vectors (slot indices, vector input) are attached to LoadGlobal/StoreGlobal ops and lower to CodeFactory::LoadGlobalIC[*] or builtins; interpreter version calls AccessorAssembler\u2019s LoadGlobalIC.\n",
  "context": [
    "bgb_lookup_paths",
    "bgb_lookup_fastpaths",
    "ignition_lookup_handlers"
  ],
  "explanation": "Consolidated view of how feedback vectors drive fast-path global accesses and how context extension checks gate the use of fast paths, across TurboFan and Ignition. Includes concrete code snippets and lowering behavior.",
  "file_line": "multiple files; specific lines annotated above"
}