{
  "body": "Index representation, untagging, increment, comparisons, and length-change guards in Maglev for Array.prototype.forEach loop lowering:\n\n- Index setup: var_index is initialized to Smi 0 and stored as a Phi in the loop (sub_builder.set(var_index, GetSmiConstant(0))). The length var starts as original_length (BuildLoadJSArrayLength(receiver)). There\u2019s a LoopLabel and BeginLoop/EndLoop.\n- Comparison: Before the loop body, it compares index_int32 < original_length_int32 using BranchIfInt32Compare(Operation::kLessThan). The index_int32 is obtained via GetInt32(index_tagged) where index_tagged is the phi (EnsureType(index_tagged, NodeType::kSmi)).\n- Increment with eager deopt: The index increment uses Int32IncrementWithOverflow under an eager deopt scope with Builtin::kArrayForEachLoopEagerDeoptContinuation. Comment notes overflow cannot really happen because max array length < int32 max; TODO to replace with asserting increment.\n- Elements access: Load elements array with BuildLoadElements(receiver). Depending on elements_kind, either BuildLoadFixedDoubleArrayElement or BuildLoadFixedArrayElement is used.\n- Hole checks: For HOLEY kinds, skip call when element is hole using BranchIfFloat64IsHole (double) or BranchIfRootConstant(..., kTheHoleValue) (tagged), with a skip_call label.\n- Post-callback guards and length change: After the callback and any recheck of maps, reload current_length = BuildLoadJSArrayLength(receiver), set var_length to it, and if it is not pointer-equal to original_length (different node identity), assert original_length_int32 <= current_length using TryBuildCheckInt32Condition(..., AssertCondition::kUnsignedLessThanEqual, DeoptimizeReason::kArrayLengthChanged). This guards against length decreasing below original, matching spec\u2019s snapshot semantics for fast path.\n- Uint32/Unsigned comparisons: The less-than and less-than-equal guards use unsigned comparisons for bounds and length-change (kUnsignedLessThan/kUnsignedLessThanEqual). In the loop header check, BranchIfInt32Compare is used with signed int32 compare but both index and length are non-negative, and later TryBuildCheckInt32Condition uses AssertCondition::kUnsignedLessThanEqual for the length change guard.\n\nAssociated nodes:\n- Int32IncrementWithOverflow\n- BranchIfInt32Compare\n- CheckInt32Condition (used via TryBuildCheckInt32Condition)\n- BuildLoadElements, BuildLoadJSArrayLength\n- LoadFixedDoubleArrayElement, LoadFixedArrayElement\n- BranchIfFloat64IsHole, BranchIfRootConstant\n",
  "context": [
    "maglev_array_foreach",
    "foreach_builder_entrypoints"
  ],
  "explanation": "Summarizes how representation conversion, index math, and bounds/length-change checks are built in the loop lowering for forEach, including specific Maglev nodes and assert conditions.",
  "file_line": "maglev/maglev-graph-builder.cc:8153-8218, 8226-8287"
}