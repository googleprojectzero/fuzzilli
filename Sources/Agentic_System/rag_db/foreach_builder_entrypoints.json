{
  "body": "Key entrypoints for Array.prototype.forEach specialization in Maglev reside inside MaglevGraphBuilder::TryReduceArrayForEach in src/maglev/maglev-graph-builder.cc. This function checks that the call is speculatable, validates the receiver and its maps support fast array iteration, ensures the NoElementsProtector dependency, validates the callback, and then lowers into an explicit loop via MaglevSubGraphBuilder with deopt continuation builtins for eager and lazy cases.\n\nHighlights of the implementation:\n- Name: Reduce path TryReduceArrayForEach\n- File: maglev/maglev-graph-builder.cc\n- Loop setup: uses MaglevSubGraphBuilder to build a loop with variables var_index (Smi tagged) and var_length (the JSArray length), and a LoopLabel loop_header.\n- Deopt continuations used for forEach: Builtin::kArrayForEachLoopLazyDeoptContinuation and Builtin::kArrayForEachLoopEagerDeoptContinuation.\n- Elements kind specialization and hole handling: the function first derives ElementsKind from the receiver's KnownNodeAspects maps via CanInlineArrayIteratingBuiltin and only proceeds if all maps support fast array iteration and can unify element kinds. For HOLEY kinds, branches skip callback when element is hole (BranchIfFloat64IsHole or BranchIfRootConstant with kTheHoleValue).\n- Representation: index is Smi-tagged phi; the int32 index used for bounds comparing and element access is obtained via GetInt32(index_tagged). It increments via Int32IncrementWithOverflow under an eager deopt scope.\n- Length and length-change guard: original_length is built from BuildLoadJSArrayLength(receiver) and cached. After each callback, current_length is reloaded and compared with original_length using TryBuildCheckInt32Condition(..., AssertCondition::kUnsignedLessThanEqual, DeoptimizeReason::kArrayLengthChanged). If different value nodes, it asserts that original_length_int32 <= current_length.\n- Elements access: loads elements via BuildLoadElements(receiver). For doubles: BuildLoadFixedDoubleArrayElement(elements, index_int32); for tagged: BuildLoadFixedArrayElement(elements, index_int32). For HOLEY kinds, there are hole checks, using BranchIfFloat64IsHole or BranchIfRootConstant.\n- Callback validation: Ensures callback is NodeType::kCallable. If not statically known callable, wraps a ThrowIfNotCallable node emission inside a DeoptFrameScope lazy continuation (Builtin::kArrayForEachLoopLazyDeoptContinuation) so that exception stack traces are proper.\n- Map re-check after callback when receiver maps were unstable: uses CheckMaps or CheckMapsWithMigration against the saved PossibleMaps set, within an eager deopt scope tied to Builtin::kArrayForEachLoopEagerDeoptContinuation.\n- Exception path: ThrowIfNotCallable calls into runtime ThrowCalledNonCallable with DefineExceptionHandlerAndLazyDeoptPoint. The deopt scope wiring ensures the lazy continuation builtin is used as deopt frame for exceptions thrown before loop lowering proceeds.\n\nKey code snippets (see FileLine for precise locations):\n- Elements kind gating/helper: static bool CanInlineArrayIteratingBuiltin(...)\n- TryReduceArrayForEach main lowering: emits loop, hole-skipping, callback calls, deopt scopes, and length-change guard.\n- Builtins identifiers for continuations: handled in MaglevGraphBuilder::DeoptFrameScope and also referenced in switch at top of file.\n",
  "context": [
    "maglev_array_foreach",
    "foreach_deopt_continuations",
    "foreach_throw_if_not_callable",
    "foreach_elements_and_maps",
    "foreach_representation_and_bounds"
  ],
  "explanation": "This entry details the key builder entrypoint and the high-level flow of Maglev lowering of Array.prototype.forEach into an explicit loop with elements specialization, deopt continuations, and callback validation.",
  "file_line": "maglev/maglev-graph-builder.cc:8072-8320 (TryReduceArrayForEach); maglev/maglev-graph-builder.cc:8029-8050 (CanInlineArrayIteratingBuiltin)"
}