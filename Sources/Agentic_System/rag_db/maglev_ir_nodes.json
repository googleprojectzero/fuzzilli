{
  "body": "maglev/maglev-ir.h and maglev/maglev-ir.cc define nodes used in TA pipeline and conversions:\n\nKey IR nodes with stable opcode names:\n- LoadTypedArrayLength (class at maglev-ir.h:6442-6466): FixedInputValueNodeT<1>, OpProperties::IntPtr | CanRead; input: receiver (Tagged), option elements_kind (ElementsKind). Codegen in x64 and arm64 reads JSTypedArray::kRawByteLengthOffset and shifts by ElementsKindToShiftSize.\n- CheckTypedArrayNotDetached (maglev-ir.h:6469-6487): FixedInputNodeT<1>, EagerDeopt | CanRead; input: object. Codegen in maglev-ir.cc: SetValueLocationConstraints at 6628; GenerateCode at 6633 (uses ArrayBufferDetachingProtector path).\n- CheckTypedArrayBounds (maglev-ir.h:6488-6511): FixedInputNodeT<2>, EagerDeopt; InputTypes {Uint32, IntPtr}; inputs: index, length; codegen maglev-ir.cc:3476-3484 compare index vs length unsigned >= and deopt OOB.\n- CheckedObjectToIndex (maglev-ir.h:6625-6645): FixedInputValueNodeT<1>, EagerDeopt | Int32 | DeferredCall | ConversionNode; converts tagged key to Int32 index with Smi fastpath, HeapNumber, string-to-array-index call; codegen maglev-ir.cc:1816-1879.\n- StoreIntTypedArrayElement, StoreDoubleTypedArrayElement (maglev-ir.h:7619-7631 macros). STORE_TYPED_ARRAY(name, OpProperties::CanWrite(), type, ...). Codegen in maglev-ir.cc: DEF_STORE_TYPED_ARRAY at 6800ff, handles addressing and writing via helper macros; for Double value representation is HoleyFloat64.\n- Conversion helpers:\n  - CheckedTruncateNumberOrOddballToInt32 (maglev-ir.h:4195-4211): EagerDeopt | Int32. Codegen: maglev-ir.cc:1881-1890 and 7526 print params.\n  - CheckedNumberOrOddballToHoleyFloat64 (maglev-ir.h:4043-4054). Codegen: maglev-ir.cc:... uses TryUnboxNumberOrOddball path.\n  - Int32ToUint8Clamped, Uint32ToUint8Clamped, Float64ToUint8Clamped, CheckedNumberToUint8Clamped (maglev-ir.h:3518-3579). Codegen in maglev-ir.cc: 5567-5613, 5704-5734, using MaglevAssembler::ToUint8Clamped and deopt when non-number for CheckedNumberToUint8Clamped.\n\nDeopt reasons referenced: kOutOfBounds (bounds), kNotANumberOrOddball / kNotANumber, kWrongValue for string checks, kNotInt32, kHole for NaN hole checks. Uint8Clamped generators use min/max labels.\n\nRepresentation and inputs:\n- LoadTypedArrayLength returns IntPtr (size_t), CheckTypedArrayBounds takes Uint32 index and IntPtr length (consistent with 32/64-bit).\n- StoreIntTypedArrayElement takes value as Int32 (after conversions), StoreDouble* takes HoleyFloat64.\n\nCodegen architecture specifics:\n- x64 maglev-ir-x64.cc: LoadTypedArrayLength::GenerateCode loads JSTypedArray::kRawByteLengthOffset, shifts right 0/1/2/3 based on ElementsKind.\n- arm64 maglev-ir-arm64.cc: similar, uses Lsr.\n- Bounds compare uses CompareIntPtrAndJumpIf(index, length, kUnsignedGreaterThanEqual, deopt) in arch-agnostic maglev-ir.cc, but relies on index being zero-extended Uint32 (ZeroExtendWord on RISCV64 path).\n\nRelated helper: maglev/maglev-graph-builder.cc BuildStoreTypedArrayElement chooses conversion node: Int32 truncation or HoleyFloat64, or Uint8Clamped specialized path leveraging CheckedNumberToUint8Clamped or Int32/Uint32/Float64ToUint8Clamped depending on accumulator/known type.",
  "context": [
    "graph_builder_typedarray_paths",
    "maglev_codegen_x64_arm64",
    "objects_typedarray",
    "elements_kind_helpers"
  ],
  "explanation": "This record collects the core Maglev IR nodes and conversions composing the TA store pipeline: index coercion, length load, bounds check, and store nodes, plus conversion nodes for values, along with deopt reasons and representations. These serve as canonical anchors for building the pipeline chain and for codegen mapping.",
  "file_line": "maglev/maglev-ir.h:3518-3579,4043-4211,6442-6511,6619-6645,7619-7631; maglev/maglev-ir.cc:1816-1890,3476-3484,5567-5734,6800ff; maglev/x64/maglev-ir-x64.cc:69-90; maglev/arm64/maglev-ir-arm64.cc:627-650"
}