{
  "body": "// builtins/set-symmetric-difference.tq - Torque builtin for Set.prototype.symmetricDifference\n// (file content captured from repo)\nnamespace collections {\n\n// https://tc39.es/proposal-set-methods/#sec-set.prototype.symmetricdifference\n@incrementUseCounter('v8::Isolate::kSetMethods')\ntransitioning javascript builtin SetPrototypeSymmetricDifference(\n    js-implicit context: NativeContext, receiver: JSAny)(other: JSAny): JSSet {\n  const methodName: constexpr string = 'Set.prototype.symmetricDifference';\n  const fastIteratorResultMap = GetIteratorResultMap();\n\n  // 1. Let O be the this value.\n  // 2. Perform ? RequireInternalSlot(O, [[SetData]]).\n  const o = Cast<JSSet>(receiver) otherwise\n  ThrowTypeError(\n      MessageTemplate::kIncompatibleMethodReceiver, methodName, receiver);\n\n  // 3. Let otherRec be ? GetSetRecord(other).\n  let otherRec = GetSetRecord(other, methodName);\n\n  // 4. Let keysIter be ? GetKeysIterator(otherRec).\n  let keysIter =\n      GetKeysIterator(otherRec.object, UnsafeCast<Callable>(otherRec.keys));\n\n  // 5. Let resultSetData be a copy of O.[[SetData]].\n  let table = NewStableBackingTableWitness(o);\n  const resultSetData = Cast<OrderedHashSet>(\n      CloneFixedArray(table.GetTable(), ExtractFixedArrayFlag::kFixedArrays))\n      otherwise unreachable;\n  let resultAndNumberOfElements = OrderedHashSetAndNumberOfElements{\n    setData: resultSetData,\n    numberOfElements: UnsafeCast<Smi>(\n        resultSetData.objects[kOrderedHashSetNumberOfElementsIndex])\n  };\n\n  try {\n    typeswitch (other) {\n      case (otherSet: JSSetWithNoCustomIteration): {\n        CheckSetRecordHasJSSetMethods(otherRec) otherwise SlowPath;\n\n        const otherTable = NewStableBackingTableWitness(otherSet);\n\n        let otherIterator = collections::NewUnmodifiedOrderedHashSetIterator(\n            otherTable.GetTable());\n\n        while (true) {\n          const nextValue = otherIterator.Next() otherwise Done;\n\n          resultAndNumberOfElements = FastSymmetricDifference(\n              nextValue, table, resultAndNumberOfElements, methodName);\n        }\n      }\n      case (otherMap: JSMapWithNoCustomIteration): {\n        CheckSetRecordHasJSMapMethods(otherRec) otherwise SlowPath;\n\n        const otherTable = NewStableBackingTableWitness(otherMap);\n\n        let otherIterator = collections::NewUnmodifiedOrderedHashMapIterator(\n            otherTable.GetTable());\n\n        while (true) {\n          const nextValue = otherIterator.Next() otherwise Done;\n\n          resultAndNumberOfElements = FastSymmetricDifference(\n              nextValue.key, table, resultAndNumberOfElements, methodName);\n        }\n      }\n      case (JSAny): {\n        goto SlowPath;\n      }\n    }\n  } label SlowPath {\n    // 6. Let next be true.\n    let nextRecord: JSReceiver;\n    // 7. Repeat, while next is not false,\n    while (true) {\n      //  a. Set next to ? IteratorStep(keysIter).\n      nextRecord = iterator::IteratorStep(keysIter, fastIteratorResultMap)\n          otherwise Done;\n\n      //  b. If next is not false, then\n      //      i. Let nextValue be ? IteratorValue(next).\n      let nextValue =\n          iterator::IteratorValue(nextRecord, fastIteratorResultMap);\n\n      //      ii. If nextValue is -0\ud835\udd3d, set nextValue to +0\ud835\udd3d.\n      nextValue = collections::NormalizeNumberKey(nextValue);\n\n      //      iii. Let inResult be SetDataHas(resultSetData, nextValue).\n      const inResult =\n          TableHasKey(resultAndNumberOfElements.setData, nextValue);\n\n      //      iv. If SetDataHas(O.[[SetData]], nextValue) is true, then\n      table.ReloadTable();\n      if (table.HasKey(nextValue)) {\n        //  1. If inResult is true, remove nextValue from resultSetData.\n        if (inResult) {\n          resultAndNumberOfElements.numberOfElements =\n              DeleteFromSetTable(resultAndNumberOfElements.setData, nextValue)\n              otherwise unreachable;\n        }\n      } else {\n        // v. Else,\n        //    1. If inResult is false, append nextValue to resultSetData.\n        if (!inResult) {\n          resultAndNumberOfElements.setData = AddToSetTable(\n              resultAndNumberOfElements.setData, nextValue, methodName);\n          resultAndNumberOfElements.numberOfElements++;\n        }\n      }\n    }\n  } label Done {\n    const shrunk = ShrinkOrderedHashSetIfNeeded(\n        resultAndNumberOfElements.numberOfElements,\n        resultAndNumberOfElements.setData);\n    return new JSSet{\n      map: *NativeContextSlot(ContextSlot::JS_SET_MAP_INDEX),\n      properties_or_hash: kEmptyFixedArray,\n      elements: kEmptyFixedArray,\n      table: shrunk\n    };\n  }\n  unreachable;\n}\n\n// This macro gets the nextValue in other table and normalize it. If the\n// nextValue exists in the receiver table, it will be removed. Otherwise\n// it will be added to the resultSetData.\nstruct OrderedHashSetAndNumberOfElements {\n  setData: OrderedHashSet;\n  numberOfElements: Smi;\n}\n\nmacro FastSymmetricDifference(\n    implicit context: Context)(nextValue: JSAny,\n    table: StableJSSetBackingTableWitness,\n    resultSetDataAndNumberOfElements: OrderedHashSetAndNumberOfElements,\n    methodName: constexpr string): OrderedHashSetAndNumberOfElements {\n  let key = nextValue;\n  let resultSetData = resultSetDataAndNumberOfElements.setData;\n  let numberOfElements = resultSetDataAndNumberOfElements.numberOfElements;\n\n  // ii. If nextValue is -0\ud835\udd3d, set nextValue to +0\ud835\udd3d.\n  key = collections::NormalizeNumberKey(key);\n\n  // iii. Let inResult be SetDataHas(resultSetData, nextValue).\n  const inResult = TableHasKey(resultSetData, key);\n\n  // iv. If SetDataHas(O.[[SetData]], nextValue) is true, then\n  dcheck(inResult == table.HasKey(key));\n  //  1. If inResult is true, remove nextValue from resultSetData.\n  if (inResult) {\n    numberOfElements = DeleteFromSetTable(resultSetData, key)\n        otherwise unreachable;\n  } else {\n    // v. Else,\n    //  1. If inResult is false, append nextValue to resultSetData.\n    resultSetData = AddToSetTable(resultSetData, key, methodName);\n    numberOfElements++;\n  }\n  return OrderedHashSetAndNumberOfElements{\n    setData: resultSetData,\n    numberOfElements: numberOfElements\n  };\n}\n}",
  "context": [
    "collections_set_union_tq",
    "collections_set_intersection_tq",
    "collections_set_difference_tq"
  ],
  "explanation": "Captures full Torque implementation for Set.prototype.symmetricDifference including FastSymmetricDifference macro and iterator loops over various collection types, plus NormalizeNumberKey handling and ShrinkOrderedHashSetIfNeeded.",
  "file_line": "builtins/set-symmetric-difference.tq:1-400"
}