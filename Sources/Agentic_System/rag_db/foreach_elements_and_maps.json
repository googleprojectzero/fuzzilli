{
  "body": "Elements kinds, map checks, and feedback-based specialization for Array.prototype.forEach in Maglev:\n\n- Elements kind selection and map gating: TryReduceArrayForEach fetches PossibleMaps for the receiver from KnownNodeAspects and calls CanInlineArrayIteratingBuiltin(broker, possible_maps, &elements_kind). This helper iterates over all maps ensuring supports_fast_array_iteration(map) is true and UnionElementsKindUptoSize combines them into a unified elements kind. If any map fails, lowering aborts.\n- Protector: It requires broker()->dependencies()->DependOnNoElementsProtector() to ensure that elements non-fast-path conditions aren\u2019t invalidated. For HOLEY kinds, this is especially relevant.\n- Map stability: It remembers whether receiver maps were unstable before the loop and stores receiver_maps_before_loop. After invoking the callback, if maps were unstable, it re-checks the maps against the saved set. It emits either CheckMapsWithMigration or CheckMaps depending on whether any map is a migration target, inside an eager deopt scope.\n- Elements operations: BuildLoadElements(receiver) loads elements array. Then element load uses BuildLoadFixedDoubleArrayElement for double kinds and BuildLoadFixedArrayElement for tagged kinds. It uses the elements_kind variable to choose the path and hole checks to conditionally skip callback.\n- Bounds checks: BranchIfInt32Compare on index vs original_length_int32, and after callback, CheckInt32Condition with AssertCondition::kUnsignedLessThanEqual vs current_length for length-change guard.\n- Related Element access helpers in the builder (outside forEach code) provide concrete examples of elements-kind dependent loads/stores and checks, e.g., TryBuildElementLoadOnJSArrayOrJSObject and TryBuildElementStoreOnJSArrayOrJSObject contain checks such as CanTreatHoleAsUndefined, CheckTypedArrayBounds, MaybeGrowFastElements, EnsureWritableFastElements, and emit LoadFixed[Double]ArrayElement/StoreFixed[Double]ArrayElement nodes. Although not directly in forEach, they show the same building blocks used for specialized array element access within Maglev.\n",
  "context": [
    "maglev_array_foreach",
    "foreach_builder_entrypoints",
    "foreach_representation_and_bounds"
  ],
  "explanation": "Details the elements kind and map specialization logic for forEach lowering in Maglev and how it reuses builder helpers for elements loads, with explicit map rechecks after callbacks for unstable maps.",
  "file_line": "maglev/maglev-graph-builder.cc:8037-8061 (CanInlineArrayIteratingBuiltin); 8179-8198, 8258-8274 (map recheck); 8077-8098, 8121-8152 (protector, callback type), 8219-8257 (element load, hole checks)"
}