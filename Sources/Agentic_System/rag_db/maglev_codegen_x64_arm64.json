{
  "body": "x64 codegen for nodes (maglev/x64/maglev-ir-x64.cc):\n- LoadTypedArrayLength::GenerateCode: Asserts JS_TYPED_ARRAY_TYPE; __ LoadBoundedSizeFromObject(result, object, JSTypedArray::kRawByteLengthOffset); shift by ElementsKindToShiftSize(elements_kind_).\n- CheckedObjectToIndex::MaxCallStackArgs returns 1 via Architecture specific (line ~120). Other TA-specific codegen happens in common maglev-ir.cc.\n\narm64 codegen (maglev/arm64/maglev-ir-arm64.cc):\n- LoadTypedArrayLength::GenerateCode: AssertObjectType JS_TYPED_ARRAY_TYPE, LoadBoundedSizeFromObject, then Lsr by shift size.\n- Many conversions identical semantically.\n\nCommon arch-agnostic codegen (maglev/maglev-ir.cc):\n- CheckTypedArrayBounds::GenerateCode: AssertZeroExtended(index), CompareIntPtrAndJumpIf(index, length, kUnsignedGreaterThanEqual, deopt). RISC-V path zero extends.\n- StoreIntTypedArrayElement / StoreDoubleTypedArrayElement: DEF_STORE_TYPED_ARRAY(...) dispatch in maglev-ir.cc at 6800ff (implementation writing to typed array based on ElementsKind and value type).\n- Uint8Clamped conversions: Int32/Uint32/Float64 variants use ToUint8Clamped and set min/max labels, as seen at 5567+, 5601 call __ ToUint8Clamped.\n\nRegister width decisions:\n- LoadTypedArrayLength result is IntPtr-sized register (size_t), index in bounds check is zero-extended Uint32; code asserts zero-extended on non-x64 as needed.\n- Address calculations: Data pointer and element addressing are in DEF_STORE_TYPED_ARRAY expansion; common pattern uses base pointer + scaled index by ElementsKindToShiftSize.\n\nBounds compare signed/unsigned:\n- Bounds is unsigned (kUnsignedGreaterThanEqual) compare of zero-extended index vs IntPtr length.\n\nCPU feature for UInt8Clamped rounding:\n- Graph builder checks IsSupported(CpuOperation::kFloat64Round) for UINT8_CLAMPED_ELEMENTS store.\n",
  "context": [
    "maglev_ir_nodes",
    "graph_builder_typedarray_paths"
  ],
  "explanation": "This record captures the architecture-specific details for x64 and arm64 codegen for TypedArray length loading and bounds checking, along with general codegen behaviors for store nodes and conversion, including unsigned compare and element addressing scale shifts.",
  "file_line": "maglev/x64/maglev-ir-x64.cc:69-90; maglev/arm64/maglev-ir-arm64.cc:627-650; maglev/maglev-ir.cc:3476-3484,5567-5734,6800ff"
}