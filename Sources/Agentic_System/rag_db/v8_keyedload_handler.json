{
  "body": "IC control and handler selection for KeyedLoadIC in ic/ic.cc:\n- KeyedLoadIC::Load: Attempts RuntimeLoad(object, key) to get value and is_found; then decides feedback and updates with UpdateLoadElement(receiver, new_load_mode) based on GetNewKeyedLoadMode (derived from OOB/hole outcomes and NoElements protector) and current state.\n- KeyedLoadIC::UpdateLoadElement(HeapObject receiver, KeyedAccessLoadMode new_mode):\n  \u2022 Computes receiver_map and target maps from feedback. For empty target_maps, install monomorphic handler = LoadElementHandler(receiver_map, new_mode) then ConfigureVectorState.\n  \u2022 If monomorphic and receiver transitioned to more general ElementsKind vs previous, keep monomorphic with new map and handler.\n  \u2022 Otherwise build polymorphic: collect maps (AddOneReceiverMapIfMissing), ensure AllowedHandlerChange(old_mode,new_mode) and not exceeding max_valid_polymorphic_map_count; then build handlers via LoadElementPolymorphicHandlers(receiver_maps,&handlers, GeneralizeKeyedAccessLoadMode(old_mode,new_mode)), which updates each handler\u2019s per-map load mode with GetUpdatedLoadModeForMap; finally ConfigureVectorState monomorphic/polymorphic accordingly.\n- LoadElementHandler(Map, mode): chooses builtin/handler by map\u2019s ElementsKind and instance_type and whether proxy/string/interceptor:\n  \u2022 If map has indexed interceptor with non-masking getter/query, return Load(Has)IndexedInterceptor builtins.\n  \u2022 Strings -> LoadHandler::LoadIndexedString (or slow for Has).\n  \u2022 JSProxy -> LoadProxy handler.\n  \u2022 Dictionary elements -> LoadHandler::LoadElement(kind=is_dictionary, is_js_array, mode).\n  \u2022 Fast/sealed/nonextensible or TypedArray/RAB-GSAB kinds -> LoadHandler::LoadElement(kind, is_js_array, mode). Preconditions assert that hole handling is only if allowed by elements kind and NoElements protector.\n- Generalization of hole/OOB policy:\n  \u2022 GetNewKeyedLoadMode determines kInBounds, kHandleHoles, kHandleOOB, or kHandleOOBAndHoles by checking AllowConvertHoleElementToUndefined (NoElements protector and prototype constraints) and whether actual access was found vs OOB/hole.\n  \u2022 GetUpdatedLoadModeForMap enforces that later handlers still match permission policy given current map (NoElements protector and elements kind). AllowedHandlerChange ensures only widening to allow holes or OOB is accepted.\n- ElementsKind transitions and stability:\n  \u2022 LoadElementPolymorphicHandlers filters deprecated maps and marks stable maps with elements kind transitions among candidate maps as unstable via NotifyLeafMapLayoutChange; builds per-map handlers using LoadElementHandler(receiver_map, GetUpdatedLoadModeForMap(...)).\n- State transitions and megamorphic fallback:\n  \u2022 SetCache and ConfigureVectorState transitions between UNINITIALIZED, MONOMORPHIC, POLYMORPHIC, MEGAMORPHIC with CopyICToMegamorphicCache when needed; handles MegaDOM separately.\n",
  "context": [
    "v8_keyedload_ic_entrypoints",
    "v8_accessor_assembler_element_load",
    "v8_elements_kind_lattice",
    "v8_keyed_load_ic_state"
  ],
  "explanation": "This records where IC.cc controls KeyedLoadIC feedback, handler selection, and state transitions, including how elements kind and OOB/hole policies are computed and how polymorphic handlers are built.",
  "file_line": "ic/ic.cc:1168-1328,1443-1535,1206-1248"
}