{
  "body": "// ThrowIfNotCallable node definition and codegen\n// src/maglev/maglev-ir.h\nclass ThrowIfNotCallable : public FixedInputNodeT<1, ThrowIfNotCallable> {\n public:\n  static constexpr OpProperties kProperties = OpProperties::CanThrow() | OpProperties::DeferredCall();\n  Input& value() { return Node::input(0); }\n  int MaxCallStackArgs() const;\n  void SetValueLocationConstraints();\n  void GenerateCode(MaglevAssembler*, const ProcessingState&);\n};\n\n// src/maglev/maglev-ir.cc (codegen)\nint ThrowIfNotCallable::MaxCallStackArgs() const { return 1; }\nvoid ThrowIfNotCallable::SetValueLocationConstraints() {\n  UseRegister(value());\n  set_temporaries_needed(1);\n}\nvoid ThrowIfNotCallable::GenerateCode(MaglevAssembler* masm,\n                                      const ProcessingState& state) {\n  Label* if_not_callable = __ MakeDeferredCode(\n      [](MaglevAssembler* masm, ThrowIfNotCallable* node) {\n        __ Push(node->value());\n        __ Move(kContextRegister, masm->native_context().object());\n        __ CallRuntime(Runtime::kThrowCalledNonCallable, 1);\n        masm->DefineExceptionHandlerAndLazyDeoptPoint(node);\n        __ Abort(AbortReason::kUnexpectedReturnFromThrow);\n      },\n      this);\n  Register value_reg = ToRegister(value());\n  MaglevAssembler::TemporaryRegisterScope temps(masm);\n  Register scratch = temps.Acquire();\n  __ JumpIfNotCallable(value_reg, scratch, CheckType::kCheckHeapObject,\n                       if_not_callable);\n}\n\n// Maglev graph builder uses ThrowIfNotCallable within a lazy deopt scope for Array.prototype.forEach\n// src/maglev/maglev-graph-builder.cc\n// EnsureType(callback, NodeType::kCallable, [&](NodeType old_type) {\n//   DeoptFrameScope lazy_deopt_scope(\n//     this, Builtin::kArrayForEachLoopLazyDeoptContinuation, target,\n//     base::VectorOf<ValueNode*>({receiver, callback, this_arg,\n//                                 GetSmiConstant(0), original_length}));\n//   AddNewNode<ThrowIfNotCallable>({callback});\n// });",
  "context": [
    "maglev_foreach_tryreduce",
    "maglev_foreach_deopt"
  ],
  "explanation": "Defines the ThrowIfNotCallable IR node with codegen that emits a runtime throw when the input is not callable. In MaglevGraphBuilder::TryReduceArrayForEach, the callback argument is validated by creating a ThrowIfNotCallable under a lazy deopt continuation so that exceptions get the proper JavaScript stack. This integrates with Maglev\u2019s exception/lazy deopt handling for the forEach loop lowering.",
  "file_line": "maglev/maglev-ir.h:9739-9754; maglev/maglev-ir.cc:5424-5440; maglev/maglev-graph-builder.cc:8127-8135"
}