{
  "body": "// builtins/set-intersection.tq - Torque builtin for Set.prototype.intersection\n// (file content captured from repo)\nnamespace collections {\n\n// https://tc39.es/proposal-set-methods/#sec-set.prototype.intersection\n@incrementUseCounter('v8::Isolate::kSetMethods')\ntransitioning javascript builtin SetPrototypeIntersection(\n    js-implicit context: NativeContext, receiver: JSAny)(other: JSAny): JSSet {\n  const methodName: constexpr string = 'Set.prototype.intersection';\n  const fastIteratorResultMap = GetIteratorResultMap();\n\n  // 1. Let O be the this value.\n  // 2. Perform ? RequireInternalSlot(O, [[SetData]]).\n  const o = Cast<JSSet>(receiver) otherwise\n  ThrowTypeError(\n      MessageTemplate::kIncompatibleMethodReceiver, methodName, receiver);\n\n  // 3. Let otherRec be ? GetSetRecord(other).\n  let otherRec = GetSetRecord(other, methodName);\n\n  let table = NewStableBackingTableWitness(o);\n\n  // 4. Let resultSetData be a new empty List.\n  let resultSetData = AllocateOrderedHashSet();\n\n  // 5. Let thisSize be the number of elements in O.[[SetData]].\n  const thisSize = table.LoadSize();\n\n  try {\n    typeswitch (other) {\n      case (otherSet: JSSetWithNoCustomIteration): {\n        CheckSetRecordHasJSSetMethods(otherRec) otherwise SlowPath;\n\n        const otherTable = NewStableBackingTableWitness(otherSet);\n\n        const otherSize = otherTable.LoadSize();\n\n        if (thisSize <= otherSize) {\n          resultSetData = FastIntersect<StableJSSetBackingTableWitness>(\n              table, otherTable, methodName, resultSetData);\n          goto Done;\n\n        } else {\n          resultSetData = FastIntersect<StableJSSetBackingTableWitness>(\n              otherTable, table, methodName, resultSetData);\n          goto Done;\n        }\n      }\n      case (otherMap: JSMapWithNoCustomIteration): {\n        CheckSetRecordHasJSMapMethods(otherRec) otherwise SlowPath;\n\n        const otherTable = NewStableBackingTableWitness(otherMap);\n\n        const otherSize = otherTable.LoadSize();\n\n        if (thisSize <= otherSize) {\n          resultSetData = FastIntersect<StableJSMapBackingTableWitness>(\n              table, otherTable, methodName, resultSetData);\n          goto Done;\n\n        } else {\n          // TODO(13556): Change `FastIntersect` macro to be able to handle\n          // this case as well.\n          let otherIterator = collections::NewUnmodifiedOrderedHashMapIterator(\n              otherTable.GetTable());\n\n          while (true) {\n            const nextValue = otherIterator.Next() otherwise Done;\n\n            if (table.HasKey(nextValue.key)) {\n              resultSetData =\n                  AddToSetTable(resultSetData, nextValue.key, methodName);\n            }\n          }\n        }\n      }\n      case (JSAny): {\n        goto SlowPath;\n      }\n    }\n  } label SlowPath {\n    // 6. If thisSize \u2264 otherRec.[[Size]], then\n    if (Convert<Number>(thisSize) <= otherRec.size) {\n      // a. Let index be 0.\n      let thisIter = collections::NewOrderedHashSetIterator(table.GetTable());\n\n      // b. Repeat, while index < thisSize,\n      while (true) {\n        // i. Let e be O.[[SetData]][index].\n        const key = thisIter.Next() otherwise Done;\n\n        // ii. Set index to index + 1.\n        // iii. If e is not empty, then\n        //   1. Let inOther be ToBoolean(? Call(otherRec.[[Has]],\n        // otherRec.[[Set]], \u00ab e \u00bb)).\n        const inOther =\n            ToBoolean(Call(context, otherRec.has, otherRec.object, key));\n\n        //   2. If inOther is true, then\n        if (inOther) {\n          //  a. NOTE: It is possible for earlier calls to otherRec.[[Has]] to\n          // remove and re-add an element of O.[[SetData]], which can cause the\n          // same element to be visited twice during this iteration.\n          // We used `OrderedHashSetIterator` that works when underlying table\n          // is changed.\n          //  b. Let alreadyInResult be SetDataHas(resultSetData, e).\n          //  c. If alreadyInResult is false, then\n          //    i. Append e to resultSetData.\n          resultSetData = AddToSetTable(resultSetData, key, methodName);\n        }\n\n        // 3. NOTE: The number of elements in O.[[SetData]] may have increased\n        // during execution of otherRec.[[Has]].\n        // 4. Set thisSize to the number of elements of O.[[SetData]].\n        // We used iterator so we do not need to update thisSize and index.\n      }\n    } else {\n      // a. Let keysIter be ? GetKeysIterator(otherRec).\n      let keysIter =\n          GetKeysIterator(otherRec.object, UnsafeCast<Callable>(otherRec.keys));\n\n      // b. Let next be true.\n      let nextRecord: JSReceiver;\n\n      // c. Repeat, while next is not false,\n      while (true) {\n        // i. Set next to ? IteratorStep(keysIter).\n        nextRecord = iterator::IteratorStep(keysIter, fastIteratorResultMap)\n            otherwise Done;\n\n        // ii. If next is not false, then\n        // 1. Let nextValue be ? IteratorValue(next).\n        const nextValue =\n            iterator::IteratorValue(nextRecord, fastIteratorResultMap);\n\n        // 2. If nextValue is -0\ud835\udd3d, set nextValue to +0\ud835\udd3d.\n        // 3. NOTE: Because other is an arbitrary object, it is possible for its\n        // \"keys\" iterator to produce the same value more than once.\n        // 4. Let alreadyInResult be SetDataHas(resultSetData, nextValue).\n        // 5. Let inThis be SetDataHas(O.[[SetData]], nextValue).\n\n        table.ReloadTable();\n        if (table.HasKey(nextValue)) {\n          // 6. If alreadyInResult is false and inThis is true, then\n          // a. Append nextValue to resultSetData.\n          resultSetData = AddToSetTable(resultSetData, nextValue, methodName);\n        }\n      }\n    }\n  } label Done {\n    return new JSSet{\n      map: *NativeContextSlot(ContextSlot::JS_SET_MAP_INDEX),\n      properties_or_hash: kEmptyFixedArray,\n      elements: kEmptyFixedArray,\n      table: resultSetData\n    };\n  }\n  unreachable;\n}\n\n// This macro creates an iterator from a collection that need to be iterated\n// (collectionToIterate), lookup each value of the iterator in a table that\n// needs to be checked (tableToLookup), and adds the value to the result\n// (resultSetData) if it exists in the table.\nmacro FastIntersect<T: type>(\n    implicit context: Context)(\n    collectionToIterate: StableJSSetBackingTableWitness, tableToLookup: T,\n    methodName: String, resultSetData: OrderedHashSet): OrderedHashSet {\n  let result = resultSetData;\n\n  let iter = collections::NewUnmodifiedOrderedHashSetIterator(\n      collectionToIterate.GetTable());\n  try {\n    while (true) {\n      const nextValue = iter.Next() otherwise Done;\n\n      if (tableToLookup.HasKey(nextValue)) {\n        result = AddToSetTable(result, nextValue, methodName);\n      }\n    }\n  } label Done {\n    return result;\n  }\n  unreachable;\n}\n}",
  "context": [
    "collections_set_union_tq",
    "collections_set_difference_tq",
    "collections_set_symmetric_difference_tq"
  ],
  "explanation": "Captures full Torque implementation for Set.prototype.intersection in builtins/set-intersection.tq including FastIntersect macro, iterator usage, fast-paths and slow-paths, OrderedHashSet allocation and AddToSetTable usage.",
  "file_line": "builtins/set-intersection.tq:1-300"
}