// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: ast.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2023 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public enum Compiler_Protobuf_VariableDeclarationKind: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case `var` // = 0
  case `let` // = 1
  case const // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .var
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .var
    case 1: self = .let
    case 2: self = .const
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .var: return 0
    case .let: return 1
    case .const: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Compiler_Protobuf_VariableDeclarationKind: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Compiler_Protobuf_VariableDeclarationKind] = [
    .var,
    .let,
    .const,
  ]
}

#endif  // swift(>=4.2)

public enum Compiler_Protobuf_FunctionType: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case plain // = 0
  case generator // = 1
  case async // = 2
  case asyncGenerator // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .plain
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .plain
    case 1: self = .generator
    case 2: self = .async
    case 3: self = .asyncGenerator
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .plain: return 0
    case .generator: return 1
    case .async: return 2
    case .asyncGenerator: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Compiler_Protobuf_FunctionType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Compiler_Protobuf_FunctionType] = [
    .plain,
    .generator,
    .async,
    .asyncGenerator,
  ]
}

#endif  // swift(>=4.2)

public struct Compiler_Protobuf_AST {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var statements: [Compiler_Protobuf_Statement] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A parameter in a function declaration. Not an expression on its own.
public struct Compiler_Protobuf_Parameter {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Compiler_Protobuf_EmptyStatement {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Compiler_Protobuf_BlockStatement {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var body: [Compiler_Protobuf_Statement] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Compiler_Protobuf_VariableDeclarator {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  /// The value is optional
  public var value: Compiler_Protobuf_Expression {
    get {return _storage._value ?? Compiler_Protobuf_Expression()}
    set {_uniqueStorage()._value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  public var hasValue: Bool {return _storage._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  public mutating func clearValue() {_uniqueStorage()._value = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Compiler_Protobuf_VariableDeclaration {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var kind: Compiler_Protobuf_VariableDeclarationKind = .var

  public var declarations: [Compiler_Protobuf_VariableDeclarator] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Compiler_Protobuf_FunctionDeclaration {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var name: String = String()

  public var type: Compiler_Protobuf_FunctionType = .plain

  public var parameters: [Compiler_Protobuf_Parameter] = []

  public var body: [Compiler_Protobuf_Statement] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Compiler_Protobuf_ClassProperty {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var key: Compiler_Protobuf_ClassProperty.OneOf_Key? = nil

  /// A "regular" property.
  public var name: String {
    get {
      if case .name(let v)? = key {return v}
      return String()
    }
    set {key = .name(newValue)}
  }

  /// An element.
  public var index: Int64 {
    get {
      if case .index(let v)? = key {return v}
      return 0
    }
    set {key = .index(newValue)}
  }

  /// A computed property.
  public var expression: Compiler_Protobuf_Expression {
    get {
      if case .expression(let v)? = key {return v}
      return Compiler_Protobuf_Expression()
    }
    set {key = .expression(newValue)}
  }

  public var isStatic: Bool = false

  /// The value is optional
  public var value: Compiler_Protobuf_Expression {
    get {return _value ?? Compiler_Protobuf_Expression()}
    set {_value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  public var hasValue: Bool {return self._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  public mutating func clearValue() {self._value = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Key: Equatable {
    /// A "regular" property.
    case name(String)
    /// An element.
    case index(Int64)
    /// A computed property.
    case expression(Compiler_Protobuf_Expression)

  #if !swift(>=4.1)
    public static func ==(lhs: Compiler_Protobuf_ClassProperty.OneOf_Key, rhs: Compiler_Protobuf_ClassProperty.OneOf_Key) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.name, .name): return {
        guard case .name(let l) = lhs, case .name(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.index, .index): return {
        guard case .index(let l) = lhs, case .index(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.expression, .expression): return {
        guard case .expression(let l) = lhs, case .expression(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _value: Compiler_Protobuf_Expression? = nil
}

public struct Compiler_Protobuf_ClassConstructor {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var parameters: [Compiler_Protobuf_Parameter] = []

  public var body: [Compiler_Protobuf_Statement] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Compiler_Protobuf_ClassMethod {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var name: String = String()

  public var isStatic: Bool = false

  public var parameters: [Compiler_Protobuf_Parameter] = []

  public var body: [Compiler_Protobuf_Statement] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Compiler_Protobuf_ClassGetter {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var name: String = String()

  public var isStatic: Bool = false

  public var body: [Compiler_Protobuf_Statement] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Compiler_Protobuf_ClassSetter {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var name: String = String()

  public var isStatic: Bool = false

  public var parameter: Compiler_Protobuf_Parameter {
    get {return _parameter ?? Compiler_Protobuf_Parameter()}
    set {_parameter = newValue}
  }
  /// Returns true if `parameter` has been explicitly set.
  public var hasParameter: Bool {return self._parameter != nil}
  /// Clears the value of `parameter`. Subsequent reads from it will return its default value.
  public mutating func clearParameter() {self._parameter = nil}

  public var body: [Compiler_Protobuf_Statement] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _parameter: Compiler_Protobuf_Parameter? = nil
}

public struct Compiler_Protobuf_ClassStaticInitializer {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var body: [Compiler_Protobuf_Statement] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Compiler_Protobuf_ClassField {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var field: Compiler_Protobuf_ClassField.OneOf_Field? = nil

  public var property: Compiler_Protobuf_ClassProperty {
    get {
      if case .property(let v)? = field {return v}
      return Compiler_Protobuf_ClassProperty()
    }
    set {field = .property(newValue)}
  }

  public var ctor: Compiler_Protobuf_ClassConstructor {
    get {
      if case .ctor(let v)? = field {return v}
      return Compiler_Protobuf_ClassConstructor()
    }
    set {field = .ctor(newValue)}
  }

  public var method: Compiler_Protobuf_ClassMethod {
    get {
      if case .method(let v)? = field {return v}
      return Compiler_Protobuf_ClassMethod()
    }
    set {field = .method(newValue)}
  }

  public var getter: Compiler_Protobuf_ClassGetter {
    get {
      if case .getter(let v)? = field {return v}
      return Compiler_Protobuf_ClassGetter()
    }
    set {field = .getter(newValue)}
  }

  public var setter: Compiler_Protobuf_ClassSetter {
    get {
      if case .setter(let v)? = field {return v}
      return Compiler_Protobuf_ClassSetter()
    }
    set {field = .setter(newValue)}
  }

  public var staticInitializer: Compiler_Protobuf_ClassStaticInitializer {
    get {
      if case .staticInitializer(let v)? = field {return v}
      return Compiler_Protobuf_ClassStaticInitializer()
    }
    set {field = .staticInitializer(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Field: Equatable {
    case property(Compiler_Protobuf_ClassProperty)
    case ctor(Compiler_Protobuf_ClassConstructor)
    case method(Compiler_Protobuf_ClassMethod)
    case getter(Compiler_Protobuf_ClassGetter)
    case setter(Compiler_Protobuf_ClassSetter)
    case staticInitializer(Compiler_Protobuf_ClassStaticInitializer)

  #if !swift(>=4.1)
    public static func ==(lhs: Compiler_Protobuf_ClassField.OneOf_Field, rhs: Compiler_Protobuf_ClassField.OneOf_Field) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.property, .property): return {
        guard case .property(let l) = lhs, case .property(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.ctor, .ctor): return {
        guard case .ctor(let l) = lhs, case .ctor(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.method, .method): return {
        guard case .method(let l) = lhs, case .method(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.getter, .getter): return {
        guard case .getter(let l) = lhs, case .getter(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.setter, .setter): return {
        guard case .setter(let l) = lhs, case .setter(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.staticInitializer, .staticInitializer): return {
        guard case .staticInitializer(let l) = lhs, case .staticInitializer(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

public struct Compiler_Protobuf_ClassDeclaration {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  /// The superclass is optional
  public var superClass: Compiler_Protobuf_Expression {
    get {return _storage._superClass ?? Compiler_Protobuf_Expression()}
    set {_uniqueStorage()._superClass = newValue}
  }
  /// Returns true if `superClass` has been explicitly set.
  public var hasSuperClass: Bool {return _storage._superClass != nil}
  /// Clears the value of `superClass`. Subsequent reads from it will return its default value.
  public mutating func clearSuperClass() {_uniqueStorage()._superClass = nil}

  public var fields: [Compiler_Protobuf_ClassField] {
    get {return _storage._fields}
    set {_uniqueStorage()._fields = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Compiler_Protobuf_ReturnStatement {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The argument is optional
  public var argument: Compiler_Protobuf_Expression {
    get {return _storage._argument ?? Compiler_Protobuf_Expression()}
    set {_uniqueStorage()._argument = newValue}
  }
  /// Returns true if `argument` has been explicitly set.
  public var hasArgument: Bool {return _storage._argument != nil}
  /// Clears the value of `argument`. Subsequent reads from it will return its default value.
  public mutating func clearArgument() {_uniqueStorage()._argument = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Compiler_Protobuf_ExpressionStatement {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var expression: Compiler_Protobuf_Expression {
    get {return _storage._expression ?? Compiler_Protobuf_Expression()}
    set {_uniqueStorage()._expression = newValue}
  }
  /// Returns true if `expression` has been explicitly set.
  public var hasExpression: Bool {return _storage._expression != nil}
  /// Clears the value of `expression`. Subsequent reads from it will return its default value.
  public mutating func clearExpression() {_uniqueStorage()._expression = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Compiler_Protobuf_IfStatement {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var test: Compiler_Protobuf_Expression {
    get {return _storage._test ?? Compiler_Protobuf_Expression()}
    set {_uniqueStorage()._test = newValue}
  }
  /// Returns true if `test` has been explicitly set.
  public var hasTest: Bool {return _storage._test != nil}
  /// Clears the value of `test`. Subsequent reads from it will return its default value.
  public mutating func clearTest() {_uniqueStorage()._test = nil}

  public var ifBody: Compiler_Protobuf_Statement {
    get {return _storage._ifBody ?? Compiler_Protobuf_Statement()}
    set {_uniqueStorage()._ifBody = newValue}
  }
  /// Returns true if `ifBody` has been explicitly set.
  public var hasIfBody: Bool {return _storage._ifBody != nil}
  /// Clears the value of `ifBody`. Subsequent reads from it will return its default value.
  public mutating func clearIfBody() {_uniqueStorage()._ifBody = nil}

  /// The else body is optional
  public var elseBody: Compiler_Protobuf_Statement {
    get {return _storage._elseBody ?? Compiler_Protobuf_Statement()}
    set {_uniqueStorage()._elseBody = newValue}
  }
  /// Returns true if `elseBody` has been explicitly set.
  public var hasElseBody: Bool {return _storage._elseBody != nil}
  /// Clears the value of `elseBody`. Subsequent reads from it will return its default value.
  public mutating func clearElseBody() {_uniqueStorage()._elseBody = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Compiler_Protobuf_WhileLoop {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var test: Compiler_Protobuf_Expression {
    get {return _storage._test ?? Compiler_Protobuf_Expression()}
    set {_uniqueStorage()._test = newValue}
  }
  /// Returns true if `test` has been explicitly set.
  public var hasTest: Bool {return _storage._test != nil}
  /// Clears the value of `test`. Subsequent reads from it will return its default value.
  public mutating func clearTest() {_uniqueStorage()._test = nil}

  public var body: Compiler_Protobuf_Statement {
    get {return _storage._body ?? Compiler_Protobuf_Statement()}
    set {_uniqueStorage()._body = newValue}
  }
  /// Returns true if `body` has been explicitly set.
  public var hasBody: Bool {return _storage._body != nil}
  /// Clears the value of `body`. Subsequent reads from it will return its default value.
  public mutating func clearBody() {_uniqueStorage()._body = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Compiler_Protobuf_DoWhileLoop {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var test: Compiler_Protobuf_Expression {
    get {return _storage._test ?? Compiler_Protobuf_Expression()}
    set {_uniqueStorage()._test = newValue}
  }
  /// Returns true if `test` has been explicitly set.
  public var hasTest: Bool {return _storage._test != nil}
  /// Clears the value of `test`. Subsequent reads from it will return its default value.
  public mutating func clearTest() {_uniqueStorage()._test = nil}

  public var body: Compiler_Protobuf_Statement {
    get {return _storage._body ?? Compiler_Protobuf_Statement()}
    set {_uniqueStorage()._body = newValue}
  }
  /// Returns true if `body` has been explicitly set.
  public var hasBody: Bool {return _storage._body != nil}
  /// Clears the value of `body`. Subsequent reads from it will return its default value.
  public mutating func clearBody() {_uniqueStorage()._body = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Compiler_Protobuf_ForLoop {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// This field is optional
  public var initializer: OneOf_Initializer? {
    get {return _storage._initializer}
    set {_uniqueStorage()._initializer = newValue}
  }

  public var declaration: Compiler_Protobuf_VariableDeclaration {
    get {
      if case .declaration(let v)? = _storage._initializer {return v}
      return Compiler_Protobuf_VariableDeclaration()
    }
    set {_uniqueStorage()._initializer = .declaration(newValue)}
  }

  public var expression: Compiler_Protobuf_Expression {
    get {
      if case .expression(let v)? = _storage._initializer {return v}
      return Compiler_Protobuf_Expression()
    }
    set {_uniqueStorage()._initializer = .expression(newValue)}
  }

  /// This field is optional
  public var condition: Compiler_Protobuf_Expression {
    get {return _storage._condition ?? Compiler_Protobuf_Expression()}
    set {_uniqueStorage()._condition = newValue}
  }
  /// Returns true if `condition` has been explicitly set.
  public var hasCondition: Bool {return _storage._condition != nil}
  /// Clears the value of `condition`. Subsequent reads from it will return its default value.
  public mutating func clearCondition() {_uniqueStorage()._condition = nil}

  /// This field is optional
  public var afterthought: Compiler_Protobuf_Expression {
    get {return _storage._afterthought ?? Compiler_Protobuf_Expression()}
    set {_uniqueStorage()._afterthought = newValue}
  }
  /// Returns true if `afterthought` has been explicitly set.
  public var hasAfterthought: Bool {return _storage._afterthought != nil}
  /// Clears the value of `afterthought`. Subsequent reads from it will return its default value.
  public mutating func clearAfterthought() {_uniqueStorage()._afterthought = nil}

  public var body: Compiler_Protobuf_Statement {
    get {return _storage._body ?? Compiler_Protobuf_Statement()}
    set {_uniqueStorage()._body = newValue}
  }
  /// Returns true if `body` has been explicitly set.
  public var hasBody: Bool {return _storage._body != nil}
  /// Clears the value of `body`. Subsequent reads from it will return its default value.
  public mutating func clearBody() {_uniqueStorage()._body = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// This field is optional
  public enum OneOf_Initializer: Equatable {
    case declaration(Compiler_Protobuf_VariableDeclaration)
    case expression(Compiler_Protobuf_Expression)

  #if !swift(>=4.1)
    public static func ==(lhs: Compiler_Protobuf_ForLoop.OneOf_Initializer, rhs: Compiler_Protobuf_ForLoop.OneOf_Initializer) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.declaration, .declaration): return {
        guard case .declaration(let l) = lhs, case .declaration(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.expression, .expression): return {
        guard case .expression(let l) = lhs, case .expression(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Compiler_Protobuf_ForInLoop {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var left: Compiler_Protobuf_VariableDeclarator {
    get {return _storage._left ?? Compiler_Protobuf_VariableDeclarator()}
    set {_uniqueStorage()._left = newValue}
  }
  /// Returns true if `left` has been explicitly set.
  public var hasLeft: Bool {return _storage._left != nil}
  /// Clears the value of `left`. Subsequent reads from it will return its default value.
  public mutating func clearLeft() {_uniqueStorage()._left = nil}

  public var right: Compiler_Protobuf_Expression {
    get {return _storage._right ?? Compiler_Protobuf_Expression()}
    set {_uniqueStorage()._right = newValue}
  }
  /// Returns true if `right` has been explicitly set.
  public var hasRight: Bool {return _storage._right != nil}
  /// Clears the value of `right`. Subsequent reads from it will return its default value.
  public mutating func clearRight() {_uniqueStorage()._right = nil}

  public var body: Compiler_Protobuf_Statement {
    get {return _storage._body ?? Compiler_Protobuf_Statement()}
    set {_uniqueStorage()._body = newValue}
  }
  /// Returns true if `body` has been explicitly set.
  public var hasBody: Bool {return _storage._body != nil}
  /// Clears the value of `body`. Subsequent reads from it will return its default value.
  public mutating func clearBody() {_uniqueStorage()._body = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Compiler_Protobuf_ForOfLoop {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var left: Compiler_Protobuf_VariableDeclarator {
    get {return _storage._left ?? Compiler_Protobuf_VariableDeclarator()}
    set {_uniqueStorage()._left = newValue}
  }
  /// Returns true if `left` has been explicitly set.
  public var hasLeft: Bool {return _storage._left != nil}
  /// Clears the value of `left`. Subsequent reads from it will return its default value.
  public mutating func clearLeft() {_uniqueStorage()._left = nil}

  public var right: Compiler_Protobuf_Expression {
    get {return _storage._right ?? Compiler_Protobuf_Expression()}
    set {_uniqueStorage()._right = newValue}
  }
  /// Returns true if `right` has been explicitly set.
  public var hasRight: Bool {return _storage._right != nil}
  /// Clears the value of `right`. Subsequent reads from it will return its default value.
  public mutating func clearRight() {_uniqueStorage()._right = nil}

  public var body: Compiler_Protobuf_Statement {
    get {return _storage._body ?? Compiler_Protobuf_Statement()}
    set {_uniqueStorage()._body = newValue}
  }
  /// Returns true if `body` has been explicitly set.
  public var hasBody: Bool {return _storage._body != nil}
  /// Clears the value of `body`. Subsequent reads from it will return its default value.
  public mutating func clearBody() {_uniqueStorage()._body = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Compiler_Protobuf_BreakStatement {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Compiler_Protobuf_ContinueStatement {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Compiler_Protobuf_CatchClause {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The parameter is optional
  public var parameter: Compiler_Protobuf_Parameter {
    get {return _parameter ?? Compiler_Protobuf_Parameter()}
    set {_parameter = newValue}
  }
  /// Returns true if `parameter` has been explicitly set.
  public var hasParameter: Bool {return self._parameter != nil}
  /// Clears the value of `parameter`. Subsequent reads from it will return its default value.
  public mutating func clearParameter() {self._parameter = nil}

  public var body: [Compiler_Protobuf_Statement] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _parameter: Compiler_Protobuf_Parameter? = nil
}

public struct Compiler_Protobuf_FinallyClause {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var body: [Compiler_Protobuf_Statement] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Compiler_Protobuf_TryStatement {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var body: [Compiler_Protobuf_Statement] = []

  /// The catch clause is optional
  public var `catch`: Compiler_Protobuf_CatchClause {
    get {return _catch ?? Compiler_Protobuf_CatchClause()}
    set {_catch = newValue}
  }
  /// Returns true if ``catch`` has been explicitly set.
  public var hasCatch: Bool {return self._catch != nil}
  /// Clears the value of ``catch``. Subsequent reads from it will return its default value.
  public mutating func clearCatch() {self._catch = nil}

  /// The finally clause is optional
  public var finally: Compiler_Protobuf_FinallyClause {
    get {return _finally ?? Compiler_Protobuf_FinallyClause()}
    set {_finally = newValue}
  }
  /// Returns true if `finally` has been explicitly set.
  public var hasFinally: Bool {return self._finally != nil}
  /// Clears the value of `finally`. Subsequent reads from it will return its default value.
  public mutating func clearFinally() {self._finally = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _catch: Compiler_Protobuf_CatchClause? = nil
  fileprivate var _finally: Compiler_Protobuf_FinallyClause? = nil
}

public struct Compiler_Protobuf_ThrowStatement {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var argument: Compiler_Protobuf_Expression {
    get {return _storage._argument ?? Compiler_Protobuf_Expression()}
    set {_uniqueStorage()._argument = newValue}
  }
  /// Returns true if `argument` has been explicitly set.
  public var hasArgument: Bool {return _storage._argument != nil}
  /// Clears the value of `argument`. Subsequent reads from it will return its default value.
  public mutating func clearArgument() {_uniqueStorage()._argument = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Compiler_Protobuf_Statement {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var statement: OneOf_Statement? {
    get {return _storage._statement}
    set {_uniqueStorage()._statement = newValue}
  }

  public var emptyStatement: Compiler_Protobuf_EmptyStatement {
    get {
      if case .emptyStatement(let v)? = _storage._statement {return v}
      return Compiler_Protobuf_EmptyStatement()
    }
    set {_uniqueStorage()._statement = .emptyStatement(newValue)}
  }

  public var blockStatement: Compiler_Protobuf_BlockStatement {
    get {
      if case .blockStatement(let v)? = _storage._statement {return v}
      return Compiler_Protobuf_BlockStatement()
    }
    set {_uniqueStorage()._statement = .blockStatement(newValue)}
  }

  public var variableDeclaration: Compiler_Protobuf_VariableDeclaration {
    get {
      if case .variableDeclaration(let v)? = _storage._statement {return v}
      return Compiler_Protobuf_VariableDeclaration()
    }
    set {_uniqueStorage()._statement = .variableDeclaration(newValue)}
  }

  public var functionDeclaration: Compiler_Protobuf_FunctionDeclaration {
    get {
      if case .functionDeclaration(let v)? = _storage._statement {return v}
      return Compiler_Protobuf_FunctionDeclaration()
    }
    set {_uniqueStorage()._statement = .functionDeclaration(newValue)}
  }

  public var classDeclaration: Compiler_Protobuf_ClassDeclaration {
    get {
      if case .classDeclaration(let v)? = _storage._statement {return v}
      return Compiler_Protobuf_ClassDeclaration()
    }
    set {_uniqueStorage()._statement = .classDeclaration(newValue)}
  }

  public var returnStatement: Compiler_Protobuf_ReturnStatement {
    get {
      if case .returnStatement(let v)? = _storage._statement {return v}
      return Compiler_Protobuf_ReturnStatement()
    }
    set {_uniqueStorage()._statement = .returnStatement(newValue)}
  }

  public var expressionStatement: Compiler_Protobuf_ExpressionStatement {
    get {
      if case .expressionStatement(let v)? = _storage._statement {return v}
      return Compiler_Protobuf_ExpressionStatement()
    }
    set {_uniqueStorage()._statement = .expressionStatement(newValue)}
  }

  public var ifStatement: Compiler_Protobuf_IfStatement {
    get {
      if case .ifStatement(let v)? = _storage._statement {return v}
      return Compiler_Protobuf_IfStatement()
    }
    set {_uniqueStorage()._statement = .ifStatement(newValue)}
  }

  public var whileLoop: Compiler_Protobuf_WhileLoop {
    get {
      if case .whileLoop(let v)? = _storage._statement {return v}
      return Compiler_Protobuf_WhileLoop()
    }
    set {_uniqueStorage()._statement = .whileLoop(newValue)}
  }

  public var doWhileLoop: Compiler_Protobuf_DoWhileLoop {
    get {
      if case .doWhileLoop(let v)? = _storage._statement {return v}
      return Compiler_Protobuf_DoWhileLoop()
    }
    set {_uniqueStorage()._statement = .doWhileLoop(newValue)}
  }

  public var forLoop: Compiler_Protobuf_ForLoop {
    get {
      if case .forLoop(let v)? = _storage._statement {return v}
      return Compiler_Protobuf_ForLoop()
    }
    set {_uniqueStorage()._statement = .forLoop(newValue)}
  }

  public var forInLoop: Compiler_Protobuf_ForInLoop {
    get {
      if case .forInLoop(let v)? = _storage._statement {return v}
      return Compiler_Protobuf_ForInLoop()
    }
    set {_uniqueStorage()._statement = .forInLoop(newValue)}
  }

  public var forOfLoop: Compiler_Protobuf_ForOfLoop {
    get {
      if case .forOfLoop(let v)? = _storage._statement {return v}
      return Compiler_Protobuf_ForOfLoop()
    }
    set {_uniqueStorage()._statement = .forOfLoop(newValue)}
  }

  public var breakStatement: Compiler_Protobuf_BreakStatement {
    get {
      if case .breakStatement(let v)? = _storage._statement {return v}
      return Compiler_Protobuf_BreakStatement()
    }
    set {_uniqueStorage()._statement = .breakStatement(newValue)}
  }

  public var continueStatement: Compiler_Protobuf_ContinueStatement {
    get {
      if case .continueStatement(let v)? = _storage._statement {return v}
      return Compiler_Protobuf_ContinueStatement()
    }
    set {_uniqueStorage()._statement = .continueStatement(newValue)}
  }

  public var tryStatement: Compiler_Protobuf_TryStatement {
    get {
      if case .tryStatement(let v)? = _storage._statement {return v}
      return Compiler_Protobuf_TryStatement()
    }
    set {_uniqueStorage()._statement = .tryStatement(newValue)}
  }

  public var throwStatement: Compiler_Protobuf_ThrowStatement {
    get {
      if case .throwStatement(let v)? = _storage._statement {return v}
      return Compiler_Protobuf_ThrowStatement()
    }
    set {_uniqueStorage()._statement = .throwStatement(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Statement: Equatable {
    case emptyStatement(Compiler_Protobuf_EmptyStatement)
    case blockStatement(Compiler_Protobuf_BlockStatement)
    case variableDeclaration(Compiler_Protobuf_VariableDeclaration)
    case functionDeclaration(Compiler_Protobuf_FunctionDeclaration)
    case classDeclaration(Compiler_Protobuf_ClassDeclaration)
    case returnStatement(Compiler_Protobuf_ReturnStatement)
    case expressionStatement(Compiler_Protobuf_ExpressionStatement)
    case ifStatement(Compiler_Protobuf_IfStatement)
    case whileLoop(Compiler_Protobuf_WhileLoop)
    case doWhileLoop(Compiler_Protobuf_DoWhileLoop)
    case forLoop(Compiler_Protobuf_ForLoop)
    case forInLoop(Compiler_Protobuf_ForInLoop)
    case forOfLoop(Compiler_Protobuf_ForOfLoop)
    case breakStatement(Compiler_Protobuf_BreakStatement)
    case continueStatement(Compiler_Protobuf_ContinueStatement)
    case tryStatement(Compiler_Protobuf_TryStatement)
    case throwStatement(Compiler_Protobuf_ThrowStatement)

  #if !swift(>=4.1)
    public static func ==(lhs: Compiler_Protobuf_Statement.OneOf_Statement, rhs: Compiler_Protobuf_Statement.OneOf_Statement) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.emptyStatement, .emptyStatement): return {
        guard case .emptyStatement(let l) = lhs, case .emptyStatement(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.blockStatement, .blockStatement): return {
        guard case .blockStatement(let l) = lhs, case .blockStatement(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.variableDeclaration, .variableDeclaration): return {
        guard case .variableDeclaration(let l) = lhs, case .variableDeclaration(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.functionDeclaration, .functionDeclaration): return {
        guard case .functionDeclaration(let l) = lhs, case .functionDeclaration(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.classDeclaration, .classDeclaration): return {
        guard case .classDeclaration(let l) = lhs, case .classDeclaration(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.returnStatement, .returnStatement): return {
        guard case .returnStatement(let l) = lhs, case .returnStatement(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.expressionStatement, .expressionStatement): return {
        guard case .expressionStatement(let l) = lhs, case .expressionStatement(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.ifStatement, .ifStatement): return {
        guard case .ifStatement(let l) = lhs, case .ifStatement(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.whileLoop, .whileLoop): return {
        guard case .whileLoop(let l) = lhs, case .whileLoop(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.doWhileLoop, .doWhileLoop): return {
        guard case .doWhileLoop(let l) = lhs, case .doWhileLoop(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.forLoop, .forLoop): return {
        guard case .forLoop(let l) = lhs, case .forLoop(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.forInLoop, .forInLoop): return {
        guard case .forInLoop(let l) = lhs, case .forInLoop(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.forOfLoop, .forOfLoop): return {
        guard case .forOfLoop(let l) = lhs, case .forOfLoop(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.breakStatement, .breakStatement): return {
        guard case .breakStatement(let l) = lhs, case .breakStatement(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.continueStatement, .continueStatement): return {
        guard case .continueStatement(let l) = lhs, case .continueStatement(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.tryStatement, .tryStatement): return {
        guard case .tryStatement(let l) = lhs, case .tryStatement(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.throwStatement, .throwStatement): return {
        guard case .throwStatement(let l) = lhs, case .throwStatement(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Compiler_Protobuf_Identifier {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Compiler_Protobuf_NumberLiteral {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var value: Double = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Compiler_Protobuf_BigIntLiteral {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var value: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Compiler_Protobuf_StringLiteral {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var value: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Compiler_Protobuf_TemplateLiteral {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var parts: [String] = []

  public var expressions: [Compiler_Protobuf_Expression] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Compiler_Protobuf_RegExpLiteral {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var pattern: String = String()

  public var flags: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Compiler_Protobuf_BooleanLiteral {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var value: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Compiler_Protobuf_NullLiteral {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Compiler_Protobuf_ThisExpression {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Compiler_Protobuf_AssignmentExpression {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var `operator`: String {
    get {return _storage._operator}
    set {_uniqueStorage()._operator = newValue}
  }

  public var lhs: Compiler_Protobuf_Expression {
    get {return _storage._lhs ?? Compiler_Protobuf_Expression()}
    set {_uniqueStorage()._lhs = newValue}
  }
  /// Returns true if `lhs` has been explicitly set.
  public var hasLhs: Bool {return _storage._lhs != nil}
  /// Clears the value of `lhs`. Subsequent reads from it will return its default value.
  public mutating func clearLhs() {_uniqueStorage()._lhs = nil}

  public var rhs: Compiler_Protobuf_Expression {
    get {return _storage._rhs ?? Compiler_Protobuf_Expression()}
    set {_uniqueStorage()._rhs = newValue}
  }
  /// Returns true if `rhs` has been explicitly set.
  public var hasRhs: Bool {return _storage._rhs != nil}
  /// Clears the value of `rhs`. Subsequent reads from it will return its default value.
  public mutating func clearRhs() {_uniqueStorage()._rhs = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Compiler_Protobuf_ObjectProperty {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var key: Compiler_Protobuf_ObjectProperty.OneOf_Key? = nil

  /// A "regular" property.
  public var name: String {
    get {
      if case .name(let v)? = key {return v}
      return String()
    }
    set {key = .name(newValue)}
  }

  /// An element.
  public var index: Int64 {
    get {
      if case .index(let v)? = key {return v}
      return 0
    }
    set {key = .index(newValue)}
  }

  /// A computed property.
  public var expression: Compiler_Protobuf_Expression {
    get {
      if case .expression(let v)? = key {return v}
      return Compiler_Protobuf_Expression()
    }
    set {key = .expression(newValue)}
  }

  public var value: Compiler_Protobuf_Expression {
    get {return _value ?? Compiler_Protobuf_Expression()}
    set {_value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  public var hasValue: Bool {return self._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  public mutating func clearValue() {self._value = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Key: Equatable {
    /// A "regular" property.
    case name(String)
    /// An element.
    case index(Int64)
    /// A computed property.
    case expression(Compiler_Protobuf_Expression)

  #if !swift(>=4.1)
    public static func ==(lhs: Compiler_Protobuf_ObjectProperty.OneOf_Key, rhs: Compiler_Protobuf_ObjectProperty.OneOf_Key) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.name, .name): return {
        guard case .name(let l) = lhs, case .name(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.index, .index): return {
        guard case .index(let l) = lhs, case .index(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.expression, .expression): return {
        guard case .expression(let l) = lhs, case .expression(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _value: Compiler_Protobuf_Expression? = nil
}

public struct Compiler_Protobuf_ObjectMethod {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var key: Compiler_Protobuf_ObjectMethod.OneOf_Key? = nil

  public var name: String {
    get {
      if case .name(let v)? = key {return v}
      return String()
    }
    set {key = .name(newValue)}
  }

  public var expression: Compiler_Protobuf_Expression {
    get {
      if case .expression(let v)? = key {return v}
      return Compiler_Protobuf_Expression()
    }
    set {key = .expression(newValue)}
  }

  public var type: Compiler_Protobuf_FunctionType = .plain

  public var parameters: [Compiler_Protobuf_Parameter] = []

  public var body: [Compiler_Protobuf_Statement] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Key: Equatable {
    case name(String)
    case expression(Compiler_Protobuf_Expression)

  #if !swift(>=4.1)
    public static func ==(lhs: Compiler_Protobuf_ObjectMethod.OneOf_Key, rhs: Compiler_Protobuf_ObjectMethod.OneOf_Key) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.name, .name): return {
        guard case .name(let l) = lhs, case .name(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.expression, .expression): return {
        guard case .expression(let l) = lhs, case .expression(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

public struct Compiler_Protobuf_ObjectGetter {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var key: Compiler_Protobuf_ObjectGetter.OneOf_Key? = nil

  public var name: String {
    get {
      if case .name(let v)? = key {return v}
      return String()
    }
    set {key = .name(newValue)}
  }

  public var expression: Compiler_Protobuf_Expression {
    get {
      if case .expression(let v)? = key {return v}
      return Compiler_Protobuf_Expression()
    }
    set {key = .expression(newValue)}
  }

  public var body: [Compiler_Protobuf_Statement] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Key: Equatable {
    case name(String)
    case expression(Compiler_Protobuf_Expression)

  #if !swift(>=4.1)
    public static func ==(lhs: Compiler_Protobuf_ObjectGetter.OneOf_Key, rhs: Compiler_Protobuf_ObjectGetter.OneOf_Key) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.name, .name): return {
        guard case .name(let l) = lhs, case .name(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.expression, .expression): return {
        guard case .expression(let l) = lhs, case .expression(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

public struct Compiler_Protobuf_ObjectSetter {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var key: Compiler_Protobuf_ObjectSetter.OneOf_Key? = nil

  public var name: String {
    get {
      if case .name(let v)? = key {return v}
      return String()
    }
    set {key = .name(newValue)}
  }

  public var expression: Compiler_Protobuf_Expression {
    get {
      if case .expression(let v)? = key {return v}
      return Compiler_Protobuf_Expression()
    }
    set {key = .expression(newValue)}
  }

  public var parameter: Compiler_Protobuf_Parameter {
    get {return _parameter ?? Compiler_Protobuf_Parameter()}
    set {_parameter = newValue}
  }
  /// Returns true if `parameter` has been explicitly set.
  public var hasParameter: Bool {return self._parameter != nil}
  /// Clears the value of `parameter`. Subsequent reads from it will return its default value.
  public mutating func clearParameter() {self._parameter = nil}

  public var body: [Compiler_Protobuf_Statement] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Key: Equatable {
    case name(String)
    case expression(Compiler_Protobuf_Expression)

  #if !swift(>=4.1)
    public static func ==(lhs: Compiler_Protobuf_ObjectSetter.OneOf_Key, rhs: Compiler_Protobuf_ObjectSetter.OneOf_Key) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.name, .name): return {
        guard case .name(let l) = lhs, case .name(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.expression, .expression): return {
        guard case .expression(let l) = lhs, case .expression(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _parameter: Compiler_Protobuf_Parameter? = nil
}

public struct Compiler_Protobuf_ObjectField {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var field: Compiler_Protobuf_ObjectField.OneOf_Field? = nil

  public var property: Compiler_Protobuf_ObjectProperty {
    get {
      if case .property(let v)? = field {return v}
      return Compiler_Protobuf_ObjectProperty()
    }
    set {field = .property(newValue)}
  }

  public var method: Compiler_Protobuf_ObjectMethod {
    get {
      if case .method(let v)? = field {return v}
      return Compiler_Protobuf_ObjectMethod()
    }
    set {field = .method(newValue)}
  }

  public var getter: Compiler_Protobuf_ObjectGetter {
    get {
      if case .getter(let v)? = field {return v}
      return Compiler_Protobuf_ObjectGetter()
    }
    set {field = .getter(newValue)}
  }

  public var setter: Compiler_Protobuf_ObjectSetter {
    get {
      if case .setter(let v)? = field {return v}
      return Compiler_Protobuf_ObjectSetter()
    }
    set {field = .setter(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Field: Equatable {
    case property(Compiler_Protobuf_ObjectProperty)
    case method(Compiler_Protobuf_ObjectMethod)
    case getter(Compiler_Protobuf_ObjectGetter)
    case setter(Compiler_Protobuf_ObjectSetter)

  #if !swift(>=4.1)
    public static func ==(lhs: Compiler_Protobuf_ObjectField.OneOf_Field, rhs: Compiler_Protobuf_ObjectField.OneOf_Field) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.property, .property): return {
        guard case .property(let l) = lhs, case .property(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.method, .method): return {
        guard case .method(let l) = lhs, case .method(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.getter, .getter): return {
        guard case .getter(let l) = lhs, case .getter(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.setter, .setter): return {
        guard case .setter(let l) = lhs, case .setter(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

public struct Compiler_Protobuf_ObjectExpression {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var fields: [Compiler_Protobuf_ObjectField] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Compiler_Protobuf_ArrayExpression {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// This can contain empty expressions which represent holes.
  public var elements: [Compiler_Protobuf_Expression] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Compiler_Protobuf_FunctionExpression {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var type: Compiler_Protobuf_FunctionType = .plain

  public var parameters: [Compiler_Protobuf_Parameter] = []

  public var body: [Compiler_Protobuf_Statement] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Compiler_Protobuf_ArrowFunctionExpression {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var type: Compiler_Protobuf_FunctionType {
    get {return _storage._type}
    set {_uniqueStorage()._type = newValue}
  }

  public var parameters: [Compiler_Protobuf_Parameter] {
    get {return _storage._parameters}
    set {_uniqueStorage()._parameters = newValue}
  }

  /// The body can either be an expression or a block statement.
  public var body: OneOf_Body? {
    get {return _storage._body}
    set {_uniqueStorage()._body = newValue}
  }

  public var block: Compiler_Protobuf_Statement {
    get {
      if case .block(let v)? = _storage._body {return v}
      return Compiler_Protobuf_Statement()
    }
    set {_uniqueStorage()._body = .block(newValue)}
  }

  public var expression: Compiler_Protobuf_Expression {
    get {
      if case .expression(let v)? = _storage._body {return v}
      return Compiler_Protobuf_Expression()
    }
    set {_uniqueStorage()._body = .expression(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The body can either be an expression or a block statement.
  public enum OneOf_Body: Equatable {
    case block(Compiler_Protobuf_Statement)
    case expression(Compiler_Protobuf_Expression)

  #if !swift(>=4.1)
    public static func ==(lhs: Compiler_Protobuf_ArrowFunctionExpression.OneOf_Body, rhs: Compiler_Protobuf_ArrowFunctionExpression.OneOf_Body) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.block, .block): return {
        guard case .block(let l) = lhs, case .block(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.expression, .expression): return {
        guard case .expression(let l) = lhs, case .expression(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Compiler_Protobuf_CallExpression {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var callee: Compiler_Protobuf_Expression {
    get {return _storage._callee ?? Compiler_Protobuf_Expression()}
    set {_uniqueStorage()._callee = newValue}
  }
  /// Returns true if `callee` has been explicitly set.
  public var hasCallee: Bool {return _storage._callee != nil}
  /// Clears the value of `callee`. Subsequent reads from it will return its default value.
  public mutating func clearCallee() {_uniqueStorage()._callee = nil}

  public var arguments: [Compiler_Protobuf_Expression] {
    get {return _storage._arguments}
    set {_uniqueStorage()._arguments = newValue}
  }

  public var isOptional: Bool {
    get {return _storage._isOptional}
    set {_uniqueStorage()._isOptional = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Compiler_Protobuf_NewExpression {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var callee: Compiler_Protobuf_Expression {
    get {return _storage._callee ?? Compiler_Protobuf_Expression()}
    set {_uniqueStorage()._callee = newValue}
  }
  /// Returns true if `callee` has been explicitly set.
  public var hasCallee: Bool {return _storage._callee != nil}
  /// Clears the value of `callee`. Subsequent reads from it will return its default value.
  public mutating func clearCallee() {_uniqueStorage()._callee = nil}

  public var arguments: [Compiler_Protobuf_Expression] {
    get {return _storage._arguments}
    set {_uniqueStorage()._arguments = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Compiler_Protobuf_MemberExpression {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var object: Compiler_Protobuf_Expression {
    get {return _storage._object ?? Compiler_Protobuf_Expression()}
    set {_uniqueStorage()._object = newValue}
  }
  /// Returns true if `object` has been explicitly set.
  public var hasObject: Bool {return _storage._object != nil}
  /// Clears the value of `object`. Subsequent reads from it will return its default value.
  public mutating func clearObject() {_uniqueStorage()._object = nil}

  public var property: OneOf_Property? {
    get {return _storage._property}
    set {_uniqueStorage()._property = newValue}
  }

  /// A "regular" property.
  public var name: String {
    get {
      if case .name(let v)? = _storage._property {return v}
      return String()
    }
    set {_uniqueStorage()._property = .name(newValue)}
  }

  /// A computed property or element.
  public var expression: Compiler_Protobuf_Expression {
    get {
      if case .expression(let v)? = _storage._property {return v}
      return Compiler_Protobuf_Expression()
    }
    set {_uniqueStorage()._property = .expression(newValue)}
  }

  public var isOptional: Bool {
    get {return _storage._isOptional}
    set {_uniqueStorage()._isOptional = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Property: Equatable {
    /// A "regular" property.
    case name(String)
    /// A computed property or element.
    case expression(Compiler_Protobuf_Expression)

  #if !swift(>=4.1)
    public static func ==(lhs: Compiler_Protobuf_MemberExpression.OneOf_Property, rhs: Compiler_Protobuf_MemberExpression.OneOf_Property) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.name, .name): return {
        guard case .name(let l) = lhs, case .name(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.expression, .expression): return {
        guard case .expression(let l) = lhs, case .expression(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Compiler_Protobuf_UnaryExpression {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var `operator`: String {
    get {return _storage._operator}
    set {_uniqueStorage()._operator = newValue}
  }

  public var argument: Compiler_Protobuf_Expression {
    get {return _storage._argument ?? Compiler_Protobuf_Expression()}
    set {_uniqueStorage()._argument = newValue}
  }
  /// Returns true if `argument` has been explicitly set.
  public var hasArgument: Bool {return _storage._argument != nil}
  /// Clears the value of `argument`. Subsequent reads from it will return its default value.
  public mutating func clearArgument() {_uniqueStorage()._argument = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Compiler_Protobuf_BinaryExpression {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var `operator`: String {
    get {return _storage._operator}
    set {_uniqueStorage()._operator = newValue}
  }

  public var lhs: Compiler_Protobuf_Expression {
    get {return _storage._lhs ?? Compiler_Protobuf_Expression()}
    set {_uniqueStorage()._lhs = newValue}
  }
  /// Returns true if `lhs` has been explicitly set.
  public var hasLhs: Bool {return _storage._lhs != nil}
  /// Clears the value of `lhs`. Subsequent reads from it will return its default value.
  public mutating func clearLhs() {_uniqueStorage()._lhs = nil}

  public var rhs: Compiler_Protobuf_Expression {
    get {return _storage._rhs ?? Compiler_Protobuf_Expression()}
    set {_uniqueStorage()._rhs = newValue}
  }
  /// Returns true if `rhs` has been explicitly set.
  public var hasRhs: Bool {return _storage._rhs != nil}
  /// Clears the value of `rhs`. Subsequent reads from it will return its default value.
  public mutating func clearRhs() {_uniqueStorage()._rhs = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Compiler_Protobuf_UpdateExpression {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var `operator`: String {
    get {return _storage._operator}
    set {_uniqueStorage()._operator = newValue}
  }

  public var isPrefix: Bool {
    get {return _storage._isPrefix}
    set {_uniqueStorage()._isPrefix = newValue}
  }

  public var argument: Compiler_Protobuf_Expression {
    get {return _storage._argument ?? Compiler_Protobuf_Expression()}
    set {_uniqueStorage()._argument = newValue}
  }
  /// Returns true if `argument` has been explicitly set.
  public var hasArgument: Bool {return _storage._argument != nil}
  /// Clears the value of `argument`. Subsequent reads from it will return its default value.
  public mutating func clearArgument() {_uniqueStorage()._argument = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Compiler_Protobuf_YieldExpression {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The argument is optional
  public var argument: Compiler_Protobuf_Expression {
    get {return _storage._argument ?? Compiler_Protobuf_Expression()}
    set {_uniqueStorage()._argument = newValue}
  }
  /// Returns true if `argument` has been explicitly set.
  public var hasArgument: Bool {return _storage._argument != nil}
  /// Clears the value of `argument`. Subsequent reads from it will return its default value.
  public mutating func clearArgument() {_uniqueStorage()._argument = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Compiler_Protobuf_SpreadElement {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var argument: Compiler_Protobuf_Expression {
    get {return _storage._argument ?? Compiler_Protobuf_Expression()}
    set {_uniqueStorage()._argument = newValue}
  }
  /// Returns true if `argument` has been explicitly set.
  public var hasArgument: Bool {return _storage._argument != nil}
  /// Clears the value of `argument`. Subsequent reads from it will return its default value.
  public mutating func clearArgument() {_uniqueStorage()._argument = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Compiler_Protobuf_SequenceExpression {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var expressions: [Compiler_Protobuf_Expression] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Compiler_Protobuf_V8IntrinsicIdentifier {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Compiler_Protobuf_Expression {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var expression: OneOf_Expression? {
    get {return _storage._expression}
    set {_uniqueStorage()._expression = newValue}
  }

  public var identifier: Compiler_Protobuf_Identifier {
    get {
      if case .identifier(let v)? = _storage._expression {return v}
      return Compiler_Protobuf_Identifier()
    }
    set {_uniqueStorage()._expression = .identifier(newValue)}
  }

  public var numberLiteral: Compiler_Protobuf_NumberLiteral {
    get {
      if case .numberLiteral(let v)? = _storage._expression {return v}
      return Compiler_Protobuf_NumberLiteral()
    }
    set {_uniqueStorage()._expression = .numberLiteral(newValue)}
  }

  public var bigIntLiteral: Compiler_Protobuf_BigIntLiteral {
    get {
      if case .bigIntLiteral(let v)? = _storage._expression {return v}
      return Compiler_Protobuf_BigIntLiteral()
    }
    set {_uniqueStorage()._expression = .bigIntLiteral(newValue)}
  }

  public var stringLiteral: Compiler_Protobuf_StringLiteral {
    get {
      if case .stringLiteral(let v)? = _storage._expression {return v}
      return Compiler_Protobuf_StringLiteral()
    }
    set {_uniqueStorage()._expression = .stringLiteral(newValue)}
  }

  public var templateLiteral: Compiler_Protobuf_TemplateLiteral {
    get {
      if case .templateLiteral(let v)? = _storage._expression {return v}
      return Compiler_Protobuf_TemplateLiteral()
    }
    set {_uniqueStorage()._expression = .templateLiteral(newValue)}
  }

  public var regExpLiteral: Compiler_Protobuf_RegExpLiteral {
    get {
      if case .regExpLiteral(let v)? = _storage._expression {return v}
      return Compiler_Protobuf_RegExpLiteral()
    }
    set {_uniqueStorage()._expression = .regExpLiteral(newValue)}
  }

  public var booleanLiteral: Compiler_Protobuf_BooleanLiteral {
    get {
      if case .booleanLiteral(let v)? = _storage._expression {return v}
      return Compiler_Protobuf_BooleanLiteral()
    }
    set {_uniqueStorage()._expression = .booleanLiteral(newValue)}
  }

  public var nullLiteral: Compiler_Protobuf_NullLiteral {
    get {
      if case .nullLiteral(let v)? = _storage._expression {return v}
      return Compiler_Protobuf_NullLiteral()
    }
    set {_uniqueStorage()._expression = .nullLiteral(newValue)}
  }

  public var thisExpression: Compiler_Protobuf_ThisExpression {
    get {
      if case .thisExpression(let v)? = _storage._expression {return v}
      return Compiler_Protobuf_ThisExpression()
    }
    set {_uniqueStorage()._expression = .thisExpression(newValue)}
  }

  public var assignmentExpression: Compiler_Protobuf_AssignmentExpression {
    get {
      if case .assignmentExpression(let v)? = _storage._expression {return v}
      return Compiler_Protobuf_AssignmentExpression()
    }
    set {_uniqueStorage()._expression = .assignmentExpression(newValue)}
  }

  public var objectExpression: Compiler_Protobuf_ObjectExpression {
    get {
      if case .objectExpression(let v)? = _storage._expression {return v}
      return Compiler_Protobuf_ObjectExpression()
    }
    set {_uniqueStorage()._expression = .objectExpression(newValue)}
  }

  public var arrayExpression: Compiler_Protobuf_ArrayExpression {
    get {
      if case .arrayExpression(let v)? = _storage._expression {return v}
      return Compiler_Protobuf_ArrayExpression()
    }
    set {_uniqueStorage()._expression = .arrayExpression(newValue)}
  }

  public var functionExpression: Compiler_Protobuf_FunctionExpression {
    get {
      if case .functionExpression(let v)? = _storage._expression {return v}
      return Compiler_Protobuf_FunctionExpression()
    }
    set {_uniqueStorage()._expression = .functionExpression(newValue)}
  }

  public var arrowFunctionExpression: Compiler_Protobuf_ArrowFunctionExpression {
    get {
      if case .arrowFunctionExpression(let v)? = _storage._expression {return v}
      return Compiler_Protobuf_ArrowFunctionExpression()
    }
    set {_uniqueStorage()._expression = .arrowFunctionExpression(newValue)}
  }

  public var callExpression: Compiler_Protobuf_CallExpression {
    get {
      if case .callExpression(let v)? = _storage._expression {return v}
      return Compiler_Protobuf_CallExpression()
    }
    set {_uniqueStorage()._expression = .callExpression(newValue)}
  }

  public var newExpression: Compiler_Protobuf_NewExpression {
    get {
      if case .newExpression(let v)? = _storage._expression {return v}
      return Compiler_Protobuf_NewExpression()
    }
    set {_uniqueStorage()._expression = .newExpression(newValue)}
  }

  public var memberExpression: Compiler_Protobuf_MemberExpression {
    get {
      if case .memberExpression(let v)? = _storage._expression {return v}
      return Compiler_Protobuf_MemberExpression()
    }
    set {_uniqueStorage()._expression = .memberExpression(newValue)}
  }

  public var unaryExpression: Compiler_Protobuf_UnaryExpression {
    get {
      if case .unaryExpression(let v)? = _storage._expression {return v}
      return Compiler_Protobuf_UnaryExpression()
    }
    set {_uniqueStorage()._expression = .unaryExpression(newValue)}
  }

  public var binaryExpression: Compiler_Protobuf_BinaryExpression {
    get {
      if case .binaryExpression(let v)? = _storage._expression {return v}
      return Compiler_Protobuf_BinaryExpression()
    }
    set {_uniqueStorage()._expression = .binaryExpression(newValue)}
  }

  public var updateExpression: Compiler_Protobuf_UpdateExpression {
    get {
      if case .updateExpression(let v)? = _storage._expression {return v}
      return Compiler_Protobuf_UpdateExpression()
    }
    set {_uniqueStorage()._expression = .updateExpression(newValue)}
  }

  public var yieldExpression: Compiler_Protobuf_YieldExpression {
    get {
      if case .yieldExpression(let v)? = _storage._expression {return v}
      return Compiler_Protobuf_YieldExpression()
    }
    set {_uniqueStorage()._expression = .yieldExpression(newValue)}
  }

  public var spreadElement: Compiler_Protobuf_SpreadElement {
    get {
      if case .spreadElement(let v)? = _storage._expression {return v}
      return Compiler_Protobuf_SpreadElement()
    }
    set {_uniqueStorage()._expression = .spreadElement(newValue)}
  }

  public var sequenceExpression: Compiler_Protobuf_SequenceExpression {
    get {
      if case .sequenceExpression(let v)? = _storage._expression {return v}
      return Compiler_Protobuf_SequenceExpression()
    }
    set {_uniqueStorage()._expression = .sequenceExpression(newValue)}
  }

  public var v8IntrinsicIdentifier: Compiler_Protobuf_V8IntrinsicIdentifier {
    get {
      if case .v8IntrinsicIdentifier(let v)? = _storage._expression {return v}
      return Compiler_Protobuf_V8IntrinsicIdentifier()
    }
    set {_uniqueStorage()._expression = .v8IntrinsicIdentifier(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Expression: Equatable {
    case identifier(Compiler_Protobuf_Identifier)
    case numberLiteral(Compiler_Protobuf_NumberLiteral)
    case bigIntLiteral(Compiler_Protobuf_BigIntLiteral)
    case stringLiteral(Compiler_Protobuf_StringLiteral)
    case templateLiteral(Compiler_Protobuf_TemplateLiteral)
    case regExpLiteral(Compiler_Protobuf_RegExpLiteral)
    case booleanLiteral(Compiler_Protobuf_BooleanLiteral)
    case nullLiteral(Compiler_Protobuf_NullLiteral)
    case thisExpression(Compiler_Protobuf_ThisExpression)
    case assignmentExpression(Compiler_Protobuf_AssignmentExpression)
    case objectExpression(Compiler_Protobuf_ObjectExpression)
    case arrayExpression(Compiler_Protobuf_ArrayExpression)
    case functionExpression(Compiler_Protobuf_FunctionExpression)
    case arrowFunctionExpression(Compiler_Protobuf_ArrowFunctionExpression)
    case callExpression(Compiler_Protobuf_CallExpression)
    case newExpression(Compiler_Protobuf_NewExpression)
    case memberExpression(Compiler_Protobuf_MemberExpression)
    case unaryExpression(Compiler_Protobuf_UnaryExpression)
    case binaryExpression(Compiler_Protobuf_BinaryExpression)
    case updateExpression(Compiler_Protobuf_UpdateExpression)
    case yieldExpression(Compiler_Protobuf_YieldExpression)
    case spreadElement(Compiler_Protobuf_SpreadElement)
    case sequenceExpression(Compiler_Protobuf_SequenceExpression)
    case v8IntrinsicIdentifier(Compiler_Protobuf_V8IntrinsicIdentifier)

  #if !swift(>=4.1)
    public static func ==(lhs: Compiler_Protobuf_Expression.OneOf_Expression, rhs: Compiler_Protobuf_Expression.OneOf_Expression) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.identifier, .identifier): return {
        guard case .identifier(let l) = lhs, case .identifier(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.numberLiteral, .numberLiteral): return {
        guard case .numberLiteral(let l) = lhs, case .numberLiteral(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.bigIntLiteral, .bigIntLiteral): return {
        guard case .bigIntLiteral(let l) = lhs, case .bigIntLiteral(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.stringLiteral, .stringLiteral): return {
        guard case .stringLiteral(let l) = lhs, case .stringLiteral(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.templateLiteral, .templateLiteral): return {
        guard case .templateLiteral(let l) = lhs, case .templateLiteral(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.regExpLiteral, .regExpLiteral): return {
        guard case .regExpLiteral(let l) = lhs, case .regExpLiteral(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.booleanLiteral, .booleanLiteral): return {
        guard case .booleanLiteral(let l) = lhs, case .booleanLiteral(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.nullLiteral, .nullLiteral): return {
        guard case .nullLiteral(let l) = lhs, case .nullLiteral(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.thisExpression, .thisExpression): return {
        guard case .thisExpression(let l) = lhs, case .thisExpression(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.assignmentExpression, .assignmentExpression): return {
        guard case .assignmentExpression(let l) = lhs, case .assignmentExpression(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.objectExpression, .objectExpression): return {
        guard case .objectExpression(let l) = lhs, case .objectExpression(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.arrayExpression, .arrayExpression): return {
        guard case .arrayExpression(let l) = lhs, case .arrayExpression(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.functionExpression, .functionExpression): return {
        guard case .functionExpression(let l) = lhs, case .functionExpression(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.arrowFunctionExpression, .arrowFunctionExpression): return {
        guard case .arrowFunctionExpression(let l) = lhs, case .arrowFunctionExpression(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.callExpression, .callExpression): return {
        guard case .callExpression(let l) = lhs, case .callExpression(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.newExpression, .newExpression): return {
        guard case .newExpression(let l) = lhs, case .newExpression(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.memberExpression, .memberExpression): return {
        guard case .memberExpression(let l) = lhs, case .memberExpression(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.unaryExpression, .unaryExpression): return {
        guard case .unaryExpression(let l) = lhs, case .unaryExpression(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.binaryExpression, .binaryExpression): return {
        guard case .binaryExpression(let l) = lhs, case .binaryExpression(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.updateExpression, .updateExpression): return {
        guard case .updateExpression(let l) = lhs, case .updateExpression(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.yieldExpression, .yieldExpression): return {
        guard case .yieldExpression(let l) = lhs, case .yieldExpression(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.spreadElement, .spreadElement): return {
        guard case .spreadElement(let l) = lhs, case .spreadElement(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.sequenceExpression, .sequenceExpression): return {
        guard case .sequenceExpression(let l) = lhs, case .sequenceExpression(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.v8IntrinsicIdentifier, .v8IntrinsicIdentifier): return {
        guard case .v8IntrinsicIdentifier(let l) = lhs, case .v8IntrinsicIdentifier(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Compiler_Protobuf_VariableDeclarationKind: @unchecked Sendable {}
extension Compiler_Protobuf_FunctionType: @unchecked Sendable {}
extension Compiler_Protobuf_AST: @unchecked Sendable {}
extension Compiler_Protobuf_Parameter: @unchecked Sendable {}
extension Compiler_Protobuf_EmptyStatement: @unchecked Sendable {}
extension Compiler_Protobuf_BlockStatement: @unchecked Sendable {}
extension Compiler_Protobuf_VariableDeclarator: @unchecked Sendable {}
extension Compiler_Protobuf_VariableDeclaration: @unchecked Sendable {}
extension Compiler_Protobuf_FunctionDeclaration: @unchecked Sendable {}
extension Compiler_Protobuf_ClassProperty: @unchecked Sendable {}
extension Compiler_Protobuf_ClassProperty.OneOf_Key: @unchecked Sendable {}
extension Compiler_Protobuf_ClassConstructor: @unchecked Sendable {}
extension Compiler_Protobuf_ClassMethod: @unchecked Sendable {}
extension Compiler_Protobuf_ClassGetter: @unchecked Sendable {}
extension Compiler_Protobuf_ClassSetter: @unchecked Sendable {}
extension Compiler_Protobuf_ClassStaticInitializer: @unchecked Sendable {}
extension Compiler_Protobuf_ClassField: @unchecked Sendable {}
extension Compiler_Protobuf_ClassField.OneOf_Field: @unchecked Sendable {}
extension Compiler_Protobuf_ClassDeclaration: @unchecked Sendable {}
extension Compiler_Protobuf_ReturnStatement: @unchecked Sendable {}
extension Compiler_Protobuf_ExpressionStatement: @unchecked Sendable {}
extension Compiler_Protobuf_IfStatement: @unchecked Sendable {}
extension Compiler_Protobuf_WhileLoop: @unchecked Sendable {}
extension Compiler_Protobuf_DoWhileLoop: @unchecked Sendable {}
extension Compiler_Protobuf_ForLoop: @unchecked Sendable {}
extension Compiler_Protobuf_ForLoop.OneOf_Initializer: @unchecked Sendable {}
extension Compiler_Protobuf_ForInLoop: @unchecked Sendable {}
extension Compiler_Protobuf_ForOfLoop: @unchecked Sendable {}
extension Compiler_Protobuf_BreakStatement: @unchecked Sendable {}
extension Compiler_Protobuf_ContinueStatement: @unchecked Sendable {}
extension Compiler_Protobuf_CatchClause: @unchecked Sendable {}
extension Compiler_Protobuf_FinallyClause: @unchecked Sendable {}
extension Compiler_Protobuf_TryStatement: @unchecked Sendable {}
extension Compiler_Protobuf_ThrowStatement: @unchecked Sendable {}
extension Compiler_Protobuf_Statement: @unchecked Sendable {}
extension Compiler_Protobuf_Statement.OneOf_Statement: @unchecked Sendable {}
extension Compiler_Protobuf_Identifier: @unchecked Sendable {}
extension Compiler_Protobuf_NumberLiteral: @unchecked Sendable {}
extension Compiler_Protobuf_BigIntLiteral: @unchecked Sendable {}
extension Compiler_Protobuf_StringLiteral: @unchecked Sendable {}
extension Compiler_Protobuf_TemplateLiteral: @unchecked Sendable {}
extension Compiler_Protobuf_RegExpLiteral: @unchecked Sendable {}
extension Compiler_Protobuf_BooleanLiteral: @unchecked Sendable {}
extension Compiler_Protobuf_NullLiteral: @unchecked Sendable {}
extension Compiler_Protobuf_ThisExpression: @unchecked Sendable {}
extension Compiler_Protobuf_AssignmentExpression: @unchecked Sendable {}
extension Compiler_Protobuf_ObjectProperty: @unchecked Sendable {}
extension Compiler_Protobuf_ObjectProperty.OneOf_Key: @unchecked Sendable {}
extension Compiler_Protobuf_ObjectMethod: @unchecked Sendable {}
extension Compiler_Protobuf_ObjectMethod.OneOf_Key: @unchecked Sendable {}
extension Compiler_Protobuf_ObjectGetter: @unchecked Sendable {}
extension Compiler_Protobuf_ObjectGetter.OneOf_Key: @unchecked Sendable {}
extension Compiler_Protobuf_ObjectSetter: @unchecked Sendable {}
extension Compiler_Protobuf_ObjectSetter.OneOf_Key: @unchecked Sendable {}
extension Compiler_Protobuf_ObjectField: @unchecked Sendable {}
extension Compiler_Protobuf_ObjectField.OneOf_Field: @unchecked Sendable {}
extension Compiler_Protobuf_ObjectExpression: @unchecked Sendable {}
extension Compiler_Protobuf_ArrayExpression: @unchecked Sendable {}
extension Compiler_Protobuf_FunctionExpression: @unchecked Sendable {}
extension Compiler_Protobuf_ArrowFunctionExpression: @unchecked Sendable {}
extension Compiler_Protobuf_ArrowFunctionExpression.OneOf_Body: @unchecked Sendable {}
extension Compiler_Protobuf_CallExpression: @unchecked Sendable {}
extension Compiler_Protobuf_NewExpression: @unchecked Sendable {}
extension Compiler_Protobuf_MemberExpression: @unchecked Sendable {}
extension Compiler_Protobuf_MemberExpression.OneOf_Property: @unchecked Sendable {}
extension Compiler_Protobuf_UnaryExpression: @unchecked Sendable {}
extension Compiler_Protobuf_BinaryExpression: @unchecked Sendable {}
extension Compiler_Protobuf_UpdateExpression: @unchecked Sendable {}
extension Compiler_Protobuf_YieldExpression: @unchecked Sendable {}
extension Compiler_Protobuf_SpreadElement: @unchecked Sendable {}
extension Compiler_Protobuf_SequenceExpression: @unchecked Sendable {}
extension Compiler_Protobuf_V8IntrinsicIdentifier: @unchecked Sendable {}
extension Compiler_Protobuf_Expression: @unchecked Sendable {}
extension Compiler_Protobuf_Expression.OneOf_Expression: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "compiler.protobuf"

extension Compiler_Protobuf_VariableDeclarationKind: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "VAR"),
    1: .same(proto: "LET"),
    2: .same(proto: "CONST"),
  ]
}

extension Compiler_Protobuf_FunctionType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PLAIN"),
    1: .same(proto: "GENERATOR"),
    2: .same(proto: "ASYNC"),
    3: .same(proto: "ASYNC_GENERATOR"),
  ]
}

extension Compiler_Protobuf_AST: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AST"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "statements"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.statements) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.statements.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.statements, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Compiler_Protobuf_AST, rhs: Compiler_Protobuf_AST) -> Bool {
    if lhs.statements != rhs.statements {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Compiler_Protobuf_Parameter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Parameter"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Compiler_Protobuf_Parameter, rhs: Compiler_Protobuf_Parameter) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Compiler_Protobuf_EmptyStatement: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EmptyStatement"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Compiler_Protobuf_EmptyStatement, rhs: Compiler_Protobuf_EmptyStatement) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Compiler_Protobuf_BlockStatement: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BlockStatement"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "body"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.body) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.body.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.body, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Compiler_Protobuf_BlockStatement, rhs: Compiler_Protobuf_BlockStatement) -> Bool {
    if lhs.body != rhs.body {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Compiler_Protobuf_VariableDeclarator: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".VariableDeclarator"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "value"),
  ]

  fileprivate class _StorageClass {
    var _name: String = String()
    var _value: Compiler_Protobuf_Expression? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _name = source._name
      _value = source._value
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._value) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 1)
      }
      try { if let v = _storage._value {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Compiler_Protobuf_VariableDeclarator, rhs: Compiler_Protobuf_VariableDeclarator) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._name != rhs_storage._name {return false}
        if _storage._value != rhs_storage._value {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Compiler_Protobuf_VariableDeclaration: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".VariableDeclaration"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "kind"),
    2: .same(proto: "declarations"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.kind) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.declarations) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.kind != .var {
      try visitor.visitSingularEnumField(value: self.kind, fieldNumber: 1)
    }
    if !self.declarations.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.declarations, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Compiler_Protobuf_VariableDeclaration, rhs: Compiler_Protobuf_VariableDeclaration) -> Bool {
    if lhs.kind != rhs.kind {return false}
    if lhs.declarations != rhs.declarations {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Compiler_Protobuf_FunctionDeclaration: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FunctionDeclaration"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "type"),
    3: .same(proto: "parameters"),
    4: .same(proto: "body"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.parameters) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.body) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if self.type != .plain {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 2)
    }
    if !self.parameters.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.parameters, fieldNumber: 3)
    }
    if !self.body.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.body, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Compiler_Protobuf_FunctionDeclaration, rhs: Compiler_Protobuf_FunctionDeclaration) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.type != rhs.type {return false}
    if lhs.parameters != rhs.parameters {return false}
    if lhs.body != rhs.body {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Compiler_Protobuf_ClassProperty: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ClassProperty"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "index"),
    3: .same(proto: "expression"),
    4: .same(proto: "isStatic"),
    5: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.key != nil {try decoder.handleConflictingOneOf()}
          self.key = .name(v)
        }
      }()
      case 2: try {
        var v: Int64?
        try decoder.decodeSingularInt64Field(value: &v)
        if let v = v {
          if self.key != nil {try decoder.handleConflictingOneOf()}
          self.key = .index(v)
        }
      }()
      case 3: try {
        var v: Compiler_Protobuf_Expression?
        var hadOneofValue = false
        if let current = self.key {
          hadOneofValue = true
          if case .expression(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.key = .expression(v)
        }
      }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.isStatic) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.key {
    case .name?: try {
      guard case .name(let v)? = self.key else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }()
    case .index?: try {
      guard case .index(let v)? = self.key else { preconditionFailure() }
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 2)
    }()
    case .expression?: try {
      guard case .expression(let v)? = self.key else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    if self.isStatic != false {
      try visitor.visitSingularBoolField(value: self.isStatic, fieldNumber: 4)
    }
    try { if let v = self._value {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Compiler_Protobuf_ClassProperty, rhs: Compiler_Protobuf_ClassProperty) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.isStatic != rhs.isStatic {return false}
    if lhs._value != rhs._value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Compiler_Protobuf_ClassConstructor: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ClassConstructor"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parameters"),
    2: .same(proto: "body"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.parameters) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.body) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.parameters.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.parameters, fieldNumber: 1)
    }
    if !self.body.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.body, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Compiler_Protobuf_ClassConstructor, rhs: Compiler_Protobuf_ClassConstructor) -> Bool {
    if lhs.parameters != rhs.parameters {return false}
    if lhs.body != rhs.body {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Compiler_Protobuf_ClassMethod: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ClassMethod"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "isStatic"),
    3: .same(proto: "parameters"),
    4: .same(proto: "body"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.isStatic) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.parameters) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.body) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if self.isStatic != false {
      try visitor.visitSingularBoolField(value: self.isStatic, fieldNumber: 2)
    }
    if !self.parameters.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.parameters, fieldNumber: 3)
    }
    if !self.body.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.body, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Compiler_Protobuf_ClassMethod, rhs: Compiler_Protobuf_ClassMethod) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.isStatic != rhs.isStatic {return false}
    if lhs.parameters != rhs.parameters {return false}
    if lhs.body != rhs.body {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Compiler_Protobuf_ClassGetter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ClassGetter"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "isStatic"),
    3: .same(proto: "body"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.isStatic) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.body) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if self.isStatic != false {
      try visitor.visitSingularBoolField(value: self.isStatic, fieldNumber: 2)
    }
    if !self.body.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.body, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Compiler_Protobuf_ClassGetter, rhs: Compiler_Protobuf_ClassGetter) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.isStatic != rhs.isStatic {return false}
    if lhs.body != rhs.body {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Compiler_Protobuf_ClassSetter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ClassSetter"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "isStatic"),
    3: .same(proto: "parameter"),
    4: .same(proto: "body"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.isStatic) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._parameter) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.body) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if self.isStatic != false {
      try visitor.visitSingularBoolField(value: self.isStatic, fieldNumber: 2)
    }
    try { if let v = self._parameter {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.body.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.body, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Compiler_Protobuf_ClassSetter, rhs: Compiler_Protobuf_ClassSetter) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.isStatic != rhs.isStatic {return false}
    if lhs._parameter != rhs._parameter {return false}
    if lhs.body != rhs.body {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Compiler_Protobuf_ClassStaticInitializer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ClassStaticInitializer"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "body"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.body) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.body.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.body, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Compiler_Protobuf_ClassStaticInitializer, rhs: Compiler_Protobuf_ClassStaticInitializer) -> Bool {
    if lhs.body != rhs.body {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Compiler_Protobuf_ClassField: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ClassField"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "property"),
    2: .same(proto: "ctor"),
    3: .same(proto: "method"),
    4: .same(proto: "getter"),
    5: .same(proto: "setter"),
    6: .same(proto: "staticInitializer"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Compiler_Protobuf_ClassProperty?
        var hadOneofValue = false
        if let current = self.field {
          hadOneofValue = true
          if case .property(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.field = .property(v)
        }
      }()
      case 2: try {
        var v: Compiler_Protobuf_ClassConstructor?
        var hadOneofValue = false
        if let current = self.field {
          hadOneofValue = true
          if case .ctor(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.field = .ctor(v)
        }
      }()
      case 3: try {
        var v: Compiler_Protobuf_ClassMethod?
        var hadOneofValue = false
        if let current = self.field {
          hadOneofValue = true
          if case .method(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.field = .method(v)
        }
      }()
      case 4: try {
        var v: Compiler_Protobuf_ClassGetter?
        var hadOneofValue = false
        if let current = self.field {
          hadOneofValue = true
          if case .getter(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.field = .getter(v)
        }
      }()
      case 5: try {
        var v: Compiler_Protobuf_ClassSetter?
        var hadOneofValue = false
        if let current = self.field {
          hadOneofValue = true
          if case .setter(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.field = .setter(v)
        }
      }()
      case 6: try {
        var v: Compiler_Protobuf_ClassStaticInitializer?
        var hadOneofValue = false
        if let current = self.field {
          hadOneofValue = true
          if case .staticInitializer(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.field = .staticInitializer(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.field {
    case .property?: try {
      guard case .property(let v)? = self.field else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .ctor?: try {
      guard case .ctor(let v)? = self.field else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .method?: try {
      guard case .method(let v)? = self.field else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .getter?: try {
      guard case .getter(let v)? = self.field else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .setter?: try {
      guard case .setter(let v)? = self.field else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .staticInitializer?: try {
      guard case .staticInitializer(let v)? = self.field else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Compiler_Protobuf_ClassField, rhs: Compiler_Protobuf_ClassField) -> Bool {
    if lhs.field != rhs.field {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Compiler_Protobuf_ClassDeclaration: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ClassDeclaration"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "superClass"),
    3: .same(proto: "fields"),
  ]

  fileprivate class _StorageClass {
    var _name: String = String()
    var _superClass: Compiler_Protobuf_Expression? = nil
    var _fields: [Compiler_Protobuf_ClassField] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _name = source._name
      _superClass = source._superClass
      _fields = source._fields
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._superClass) }()
        case 3: try { try decoder.decodeRepeatedMessageField(value: &_storage._fields) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 1)
      }
      try { if let v = _storage._superClass {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      if !_storage._fields.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._fields, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Compiler_Protobuf_ClassDeclaration, rhs: Compiler_Protobuf_ClassDeclaration) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._name != rhs_storage._name {return false}
        if _storage._superClass != rhs_storage._superClass {return false}
        if _storage._fields != rhs_storage._fields {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Compiler_Protobuf_ReturnStatement: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ReturnStatement"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "argument"),
  ]

  fileprivate class _StorageClass {
    var _argument: Compiler_Protobuf_Expression? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _argument = source._argument
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._argument) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._argument {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Compiler_Protobuf_ReturnStatement, rhs: Compiler_Protobuf_ReturnStatement) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._argument != rhs_storage._argument {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Compiler_Protobuf_ExpressionStatement: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ExpressionStatement"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "expression"),
  ]

  fileprivate class _StorageClass {
    var _expression: Compiler_Protobuf_Expression? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _expression = source._expression
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._expression) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._expression {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Compiler_Protobuf_ExpressionStatement, rhs: Compiler_Protobuf_ExpressionStatement) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._expression != rhs_storage._expression {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Compiler_Protobuf_IfStatement: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".IfStatement"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "test"),
    2: .same(proto: "ifBody"),
    3: .same(proto: "elseBody"),
  ]

  fileprivate class _StorageClass {
    var _test: Compiler_Protobuf_Expression? = nil
    var _ifBody: Compiler_Protobuf_Statement? = nil
    var _elseBody: Compiler_Protobuf_Statement? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _test = source._test
      _ifBody = source._ifBody
      _elseBody = source._elseBody
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._test) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._ifBody) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._elseBody) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._test {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._ifBody {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._elseBody {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Compiler_Protobuf_IfStatement, rhs: Compiler_Protobuf_IfStatement) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._test != rhs_storage._test {return false}
        if _storage._ifBody != rhs_storage._ifBody {return false}
        if _storage._elseBody != rhs_storage._elseBody {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Compiler_Protobuf_WhileLoop: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WhileLoop"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "test"),
    2: .same(proto: "body"),
  ]

  fileprivate class _StorageClass {
    var _test: Compiler_Protobuf_Expression? = nil
    var _body: Compiler_Protobuf_Statement? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _test = source._test
      _body = source._body
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._test) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._body) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._test {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._body {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Compiler_Protobuf_WhileLoop, rhs: Compiler_Protobuf_WhileLoop) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._test != rhs_storage._test {return false}
        if _storage._body != rhs_storage._body {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Compiler_Protobuf_DoWhileLoop: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DoWhileLoop"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "test"),
    2: .same(proto: "body"),
  ]

  fileprivate class _StorageClass {
    var _test: Compiler_Protobuf_Expression? = nil
    var _body: Compiler_Protobuf_Statement? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _test = source._test
      _body = source._body
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._test) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._body) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._test {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._body {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Compiler_Protobuf_DoWhileLoop, rhs: Compiler_Protobuf_DoWhileLoop) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._test != rhs_storage._test {return false}
        if _storage._body != rhs_storage._body {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Compiler_Protobuf_ForLoop: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ForLoop"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "declaration"),
    2: .same(proto: "expression"),
    3: .same(proto: "condition"),
    4: .same(proto: "afterthought"),
    5: .same(proto: "body"),
  ]

  fileprivate class _StorageClass {
    var _initializer: Compiler_Protobuf_ForLoop.OneOf_Initializer?
    var _condition: Compiler_Protobuf_Expression? = nil
    var _afterthought: Compiler_Protobuf_Expression? = nil
    var _body: Compiler_Protobuf_Statement? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _initializer = source._initializer
      _condition = source._condition
      _afterthought = source._afterthought
      _body = source._body
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try {
          var v: Compiler_Protobuf_VariableDeclaration?
          var hadOneofValue = false
          if let current = _storage._initializer {
            hadOneofValue = true
            if case .declaration(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._initializer = .declaration(v)
          }
        }()
        case 2: try {
          var v: Compiler_Protobuf_Expression?
          var hadOneofValue = false
          if let current = _storage._initializer {
            hadOneofValue = true
            if case .expression(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._initializer = .expression(v)
          }
        }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._condition) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._afterthought) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._body) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      switch _storage._initializer {
      case .declaration?: try {
        guard case .declaration(let v)? = _storage._initializer else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }()
      case .expression?: try {
        guard case .expression(let v)? = _storage._initializer else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }()
      case nil: break
      }
      try { if let v = _storage._condition {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._afterthought {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._body {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Compiler_Protobuf_ForLoop, rhs: Compiler_Protobuf_ForLoop) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._initializer != rhs_storage._initializer {return false}
        if _storage._condition != rhs_storage._condition {return false}
        if _storage._afterthought != rhs_storage._afterthought {return false}
        if _storage._body != rhs_storage._body {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Compiler_Protobuf_ForInLoop: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ForInLoop"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "left"),
    2: .same(proto: "right"),
    3: .same(proto: "body"),
  ]

  fileprivate class _StorageClass {
    var _left: Compiler_Protobuf_VariableDeclarator? = nil
    var _right: Compiler_Protobuf_Expression? = nil
    var _body: Compiler_Protobuf_Statement? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _left = source._left
      _right = source._right
      _body = source._body
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._left) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._right) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._body) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._left {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._right {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._body {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Compiler_Protobuf_ForInLoop, rhs: Compiler_Protobuf_ForInLoop) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._left != rhs_storage._left {return false}
        if _storage._right != rhs_storage._right {return false}
        if _storage._body != rhs_storage._body {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Compiler_Protobuf_ForOfLoop: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ForOfLoop"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "left"),
    2: .same(proto: "right"),
    3: .same(proto: "body"),
  ]

  fileprivate class _StorageClass {
    var _left: Compiler_Protobuf_VariableDeclarator? = nil
    var _right: Compiler_Protobuf_Expression? = nil
    var _body: Compiler_Protobuf_Statement? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _left = source._left
      _right = source._right
      _body = source._body
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._left) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._right) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._body) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._left {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._right {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._body {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Compiler_Protobuf_ForOfLoop, rhs: Compiler_Protobuf_ForOfLoop) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._left != rhs_storage._left {return false}
        if _storage._right != rhs_storage._right {return false}
        if _storage._body != rhs_storage._body {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Compiler_Protobuf_BreakStatement: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BreakStatement"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Compiler_Protobuf_BreakStatement, rhs: Compiler_Protobuf_BreakStatement) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Compiler_Protobuf_ContinueStatement: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ContinueStatement"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Compiler_Protobuf_ContinueStatement, rhs: Compiler_Protobuf_ContinueStatement) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Compiler_Protobuf_CatchClause: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CatchClause"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parameter"),
    2: .same(proto: "body"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._parameter) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.body) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._parameter {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.body.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.body, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Compiler_Protobuf_CatchClause, rhs: Compiler_Protobuf_CatchClause) -> Bool {
    if lhs._parameter != rhs._parameter {return false}
    if lhs.body != rhs.body {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Compiler_Protobuf_FinallyClause: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FinallyClause"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    3: .same(proto: "body"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.body) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.body.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.body, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Compiler_Protobuf_FinallyClause, rhs: Compiler_Protobuf_FinallyClause) -> Bool {
    if lhs.body != rhs.body {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Compiler_Protobuf_TryStatement: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TryStatement"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "body"),
    2: .same(proto: "catch"),
    3: .same(proto: "finally"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.body) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._catch) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._finally) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.body.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.body, fieldNumber: 1)
    }
    try { if let v = self._catch {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._finally {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Compiler_Protobuf_TryStatement, rhs: Compiler_Protobuf_TryStatement) -> Bool {
    if lhs.body != rhs.body {return false}
    if lhs._catch != rhs._catch {return false}
    if lhs._finally != rhs._finally {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Compiler_Protobuf_ThrowStatement: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ThrowStatement"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "argument"),
  ]

  fileprivate class _StorageClass {
    var _argument: Compiler_Protobuf_Expression? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _argument = source._argument
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._argument) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._argument {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Compiler_Protobuf_ThrowStatement, rhs: Compiler_Protobuf_ThrowStatement) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._argument != rhs_storage._argument {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Compiler_Protobuf_Statement: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Statement"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "emptyStatement"),
    2: .same(proto: "blockStatement"),
    3: .same(proto: "variableDeclaration"),
    4: .same(proto: "functionDeclaration"),
    5: .same(proto: "classDeclaration"),
    6: .same(proto: "returnStatement"),
    7: .same(proto: "expressionStatement"),
    8: .same(proto: "ifStatement"),
    9: .same(proto: "whileLoop"),
    10: .same(proto: "doWhileLoop"),
    11: .same(proto: "forLoop"),
    12: .same(proto: "forInLoop"),
    13: .same(proto: "forOfLoop"),
    14: .same(proto: "breakStatement"),
    15: .same(proto: "continueStatement"),
    16: .same(proto: "tryStatement"),
    17: .same(proto: "throwStatement"),
  ]

  fileprivate class _StorageClass {
    var _statement: Compiler_Protobuf_Statement.OneOf_Statement?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _statement = source._statement
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try {
          var v: Compiler_Protobuf_EmptyStatement?
          var hadOneofValue = false
          if let current = _storage._statement {
            hadOneofValue = true
            if case .emptyStatement(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._statement = .emptyStatement(v)
          }
        }()
        case 2: try {
          var v: Compiler_Protobuf_BlockStatement?
          var hadOneofValue = false
          if let current = _storage._statement {
            hadOneofValue = true
            if case .blockStatement(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._statement = .blockStatement(v)
          }
        }()
        case 3: try {
          var v: Compiler_Protobuf_VariableDeclaration?
          var hadOneofValue = false
          if let current = _storage._statement {
            hadOneofValue = true
            if case .variableDeclaration(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._statement = .variableDeclaration(v)
          }
        }()
        case 4: try {
          var v: Compiler_Protobuf_FunctionDeclaration?
          var hadOneofValue = false
          if let current = _storage._statement {
            hadOneofValue = true
            if case .functionDeclaration(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._statement = .functionDeclaration(v)
          }
        }()
        case 5: try {
          var v: Compiler_Protobuf_ClassDeclaration?
          var hadOneofValue = false
          if let current = _storage._statement {
            hadOneofValue = true
            if case .classDeclaration(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._statement = .classDeclaration(v)
          }
        }()
        case 6: try {
          var v: Compiler_Protobuf_ReturnStatement?
          var hadOneofValue = false
          if let current = _storage._statement {
            hadOneofValue = true
            if case .returnStatement(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._statement = .returnStatement(v)
          }
        }()
        case 7: try {
          var v: Compiler_Protobuf_ExpressionStatement?
          var hadOneofValue = false
          if let current = _storage._statement {
            hadOneofValue = true
            if case .expressionStatement(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._statement = .expressionStatement(v)
          }
        }()
        case 8: try {
          var v: Compiler_Protobuf_IfStatement?
          var hadOneofValue = false
          if let current = _storage._statement {
            hadOneofValue = true
            if case .ifStatement(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._statement = .ifStatement(v)
          }
        }()
        case 9: try {
          var v: Compiler_Protobuf_WhileLoop?
          var hadOneofValue = false
          if let current = _storage._statement {
            hadOneofValue = true
            if case .whileLoop(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._statement = .whileLoop(v)
          }
        }()
        case 10: try {
          var v: Compiler_Protobuf_DoWhileLoop?
          var hadOneofValue = false
          if let current = _storage._statement {
            hadOneofValue = true
            if case .doWhileLoop(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._statement = .doWhileLoop(v)
          }
        }()
        case 11: try {
          var v: Compiler_Protobuf_ForLoop?
          var hadOneofValue = false
          if let current = _storage._statement {
            hadOneofValue = true
            if case .forLoop(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._statement = .forLoop(v)
          }
        }()
        case 12: try {
          var v: Compiler_Protobuf_ForInLoop?
          var hadOneofValue = false
          if let current = _storage._statement {
            hadOneofValue = true
            if case .forInLoop(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._statement = .forInLoop(v)
          }
        }()
        case 13: try {
          var v: Compiler_Protobuf_ForOfLoop?
          var hadOneofValue = false
          if let current = _storage._statement {
            hadOneofValue = true
            if case .forOfLoop(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._statement = .forOfLoop(v)
          }
        }()
        case 14: try {
          var v: Compiler_Protobuf_BreakStatement?
          var hadOneofValue = false
          if let current = _storage._statement {
            hadOneofValue = true
            if case .breakStatement(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._statement = .breakStatement(v)
          }
        }()
        case 15: try {
          var v: Compiler_Protobuf_ContinueStatement?
          var hadOneofValue = false
          if let current = _storage._statement {
            hadOneofValue = true
            if case .continueStatement(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._statement = .continueStatement(v)
          }
        }()
        case 16: try {
          var v: Compiler_Protobuf_TryStatement?
          var hadOneofValue = false
          if let current = _storage._statement {
            hadOneofValue = true
            if case .tryStatement(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._statement = .tryStatement(v)
          }
        }()
        case 17: try {
          var v: Compiler_Protobuf_ThrowStatement?
          var hadOneofValue = false
          if let current = _storage._statement {
            hadOneofValue = true
            if case .throwStatement(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._statement = .throwStatement(v)
          }
        }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      switch _storage._statement {
      case .emptyStatement?: try {
        guard case .emptyStatement(let v)? = _storage._statement else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }()
      case .blockStatement?: try {
        guard case .blockStatement(let v)? = _storage._statement else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }()
      case .variableDeclaration?: try {
        guard case .variableDeclaration(let v)? = _storage._statement else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }()
      case .functionDeclaration?: try {
        guard case .functionDeclaration(let v)? = _storage._statement else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }()
      case .classDeclaration?: try {
        guard case .classDeclaration(let v)? = _storage._statement else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }()
      case .returnStatement?: try {
        guard case .returnStatement(let v)? = _storage._statement else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }()
      case .expressionStatement?: try {
        guard case .expressionStatement(let v)? = _storage._statement else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }()
      case .ifStatement?: try {
        guard case .ifStatement(let v)? = _storage._statement else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }()
      case .whileLoop?: try {
        guard case .whileLoop(let v)? = _storage._statement else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      }()
      case .doWhileLoop?: try {
        guard case .doWhileLoop(let v)? = _storage._statement else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      }()
      case .forLoop?: try {
        guard case .forLoop(let v)? = _storage._statement else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      }()
      case .forInLoop?: try {
        guard case .forInLoop(let v)? = _storage._statement else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      }()
      case .forOfLoop?: try {
        guard case .forOfLoop(let v)? = _storage._statement else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      }()
      case .breakStatement?: try {
        guard case .breakStatement(let v)? = _storage._statement else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      }()
      case .continueStatement?: try {
        guard case .continueStatement(let v)? = _storage._statement else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      }()
      case .tryStatement?: try {
        guard case .tryStatement(let v)? = _storage._statement else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      }()
      case .throwStatement?: try {
        guard case .throwStatement(let v)? = _storage._statement else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      }()
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Compiler_Protobuf_Statement, rhs: Compiler_Protobuf_Statement) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._statement != rhs_storage._statement {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Compiler_Protobuf_Identifier: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Identifier"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Compiler_Protobuf_Identifier, rhs: Compiler_Protobuf_Identifier) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Compiler_Protobuf_NumberLiteral: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NumberLiteral"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.value != 0 {
      try visitor.visitSingularDoubleField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Compiler_Protobuf_NumberLiteral, rhs: Compiler_Protobuf_NumberLiteral) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Compiler_Protobuf_BigIntLiteral: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BigIntLiteral"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Compiler_Protobuf_BigIntLiteral, rhs: Compiler_Protobuf_BigIntLiteral) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Compiler_Protobuf_StringLiteral: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StringLiteral"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Compiler_Protobuf_StringLiteral, rhs: Compiler_Protobuf_StringLiteral) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Compiler_Protobuf_TemplateLiteral: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TemplateLiteral"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parts"),
    2: .same(proto: "expressions"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.parts) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.expressions) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.parts.isEmpty {
      try visitor.visitRepeatedStringField(value: self.parts, fieldNumber: 1)
    }
    if !self.expressions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.expressions, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Compiler_Protobuf_TemplateLiteral, rhs: Compiler_Protobuf_TemplateLiteral) -> Bool {
    if lhs.parts != rhs.parts {return false}
    if lhs.expressions != rhs.expressions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Compiler_Protobuf_RegExpLiteral: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RegExpLiteral"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pattern"),
    2: .same(proto: "flags"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.pattern) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.flags) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.pattern.isEmpty {
      try visitor.visitSingularStringField(value: self.pattern, fieldNumber: 1)
    }
    if !self.flags.isEmpty {
      try visitor.visitSingularStringField(value: self.flags, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Compiler_Protobuf_RegExpLiteral, rhs: Compiler_Protobuf_RegExpLiteral) -> Bool {
    if lhs.pattern != rhs.pattern {return false}
    if lhs.flags != rhs.flags {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Compiler_Protobuf_BooleanLiteral: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BooleanLiteral"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.value != false {
      try visitor.visitSingularBoolField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Compiler_Protobuf_BooleanLiteral, rhs: Compiler_Protobuf_BooleanLiteral) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Compiler_Protobuf_NullLiteral: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NullLiteral"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Compiler_Protobuf_NullLiteral, rhs: Compiler_Protobuf_NullLiteral) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Compiler_Protobuf_ThisExpression: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ThisExpression"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Compiler_Protobuf_ThisExpression, rhs: Compiler_Protobuf_ThisExpression) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Compiler_Protobuf_AssignmentExpression: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AssignmentExpression"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "operator"),
    2: .same(proto: "lhs"),
    3: .same(proto: "rhs"),
  ]

  fileprivate class _StorageClass {
    var _operator: String = String()
    var _lhs: Compiler_Protobuf_Expression? = nil
    var _rhs: Compiler_Protobuf_Expression? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _operator = source._operator
      _lhs = source._lhs
      _rhs = source._rhs
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._operator) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._lhs) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._rhs) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._operator.isEmpty {
        try visitor.visitSingularStringField(value: _storage._operator, fieldNumber: 1)
      }
      try { if let v = _storage._lhs {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._rhs {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Compiler_Protobuf_AssignmentExpression, rhs: Compiler_Protobuf_AssignmentExpression) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._operator != rhs_storage._operator {return false}
        if _storage._lhs != rhs_storage._lhs {return false}
        if _storage._rhs != rhs_storage._rhs {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Compiler_Protobuf_ObjectProperty: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ObjectProperty"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "index"),
    3: .same(proto: "expression"),
    4: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.key != nil {try decoder.handleConflictingOneOf()}
          self.key = .name(v)
        }
      }()
      case 2: try {
        var v: Int64?
        try decoder.decodeSingularInt64Field(value: &v)
        if let v = v {
          if self.key != nil {try decoder.handleConflictingOneOf()}
          self.key = .index(v)
        }
      }()
      case 3: try {
        var v: Compiler_Protobuf_Expression?
        var hadOneofValue = false
        if let current = self.key {
          hadOneofValue = true
          if case .expression(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.key = .expression(v)
        }
      }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.key {
    case .name?: try {
      guard case .name(let v)? = self.key else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }()
    case .index?: try {
      guard case .index(let v)? = self.key else { preconditionFailure() }
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 2)
    }()
    case .expression?: try {
      guard case .expression(let v)? = self.key else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try { if let v = self._value {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Compiler_Protobuf_ObjectProperty, rhs: Compiler_Protobuf_ObjectProperty) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs._value != rhs._value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Compiler_Protobuf_ObjectMethod: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ObjectMethod"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "expression"),
    3: .same(proto: "type"),
    4: .same(proto: "parameters"),
    5: .same(proto: "body"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.key != nil {try decoder.handleConflictingOneOf()}
          self.key = .name(v)
        }
      }()
      case 2: try {
        var v: Compiler_Protobuf_Expression?
        var hadOneofValue = false
        if let current = self.key {
          hadOneofValue = true
          if case .expression(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.key = .expression(v)
        }
      }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.parameters) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.body) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.key {
    case .name?: try {
      guard case .name(let v)? = self.key else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }()
    case .expression?: try {
      guard case .expression(let v)? = self.key else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    if self.type != .plain {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 3)
    }
    if !self.parameters.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.parameters, fieldNumber: 4)
    }
    if !self.body.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.body, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Compiler_Protobuf_ObjectMethod, rhs: Compiler_Protobuf_ObjectMethod) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.type != rhs.type {return false}
    if lhs.parameters != rhs.parameters {return false}
    if lhs.body != rhs.body {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Compiler_Protobuf_ObjectGetter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ObjectGetter"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "expression"),
    3: .same(proto: "body"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.key != nil {try decoder.handleConflictingOneOf()}
          self.key = .name(v)
        }
      }()
      case 2: try {
        var v: Compiler_Protobuf_Expression?
        var hadOneofValue = false
        if let current = self.key {
          hadOneofValue = true
          if case .expression(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.key = .expression(v)
        }
      }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.body) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.key {
    case .name?: try {
      guard case .name(let v)? = self.key else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }()
    case .expression?: try {
      guard case .expression(let v)? = self.key else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    if !self.body.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.body, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Compiler_Protobuf_ObjectGetter, rhs: Compiler_Protobuf_ObjectGetter) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.body != rhs.body {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Compiler_Protobuf_ObjectSetter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ObjectSetter"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "expression"),
    3: .same(proto: "parameter"),
    4: .same(proto: "body"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.key != nil {try decoder.handleConflictingOneOf()}
          self.key = .name(v)
        }
      }()
      case 2: try {
        var v: Compiler_Protobuf_Expression?
        var hadOneofValue = false
        if let current = self.key {
          hadOneofValue = true
          if case .expression(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.key = .expression(v)
        }
      }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._parameter) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.body) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.key {
    case .name?: try {
      guard case .name(let v)? = self.key else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }()
    case .expression?: try {
      guard case .expression(let v)? = self.key else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try { if let v = self._parameter {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.body.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.body, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Compiler_Protobuf_ObjectSetter, rhs: Compiler_Protobuf_ObjectSetter) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs._parameter != rhs._parameter {return false}
    if lhs.body != rhs.body {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Compiler_Protobuf_ObjectField: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ObjectField"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "property"),
    2: .same(proto: "method"),
    3: .same(proto: "getter"),
    4: .same(proto: "setter"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Compiler_Protobuf_ObjectProperty?
        var hadOneofValue = false
        if let current = self.field {
          hadOneofValue = true
          if case .property(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.field = .property(v)
        }
      }()
      case 2: try {
        var v: Compiler_Protobuf_ObjectMethod?
        var hadOneofValue = false
        if let current = self.field {
          hadOneofValue = true
          if case .method(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.field = .method(v)
        }
      }()
      case 3: try {
        var v: Compiler_Protobuf_ObjectGetter?
        var hadOneofValue = false
        if let current = self.field {
          hadOneofValue = true
          if case .getter(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.field = .getter(v)
        }
      }()
      case 4: try {
        var v: Compiler_Protobuf_ObjectSetter?
        var hadOneofValue = false
        if let current = self.field {
          hadOneofValue = true
          if case .setter(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.field = .setter(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.field {
    case .property?: try {
      guard case .property(let v)? = self.field else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .method?: try {
      guard case .method(let v)? = self.field else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .getter?: try {
      guard case .getter(let v)? = self.field else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .setter?: try {
      guard case .setter(let v)? = self.field else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Compiler_Protobuf_ObjectField, rhs: Compiler_Protobuf_ObjectField) -> Bool {
    if lhs.field != rhs.field {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Compiler_Protobuf_ObjectExpression: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ObjectExpression"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "fields"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.fields) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.fields.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.fields, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Compiler_Protobuf_ObjectExpression, rhs: Compiler_Protobuf_ObjectExpression) -> Bool {
    if lhs.fields != rhs.fields {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Compiler_Protobuf_ArrayExpression: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ArrayExpression"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "elements"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.elements) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.elements.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.elements, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Compiler_Protobuf_ArrayExpression, rhs: Compiler_Protobuf_ArrayExpression) -> Bool {
    if lhs.elements != rhs.elements {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Compiler_Protobuf_FunctionExpression: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FunctionExpression"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "parameters"),
    3: .same(proto: "body"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.parameters) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.body) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != .plain {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    if !self.parameters.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.parameters, fieldNumber: 2)
    }
    if !self.body.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.body, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Compiler_Protobuf_FunctionExpression, rhs: Compiler_Protobuf_FunctionExpression) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.parameters != rhs.parameters {return false}
    if lhs.body != rhs.body {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Compiler_Protobuf_ArrowFunctionExpression: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ArrowFunctionExpression"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "parameters"),
    3: .same(proto: "block"),
    4: .same(proto: "expression"),
  ]

  fileprivate class _StorageClass {
    var _type: Compiler_Protobuf_FunctionType = .plain
    var _parameters: [Compiler_Protobuf_Parameter] = []
    var _body: Compiler_Protobuf_ArrowFunctionExpression.OneOf_Body?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _type = source._type
      _parameters = source._parameters
      _body = source._body
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularEnumField(value: &_storage._type) }()
        case 2: try { try decoder.decodeRepeatedMessageField(value: &_storage._parameters) }()
        case 3: try {
          var v: Compiler_Protobuf_Statement?
          var hadOneofValue = false
          if let current = _storage._body {
            hadOneofValue = true
            if case .block(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._body = .block(v)
          }
        }()
        case 4: try {
          var v: Compiler_Protobuf_Expression?
          var hadOneofValue = false
          if let current = _storage._body {
            hadOneofValue = true
            if case .expression(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._body = .expression(v)
          }
        }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._type != .plain {
        try visitor.visitSingularEnumField(value: _storage._type, fieldNumber: 1)
      }
      if !_storage._parameters.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._parameters, fieldNumber: 2)
      }
      switch _storage._body {
      case .block?: try {
        guard case .block(let v)? = _storage._body else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }()
      case .expression?: try {
        guard case .expression(let v)? = _storage._body else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }()
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Compiler_Protobuf_ArrowFunctionExpression, rhs: Compiler_Protobuf_ArrowFunctionExpression) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._type != rhs_storage._type {return false}
        if _storage._parameters != rhs_storage._parameters {return false}
        if _storage._body != rhs_storage._body {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Compiler_Protobuf_CallExpression: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CallExpression"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "callee"),
    2: .same(proto: "arguments"),
    3: .same(proto: "isOptional"),
  ]

  fileprivate class _StorageClass {
    var _callee: Compiler_Protobuf_Expression? = nil
    var _arguments: [Compiler_Protobuf_Expression] = []
    var _isOptional: Bool = false

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _callee = source._callee
      _arguments = source._arguments
      _isOptional = source._isOptional
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._callee) }()
        case 2: try { try decoder.decodeRepeatedMessageField(value: &_storage._arguments) }()
        case 3: try { try decoder.decodeSingularBoolField(value: &_storage._isOptional) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._callee {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      if !_storage._arguments.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._arguments, fieldNumber: 2)
      }
      if _storage._isOptional != false {
        try visitor.visitSingularBoolField(value: _storage._isOptional, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Compiler_Protobuf_CallExpression, rhs: Compiler_Protobuf_CallExpression) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._callee != rhs_storage._callee {return false}
        if _storage._arguments != rhs_storage._arguments {return false}
        if _storage._isOptional != rhs_storage._isOptional {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Compiler_Protobuf_NewExpression: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NewExpression"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "callee"),
    2: .same(proto: "arguments"),
  ]

  fileprivate class _StorageClass {
    var _callee: Compiler_Protobuf_Expression? = nil
    var _arguments: [Compiler_Protobuf_Expression] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _callee = source._callee
      _arguments = source._arguments
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._callee) }()
        case 2: try { try decoder.decodeRepeatedMessageField(value: &_storage._arguments) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._callee {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      if !_storage._arguments.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._arguments, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Compiler_Protobuf_NewExpression, rhs: Compiler_Protobuf_NewExpression) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._callee != rhs_storage._callee {return false}
        if _storage._arguments != rhs_storage._arguments {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Compiler_Protobuf_MemberExpression: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MemberExpression"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "object"),
    2: .same(proto: "name"),
    3: .same(proto: "expression"),
    4: .same(proto: "isOptional"),
  ]

  fileprivate class _StorageClass {
    var _object: Compiler_Protobuf_Expression? = nil
    var _property: Compiler_Protobuf_MemberExpression.OneOf_Property?
    var _isOptional: Bool = false

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _object = source._object
      _property = source._property
      _isOptional = source._isOptional
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._object) }()
        case 2: try {
          var v: String?
          try decoder.decodeSingularStringField(value: &v)
          if let v = v {
            if _storage._property != nil {try decoder.handleConflictingOneOf()}
            _storage._property = .name(v)
          }
        }()
        case 3: try {
          var v: Compiler_Protobuf_Expression?
          var hadOneofValue = false
          if let current = _storage._property {
            hadOneofValue = true
            if case .expression(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._property = .expression(v)
          }
        }()
        case 4: try { try decoder.decodeSingularBoolField(value: &_storage._isOptional) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._object {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      switch _storage._property {
      case .name?: try {
        guard case .name(let v)? = _storage._property else { preconditionFailure() }
        try visitor.visitSingularStringField(value: v, fieldNumber: 2)
      }()
      case .expression?: try {
        guard case .expression(let v)? = _storage._property else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }()
      case nil: break
      }
      if _storage._isOptional != false {
        try visitor.visitSingularBoolField(value: _storage._isOptional, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Compiler_Protobuf_MemberExpression, rhs: Compiler_Protobuf_MemberExpression) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._object != rhs_storage._object {return false}
        if _storage._property != rhs_storage._property {return false}
        if _storage._isOptional != rhs_storage._isOptional {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Compiler_Protobuf_UnaryExpression: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UnaryExpression"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "operator"),
    2: .same(proto: "argument"),
  ]

  fileprivate class _StorageClass {
    var _operator: String = String()
    var _argument: Compiler_Protobuf_Expression? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _operator = source._operator
      _argument = source._argument
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._operator) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._argument) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._operator.isEmpty {
        try visitor.visitSingularStringField(value: _storage._operator, fieldNumber: 1)
      }
      try { if let v = _storage._argument {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Compiler_Protobuf_UnaryExpression, rhs: Compiler_Protobuf_UnaryExpression) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._operator != rhs_storage._operator {return false}
        if _storage._argument != rhs_storage._argument {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Compiler_Protobuf_BinaryExpression: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BinaryExpression"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "operator"),
    2: .same(proto: "lhs"),
    3: .same(proto: "rhs"),
  ]

  fileprivate class _StorageClass {
    var _operator: String = String()
    var _lhs: Compiler_Protobuf_Expression? = nil
    var _rhs: Compiler_Protobuf_Expression? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _operator = source._operator
      _lhs = source._lhs
      _rhs = source._rhs
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._operator) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._lhs) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._rhs) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._operator.isEmpty {
        try visitor.visitSingularStringField(value: _storage._operator, fieldNumber: 1)
      }
      try { if let v = _storage._lhs {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._rhs {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Compiler_Protobuf_BinaryExpression, rhs: Compiler_Protobuf_BinaryExpression) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._operator != rhs_storage._operator {return false}
        if _storage._lhs != rhs_storage._lhs {return false}
        if _storage._rhs != rhs_storage._rhs {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Compiler_Protobuf_UpdateExpression: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateExpression"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "operator"),
    2: .same(proto: "isPrefix"),
    3: .same(proto: "argument"),
  ]

  fileprivate class _StorageClass {
    var _operator: String = String()
    var _isPrefix: Bool = false
    var _argument: Compiler_Protobuf_Expression? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _operator = source._operator
      _isPrefix = source._isPrefix
      _argument = source._argument
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._operator) }()
        case 2: try { try decoder.decodeSingularBoolField(value: &_storage._isPrefix) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._argument) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._operator.isEmpty {
        try visitor.visitSingularStringField(value: _storage._operator, fieldNumber: 1)
      }
      if _storage._isPrefix != false {
        try visitor.visitSingularBoolField(value: _storage._isPrefix, fieldNumber: 2)
      }
      try { if let v = _storage._argument {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Compiler_Protobuf_UpdateExpression, rhs: Compiler_Protobuf_UpdateExpression) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._operator != rhs_storage._operator {return false}
        if _storage._isPrefix != rhs_storage._isPrefix {return false}
        if _storage._argument != rhs_storage._argument {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Compiler_Protobuf_YieldExpression: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".YieldExpression"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "argument"),
  ]

  fileprivate class _StorageClass {
    var _argument: Compiler_Protobuf_Expression? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _argument = source._argument
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._argument) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._argument {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Compiler_Protobuf_YieldExpression, rhs: Compiler_Protobuf_YieldExpression) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._argument != rhs_storage._argument {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Compiler_Protobuf_SpreadElement: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SpreadElement"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "argument"),
  ]

  fileprivate class _StorageClass {
    var _argument: Compiler_Protobuf_Expression? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _argument = source._argument
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._argument) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._argument {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Compiler_Protobuf_SpreadElement, rhs: Compiler_Protobuf_SpreadElement) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._argument != rhs_storage._argument {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Compiler_Protobuf_SequenceExpression: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SequenceExpression"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "expressions"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.expressions) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.expressions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.expressions, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Compiler_Protobuf_SequenceExpression, rhs: Compiler_Protobuf_SequenceExpression) -> Bool {
    if lhs.expressions != rhs.expressions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Compiler_Protobuf_V8IntrinsicIdentifier: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".V8IntrinsicIdentifier"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Compiler_Protobuf_V8IntrinsicIdentifier, rhs: Compiler_Protobuf_V8IntrinsicIdentifier) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Compiler_Protobuf_Expression: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Expression"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "identifier"),
    2: .same(proto: "numberLiteral"),
    3: .same(proto: "bigIntLiteral"),
    4: .same(proto: "stringLiteral"),
    5: .same(proto: "templateLiteral"),
    6: .same(proto: "regExpLiteral"),
    7: .same(proto: "booleanLiteral"),
    8: .same(proto: "nullLiteral"),
    9: .same(proto: "thisExpression"),
    10: .same(proto: "assignmentExpression"),
    11: .same(proto: "objectExpression"),
    12: .same(proto: "arrayExpression"),
    13: .same(proto: "functionExpression"),
    14: .same(proto: "arrowFunctionExpression"),
    15: .same(proto: "callExpression"),
    16: .same(proto: "newExpression"),
    17: .same(proto: "memberExpression"),
    18: .same(proto: "unaryExpression"),
    19: .same(proto: "binaryExpression"),
    20: .same(proto: "updateExpression"),
    21: .same(proto: "yieldExpression"),
    22: .same(proto: "spreadElement"),
    23: .same(proto: "sequenceExpression"),
    24: .same(proto: "v8IntrinsicIdentifier"),
  ]

  fileprivate class _StorageClass {
    var _expression: Compiler_Protobuf_Expression.OneOf_Expression?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _expression = source._expression
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try {
          var v: Compiler_Protobuf_Identifier?
          var hadOneofValue = false
          if let current = _storage._expression {
            hadOneofValue = true
            if case .identifier(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._expression = .identifier(v)
          }
        }()
        case 2: try {
          var v: Compiler_Protobuf_NumberLiteral?
          var hadOneofValue = false
          if let current = _storage._expression {
            hadOneofValue = true
            if case .numberLiteral(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._expression = .numberLiteral(v)
          }
        }()
        case 3: try {
          var v: Compiler_Protobuf_BigIntLiteral?
          var hadOneofValue = false
          if let current = _storage._expression {
            hadOneofValue = true
            if case .bigIntLiteral(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._expression = .bigIntLiteral(v)
          }
        }()
        case 4: try {
          var v: Compiler_Protobuf_StringLiteral?
          var hadOneofValue = false
          if let current = _storage._expression {
            hadOneofValue = true
            if case .stringLiteral(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._expression = .stringLiteral(v)
          }
        }()
        case 5: try {
          var v: Compiler_Protobuf_TemplateLiteral?
          var hadOneofValue = false
          if let current = _storage._expression {
            hadOneofValue = true
            if case .templateLiteral(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._expression = .templateLiteral(v)
          }
        }()
        case 6: try {
          var v: Compiler_Protobuf_RegExpLiteral?
          var hadOneofValue = false
          if let current = _storage._expression {
            hadOneofValue = true
            if case .regExpLiteral(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._expression = .regExpLiteral(v)
          }
        }()
        case 7: try {
          var v: Compiler_Protobuf_BooleanLiteral?
          var hadOneofValue = false
          if let current = _storage._expression {
            hadOneofValue = true
            if case .booleanLiteral(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._expression = .booleanLiteral(v)
          }
        }()
        case 8: try {
          var v: Compiler_Protobuf_NullLiteral?
          var hadOneofValue = false
          if let current = _storage._expression {
            hadOneofValue = true
            if case .nullLiteral(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._expression = .nullLiteral(v)
          }
        }()
        case 9: try {
          var v: Compiler_Protobuf_ThisExpression?
          var hadOneofValue = false
          if let current = _storage._expression {
            hadOneofValue = true
            if case .thisExpression(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._expression = .thisExpression(v)
          }
        }()
        case 10: try {
          var v: Compiler_Protobuf_AssignmentExpression?
          var hadOneofValue = false
          if let current = _storage._expression {
            hadOneofValue = true
            if case .assignmentExpression(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._expression = .assignmentExpression(v)
          }
        }()
        case 11: try {
          var v: Compiler_Protobuf_ObjectExpression?
          var hadOneofValue = false
          if let current = _storage._expression {
            hadOneofValue = true
            if case .objectExpression(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._expression = .objectExpression(v)
          }
        }()
        case 12: try {
          var v: Compiler_Protobuf_ArrayExpression?
          var hadOneofValue = false
          if let current = _storage._expression {
            hadOneofValue = true
            if case .arrayExpression(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._expression = .arrayExpression(v)
          }
        }()
        case 13: try {
          var v: Compiler_Protobuf_FunctionExpression?
          var hadOneofValue = false
          if let current = _storage._expression {
            hadOneofValue = true
            if case .functionExpression(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._expression = .functionExpression(v)
          }
        }()
        case 14: try {
          var v: Compiler_Protobuf_ArrowFunctionExpression?
          var hadOneofValue = false
          if let current = _storage._expression {
            hadOneofValue = true
            if case .arrowFunctionExpression(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._expression = .arrowFunctionExpression(v)
          }
        }()
        case 15: try {
          var v: Compiler_Protobuf_CallExpression?
          var hadOneofValue = false
          if let current = _storage._expression {
            hadOneofValue = true
            if case .callExpression(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._expression = .callExpression(v)
          }
        }()
        case 16: try {
          var v: Compiler_Protobuf_NewExpression?
          var hadOneofValue = false
          if let current = _storage._expression {
            hadOneofValue = true
            if case .newExpression(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._expression = .newExpression(v)
          }
        }()
        case 17: try {
          var v: Compiler_Protobuf_MemberExpression?
          var hadOneofValue = false
          if let current = _storage._expression {
            hadOneofValue = true
            if case .memberExpression(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._expression = .memberExpression(v)
          }
        }()
        case 18: try {
          var v: Compiler_Protobuf_UnaryExpression?
          var hadOneofValue = false
          if let current = _storage._expression {
            hadOneofValue = true
            if case .unaryExpression(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._expression = .unaryExpression(v)
          }
        }()
        case 19: try {
          var v: Compiler_Protobuf_BinaryExpression?
          var hadOneofValue = false
          if let current = _storage._expression {
            hadOneofValue = true
            if case .binaryExpression(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._expression = .binaryExpression(v)
          }
        }()
        case 20: try {
          var v: Compiler_Protobuf_UpdateExpression?
          var hadOneofValue = false
          if let current = _storage._expression {
            hadOneofValue = true
            if case .updateExpression(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._expression = .updateExpression(v)
          }
        }()
        case 21: try {
          var v: Compiler_Protobuf_YieldExpression?
          var hadOneofValue = false
          if let current = _storage._expression {
            hadOneofValue = true
            if case .yieldExpression(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._expression = .yieldExpression(v)
          }
        }()
        case 22: try {
          var v: Compiler_Protobuf_SpreadElement?
          var hadOneofValue = false
          if let current = _storage._expression {
            hadOneofValue = true
            if case .spreadElement(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._expression = .spreadElement(v)
          }
        }()
        case 23: try {
          var v: Compiler_Protobuf_SequenceExpression?
          var hadOneofValue = false
          if let current = _storage._expression {
            hadOneofValue = true
            if case .sequenceExpression(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._expression = .sequenceExpression(v)
          }
        }()
        case 24: try {
          var v: Compiler_Protobuf_V8IntrinsicIdentifier?
          var hadOneofValue = false
          if let current = _storage._expression {
            hadOneofValue = true
            if case .v8IntrinsicIdentifier(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._expression = .v8IntrinsicIdentifier(v)
          }
        }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      switch _storage._expression {
      case .identifier?: try {
        guard case .identifier(let v)? = _storage._expression else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }()
      case .numberLiteral?: try {
        guard case .numberLiteral(let v)? = _storage._expression else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }()
      case .bigIntLiteral?: try {
        guard case .bigIntLiteral(let v)? = _storage._expression else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }()
      case .stringLiteral?: try {
        guard case .stringLiteral(let v)? = _storage._expression else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }()
      case .templateLiteral?: try {
        guard case .templateLiteral(let v)? = _storage._expression else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }()
      case .regExpLiteral?: try {
        guard case .regExpLiteral(let v)? = _storage._expression else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }()
      case .booleanLiteral?: try {
        guard case .booleanLiteral(let v)? = _storage._expression else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }()
      case .nullLiteral?: try {
        guard case .nullLiteral(let v)? = _storage._expression else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }()
      case .thisExpression?: try {
        guard case .thisExpression(let v)? = _storage._expression else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      }()
      case .assignmentExpression?: try {
        guard case .assignmentExpression(let v)? = _storage._expression else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      }()
      case .objectExpression?: try {
        guard case .objectExpression(let v)? = _storage._expression else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      }()
      case .arrayExpression?: try {
        guard case .arrayExpression(let v)? = _storage._expression else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      }()
      case .functionExpression?: try {
        guard case .functionExpression(let v)? = _storage._expression else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      }()
      case .arrowFunctionExpression?: try {
        guard case .arrowFunctionExpression(let v)? = _storage._expression else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      }()
      case .callExpression?: try {
        guard case .callExpression(let v)? = _storage._expression else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      }()
      case .newExpression?: try {
        guard case .newExpression(let v)? = _storage._expression else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      }()
      case .memberExpression?: try {
        guard case .memberExpression(let v)? = _storage._expression else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      }()
      case .unaryExpression?: try {
        guard case .unaryExpression(let v)? = _storage._expression else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      }()
      case .binaryExpression?: try {
        guard case .binaryExpression(let v)? = _storage._expression else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
      }()
      case .updateExpression?: try {
        guard case .updateExpression(let v)? = _storage._expression else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      }()
      case .yieldExpression?: try {
        guard case .yieldExpression(let v)? = _storage._expression else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
      }()
      case .spreadElement?: try {
        guard case .spreadElement(let v)? = _storage._expression else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
      }()
      case .sequenceExpression?: try {
        guard case .sequenceExpression(let v)? = _storage._expression else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 23)
      }()
      case .v8IntrinsicIdentifier?: try {
        guard case .v8IntrinsicIdentifier(let v)? = _storage._expression else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 24)
      }()
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Compiler_Protobuf_Expression, rhs: Compiler_Protobuf_Expression) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._expression != rhs_storage._expression {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
