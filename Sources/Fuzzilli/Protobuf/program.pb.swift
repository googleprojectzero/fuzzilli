// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: program.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// should be in sync with TypeCollectionStatus.swift
public enum Fuzzilli_Protobuf_TypeCollectionStatus: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case success // = 0
  case error // = 1
  case timeout // = 2
  case notattempted // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .success
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .success
    case 1: self = .error
    case 2: self = .timeout
    case 3: self = .notattempted
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .success: return 0
    case .error: return 1
    case .timeout: return 2
    case .notattempted: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Fuzzilli_Protobuf_TypeCollectionStatus: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Fuzzilli_Protobuf_TypeCollectionStatus] = [
    .success,
    .error,
    .timeout,
    .notattempted,
  ]
}

#endif  // swift(>=4.2)

public struct Fuzzilli_Protobuf_Instruction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The operation is either encoded as an index into an OperationTable
  /// (so that shared operations are also only present once in the protobuf)
  /// or is one of the many Operation messages.
  public var inouts: [UInt32] {
    get {return _storage._inouts}
    set {_uniqueStorage()._inouts = newValue}
  }

  public var operation: OneOf_Operation? {
    get {return _storage._operation}
    set {_uniqueStorage()._operation = newValue}
  }

  public var opIdx: UInt32 {
    get {
      if case .opIdx(let v)? = _storage._operation {return v}
      return 0
    }
    set {_uniqueStorage()._operation = .opIdx(newValue)}
  }

  /// TODO fixup keys
  public var loadInteger: Fuzzilli_Protobuf_LoadInteger {
    get {
      if case .loadInteger(let v)? = _storage._operation {return v}
      return Fuzzilli_Protobuf_LoadInteger()
    }
    set {_uniqueStorage()._operation = .loadInteger(newValue)}
  }

  public var loadBigInt: Fuzzilli_Protobuf_LoadBigInt {
    get {
      if case .loadBigInt(let v)? = _storage._operation {return v}
      return Fuzzilli_Protobuf_LoadBigInt()
    }
    set {_uniqueStorage()._operation = .loadBigInt(newValue)}
  }

  public var loadFloat: Fuzzilli_Protobuf_LoadFloat {
    get {
      if case .loadFloat(let v)? = _storage._operation {return v}
      return Fuzzilli_Protobuf_LoadFloat()
    }
    set {_uniqueStorage()._operation = .loadFloat(newValue)}
  }

  public var loadString: Fuzzilli_Protobuf_LoadString {
    get {
      if case .loadString(let v)? = _storage._operation {return v}
      return Fuzzilli_Protobuf_LoadString()
    }
    set {_uniqueStorage()._operation = .loadString(newValue)}
  }

  public var loadBoolean: Fuzzilli_Protobuf_LoadBoolean {
    get {
      if case .loadBoolean(let v)? = _storage._operation {return v}
      return Fuzzilli_Protobuf_LoadBoolean()
    }
    set {_uniqueStorage()._operation = .loadBoolean(newValue)}
  }

  public var loadUndefined: Fuzzilli_Protobuf_LoadUndefined {
    get {
      if case .loadUndefined(let v)? = _storage._operation {return v}
      return Fuzzilli_Protobuf_LoadUndefined()
    }
    set {_uniqueStorage()._operation = .loadUndefined(newValue)}
  }

  public var loadNull: Fuzzilli_Protobuf_LoadNull {
    get {
      if case .loadNull(let v)? = _storage._operation {return v}
      return Fuzzilli_Protobuf_LoadNull()
    }
    set {_uniqueStorage()._operation = .loadNull(newValue)}
  }

  public var loadRegExp: Fuzzilli_Protobuf_LoadRegExp {
    get {
      if case .loadRegExp(let v)? = _storage._operation {return v}
      return Fuzzilli_Protobuf_LoadRegExp()
    }
    set {_uniqueStorage()._operation = .loadRegExp(newValue)}
  }

  public var createObject: Fuzzilli_Protobuf_CreateObject {
    get {
      if case .createObject(let v)? = _storage._operation {return v}
      return Fuzzilli_Protobuf_CreateObject()
    }
    set {_uniqueStorage()._operation = .createObject(newValue)}
  }

  public var createArray: Fuzzilli_Protobuf_CreateArray {
    get {
      if case .createArray(let v)? = _storage._operation {return v}
      return Fuzzilli_Protobuf_CreateArray()
    }
    set {_uniqueStorage()._operation = .createArray(newValue)}
  }

  public var createObjectWithSpread: Fuzzilli_Protobuf_CreateObjectWithSpread {
    get {
      if case .createObjectWithSpread(let v)? = _storage._operation {return v}
      return Fuzzilli_Protobuf_CreateObjectWithSpread()
    }
    set {_uniqueStorage()._operation = .createObjectWithSpread(newValue)}
  }

  public var createArrayWithSpread: Fuzzilli_Protobuf_CreateArrayWithSpread {
    get {
      if case .createArrayWithSpread(let v)? = _storage._operation {return v}
      return Fuzzilli_Protobuf_CreateArrayWithSpread()
    }
    set {_uniqueStorage()._operation = .createArrayWithSpread(newValue)}
  }

  public var loadBuiltin: Fuzzilli_Protobuf_LoadBuiltin {
    get {
      if case .loadBuiltin(let v)? = _storage._operation {return v}
      return Fuzzilli_Protobuf_LoadBuiltin()
    }
    set {_uniqueStorage()._operation = .loadBuiltin(newValue)}
  }

  public var loadProperty: Fuzzilli_Protobuf_LoadProperty {
    get {
      if case .loadProperty(let v)? = _storage._operation {return v}
      return Fuzzilli_Protobuf_LoadProperty()
    }
    set {_uniqueStorage()._operation = .loadProperty(newValue)}
  }

  public var storeProperty: Fuzzilli_Protobuf_StoreProperty {
    get {
      if case .storeProperty(let v)? = _storage._operation {return v}
      return Fuzzilli_Protobuf_StoreProperty()
    }
    set {_uniqueStorage()._operation = .storeProperty(newValue)}
  }

  public var deleteProperty: Fuzzilli_Protobuf_DeleteProperty {
    get {
      if case .deleteProperty(let v)? = _storage._operation {return v}
      return Fuzzilli_Protobuf_DeleteProperty()
    }
    set {_uniqueStorage()._operation = .deleteProperty(newValue)}
  }

  public var loadElement: Fuzzilli_Protobuf_LoadElement {
    get {
      if case .loadElement(let v)? = _storage._operation {return v}
      return Fuzzilli_Protobuf_LoadElement()
    }
    set {_uniqueStorage()._operation = .loadElement(newValue)}
  }

  public var storeElement: Fuzzilli_Protobuf_StoreElement {
    get {
      if case .storeElement(let v)? = _storage._operation {return v}
      return Fuzzilli_Protobuf_StoreElement()
    }
    set {_uniqueStorage()._operation = .storeElement(newValue)}
  }

  public var deleteElement: Fuzzilli_Protobuf_DeleteElement {
    get {
      if case .deleteElement(let v)? = _storage._operation {return v}
      return Fuzzilli_Protobuf_DeleteElement()
    }
    set {_uniqueStorage()._operation = .deleteElement(newValue)}
  }

  public var loadComputedProperty: Fuzzilli_Protobuf_LoadComputedProperty {
    get {
      if case .loadComputedProperty(let v)? = _storage._operation {return v}
      return Fuzzilli_Protobuf_LoadComputedProperty()
    }
    set {_uniqueStorage()._operation = .loadComputedProperty(newValue)}
  }

  public var storeComputedProperty: Fuzzilli_Protobuf_StoreComputedProperty {
    get {
      if case .storeComputedProperty(let v)? = _storage._operation {return v}
      return Fuzzilli_Protobuf_StoreComputedProperty()
    }
    set {_uniqueStorage()._operation = .storeComputedProperty(newValue)}
  }

  public var deleteComputedProperty: Fuzzilli_Protobuf_DeleteComputedProperty {
    get {
      if case .deleteComputedProperty(let v)? = _storage._operation {return v}
      return Fuzzilli_Protobuf_DeleteComputedProperty()
    }
    set {_uniqueStorage()._operation = .deleteComputedProperty(newValue)}
  }

  public var typeOf: Fuzzilli_Protobuf_TypeOf {
    get {
      if case .typeOf(let v)? = _storage._operation {return v}
      return Fuzzilli_Protobuf_TypeOf()
    }
    set {_uniqueStorage()._operation = .typeOf(newValue)}
  }

  public var instanceOf: Fuzzilli_Protobuf_InstanceOf {
    get {
      if case .instanceOf(let v)? = _storage._operation {return v}
      return Fuzzilli_Protobuf_InstanceOf()
    }
    set {_uniqueStorage()._operation = .instanceOf(newValue)}
  }

  public var `in`: Fuzzilli_Protobuf_In {
    get {
      if case .in(let v)? = _storage._operation {return v}
      return Fuzzilli_Protobuf_In()
    }
    set {_uniqueStorage()._operation = .in(newValue)}
  }

  public var beginPlainFunctionDefinition: Fuzzilli_Protobuf_BeginPlainFunctionDefinition {
    get {
      if case .beginPlainFunctionDefinition(let v)? = _storage._operation {return v}
      return Fuzzilli_Protobuf_BeginPlainFunctionDefinition()
    }
    set {_uniqueStorage()._operation = .beginPlainFunctionDefinition(newValue)}
  }

  public var endPlainFunctionDefinition: Fuzzilli_Protobuf_EndPlainFunctionDefinition {
    get {
      if case .endPlainFunctionDefinition(let v)? = _storage._operation {return v}
      return Fuzzilli_Protobuf_EndPlainFunctionDefinition()
    }
    set {_uniqueStorage()._operation = .endPlainFunctionDefinition(newValue)}
  }

  public var beginStrictFunctionDefinition: Fuzzilli_Protobuf_BeginStrictFunctionDefinition {
    get {
      if case .beginStrictFunctionDefinition(let v)? = _storage._operation {return v}
      return Fuzzilli_Protobuf_BeginStrictFunctionDefinition()
    }
    set {_uniqueStorage()._operation = .beginStrictFunctionDefinition(newValue)}
  }

  public var endStrictFunctionDefinition: Fuzzilli_Protobuf_EndStrictFunctionDefinition {
    get {
      if case .endStrictFunctionDefinition(let v)? = _storage._operation {return v}
      return Fuzzilli_Protobuf_EndStrictFunctionDefinition()
    }
    set {_uniqueStorage()._operation = .endStrictFunctionDefinition(newValue)}
  }

  public var beginArrowFunctionDefinition: Fuzzilli_Protobuf_BeginArrowFunctionDefinition {
    get {
      if case .beginArrowFunctionDefinition(let v)? = _storage._operation {return v}
      return Fuzzilli_Protobuf_BeginArrowFunctionDefinition()
    }
    set {_uniqueStorage()._operation = .beginArrowFunctionDefinition(newValue)}
  }

  public var endArrowFunctionDefinition: Fuzzilli_Protobuf_EndArrowFunctionDefinition {
    get {
      if case .endArrowFunctionDefinition(let v)? = _storage._operation {return v}
      return Fuzzilli_Protobuf_EndArrowFunctionDefinition()
    }
    set {_uniqueStorage()._operation = .endArrowFunctionDefinition(newValue)}
  }

  public var beginGeneratorFunctionDefinition: Fuzzilli_Protobuf_BeginGeneratorFunctionDefinition {
    get {
      if case .beginGeneratorFunctionDefinition(let v)? = _storage._operation {return v}
      return Fuzzilli_Protobuf_BeginGeneratorFunctionDefinition()
    }
    set {_uniqueStorage()._operation = .beginGeneratorFunctionDefinition(newValue)}
  }

  public var endGeneratorFunctionDefinition: Fuzzilli_Protobuf_EndGeneratorFunctionDefinition {
    get {
      if case .endGeneratorFunctionDefinition(let v)? = _storage._operation {return v}
      return Fuzzilli_Protobuf_EndGeneratorFunctionDefinition()
    }
    set {_uniqueStorage()._operation = .endGeneratorFunctionDefinition(newValue)}
  }

  public var beginAsyncFunctionDefinition: Fuzzilli_Protobuf_BeginAsyncFunctionDefinition {
    get {
      if case .beginAsyncFunctionDefinition(let v)? = _storage._operation {return v}
      return Fuzzilli_Protobuf_BeginAsyncFunctionDefinition()
    }
    set {_uniqueStorage()._operation = .beginAsyncFunctionDefinition(newValue)}
  }

  public var endAsyncFunctionDefinition: Fuzzilli_Protobuf_EndAsyncFunctionDefinition {
    get {
      if case .endAsyncFunctionDefinition(let v)? = _storage._operation {return v}
      return Fuzzilli_Protobuf_EndAsyncFunctionDefinition()
    }
    set {_uniqueStorage()._operation = .endAsyncFunctionDefinition(newValue)}
  }

  public var beginAsyncArrowFunctionDefinition: Fuzzilli_Protobuf_BeginAsyncArrowFunctionDefinition {
    get {
      if case .beginAsyncArrowFunctionDefinition(let v)? = _storage._operation {return v}
      return Fuzzilli_Protobuf_BeginAsyncArrowFunctionDefinition()
    }
    set {_uniqueStorage()._operation = .beginAsyncArrowFunctionDefinition(newValue)}
  }

  public var endAsyncArrowFunctionDefinition: Fuzzilli_Protobuf_EndAsyncArrowFunctionDefinition {
    get {
      if case .endAsyncArrowFunctionDefinition(let v)? = _storage._operation {return v}
      return Fuzzilli_Protobuf_EndAsyncArrowFunctionDefinition()
    }
    set {_uniqueStorage()._operation = .endAsyncArrowFunctionDefinition(newValue)}
  }

  public var `return`: Fuzzilli_Protobuf_Return {
    get {
      if case .return(let v)? = _storage._operation {return v}
      return Fuzzilli_Protobuf_Return()
    }
    set {_uniqueStorage()._operation = .return(newValue)}
  }

  public var yield: Fuzzilli_Protobuf_Yield {
    get {
      if case .yield(let v)? = _storage._operation {return v}
      return Fuzzilli_Protobuf_Yield()
    }
    set {_uniqueStorage()._operation = .yield(newValue)}
  }

  public var yieldEach: Fuzzilli_Protobuf_YieldEach {
    get {
      if case .yieldEach(let v)? = _storage._operation {return v}
      return Fuzzilli_Protobuf_YieldEach()
    }
    set {_uniqueStorage()._operation = .yieldEach(newValue)}
  }

  public var await: Fuzzilli_Protobuf_Await {
    get {
      if case .await(let v)? = _storage._operation {return v}
      return Fuzzilli_Protobuf_Await()
    }
    set {_uniqueStorage()._operation = .await(newValue)}
  }

  public var callMethod: Fuzzilli_Protobuf_CallMethod {
    get {
      if case .callMethod(let v)? = _storage._operation {return v}
      return Fuzzilli_Protobuf_CallMethod()
    }
    set {_uniqueStorage()._operation = .callMethod(newValue)}
  }

  public var callFunction: Fuzzilli_Protobuf_CallFunction {
    get {
      if case .callFunction(let v)? = _storage._operation {return v}
      return Fuzzilli_Protobuf_CallFunction()
    }
    set {_uniqueStorage()._operation = .callFunction(newValue)}
  }

  public var construct: Fuzzilli_Protobuf_Construct {
    get {
      if case .construct(let v)? = _storage._operation {return v}
      return Fuzzilli_Protobuf_Construct()
    }
    set {_uniqueStorage()._operation = .construct(newValue)}
  }

  public var callFunctionWithSpread: Fuzzilli_Protobuf_CallFunctionWithSpread {
    get {
      if case .callFunctionWithSpread(let v)? = _storage._operation {return v}
      return Fuzzilli_Protobuf_CallFunctionWithSpread()
    }
    set {_uniqueStorage()._operation = .callFunctionWithSpread(newValue)}
  }

  public var unaryOperation: Fuzzilli_Protobuf_UnaryOperation {
    get {
      if case .unaryOperation(let v)? = _storage._operation {return v}
      return Fuzzilli_Protobuf_UnaryOperation()
    }
    set {_uniqueStorage()._operation = .unaryOperation(newValue)}
  }

  public var binaryOperation: Fuzzilli_Protobuf_BinaryOperation {
    get {
      if case .binaryOperation(let v)? = _storage._operation {return v}
      return Fuzzilli_Protobuf_BinaryOperation()
    }
    set {_uniqueStorage()._operation = .binaryOperation(newValue)}
  }

  public var phi: Fuzzilli_Protobuf_Phi {
    get {
      if case .phi(let v)? = _storage._operation {return v}
      return Fuzzilli_Protobuf_Phi()
    }
    set {_uniqueStorage()._operation = .phi(newValue)}
  }

  public var copy: Fuzzilli_Protobuf_Copy {
    get {
      if case .copy(let v)? = _storage._operation {return v}
      return Fuzzilli_Protobuf_Copy()
    }
    set {_uniqueStorage()._operation = .copy(newValue)}
  }

  public var compare: Fuzzilli_Protobuf_Compare {
    get {
      if case .compare(let v)? = _storage._operation {return v}
      return Fuzzilli_Protobuf_Compare()
    }
    set {_uniqueStorage()._operation = .compare(newValue)}
  }

  public var eval: Fuzzilli_Protobuf_Eval {
    get {
      if case .eval(let v)? = _storage._operation {return v}
      return Fuzzilli_Protobuf_Eval()
    }
    set {_uniqueStorage()._operation = .eval(newValue)}
  }

  public var beginWith: Fuzzilli_Protobuf_BeginWith {
    get {
      if case .beginWith(let v)? = _storage._operation {return v}
      return Fuzzilli_Protobuf_BeginWith()
    }
    set {_uniqueStorage()._operation = .beginWith(newValue)}
  }

  public var endWith: Fuzzilli_Protobuf_EndWith {
    get {
      if case .endWith(let v)? = _storage._operation {return v}
      return Fuzzilli_Protobuf_EndWith()
    }
    set {_uniqueStorage()._operation = .endWith(newValue)}
  }

  public var loadFromScope: Fuzzilli_Protobuf_LoadFromScope {
    get {
      if case .loadFromScope(let v)? = _storage._operation {return v}
      return Fuzzilli_Protobuf_LoadFromScope()
    }
    set {_uniqueStorage()._operation = .loadFromScope(newValue)}
  }

  public var storeToScope: Fuzzilli_Protobuf_StoreToScope {
    get {
      if case .storeToScope(let v)? = _storage._operation {return v}
      return Fuzzilli_Protobuf_StoreToScope()
    }
    set {_uniqueStorage()._operation = .storeToScope(newValue)}
  }

  public var beginIf: Fuzzilli_Protobuf_BeginIf {
    get {
      if case .beginIf(let v)? = _storage._operation {return v}
      return Fuzzilli_Protobuf_BeginIf()
    }
    set {_uniqueStorage()._operation = .beginIf(newValue)}
  }

  public var beginElse: Fuzzilli_Protobuf_BeginElse {
    get {
      if case .beginElse(let v)? = _storage._operation {return v}
      return Fuzzilli_Protobuf_BeginElse()
    }
    set {_uniqueStorage()._operation = .beginElse(newValue)}
  }

  public var endIf: Fuzzilli_Protobuf_EndIf {
    get {
      if case .endIf(let v)? = _storage._operation {return v}
      return Fuzzilli_Protobuf_EndIf()
    }
    set {_uniqueStorage()._operation = .endIf(newValue)}
  }

  public var beginWhile: Fuzzilli_Protobuf_BeginWhile {
    get {
      if case .beginWhile(let v)? = _storage._operation {return v}
      return Fuzzilli_Protobuf_BeginWhile()
    }
    set {_uniqueStorage()._operation = .beginWhile(newValue)}
  }

  public var endWhile: Fuzzilli_Protobuf_EndWhile {
    get {
      if case .endWhile(let v)? = _storage._operation {return v}
      return Fuzzilli_Protobuf_EndWhile()
    }
    set {_uniqueStorage()._operation = .endWhile(newValue)}
  }

  public var beginDoWhile: Fuzzilli_Protobuf_BeginDoWhile {
    get {
      if case .beginDoWhile(let v)? = _storage._operation {return v}
      return Fuzzilli_Protobuf_BeginDoWhile()
    }
    set {_uniqueStorage()._operation = .beginDoWhile(newValue)}
  }

  public var endDoWhile: Fuzzilli_Protobuf_EndDoWhile {
    get {
      if case .endDoWhile(let v)? = _storage._operation {return v}
      return Fuzzilli_Protobuf_EndDoWhile()
    }
    set {_uniqueStorage()._operation = .endDoWhile(newValue)}
  }

  public var beginFor: Fuzzilli_Protobuf_BeginFor {
    get {
      if case .beginFor(let v)? = _storage._operation {return v}
      return Fuzzilli_Protobuf_BeginFor()
    }
    set {_uniqueStorage()._operation = .beginFor(newValue)}
  }

  public var endFor: Fuzzilli_Protobuf_EndFor {
    get {
      if case .endFor(let v)? = _storage._operation {return v}
      return Fuzzilli_Protobuf_EndFor()
    }
    set {_uniqueStorage()._operation = .endFor(newValue)}
  }

  public var beginForIn: Fuzzilli_Protobuf_BeginForIn {
    get {
      if case .beginForIn(let v)? = _storage._operation {return v}
      return Fuzzilli_Protobuf_BeginForIn()
    }
    set {_uniqueStorage()._operation = .beginForIn(newValue)}
  }

  public var endForIn: Fuzzilli_Protobuf_EndForIn {
    get {
      if case .endForIn(let v)? = _storage._operation {return v}
      return Fuzzilli_Protobuf_EndForIn()
    }
    set {_uniqueStorage()._operation = .endForIn(newValue)}
  }

  public var beginForOf: Fuzzilli_Protobuf_BeginForOf {
    get {
      if case .beginForOf(let v)? = _storage._operation {return v}
      return Fuzzilli_Protobuf_BeginForOf()
    }
    set {_uniqueStorage()._operation = .beginForOf(newValue)}
  }

  public var endForOf: Fuzzilli_Protobuf_EndForOf {
    get {
      if case .endForOf(let v)? = _storage._operation {return v}
      return Fuzzilli_Protobuf_EndForOf()
    }
    set {_uniqueStorage()._operation = .endForOf(newValue)}
  }

  public var `break`: Fuzzilli_Protobuf_Break {
    get {
      if case .break(let v)? = _storage._operation {return v}
      return Fuzzilli_Protobuf_Break()
    }
    set {_uniqueStorage()._operation = .break(newValue)}
  }

  public var `continue`: Fuzzilli_Protobuf_Continue {
    get {
      if case .continue(let v)? = _storage._operation {return v}
      return Fuzzilli_Protobuf_Continue()
    }
    set {_uniqueStorage()._operation = .continue(newValue)}
  }

  public var beginTry: Fuzzilli_Protobuf_BeginTry {
    get {
      if case .beginTry(let v)? = _storage._operation {return v}
      return Fuzzilli_Protobuf_BeginTry()
    }
    set {_uniqueStorage()._operation = .beginTry(newValue)}
  }

  public var beginCatch: Fuzzilli_Protobuf_BeginCatch {
    get {
      if case .beginCatch(let v)? = _storage._operation {return v}
      return Fuzzilli_Protobuf_BeginCatch()
    }
    set {_uniqueStorage()._operation = .beginCatch(newValue)}
  }

  public var endTryCatch: Fuzzilli_Protobuf_EndTryCatch {
    get {
      if case .endTryCatch(let v)? = _storage._operation {return v}
      return Fuzzilli_Protobuf_EndTryCatch()
    }
    set {_uniqueStorage()._operation = .endTryCatch(newValue)}
  }

  public var throwException: Fuzzilli_Protobuf_ThrowException {
    get {
      if case .throwException(let v)? = _storage._operation {return v}
      return Fuzzilli_Protobuf_ThrowException()
    }
    set {_uniqueStorage()._operation = .throwException(newValue)}
  }

  public var comment: Fuzzilli_Protobuf_Comment {
    get {
      if case .comment(let v)? = _storage._operation {return v}
      return Fuzzilli_Protobuf_Comment()
    }
    set {_uniqueStorage()._operation = .comment(newValue)}
  }

  public var beginCodeString: Fuzzilli_Protobuf_BeginCodeString {
    get {
      if case .beginCodeString(let v)? = _storage._operation {return v}
      return Fuzzilli_Protobuf_BeginCodeString()
    }
    set {_uniqueStorage()._operation = .beginCodeString(newValue)}
  }

  public var endCodeString: Fuzzilli_Protobuf_EndCodeString {
    get {
      if case .endCodeString(let v)? = _storage._operation {return v}
      return Fuzzilli_Protobuf_EndCodeString()
    }
    set {_uniqueStorage()._operation = .endCodeString(newValue)}
  }

  public var nop: Fuzzilli_Protobuf_Nop {
    get {
      if case .nop(let v)? = _storage._operation {return v}
      return Fuzzilli_Protobuf_Nop()
    }
    set {_uniqueStorage()._operation = .nop(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Operation: Equatable {
    case opIdx(UInt32)
    /// TODO fixup keys
    case loadInteger(Fuzzilli_Protobuf_LoadInteger)
    case loadBigInt(Fuzzilli_Protobuf_LoadBigInt)
    case loadFloat(Fuzzilli_Protobuf_LoadFloat)
    case loadString(Fuzzilli_Protobuf_LoadString)
    case loadBoolean(Fuzzilli_Protobuf_LoadBoolean)
    case loadUndefined(Fuzzilli_Protobuf_LoadUndefined)
    case loadNull(Fuzzilli_Protobuf_LoadNull)
    case loadRegExp(Fuzzilli_Protobuf_LoadRegExp)
    case createObject(Fuzzilli_Protobuf_CreateObject)
    case createArray(Fuzzilli_Protobuf_CreateArray)
    case createObjectWithSpread(Fuzzilli_Protobuf_CreateObjectWithSpread)
    case createArrayWithSpread(Fuzzilli_Protobuf_CreateArrayWithSpread)
    case loadBuiltin(Fuzzilli_Protobuf_LoadBuiltin)
    case loadProperty(Fuzzilli_Protobuf_LoadProperty)
    case storeProperty(Fuzzilli_Protobuf_StoreProperty)
    case deleteProperty(Fuzzilli_Protobuf_DeleteProperty)
    case loadElement(Fuzzilli_Protobuf_LoadElement)
    case storeElement(Fuzzilli_Protobuf_StoreElement)
    case deleteElement(Fuzzilli_Protobuf_DeleteElement)
    case loadComputedProperty(Fuzzilli_Protobuf_LoadComputedProperty)
    case storeComputedProperty(Fuzzilli_Protobuf_StoreComputedProperty)
    case deleteComputedProperty(Fuzzilli_Protobuf_DeleteComputedProperty)
    case typeOf(Fuzzilli_Protobuf_TypeOf)
    case instanceOf(Fuzzilli_Protobuf_InstanceOf)
    case `in`(Fuzzilli_Protobuf_In)
    case beginPlainFunctionDefinition(Fuzzilli_Protobuf_BeginPlainFunctionDefinition)
    case endPlainFunctionDefinition(Fuzzilli_Protobuf_EndPlainFunctionDefinition)
    case beginStrictFunctionDefinition(Fuzzilli_Protobuf_BeginStrictFunctionDefinition)
    case endStrictFunctionDefinition(Fuzzilli_Protobuf_EndStrictFunctionDefinition)
    case beginArrowFunctionDefinition(Fuzzilli_Protobuf_BeginArrowFunctionDefinition)
    case endArrowFunctionDefinition(Fuzzilli_Protobuf_EndArrowFunctionDefinition)
    case beginGeneratorFunctionDefinition(Fuzzilli_Protobuf_BeginGeneratorFunctionDefinition)
    case endGeneratorFunctionDefinition(Fuzzilli_Protobuf_EndGeneratorFunctionDefinition)
    case beginAsyncFunctionDefinition(Fuzzilli_Protobuf_BeginAsyncFunctionDefinition)
    case endAsyncFunctionDefinition(Fuzzilli_Protobuf_EndAsyncFunctionDefinition)
    case beginAsyncArrowFunctionDefinition(Fuzzilli_Protobuf_BeginAsyncArrowFunctionDefinition)
    case endAsyncArrowFunctionDefinition(Fuzzilli_Protobuf_EndAsyncArrowFunctionDefinition)
    case `return`(Fuzzilli_Protobuf_Return)
    case yield(Fuzzilli_Protobuf_Yield)
    case yieldEach(Fuzzilli_Protobuf_YieldEach)
    case await(Fuzzilli_Protobuf_Await)
    case callMethod(Fuzzilli_Protobuf_CallMethod)
    case callFunction(Fuzzilli_Protobuf_CallFunction)
    case construct(Fuzzilli_Protobuf_Construct)
    case callFunctionWithSpread(Fuzzilli_Protobuf_CallFunctionWithSpread)
    case unaryOperation(Fuzzilli_Protobuf_UnaryOperation)
    case binaryOperation(Fuzzilli_Protobuf_BinaryOperation)
    case phi(Fuzzilli_Protobuf_Phi)
    case copy(Fuzzilli_Protobuf_Copy)
    case compare(Fuzzilli_Protobuf_Compare)
    case eval(Fuzzilli_Protobuf_Eval)
    case beginWith(Fuzzilli_Protobuf_BeginWith)
    case endWith(Fuzzilli_Protobuf_EndWith)
    case loadFromScope(Fuzzilli_Protobuf_LoadFromScope)
    case storeToScope(Fuzzilli_Protobuf_StoreToScope)
    case beginIf(Fuzzilli_Protobuf_BeginIf)
    case beginElse(Fuzzilli_Protobuf_BeginElse)
    case endIf(Fuzzilli_Protobuf_EndIf)
    case beginWhile(Fuzzilli_Protobuf_BeginWhile)
    case endWhile(Fuzzilli_Protobuf_EndWhile)
    case beginDoWhile(Fuzzilli_Protobuf_BeginDoWhile)
    case endDoWhile(Fuzzilli_Protobuf_EndDoWhile)
    case beginFor(Fuzzilli_Protobuf_BeginFor)
    case endFor(Fuzzilli_Protobuf_EndFor)
    case beginForIn(Fuzzilli_Protobuf_BeginForIn)
    case endForIn(Fuzzilli_Protobuf_EndForIn)
    case beginForOf(Fuzzilli_Protobuf_BeginForOf)
    case endForOf(Fuzzilli_Protobuf_EndForOf)
    case `break`(Fuzzilli_Protobuf_Break)
    case `continue`(Fuzzilli_Protobuf_Continue)
    case beginTry(Fuzzilli_Protobuf_BeginTry)
    case beginCatch(Fuzzilli_Protobuf_BeginCatch)
    case endTryCatch(Fuzzilli_Protobuf_EndTryCatch)
    case throwException(Fuzzilli_Protobuf_ThrowException)
    case comment(Fuzzilli_Protobuf_Comment)
    case beginCodeString(Fuzzilli_Protobuf_BeginCodeString)
    case endCodeString(Fuzzilli_Protobuf_EndCodeString)
    case nop(Fuzzilli_Protobuf_Nop)

  #if !swift(>=4.1)
    public static func ==(lhs: Fuzzilli_Protobuf_Instruction.OneOf_Operation, rhs: Fuzzilli_Protobuf_Instruction.OneOf_Operation) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.opIdx, .opIdx): return {
        guard case .opIdx(let l) = lhs, case .opIdx(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.loadInteger, .loadInteger): return {
        guard case .loadInteger(let l) = lhs, case .loadInteger(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.loadBigInt, .loadBigInt): return {
        guard case .loadBigInt(let l) = lhs, case .loadBigInt(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.loadFloat, .loadFloat): return {
        guard case .loadFloat(let l) = lhs, case .loadFloat(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.loadString, .loadString): return {
        guard case .loadString(let l) = lhs, case .loadString(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.loadBoolean, .loadBoolean): return {
        guard case .loadBoolean(let l) = lhs, case .loadBoolean(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.loadUndefined, .loadUndefined): return {
        guard case .loadUndefined(let l) = lhs, case .loadUndefined(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.loadNull, .loadNull): return {
        guard case .loadNull(let l) = lhs, case .loadNull(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.loadRegExp, .loadRegExp): return {
        guard case .loadRegExp(let l) = lhs, case .loadRegExp(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.createObject, .createObject): return {
        guard case .createObject(let l) = lhs, case .createObject(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.createArray, .createArray): return {
        guard case .createArray(let l) = lhs, case .createArray(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.createObjectWithSpread, .createObjectWithSpread): return {
        guard case .createObjectWithSpread(let l) = lhs, case .createObjectWithSpread(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.createArrayWithSpread, .createArrayWithSpread): return {
        guard case .createArrayWithSpread(let l) = lhs, case .createArrayWithSpread(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.loadBuiltin, .loadBuiltin): return {
        guard case .loadBuiltin(let l) = lhs, case .loadBuiltin(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.loadProperty, .loadProperty): return {
        guard case .loadProperty(let l) = lhs, case .loadProperty(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.storeProperty, .storeProperty): return {
        guard case .storeProperty(let l) = lhs, case .storeProperty(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.deleteProperty, .deleteProperty): return {
        guard case .deleteProperty(let l) = lhs, case .deleteProperty(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.loadElement, .loadElement): return {
        guard case .loadElement(let l) = lhs, case .loadElement(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.storeElement, .storeElement): return {
        guard case .storeElement(let l) = lhs, case .storeElement(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.deleteElement, .deleteElement): return {
        guard case .deleteElement(let l) = lhs, case .deleteElement(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.loadComputedProperty, .loadComputedProperty): return {
        guard case .loadComputedProperty(let l) = lhs, case .loadComputedProperty(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.storeComputedProperty, .storeComputedProperty): return {
        guard case .storeComputedProperty(let l) = lhs, case .storeComputedProperty(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.deleteComputedProperty, .deleteComputedProperty): return {
        guard case .deleteComputedProperty(let l) = lhs, case .deleteComputedProperty(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.typeOf, .typeOf): return {
        guard case .typeOf(let l) = lhs, case .typeOf(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.instanceOf, .instanceOf): return {
        guard case .instanceOf(let l) = lhs, case .instanceOf(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.in, .in): return {
        guard case .in(let l) = lhs, case .in(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.beginPlainFunctionDefinition, .beginPlainFunctionDefinition): return {
        guard case .beginPlainFunctionDefinition(let l) = lhs, case .beginPlainFunctionDefinition(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.endPlainFunctionDefinition, .endPlainFunctionDefinition): return {
        guard case .endPlainFunctionDefinition(let l) = lhs, case .endPlainFunctionDefinition(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.beginStrictFunctionDefinition, .beginStrictFunctionDefinition): return {
        guard case .beginStrictFunctionDefinition(let l) = lhs, case .beginStrictFunctionDefinition(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.endStrictFunctionDefinition, .endStrictFunctionDefinition): return {
        guard case .endStrictFunctionDefinition(let l) = lhs, case .endStrictFunctionDefinition(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.beginArrowFunctionDefinition, .beginArrowFunctionDefinition): return {
        guard case .beginArrowFunctionDefinition(let l) = lhs, case .beginArrowFunctionDefinition(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.endArrowFunctionDefinition, .endArrowFunctionDefinition): return {
        guard case .endArrowFunctionDefinition(let l) = lhs, case .endArrowFunctionDefinition(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.beginGeneratorFunctionDefinition, .beginGeneratorFunctionDefinition): return {
        guard case .beginGeneratorFunctionDefinition(let l) = lhs, case .beginGeneratorFunctionDefinition(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.endGeneratorFunctionDefinition, .endGeneratorFunctionDefinition): return {
        guard case .endGeneratorFunctionDefinition(let l) = lhs, case .endGeneratorFunctionDefinition(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.beginAsyncFunctionDefinition, .beginAsyncFunctionDefinition): return {
        guard case .beginAsyncFunctionDefinition(let l) = lhs, case .beginAsyncFunctionDefinition(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.endAsyncFunctionDefinition, .endAsyncFunctionDefinition): return {
        guard case .endAsyncFunctionDefinition(let l) = lhs, case .endAsyncFunctionDefinition(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.beginAsyncArrowFunctionDefinition, .beginAsyncArrowFunctionDefinition): return {
        guard case .beginAsyncArrowFunctionDefinition(let l) = lhs, case .beginAsyncArrowFunctionDefinition(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.endAsyncArrowFunctionDefinition, .endAsyncArrowFunctionDefinition): return {
        guard case .endAsyncArrowFunctionDefinition(let l) = lhs, case .endAsyncArrowFunctionDefinition(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.return, .return): return {
        guard case .return(let l) = lhs, case .return(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.yield, .yield): return {
        guard case .yield(let l) = lhs, case .yield(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.yieldEach, .yieldEach): return {
        guard case .yieldEach(let l) = lhs, case .yieldEach(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.await, .await): return {
        guard case .await(let l) = lhs, case .await(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.callMethod, .callMethod): return {
        guard case .callMethod(let l) = lhs, case .callMethod(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.callFunction, .callFunction): return {
        guard case .callFunction(let l) = lhs, case .callFunction(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.construct, .construct): return {
        guard case .construct(let l) = lhs, case .construct(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.callFunctionWithSpread, .callFunctionWithSpread): return {
        guard case .callFunctionWithSpread(let l) = lhs, case .callFunctionWithSpread(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.unaryOperation, .unaryOperation): return {
        guard case .unaryOperation(let l) = lhs, case .unaryOperation(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.binaryOperation, .binaryOperation): return {
        guard case .binaryOperation(let l) = lhs, case .binaryOperation(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.phi, .phi): return {
        guard case .phi(let l) = lhs, case .phi(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.copy, .copy): return {
        guard case .copy(let l) = lhs, case .copy(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.compare, .compare): return {
        guard case .compare(let l) = lhs, case .compare(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.eval, .eval): return {
        guard case .eval(let l) = lhs, case .eval(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.beginWith, .beginWith): return {
        guard case .beginWith(let l) = lhs, case .beginWith(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.endWith, .endWith): return {
        guard case .endWith(let l) = lhs, case .endWith(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.loadFromScope, .loadFromScope): return {
        guard case .loadFromScope(let l) = lhs, case .loadFromScope(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.storeToScope, .storeToScope): return {
        guard case .storeToScope(let l) = lhs, case .storeToScope(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.beginIf, .beginIf): return {
        guard case .beginIf(let l) = lhs, case .beginIf(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.beginElse, .beginElse): return {
        guard case .beginElse(let l) = lhs, case .beginElse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.endIf, .endIf): return {
        guard case .endIf(let l) = lhs, case .endIf(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.beginWhile, .beginWhile): return {
        guard case .beginWhile(let l) = lhs, case .beginWhile(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.endWhile, .endWhile): return {
        guard case .endWhile(let l) = lhs, case .endWhile(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.beginDoWhile, .beginDoWhile): return {
        guard case .beginDoWhile(let l) = lhs, case .beginDoWhile(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.endDoWhile, .endDoWhile): return {
        guard case .endDoWhile(let l) = lhs, case .endDoWhile(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.beginFor, .beginFor): return {
        guard case .beginFor(let l) = lhs, case .beginFor(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.endFor, .endFor): return {
        guard case .endFor(let l) = lhs, case .endFor(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.beginForIn, .beginForIn): return {
        guard case .beginForIn(let l) = lhs, case .beginForIn(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.endForIn, .endForIn): return {
        guard case .endForIn(let l) = lhs, case .endForIn(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.beginForOf, .beginForOf): return {
        guard case .beginForOf(let l) = lhs, case .beginForOf(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.endForOf, .endForOf): return {
        guard case .endForOf(let l) = lhs, case .endForOf(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.break, .break): return {
        guard case .break(let l) = lhs, case .break(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.continue, .continue): return {
        guard case .continue(let l) = lhs, case .continue(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.beginTry, .beginTry): return {
        guard case .beginTry(let l) = lhs, case .beginTry(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.beginCatch, .beginCatch): return {
        guard case .beginCatch(let l) = lhs, case .beginCatch(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.endTryCatch, .endTryCatch): return {
        guard case .endTryCatch(let l) = lhs, case .endTryCatch(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.throwException, .throwException): return {
        guard case .throwException(let l) = lhs, case .throwException(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.comment, .comment): return {
        guard case .comment(let l) = lhs, case .comment(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.beginCodeString, .beginCodeString): return {
        guard case .beginCodeString(let l) = lhs, case .beginCodeString(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.endCodeString, .endCodeString): return {
        guard case .endCodeString(let l) = lhs, case .endCodeString(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.nop, .nop): return {
        guard case .nop(let l) = lhs, case .nop(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Fuzzilli_Protobuf_Program {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var instructions: [Fuzzilli_Protobuf_Instruction] = []

  public var runtimeTypes: Dictionary<UInt32,Fuzzilli_Protobuf_Type> = [:]

  public var typeCollectionStatus: Fuzzilli_Protobuf_TypeCollectionStatus = .success

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "fuzzilli.protobuf"

extension Fuzzilli_Protobuf_TypeCollectionStatus: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SUCCESS"),
    1: .same(proto: "ERROR"),
    2: .same(proto: "TIMEOUT"),
    3: .same(proto: "NOTATTEMPTED"),
  ]
}

extension Fuzzilli_Protobuf_Instruction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Instruction"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "inouts"),
    2: .same(proto: "opIdx"),
    5: .same(proto: "loadInteger"),
    76: .same(proto: "loadBigInt"),
    6: .same(proto: "loadFloat"),
    7: .same(proto: "loadString"),
    8: .same(proto: "loadBoolean"),
    9: .same(proto: "loadUndefined"),
    10: .same(proto: "loadNull"),
    77: .same(proto: "loadRegExp"),
    11: .same(proto: "createObject"),
    12: .same(proto: "createArray"),
    13: .same(proto: "createObjectWithSpread"),
    14: .same(proto: "createArrayWithSpread"),
    15: .same(proto: "loadBuiltin"),
    16: .same(proto: "loadProperty"),
    17: .same(proto: "storeProperty"),
    18: .same(proto: "deleteProperty"),
    19: .same(proto: "loadElement"),
    20: .same(proto: "storeElement"),
    21: .same(proto: "deleteElement"),
    22: .same(proto: "loadComputedProperty"),
    23: .same(proto: "storeComputedProperty"),
    24: .same(proto: "deleteComputedProperty"),
    25: .same(proto: "typeOf"),
    26: .same(proto: "instanceOf"),
    27: .same(proto: "in"),
    28: .same(proto: "beginPlainFunctionDefinition"),
    30: .same(proto: "endPlainFunctionDefinition"),
    65: .same(proto: "beginStrictFunctionDefinition"),
    66: .same(proto: "endStrictFunctionDefinition"),
    67: .same(proto: "beginArrowFunctionDefinition"),
    68: .same(proto: "endArrowFunctionDefinition"),
    69: .same(proto: "beginGeneratorFunctionDefinition"),
    70: .same(proto: "endGeneratorFunctionDefinition"),
    71: .same(proto: "beginAsyncFunctionDefinition"),
    72: .same(proto: "endAsyncFunctionDefinition"),
    79: .same(proto: "beginAsyncArrowFunctionDefinition"),
    80: .same(proto: "endAsyncArrowFunctionDefinition"),
    29: .same(proto: "return"),
    73: .same(proto: "yield"),
    74: .same(proto: "yieldEach"),
    75: .same(proto: "await"),
    31: .same(proto: "callMethod"),
    32: .same(proto: "callFunction"),
    33: .same(proto: "construct"),
    34: .same(proto: "callFunctionWithSpread"),
    35: .same(proto: "unaryOperation"),
    36: .same(proto: "binaryOperation"),
    37: .same(proto: "phi"),
    38: .same(proto: "copy"),
    39: .same(proto: "compare"),
    40: .same(proto: "eval"),
    41: .same(proto: "beginWith"),
    42: .same(proto: "endWith"),
    43: .same(proto: "loadFromScope"),
    44: .same(proto: "storeToScope"),
    45: .same(proto: "beginIf"),
    46: .same(proto: "beginElse"),
    47: .same(proto: "endIf"),
    48: .same(proto: "beginWhile"),
    49: .same(proto: "endWhile"),
    50: .same(proto: "beginDoWhile"),
    51: .same(proto: "endDoWhile"),
    52: .same(proto: "beginFor"),
    53: .same(proto: "endFor"),
    54: .same(proto: "beginForIn"),
    55: .same(proto: "endForIn"),
    56: .same(proto: "beginForOf"),
    57: .same(proto: "endForOf"),
    58: .same(proto: "break"),
    59: .same(proto: "continue"),
    60: .same(proto: "beginTry"),
    61: .same(proto: "beginCatch"),
    62: .same(proto: "endTryCatch"),
    63: .same(proto: "throwException"),
    78: .same(proto: "comment"),
    81: .same(proto: "beginCodeString"),
    82: .same(proto: "endCodeString"),
    64: .same(proto: "nop"),
  ]

  fileprivate class _StorageClass {
    var _inouts: [UInt32] = []
    var _operation: Fuzzilli_Protobuf_Instruction.OneOf_Operation?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _inouts = source._inouts
      _operation = source._operation
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeRepeatedUInt32Field(value: &_storage._inouts) }()
        case 2: try {
          if _storage._operation != nil {try decoder.handleConflictingOneOf()}
          var v: UInt32?
          try decoder.decodeSingularUInt32Field(value: &v)
          if let v = v {_storage._operation = .opIdx(v)}
        }()
        case 5: try {
          var v: Fuzzilli_Protobuf_LoadInteger?
          if let current = _storage._operation {
            try decoder.handleConflictingOneOf()
            if case .loadInteger(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._operation = .loadInteger(v)}
        }()
        case 6: try {
          var v: Fuzzilli_Protobuf_LoadFloat?
          if let current = _storage._operation {
            try decoder.handleConflictingOneOf()
            if case .loadFloat(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._operation = .loadFloat(v)}
        }()
        case 7: try {
          var v: Fuzzilli_Protobuf_LoadString?
          if let current = _storage._operation {
            try decoder.handleConflictingOneOf()
            if case .loadString(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._operation = .loadString(v)}
        }()
        case 8: try {
          var v: Fuzzilli_Protobuf_LoadBoolean?
          if let current = _storage._operation {
            try decoder.handleConflictingOneOf()
            if case .loadBoolean(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._operation = .loadBoolean(v)}
        }()
        case 9: try {
          var v: Fuzzilli_Protobuf_LoadUndefined?
          if let current = _storage._operation {
            try decoder.handleConflictingOneOf()
            if case .loadUndefined(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._operation = .loadUndefined(v)}
        }()
        case 10: try {
          var v: Fuzzilli_Protobuf_LoadNull?
          if let current = _storage._operation {
            try decoder.handleConflictingOneOf()
            if case .loadNull(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._operation = .loadNull(v)}
        }()
        case 11: try {
          var v: Fuzzilli_Protobuf_CreateObject?
          if let current = _storage._operation {
            try decoder.handleConflictingOneOf()
            if case .createObject(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._operation = .createObject(v)}
        }()
        case 12: try {
          var v: Fuzzilli_Protobuf_CreateArray?
          if let current = _storage._operation {
            try decoder.handleConflictingOneOf()
            if case .createArray(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._operation = .createArray(v)}
        }()
        case 13: try {
          var v: Fuzzilli_Protobuf_CreateObjectWithSpread?
          if let current = _storage._operation {
            try decoder.handleConflictingOneOf()
            if case .createObjectWithSpread(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._operation = .createObjectWithSpread(v)}
        }()
        case 14: try {
          var v: Fuzzilli_Protobuf_CreateArrayWithSpread?
          if let current = _storage._operation {
            try decoder.handleConflictingOneOf()
            if case .createArrayWithSpread(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._operation = .createArrayWithSpread(v)}
        }()
        case 15: try {
          var v: Fuzzilli_Protobuf_LoadBuiltin?
          if let current = _storage._operation {
            try decoder.handleConflictingOneOf()
            if case .loadBuiltin(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._operation = .loadBuiltin(v)}
        }()
        case 16: try {
          var v: Fuzzilli_Protobuf_LoadProperty?
          if let current = _storage._operation {
            try decoder.handleConflictingOneOf()
            if case .loadProperty(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._operation = .loadProperty(v)}
        }()
        case 17: try {
          var v: Fuzzilli_Protobuf_StoreProperty?
          if let current = _storage._operation {
            try decoder.handleConflictingOneOf()
            if case .storeProperty(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._operation = .storeProperty(v)}
        }()
        case 18: try {
          var v: Fuzzilli_Protobuf_DeleteProperty?
          if let current = _storage._operation {
            try decoder.handleConflictingOneOf()
            if case .deleteProperty(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._operation = .deleteProperty(v)}
        }()
        case 19: try {
          var v: Fuzzilli_Protobuf_LoadElement?
          if let current = _storage._operation {
            try decoder.handleConflictingOneOf()
            if case .loadElement(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._operation = .loadElement(v)}
        }()
        case 20: try {
          var v: Fuzzilli_Protobuf_StoreElement?
          if let current = _storage._operation {
            try decoder.handleConflictingOneOf()
            if case .storeElement(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._operation = .storeElement(v)}
        }()
        case 21: try {
          var v: Fuzzilli_Protobuf_DeleteElement?
          if let current = _storage._operation {
            try decoder.handleConflictingOneOf()
            if case .deleteElement(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._operation = .deleteElement(v)}
        }()
        case 22: try {
          var v: Fuzzilli_Protobuf_LoadComputedProperty?
          if let current = _storage._operation {
            try decoder.handleConflictingOneOf()
            if case .loadComputedProperty(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._operation = .loadComputedProperty(v)}
        }()
        case 23: try {
          var v: Fuzzilli_Protobuf_StoreComputedProperty?
          if let current = _storage._operation {
            try decoder.handleConflictingOneOf()
            if case .storeComputedProperty(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._operation = .storeComputedProperty(v)}
        }()
        case 24: try {
          var v: Fuzzilli_Protobuf_DeleteComputedProperty?
          if let current = _storage._operation {
            try decoder.handleConflictingOneOf()
            if case .deleteComputedProperty(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._operation = .deleteComputedProperty(v)}
        }()
        case 25: try {
          var v: Fuzzilli_Protobuf_TypeOf?
          if let current = _storage._operation {
            try decoder.handleConflictingOneOf()
            if case .typeOf(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._operation = .typeOf(v)}
        }()
        case 26: try {
          var v: Fuzzilli_Protobuf_InstanceOf?
          if let current = _storage._operation {
            try decoder.handleConflictingOneOf()
            if case .instanceOf(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._operation = .instanceOf(v)}
        }()
        case 27: try {
          var v: Fuzzilli_Protobuf_In?
          if let current = _storage._operation {
            try decoder.handleConflictingOneOf()
            if case .in(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._operation = .in(v)}
        }()
        case 28: try {
          var v: Fuzzilli_Protobuf_BeginPlainFunctionDefinition?
          if let current = _storage._operation {
            try decoder.handleConflictingOneOf()
            if case .beginPlainFunctionDefinition(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._operation = .beginPlainFunctionDefinition(v)}
        }()
        case 29: try {
          var v: Fuzzilli_Protobuf_Return?
          if let current = _storage._operation {
            try decoder.handleConflictingOneOf()
            if case .return(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._operation = .return(v)}
        }()
        case 30: try {
          var v: Fuzzilli_Protobuf_EndPlainFunctionDefinition?
          if let current = _storage._operation {
            try decoder.handleConflictingOneOf()
            if case .endPlainFunctionDefinition(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._operation = .endPlainFunctionDefinition(v)}
        }()
        case 31: try {
          var v: Fuzzilli_Protobuf_CallMethod?
          if let current = _storage._operation {
            try decoder.handleConflictingOneOf()
            if case .callMethod(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._operation = .callMethod(v)}
        }()
        case 32: try {
          var v: Fuzzilli_Protobuf_CallFunction?
          if let current = _storage._operation {
            try decoder.handleConflictingOneOf()
            if case .callFunction(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._operation = .callFunction(v)}
        }()
        case 33: try {
          var v: Fuzzilli_Protobuf_Construct?
          if let current = _storage._operation {
            try decoder.handleConflictingOneOf()
            if case .construct(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._operation = .construct(v)}
        }()
        case 34: try {
          var v: Fuzzilli_Protobuf_CallFunctionWithSpread?
          if let current = _storage._operation {
            try decoder.handleConflictingOneOf()
            if case .callFunctionWithSpread(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._operation = .callFunctionWithSpread(v)}
        }()
        case 35: try {
          var v: Fuzzilli_Protobuf_UnaryOperation?
          if let current = _storage._operation {
            try decoder.handleConflictingOneOf()
            if case .unaryOperation(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._operation = .unaryOperation(v)}
        }()
        case 36: try {
          var v: Fuzzilli_Protobuf_BinaryOperation?
          if let current = _storage._operation {
            try decoder.handleConflictingOneOf()
            if case .binaryOperation(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._operation = .binaryOperation(v)}
        }()
        case 37: try {
          var v: Fuzzilli_Protobuf_Phi?
          if let current = _storage._operation {
            try decoder.handleConflictingOneOf()
            if case .phi(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._operation = .phi(v)}
        }()
        case 38: try {
          var v: Fuzzilli_Protobuf_Copy?
          if let current = _storage._operation {
            try decoder.handleConflictingOneOf()
            if case .copy(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._operation = .copy(v)}
        }()
        case 39: try {
          var v: Fuzzilli_Protobuf_Compare?
          if let current = _storage._operation {
            try decoder.handleConflictingOneOf()
            if case .compare(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._operation = .compare(v)}
        }()
        case 40: try {
          var v: Fuzzilli_Protobuf_Eval?
          if let current = _storage._operation {
            try decoder.handleConflictingOneOf()
            if case .eval(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._operation = .eval(v)}
        }()
        case 41: try {
          var v: Fuzzilli_Protobuf_BeginWith?
          if let current = _storage._operation {
            try decoder.handleConflictingOneOf()
            if case .beginWith(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._operation = .beginWith(v)}
        }()
        case 42: try {
          var v: Fuzzilli_Protobuf_EndWith?
          if let current = _storage._operation {
            try decoder.handleConflictingOneOf()
            if case .endWith(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._operation = .endWith(v)}
        }()
        case 43: try {
          var v: Fuzzilli_Protobuf_LoadFromScope?
          if let current = _storage._operation {
            try decoder.handleConflictingOneOf()
            if case .loadFromScope(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._operation = .loadFromScope(v)}
        }()
        case 44: try {
          var v: Fuzzilli_Protobuf_StoreToScope?
          if let current = _storage._operation {
            try decoder.handleConflictingOneOf()
            if case .storeToScope(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._operation = .storeToScope(v)}
        }()
        case 45: try {
          var v: Fuzzilli_Protobuf_BeginIf?
          if let current = _storage._operation {
            try decoder.handleConflictingOneOf()
            if case .beginIf(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._operation = .beginIf(v)}
        }()
        case 46: try {
          var v: Fuzzilli_Protobuf_BeginElse?
          if let current = _storage._operation {
            try decoder.handleConflictingOneOf()
            if case .beginElse(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._operation = .beginElse(v)}
        }()
        case 47: try {
          var v: Fuzzilli_Protobuf_EndIf?
          if let current = _storage._operation {
            try decoder.handleConflictingOneOf()
            if case .endIf(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._operation = .endIf(v)}
        }()
        case 48: try {
          var v: Fuzzilli_Protobuf_BeginWhile?
          if let current = _storage._operation {
            try decoder.handleConflictingOneOf()
            if case .beginWhile(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._operation = .beginWhile(v)}
        }()
        case 49: try {
          var v: Fuzzilli_Protobuf_EndWhile?
          if let current = _storage._operation {
            try decoder.handleConflictingOneOf()
            if case .endWhile(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._operation = .endWhile(v)}
        }()
        case 50: try {
          var v: Fuzzilli_Protobuf_BeginDoWhile?
          if let current = _storage._operation {
            try decoder.handleConflictingOneOf()
            if case .beginDoWhile(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._operation = .beginDoWhile(v)}
        }()
        case 51: try {
          var v: Fuzzilli_Protobuf_EndDoWhile?
          if let current = _storage._operation {
            try decoder.handleConflictingOneOf()
            if case .endDoWhile(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._operation = .endDoWhile(v)}
        }()
        case 52: try {
          var v: Fuzzilli_Protobuf_BeginFor?
          if let current = _storage._operation {
            try decoder.handleConflictingOneOf()
            if case .beginFor(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._operation = .beginFor(v)}
        }()
        case 53: try {
          var v: Fuzzilli_Protobuf_EndFor?
          if let current = _storage._operation {
            try decoder.handleConflictingOneOf()
            if case .endFor(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._operation = .endFor(v)}
        }()
        case 54: try {
          var v: Fuzzilli_Protobuf_BeginForIn?
          if let current = _storage._operation {
            try decoder.handleConflictingOneOf()
            if case .beginForIn(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._operation = .beginForIn(v)}
        }()
        case 55: try {
          var v: Fuzzilli_Protobuf_EndForIn?
          if let current = _storage._operation {
            try decoder.handleConflictingOneOf()
            if case .endForIn(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._operation = .endForIn(v)}
        }()
        case 56: try {
          var v: Fuzzilli_Protobuf_BeginForOf?
          if let current = _storage._operation {
            try decoder.handleConflictingOneOf()
            if case .beginForOf(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._operation = .beginForOf(v)}
        }()
        case 57: try {
          var v: Fuzzilli_Protobuf_EndForOf?
          if let current = _storage._operation {
            try decoder.handleConflictingOneOf()
            if case .endForOf(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._operation = .endForOf(v)}
        }()
        case 58: try {
          var v: Fuzzilli_Protobuf_Break?
          if let current = _storage._operation {
            try decoder.handleConflictingOneOf()
            if case .break(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._operation = .break(v)}
        }()
        case 59: try {
          var v: Fuzzilli_Protobuf_Continue?
          if let current = _storage._operation {
            try decoder.handleConflictingOneOf()
            if case .continue(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._operation = .continue(v)}
        }()
        case 60: try {
          var v: Fuzzilli_Protobuf_BeginTry?
          if let current = _storage._operation {
            try decoder.handleConflictingOneOf()
            if case .beginTry(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._operation = .beginTry(v)}
        }()
        case 61: try {
          var v: Fuzzilli_Protobuf_BeginCatch?
          if let current = _storage._operation {
            try decoder.handleConflictingOneOf()
            if case .beginCatch(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._operation = .beginCatch(v)}
        }()
        case 62: try {
          var v: Fuzzilli_Protobuf_EndTryCatch?
          if let current = _storage._operation {
            try decoder.handleConflictingOneOf()
            if case .endTryCatch(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._operation = .endTryCatch(v)}
        }()
        case 63: try {
          var v: Fuzzilli_Protobuf_ThrowException?
          if let current = _storage._operation {
            try decoder.handleConflictingOneOf()
            if case .throwException(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._operation = .throwException(v)}
        }()
        case 64: try {
          var v: Fuzzilli_Protobuf_Nop?
          if let current = _storage._operation {
            try decoder.handleConflictingOneOf()
            if case .nop(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._operation = .nop(v)}
        }()
        case 65: try {
          var v: Fuzzilli_Protobuf_BeginStrictFunctionDefinition?
          if let current = _storage._operation {
            try decoder.handleConflictingOneOf()
            if case .beginStrictFunctionDefinition(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._operation = .beginStrictFunctionDefinition(v)}
        }()
        case 66: try {
          var v: Fuzzilli_Protobuf_EndStrictFunctionDefinition?
          if let current = _storage._operation {
            try decoder.handleConflictingOneOf()
            if case .endStrictFunctionDefinition(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._operation = .endStrictFunctionDefinition(v)}
        }()
        case 67: try {
          var v: Fuzzilli_Protobuf_BeginArrowFunctionDefinition?
          if let current = _storage._operation {
            try decoder.handleConflictingOneOf()
            if case .beginArrowFunctionDefinition(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._operation = .beginArrowFunctionDefinition(v)}
        }()
        case 68: try {
          var v: Fuzzilli_Protobuf_EndArrowFunctionDefinition?
          if let current = _storage._operation {
            try decoder.handleConflictingOneOf()
            if case .endArrowFunctionDefinition(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._operation = .endArrowFunctionDefinition(v)}
        }()
        case 69: try {
          var v: Fuzzilli_Protobuf_BeginGeneratorFunctionDefinition?
          if let current = _storage._operation {
            try decoder.handleConflictingOneOf()
            if case .beginGeneratorFunctionDefinition(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._operation = .beginGeneratorFunctionDefinition(v)}
        }()
        case 70: try {
          var v: Fuzzilli_Protobuf_EndGeneratorFunctionDefinition?
          if let current = _storage._operation {
            try decoder.handleConflictingOneOf()
            if case .endGeneratorFunctionDefinition(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._operation = .endGeneratorFunctionDefinition(v)}
        }()
        case 71: try {
          var v: Fuzzilli_Protobuf_BeginAsyncFunctionDefinition?
          if let current = _storage._operation {
            try decoder.handleConflictingOneOf()
            if case .beginAsyncFunctionDefinition(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._operation = .beginAsyncFunctionDefinition(v)}
        }()
        case 72: try {
          var v: Fuzzilli_Protobuf_EndAsyncFunctionDefinition?
          if let current = _storage._operation {
            try decoder.handleConflictingOneOf()
            if case .endAsyncFunctionDefinition(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._operation = .endAsyncFunctionDefinition(v)}
        }()
        case 73: try {
          var v: Fuzzilli_Protobuf_Yield?
          if let current = _storage._operation {
            try decoder.handleConflictingOneOf()
            if case .yield(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._operation = .yield(v)}
        }()
        case 74: try {
          var v: Fuzzilli_Protobuf_YieldEach?
          if let current = _storage._operation {
            try decoder.handleConflictingOneOf()
            if case .yieldEach(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._operation = .yieldEach(v)}
        }()
        case 75: try {
          var v: Fuzzilli_Protobuf_Await?
          if let current = _storage._operation {
            try decoder.handleConflictingOneOf()
            if case .await(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._operation = .await(v)}
        }()
        case 76: try {
          var v: Fuzzilli_Protobuf_LoadBigInt?
          if let current = _storage._operation {
            try decoder.handleConflictingOneOf()
            if case .loadBigInt(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._operation = .loadBigInt(v)}
        }()
        case 77: try {
          var v: Fuzzilli_Protobuf_LoadRegExp?
          if let current = _storage._operation {
            try decoder.handleConflictingOneOf()
            if case .loadRegExp(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._operation = .loadRegExp(v)}
        }()
        case 78: try {
          var v: Fuzzilli_Protobuf_Comment?
          if let current = _storage._operation {
            try decoder.handleConflictingOneOf()
            if case .comment(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._operation = .comment(v)}
        }()
        case 79: try {
          var v: Fuzzilli_Protobuf_BeginAsyncArrowFunctionDefinition?
          if let current = _storage._operation {
            try decoder.handleConflictingOneOf()
            if case .beginAsyncArrowFunctionDefinition(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._operation = .beginAsyncArrowFunctionDefinition(v)}
        }()
        case 80: try {
          var v: Fuzzilli_Protobuf_EndAsyncArrowFunctionDefinition?
          if let current = _storage._operation {
            try decoder.handleConflictingOneOf()
            if case .endAsyncArrowFunctionDefinition(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._operation = .endAsyncArrowFunctionDefinition(v)}
        }()
        case 81: try {
          var v: Fuzzilli_Protobuf_BeginCodeString?
          if let current = _storage._operation {
            try decoder.handleConflictingOneOf()
            if case .beginCodeString(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._operation = .beginCodeString(v)}
        }()
        case 82: try {
          var v: Fuzzilli_Protobuf_EndCodeString?
          if let current = _storage._operation {
            try decoder.handleConflictingOneOf()
            if case .endCodeString(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._operation = .endCodeString(v)}
        }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._inouts.isEmpty {
        try visitor.visitPackedUInt32Field(value: _storage._inouts, fieldNumber: 1)
      }
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch _storage._operation {
      case .opIdx?: try {
        guard case .opIdx(let v)? = _storage._operation else { preconditionFailure() }
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
      }()
      case .loadInteger?: try {
        guard case .loadInteger(let v)? = _storage._operation else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }()
      case .loadFloat?: try {
        guard case .loadFloat(let v)? = _storage._operation else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }()
      case .loadString?: try {
        guard case .loadString(let v)? = _storage._operation else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }()
      case .loadBoolean?: try {
        guard case .loadBoolean(let v)? = _storage._operation else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }()
      case .loadUndefined?: try {
        guard case .loadUndefined(let v)? = _storage._operation else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      }()
      case .loadNull?: try {
        guard case .loadNull(let v)? = _storage._operation else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      }()
      case .createObject?: try {
        guard case .createObject(let v)? = _storage._operation else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      }()
      case .createArray?: try {
        guard case .createArray(let v)? = _storage._operation else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      }()
      case .createObjectWithSpread?: try {
        guard case .createObjectWithSpread(let v)? = _storage._operation else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      }()
      case .createArrayWithSpread?: try {
        guard case .createArrayWithSpread(let v)? = _storage._operation else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      }()
      case .loadBuiltin?: try {
        guard case .loadBuiltin(let v)? = _storage._operation else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      }()
      case .loadProperty?: try {
        guard case .loadProperty(let v)? = _storage._operation else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      }()
      case .storeProperty?: try {
        guard case .storeProperty(let v)? = _storage._operation else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      }()
      case .deleteProperty?: try {
        guard case .deleteProperty(let v)? = _storage._operation else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      }()
      case .loadElement?: try {
        guard case .loadElement(let v)? = _storage._operation else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
      }()
      case .storeElement?: try {
        guard case .storeElement(let v)? = _storage._operation else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      }()
      case .deleteElement?: try {
        guard case .deleteElement(let v)? = _storage._operation else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
      }()
      case .loadComputedProperty?: try {
        guard case .loadComputedProperty(let v)? = _storage._operation else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
      }()
      case .storeComputedProperty?: try {
        guard case .storeComputedProperty(let v)? = _storage._operation else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 23)
      }()
      case .deleteComputedProperty?: try {
        guard case .deleteComputedProperty(let v)? = _storage._operation else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 24)
      }()
      case .typeOf?: try {
        guard case .typeOf(let v)? = _storage._operation else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 25)
      }()
      case .instanceOf?: try {
        guard case .instanceOf(let v)? = _storage._operation else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 26)
      }()
      case .in?: try {
        guard case .in(let v)? = _storage._operation else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 27)
      }()
      case .beginPlainFunctionDefinition?: try {
        guard case .beginPlainFunctionDefinition(let v)? = _storage._operation else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 28)
      }()
      case .return?: try {
        guard case .return(let v)? = _storage._operation else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 29)
      }()
      case .endPlainFunctionDefinition?: try {
        guard case .endPlainFunctionDefinition(let v)? = _storage._operation else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 30)
      }()
      case .callMethod?: try {
        guard case .callMethod(let v)? = _storage._operation else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 31)
      }()
      case .callFunction?: try {
        guard case .callFunction(let v)? = _storage._operation else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 32)
      }()
      case .construct?: try {
        guard case .construct(let v)? = _storage._operation else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 33)
      }()
      case .callFunctionWithSpread?: try {
        guard case .callFunctionWithSpread(let v)? = _storage._operation else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 34)
      }()
      case .unaryOperation?: try {
        guard case .unaryOperation(let v)? = _storage._operation else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 35)
      }()
      case .binaryOperation?: try {
        guard case .binaryOperation(let v)? = _storage._operation else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 36)
      }()
      case .phi?: try {
        guard case .phi(let v)? = _storage._operation else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 37)
      }()
      case .copy?: try {
        guard case .copy(let v)? = _storage._operation else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 38)
      }()
      case .compare?: try {
        guard case .compare(let v)? = _storage._operation else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 39)
      }()
      case .eval?: try {
        guard case .eval(let v)? = _storage._operation else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 40)
      }()
      case .beginWith?: try {
        guard case .beginWith(let v)? = _storage._operation else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 41)
      }()
      case .endWith?: try {
        guard case .endWith(let v)? = _storage._operation else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 42)
      }()
      case .loadFromScope?: try {
        guard case .loadFromScope(let v)? = _storage._operation else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 43)
      }()
      case .storeToScope?: try {
        guard case .storeToScope(let v)? = _storage._operation else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 44)
      }()
      case .beginIf?: try {
        guard case .beginIf(let v)? = _storage._operation else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 45)
      }()
      case .beginElse?: try {
        guard case .beginElse(let v)? = _storage._operation else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 46)
      }()
      case .endIf?: try {
        guard case .endIf(let v)? = _storage._operation else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 47)
      }()
      case .beginWhile?: try {
        guard case .beginWhile(let v)? = _storage._operation else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 48)
      }()
      case .endWhile?: try {
        guard case .endWhile(let v)? = _storage._operation else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 49)
      }()
      case .beginDoWhile?: try {
        guard case .beginDoWhile(let v)? = _storage._operation else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 50)
      }()
      case .endDoWhile?: try {
        guard case .endDoWhile(let v)? = _storage._operation else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 51)
      }()
      case .beginFor?: try {
        guard case .beginFor(let v)? = _storage._operation else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 52)
      }()
      case .endFor?: try {
        guard case .endFor(let v)? = _storage._operation else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 53)
      }()
      case .beginForIn?: try {
        guard case .beginForIn(let v)? = _storage._operation else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 54)
      }()
      case .endForIn?: try {
        guard case .endForIn(let v)? = _storage._operation else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 55)
      }()
      case .beginForOf?: try {
        guard case .beginForOf(let v)? = _storage._operation else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 56)
      }()
      case .endForOf?: try {
        guard case .endForOf(let v)? = _storage._operation else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 57)
      }()
      case .break?: try {
        guard case .break(let v)? = _storage._operation else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 58)
      }()
      case .continue?: try {
        guard case .continue(let v)? = _storage._operation else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 59)
      }()
      case .beginTry?: try {
        guard case .beginTry(let v)? = _storage._operation else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 60)
      }()
      case .beginCatch?: try {
        guard case .beginCatch(let v)? = _storage._operation else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 61)
      }()
      case .endTryCatch?: try {
        guard case .endTryCatch(let v)? = _storage._operation else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 62)
      }()
      case .throwException?: try {
        guard case .throwException(let v)? = _storage._operation else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 63)
      }()
      case .nop?: try {
        guard case .nop(let v)? = _storage._operation else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 64)
      }()
      case .beginStrictFunctionDefinition?: try {
        guard case .beginStrictFunctionDefinition(let v)? = _storage._operation else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 65)
      }()
      case .endStrictFunctionDefinition?: try {
        guard case .endStrictFunctionDefinition(let v)? = _storage._operation else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 66)
      }()
      case .beginArrowFunctionDefinition?: try {
        guard case .beginArrowFunctionDefinition(let v)? = _storage._operation else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 67)
      }()
      case .endArrowFunctionDefinition?: try {
        guard case .endArrowFunctionDefinition(let v)? = _storage._operation else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 68)
      }()
      case .beginGeneratorFunctionDefinition?: try {
        guard case .beginGeneratorFunctionDefinition(let v)? = _storage._operation else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 69)
      }()
      case .endGeneratorFunctionDefinition?: try {
        guard case .endGeneratorFunctionDefinition(let v)? = _storage._operation else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 70)
      }()
      case .beginAsyncFunctionDefinition?: try {
        guard case .beginAsyncFunctionDefinition(let v)? = _storage._operation else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 71)
      }()
      case .endAsyncFunctionDefinition?: try {
        guard case .endAsyncFunctionDefinition(let v)? = _storage._operation else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 72)
      }()
      case .yield?: try {
        guard case .yield(let v)? = _storage._operation else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 73)
      }()
      case .yieldEach?: try {
        guard case .yieldEach(let v)? = _storage._operation else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 74)
      }()
      case .await?: try {
        guard case .await(let v)? = _storage._operation else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 75)
      }()
      case .loadBigInt?: try {
        guard case .loadBigInt(let v)? = _storage._operation else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 76)
      }()
      case .loadRegExp?: try {
        guard case .loadRegExp(let v)? = _storage._operation else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 77)
      }()
      case .comment?: try {
        guard case .comment(let v)? = _storage._operation else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 78)
      }()
      case .beginAsyncArrowFunctionDefinition?: try {
        guard case .beginAsyncArrowFunctionDefinition(let v)? = _storage._operation else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 79)
      }()
      case .endAsyncArrowFunctionDefinition?: try {
        guard case .endAsyncArrowFunctionDefinition(let v)? = _storage._operation else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 80)
      }()
      case .beginCodeString?: try {
        guard case .beginCodeString(let v)? = _storage._operation else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 81)
      }()
      case .endCodeString?: try {
        guard case .endCodeString(let v)? = _storage._operation else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 82)
      }()
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Fuzzilli_Protobuf_Instruction, rhs: Fuzzilli_Protobuf_Instruction) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._inouts != rhs_storage._inouts {return false}
        if _storage._operation != rhs_storage._operation {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Fuzzilli_Protobuf_Program: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Program"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "instructions"),
    2: .same(proto: "runtimeTypes"),
    3: .same(proto: "typeCollectionStatus"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.instructions) }()
      case 2: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufUInt32,Fuzzilli_Protobuf_Type>.self, value: &self.runtimeTypes) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.typeCollectionStatus) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.instructions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.instructions, fieldNumber: 1)
    }
    if !self.runtimeTypes.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufUInt32,Fuzzilli_Protobuf_Type>.self, value: self.runtimeTypes, fieldNumber: 2)
    }
    if self.typeCollectionStatus != .success {
      try visitor.visitSingularEnumField(value: self.typeCollectionStatus, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Fuzzilli_Protobuf_Program, rhs: Fuzzilli_Protobuf_Program) -> Bool {
    if lhs.instructions != rhs.instructions {return false}
    if lhs.runtimeTypes != rhs.runtimeTypes {return false}
    if lhs.typeCollectionStatus != rhs.typeCollectionStatus {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
