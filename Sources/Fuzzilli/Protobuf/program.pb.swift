// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: program.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct Fuzzilli_Protobuf_Instruction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The operation is either encoded as an index, referring to the nth operation
  /// (so that shared operations are also only present once in the protobuf), or
  /// as one of the many concrete Operation messages.
  public var inouts: [UInt32] = []

  public var operation: Fuzzilli_Protobuf_Instruction.OneOf_Operation? = nil

  public var opIdx: UInt32 {
    get {
      if case .opIdx(let v)? = operation {return v}
      return 0
    }
    set {operation = .opIdx(newValue)}
  }

  /// TODO fixup keys
  public var loadInteger: Fuzzilli_Protobuf_LoadInteger {
    get {
      if case .loadInteger(let v)? = operation {return v}
      return Fuzzilli_Protobuf_LoadInteger()
    }
    set {operation = .loadInteger(newValue)}
  }

  public var loadBigInt: Fuzzilli_Protobuf_LoadBigInt {
    get {
      if case .loadBigInt(let v)? = operation {return v}
      return Fuzzilli_Protobuf_LoadBigInt()
    }
    set {operation = .loadBigInt(newValue)}
  }

  public var loadFloat: Fuzzilli_Protobuf_LoadFloat {
    get {
      if case .loadFloat(let v)? = operation {return v}
      return Fuzzilli_Protobuf_LoadFloat()
    }
    set {operation = .loadFloat(newValue)}
  }

  public var loadString: Fuzzilli_Protobuf_LoadString {
    get {
      if case .loadString(let v)? = operation {return v}
      return Fuzzilli_Protobuf_LoadString()
    }
    set {operation = .loadString(newValue)}
  }

  public var loadBoolean: Fuzzilli_Protobuf_LoadBoolean {
    get {
      if case .loadBoolean(let v)? = operation {return v}
      return Fuzzilli_Protobuf_LoadBoolean()
    }
    set {operation = .loadBoolean(newValue)}
  }

  public var loadUndefined: Fuzzilli_Protobuf_LoadUndefined {
    get {
      if case .loadUndefined(let v)? = operation {return v}
      return Fuzzilli_Protobuf_LoadUndefined()
    }
    set {operation = .loadUndefined(newValue)}
  }

  public var loadNull: Fuzzilli_Protobuf_LoadNull {
    get {
      if case .loadNull(let v)? = operation {return v}
      return Fuzzilli_Protobuf_LoadNull()
    }
    set {operation = .loadNull(newValue)}
  }

  public var loadThis: Fuzzilli_Protobuf_LoadThis {
    get {
      if case .loadThis(let v)? = operation {return v}
      return Fuzzilli_Protobuf_LoadThis()
    }
    set {operation = .loadThis(newValue)}
  }

  public var loadArguments: Fuzzilli_Protobuf_LoadArguments {
    get {
      if case .loadArguments(let v)? = operation {return v}
      return Fuzzilli_Protobuf_LoadArguments()
    }
    set {operation = .loadArguments(newValue)}
  }

  public var loadRegExp: Fuzzilli_Protobuf_LoadRegExp {
    get {
      if case .loadRegExp(let v)? = operation {return v}
      return Fuzzilli_Protobuf_LoadRegExp()
    }
    set {operation = .loadRegExp(newValue)}
  }

  public var createObject: Fuzzilli_Protobuf_CreateObject {
    get {
      if case .createObject(let v)? = operation {return v}
      return Fuzzilli_Protobuf_CreateObject()
    }
    set {operation = .createObject(newValue)}
  }

  public var createArray: Fuzzilli_Protobuf_CreateArray {
    get {
      if case .createArray(let v)? = operation {return v}
      return Fuzzilli_Protobuf_CreateArray()
    }
    set {operation = .createArray(newValue)}
  }

  public var createTemplateString: Fuzzilli_Protobuf_CreateTemplateString {
    get {
      if case .createTemplateString(let v)? = operation {return v}
      return Fuzzilli_Protobuf_CreateTemplateString()
    }
    set {operation = .createTemplateString(newValue)}
  }

  public var createObjectWithSpread: Fuzzilli_Protobuf_CreateObjectWithSpread {
    get {
      if case .createObjectWithSpread(let v)? = operation {return v}
      return Fuzzilli_Protobuf_CreateObjectWithSpread()
    }
    set {operation = .createObjectWithSpread(newValue)}
  }

  public var createArrayWithSpread: Fuzzilli_Protobuf_CreateArrayWithSpread {
    get {
      if case .createArrayWithSpread(let v)? = operation {return v}
      return Fuzzilli_Protobuf_CreateArrayWithSpread()
    }
    set {operation = .createArrayWithSpread(newValue)}
  }

  public var loadBuiltin: Fuzzilli_Protobuf_LoadBuiltin {
    get {
      if case .loadBuiltin(let v)? = operation {return v}
      return Fuzzilli_Protobuf_LoadBuiltin()
    }
    set {operation = .loadBuiltin(newValue)}
  }

  public var loadProperty: Fuzzilli_Protobuf_LoadProperty {
    get {
      if case .loadProperty(let v)? = operation {return v}
      return Fuzzilli_Protobuf_LoadProperty()
    }
    set {operation = .loadProperty(newValue)}
  }

  public var storeProperty: Fuzzilli_Protobuf_StoreProperty {
    get {
      if case .storeProperty(let v)? = operation {return v}
      return Fuzzilli_Protobuf_StoreProperty()
    }
    set {operation = .storeProperty(newValue)}
  }

  public var storePropertyWithBinop: Fuzzilli_Protobuf_StorePropertyWithBinop {
    get {
      if case .storePropertyWithBinop(let v)? = operation {return v}
      return Fuzzilli_Protobuf_StorePropertyWithBinop()
    }
    set {operation = .storePropertyWithBinop(newValue)}
  }

  public var deleteProperty: Fuzzilli_Protobuf_DeleteProperty {
    get {
      if case .deleteProperty(let v)? = operation {return v}
      return Fuzzilli_Protobuf_DeleteProperty()
    }
    set {operation = .deleteProperty(newValue)}
  }

  public var configureProperty: Fuzzilli_Protobuf_ConfigureProperty {
    get {
      if case .configureProperty(let v)? = operation {return v}
      return Fuzzilli_Protobuf_ConfigureProperty()
    }
    set {operation = .configureProperty(newValue)}
  }

  public var loadElement: Fuzzilli_Protobuf_LoadElement {
    get {
      if case .loadElement(let v)? = operation {return v}
      return Fuzzilli_Protobuf_LoadElement()
    }
    set {operation = .loadElement(newValue)}
  }

  public var storeElement: Fuzzilli_Protobuf_StoreElement {
    get {
      if case .storeElement(let v)? = operation {return v}
      return Fuzzilli_Protobuf_StoreElement()
    }
    set {operation = .storeElement(newValue)}
  }

  public var storeElementWithBinop: Fuzzilli_Protobuf_StoreElementWithBinop {
    get {
      if case .storeElementWithBinop(let v)? = operation {return v}
      return Fuzzilli_Protobuf_StoreElementWithBinop()
    }
    set {operation = .storeElementWithBinop(newValue)}
  }

  public var deleteElement: Fuzzilli_Protobuf_DeleteElement {
    get {
      if case .deleteElement(let v)? = operation {return v}
      return Fuzzilli_Protobuf_DeleteElement()
    }
    set {operation = .deleteElement(newValue)}
  }

  public var configureElement: Fuzzilli_Protobuf_ConfigureElement {
    get {
      if case .configureElement(let v)? = operation {return v}
      return Fuzzilli_Protobuf_ConfigureElement()
    }
    set {operation = .configureElement(newValue)}
  }

  public var loadComputedProperty: Fuzzilli_Protobuf_LoadComputedProperty {
    get {
      if case .loadComputedProperty(let v)? = operation {return v}
      return Fuzzilli_Protobuf_LoadComputedProperty()
    }
    set {operation = .loadComputedProperty(newValue)}
  }

  public var storeComputedProperty: Fuzzilli_Protobuf_StoreComputedProperty {
    get {
      if case .storeComputedProperty(let v)? = operation {return v}
      return Fuzzilli_Protobuf_StoreComputedProperty()
    }
    set {operation = .storeComputedProperty(newValue)}
  }

  public var storeComputedPropertyWithBinop: Fuzzilli_Protobuf_StoreComputedPropertyWithBinop {
    get {
      if case .storeComputedPropertyWithBinop(let v)? = operation {return v}
      return Fuzzilli_Protobuf_StoreComputedPropertyWithBinop()
    }
    set {operation = .storeComputedPropertyWithBinop(newValue)}
  }

  public var deleteComputedProperty: Fuzzilli_Protobuf_DeleteComputedProperty {
    get {
      if case .deleteComputedProperty(let v)? = operation {return v}
      return Fuzzilli_Protobuf_DeleteComputedProperty()
    }
    set {operation = .deleteComputedProperty(newValue)}
  }

  public var configureComputedProperty: Fuzzilli_Protobuf_ConfigureComputedProperty {
    get {
      if case .configureComputedProperty(let v)? = operation {return v}
      return Fuzzilli_Protobuf_ConfigureComputedProperty()
    }
    set {operation = .configureComputedProperty(newValue)}
  }

  public var typeOf: Fuzzilli_Protobuf_TypeOf {
    get {
      if case .typeOf(let v)? = operation {return v}
      return Fuzzilli_Protobuf_TypeOf()
    }
    set {operation = .typeOf(newValue)}
  }

  public var testInstanceOf: Fuzzilli_Protobuf_TestInstanceOf {
    get {
      if case .testInstanceOf(let v)? = operation {return v}
      return Fuzzilli_Protobuf_TestInstanceOf()
    }
    set {operation = .testInstanceOf(newValue)}
  }

  public var testIn: Fuzzilli_Protobuf_TestIn {
    get {
      if case .testIn(let v)? = operation {return v}
      return Fuzzilli_Protobuf_TestIn()
    }
    set {operation = .testIn(newValue)}
  }

  public var beginPlainFunction: Fuzzilli_Protobuf_BeginPlainFunction {
    get {
      if case .beginPlainFunction(let v)? = operation {return v}
      return Fuzzilli_Protobuf_BeginPlainFunction()
    }
    set {operation = .beginPlainFunction(newValue)}
  }

  public var endPlainFunction: Fuzzilli_Protobuf_EndPlainFunction {
    get {
      if case .endPlainFunction(let v)? = operation {return v}
      return Fuzzilli_Protobuf_EndPlainFunction()
    }
    set {operation = .endPlainFunction(newValue)}
  }

  public var beginArrowFunction: Fuzzilli_Protobuf_BeginArrowFunction {
    get {
      if case .beginArrowFunction(let v)? = operation {return v}
      return Fuzzilli_Protobuf_BeginArrowFunction()
    }
    set {operation = .beginArrowFunction(newValue)}
  }

  public var endArrowFunction: Fuzzilli_Protobuf_EndArrowFunction {
    get {
      if case .endArrowFunction(let v)? = operation {return v}
      return Fuzzilli_Protobuf_EndArrowFunction()
    }
    set {operation = .endArrowFunction(newValue)}
  }

  public var beginGeneratorFunction: Fuzzilli_Protobuf_BeginGeneratorFunction {
    get {
      if case .beginGeneratorFunction(let v)? = operation {return v}
      return Fuzzilli_Protobuf_BeginGeneratorFunction()
    }
    set {operation = .beginGeneratorFunction(newValue)}
  }

  public var endGeneratorFunction: Fuzzilli_Protobuf_EndGeneratorFunction {
    get {
      if case .endGeneratorFunction(let v)? = operation {return v}
      return Fuzzilli_Protobuf_EndGeneratorFunction()
    }
    set {operation = .endGeneratorFunction(newValue)}
  }

  public var beginAsyncFunction: Fuzzilli_Protobuf_BeginAsyncFunction {
    get {
      if case .beginAsyncFunction(let v)? = operation {return v}
      return Fuzzilli_Protobuf_BeginAsyncFunction()
    }
    set {operation = .beginAsyncFunction(newValue)}
  }

  public var endAsyncFunction: Fuzzilli_Protobuf_EndAsyncFunction {
    get {
      if case .endAsyncFunction(let v)? = operation {return v}
      return Fuzzilli_Protobuf_EndAsyncFunction()
    }
    set {operation = .endAsyncFunction(newValue)}
  }

  public var beginAsyncArrowFunction: Fuzzilli_Protobuf_BeginAsyncArrowFunction {
    get {
      if case .beginAsyncArrowFunction(let v)? = operation {return v}
      return Fuzzilli_Protobuf_BeginAsyncArrowFunction()
    }
    set {operation = .beginAsyncArrowFunction(newValue)}
  }

  public var endAsyncArrowFunction: Fuzzilli_Protobuf_EndAsyncArrowFunction {
    get {
      if case .endAsyncArrowFunction(let v)? = operation {return v}
      return Fuzzilli_Protobuf_EndAsyncArrowFunction()
    }
    set {operation = .endAsyncArrowFunction(newValue)}
  }

  public var beginAsyncGeneratorFunction: Fuzzilli_Protobuf_BeginAsyncGeneratorFunction {
    get {
      if case .beginAsyncGeneratorFunction(let v)? = operation {return v}
      return Fuzzilli_Protobuf_BeginAsyncGeneratorFunction()
    }
    set {operation = .beginAsyncGeneratorFunction(newValue)}
  }

  public var endAsyncGeneratorFunction: Fuzzilli_Protobuf_EndAsyncGeneratorFunction {
    get {
      if case .endAsyncGeneratorFunction(let v)? = operation {return v}
      return Fuzzilli_Protobuf_EndAsyncGeneratorFunction()
    }
    set {operation = .endAsyncGeneratorFunction(newValue)}
  }

  public var `return`: Fuzzilli_Protobuf_Return {
    get {
      if case .return(let v)? = operation {return v}
      return Fuzzilli_Protobuf_Return()
    }
    set {operation = .return(newValue)}
  }

  public var yield: Fuzzilli_Protobuf_Yield {
    get {
      if case .yield(let v)? = operation {return v}
      return Fuzzilli_Protobuf_Yield()
    }
    set {operation = .yield(newValue)}
  }

  public var yieldEach: Fuzzilli_Protobuf_YieldEach {
    get {
      if case .yieldEach(let v)? = operation {return v}
      return Fuzzilli_Protobuf_YieldEach()
    }
    set {operation = .yieldEach(newValue)}
  }

  public var await: Fuzzilli_Protobuf_Await {
    get {
      if case .await(let v)? = operation {return v}
      return Fuzzilli_Protobuf_Await()
    }
    set {operation = .await(newValue)}
  }

  public var callFunction: Fuzzilli_Protobuf_CallFunction {
    get {
      if case .callFunction(let v)? = operation {return v}
      return Fuzzilli_Protobuf_CallFunction()
    }
    set {operation = .callFunction(newValue)}
  }

  public var callFunctionWithSpread: Fuzzilli_Protobuf_CallFunctionWithSpread {
    get {
      if case .callFunctionWithSpread(let v)? = operation {return v}
      return Fuzzilli_Protobuf_CallFunctionWithSpread()
    }
    set {operation = .callFunctionWithSpread(newValue)}
  }

  public var construct: Fuzzilli_Protobuf_Construct {
    get {
      if case .construct(let v)? = operation {return v}
      return Fuzzilli_Protobuf_Construct()
    }
    set {operation = .construct(newValue)}
  }

  public var constructWithSpread: Fuzzilli_Protobuf_ConstructWithSpread {
    get {
      if case .constructWithSpread(let v)? = operation {return v}
      return Fuzzilli_Protobuf_ConstructWithSpread()
    }
    set {operation = .constructWithSpread(newValue)}
  }

  public var callMethod: Fuzzilli_Protobuf_CallMethod {
    get {
      if case .callMethod(let v)? = operation {return v}
      return Fuzzilli_Protobuf_CallMethod()
    }
    set {operation = .callMethod(newValue)}
  }

  public var callMethodWithSpread: Fuzzilli_Protobuf_CallMethodWithSpread {
    get {
      if case .callMethodWithSpread(let v)? = operation {return v}
      return Fuzzilli_Protobuf_CallMethodWithSpread()
    }
    set {operation = .callMethodWithSpread(newValue)}
  }

  public var callComputedMethod: Fuzzilli_Protobuf_CallComputedMethod {
    get {
      if case .callComputedMethod(let v)? = operation {return v}
      return Fuzzilli_Protobuf_CallComputedMethod()
    }
    set {operation = .callComputedMethod(newValue)}
  }

  public var callComputedMethodWithSpread: Fuzzilli_Protobuf_CallComputedMethodWithSpread {
    get {
      if case .callComputedMethodWithSpread(let v)? = operation {return v}
      return Fuzzilli_Protobuf_CallComputedMethodWithSpread()
    }
    set {operation = .callComputedMethodWithSpread(newValue)}
  }

  public var unaryOperation: Fuzzilli_Protobuf_UnaryOperation {
    get {
      if case .unaryOperation(let v)? = operation {return v}
      return Fuzzilli_Protobuf_UnaryOperation()
    }
    set {operation = .unaryOperation(newValue)}
  }

  public var binaryOperation: Fuzzilli_Protobuf_BinaryOperation {
    get {
      if case .binaryOperation(let v)? = operation {return v}
      return Fuzzilli_Protobuf_BinaryOperation()
    }
    set {operation = .binaryOperation(newValue)}
  }

  public var reassignWithBinop: Fuzzilli_Protobuf_ReassignWithBinop {
    get {
      if case .reassignWithBinop(let v)? = operation {return v}
      return Fuzzilli_Protobuf_ReassignWithBinop()
    }
    set {operation = .reassignWithBinop(newValue)}
  }

  public var dup: Fuzzilli_Protobuf_Dup {
    get {
      if case .dup(let v)? = operation {return v}
      return Fuzzilli_Protobuf_Dup()
    }
    set {operation = .dup(newValue)}
  }

  public var reassign: Fuzzilli_Protobuf_Reassign {
    get {
      if case .reassign(let v)? = operation {return v}
      return Fuzzilli_Protobuf_Reassign()
    }
    set {operation = .reassign(newValue)}
  }

  public var destructArray: Fuzzilli_Protobuf_DestructArray {
    get {
      if case .destructArray(let v)? = operation {return v}
      return Fuzzilli_Protobuf_DestructArray()
    }
    set {operation = .destructArray(newValue)}
  }

  public var destructArrayAndReassign: Fuzzilli_Protobuf_DestructArrayAndReassign {
    get {
      if case .destructArrayAndReassign(let v)? = operation {return v}
      return Fuzzilli_Protobuf_DestructArrayAndReassign()
    }
    set {operation = .destructArrayAndReassign(newValue)}
  }

  public var destructObject: Fuzzilli_Protobuf_DestructObject {
    get {
      if case .destructObject(let v)? = operation {return v}
      return Fuzzilli_Protobuf_DestructObject()
    }
    set {operation = .destructObject(newValue)}
  }

  public var destructObjectAndReassign: Fuzzilli_Protobuf_DestructObjectAndReassign {
    get {
      if case .destructObjectAndReassign(let v)? = operation {return v}
      return Fuzzilli_Protobuf_DestructObjectAndReassign()
    }
    set {operation = .destructObjectAndReassign(newValue)}
  }

  public var compare: Fuzzilli_Protobuf_Compare {
    get {
      if case .compare(let v)? = operation {return v}
      return Fuzzilli_Protobuf_Compare()
    }
    set {operation = .compare(newValue)}
  }

  public var conditionalOperation: Fuzzilli_Protobuf_ConditionalOperation {
    get {
      if case .conditionalOperation(let v)? = operation {return v}
      return Fuzzilli_Protobuf_ConditionalOperation()
    }
    set {operation = .conditionalOperation(newValue)}
  }

  public var eval: Fuzzilli_Protobuf_Eval {
    get {
      if case .eval(let v)? = operation {return v}
      return Fuzzilli_Protobuf_Eval()
    }
    set {operation = .eval(newValue)}
  }

  public var beginClass: Fuzzilli_Protobuf_BeginClass {
    get {
      if case .beginClass(let v)? = operation {return v}
      return Fuzzilli_Protobuf_BeginClass()
    }
    set {operation = .beginClass(newValue)}
  }

  public var beginMethod: Fuzzilli_Protobuf_BeginMethod {
    get {
      if case .beginMethod(let v)? = operation {return v}
      return Fuzzilli_Protobuf_BeginMethod()
    }
    set {operation = .beginMethod(newValue)}
  }

  public var endClass: Fuzzilli_Protobuf_EndClass {
    get {
      if case .endClass(let v)? = operation {return v}
      return Fuzzilli_Protobuf_EndClass()
    }
    set {operation = .endClass(newValue)}
  }

  public var callSuperConstructor: Fuzzilli_Protobuf_CallSuperConstructor {
    get {
      if case .callSuperConstructor(let v)? = operation {return v}
      return Fuzzilli_Protobuf_CallSuperConstructor()
    }
    set {operation = .callSuperConstructor(newValue)}
  }

  public var callSuperMethod: Fuzzilli_Protobuf_CallSuperMethod {
    get {
      if case .callSuperMethod(let v)? = operation {return v}
      return Fuzzilli_Protobuf_CallSuperMethod()
    }
    set {operation = .callSuperMethod(newValue)}
  }

  public var loadSuperProperty: Fuzzilli_Protobuf_LoadSuperProperty {
    get {
      if case .loadSuperProperty(let v)? = operation {return v}
      return Fuzzilli_Protobuf_LoadSuperProperty()
    }
    set {operation = .loadSuperProperty(newValue)}
  }

  public var storeSuperProperty: Fuzzilli_Protobuf_StoreSuperProperty {
    get {
      if case .storeSuperProperty(let v)? = operation {return v}
      return Fuzzilli_Protobuf_StoreSuperProperty()
    }
    set {operation = .storeSuperProperty(newValue)}
  }

  public var storeSuperPropertyWithBinop: Fuzzilli_Protobuf_StoreSuperPropertyWithBinop {
    get {
      if case .storeSuperPropertyWithBinop(let v)? = operation {return v}
      return Fuzzilli_Protobuf_StoreSuperPropertyWithBinop()
    }
    set {operation = .storeSuperPropertyWithBinop(newValue)}
  }

  public var explore: Fuzzilli_Protobuf_Explore {
    get {
      if case .explore(let v)? = operation {return v}
      return Fuzzilli_Protobuf_Explore()
    }
    set {operation = .explore(newValue)}
  }

  public var beginWith: Fuzzilli_Protobuf_BeginWith {
    get {
      if case .beginWith(let v)? = operation {return v}
      return Fuzzilli_Protobuf_BeginWith()
    }
    set {operation = .beginWith(newValue)}
  }

  public var endWith: Fuzzilli_Protobuf_EndWith {
    get {
      if case .endWith(let v)? = operation {return v}
      return Fuzzilli_Protobuf_EndWith()
    }
    set {operation = .endWith(newValue)}
  }

  public var loadFromScope: Fuzzilli_Protobuf_LoadFromScope {
    get {
      if case .loadFromScope(let v)? = operation {return v}
      return Fuzzilli_Protobuf_LoadFromScope()
    }
    set {operation = .loadFromScope(newValue)}
  }

  public var storeToScope: Fuzzilli_Protobuf_StoreToScope {
    get {
      if case .storeToScope(let v)? = operation {return v}
      return Fuzzilli_Protobuf_StoreToScope()
    }
    set {operation = .storeToScope(newValue)}
  }

  public var beginIf: Fuzzilli_Protobuf_BeginIf {
    get {
      if case .beginIf(let v)? = operation {return v}
      return Fuzzilli_Protobuf_BeginIf()
    }
    set {operation = .beginIf(newValue)}
  }

  public var beginElse: Fuzzilli_Protobuf_BeginElse {
    get {
      if case .beginElse(let v)? = operation {return v}
      return Fuzzilli_Protobuf_BeginElse()
    }
    set {operation = .beginElse(newValue)}
  }

  public var endIf: Fuzzilli_Protobuf_EndIf {
    get {
      if case .endIf(let v)? = operation {return v}
      return Fuzzilli_Protobuf_EndIf()
    }
    set {operation = .endIf(newValue)}
  }

  public var beginSwitch: Fuzzilli_Protobuf_BeginSwitch {
    get {
      if case .beginSwitch(let v)? = operation {return v}
      return Fuzzilli_Protobuf_BeginSwitch()
    }
    set {operation = .beginSwitch(newValue)}
  }

  public var beginSwitchCase: Fuzzilli_Protobuf_BeginSwitchCase {
    get {
      if case .beginSwitchCase(let v)? = operation {return v}
      return Fuzzilli_Protobuf_BeginSwitchCase()
    }
    set {operation = .beginSwitchCase(newValue)}
  }

  public var beginSwitchDefaultCase: Fuzzilli_Protobuf_BeginSwitchDefaultCase {
    get {
      if case .beginSwitchDefaultCase(let v)? = operation {return v}
      return Fuzzilli_Protobuf_BeginSwitchDefaultCase()
    }
    set {operation = .beginSwitchDefaultCase(newValue)}
  }

  public var switchBreak: Fuzzilli_Protobuf_SwitchBreak {
    get {
      if case .switchBreak(let v)? = operation {return v}
      return Fuzzilli_Protobuf_SwitchBreak()
    }
    set {operation = .switchBreak(newValue)}
  }

  public var endSwitch: Fuzzilli_Protobuf_EndSwitch {
    get {
      if case .endSwitch(let v)? = operation {return v}
      return Fuzzilli_Protobuf_EndSwitch()
    }
    set {operation = .endSwitch(newValue)}
  }

  public var endSwitchCase: Fuzzilli_Protobuf_EndSwitchCase {
    get {
      if case .endSwitchCase(let v)? = operation {return v}
      return Fuzzilli_Protobuf_EndSwitchCase()
    }
    set {operation = .endSwitchCase(newValue)}
  }

  public var beginWhile: Fuzzilli_Protobuf_BeginWhile {
    get {
      if case .beginWhile(let v)? = operation {return v}
      return Fuzzilli_Protobuf_BeginWhile()
    }
    set {operation = .beginWhile(newValue)}
  }

  public var endWhile: Fuzzilli_Protobuf_EndWhile {
    get {
      if case .endWhile(let v)? = operation {return v}
      return Fuzzilli_Protobuf_EndWhile()
    }
    set {operation = .endWhile(newValue)}
  }

  public var beginDoWhile: Fuzzilli_Protobuf_BeginDoWhile {
    get {
      if case .beginDoWhile(let v)? = operation {return v}
      return Fuzzilli_Protobuf_BeginDoWhile()
    }
    set {operation = .beginDoWhile(newValue)}
  }

  public var endDoWhile: Fuzzilli_Protobuf_EndDoWhile {
    get {
      if case .endDoWhile(let v)? = operation {return v}
      return Fuzzilli_Protobuf_EndDoWhile()
    }
    set {operation = .endDoWhile(newValue)}
  }

  public var beginFor: Fuzzilli_Protobuf_BeginFor {
    get {
      if case .beginFor(let v)? = operation {return v}
      return Fuzzilli_Protobuf_BeginFor()
    }
    set {operation = .beginFor(newValue)}
  }

  public var endFor: Fuzzilli_Protobuf_EndFor {
    get {
      if case .endFor(let v)? = operation {return v}
      return Fuzzilli_Protobuf_EndFor()
    }
    set {operation = .endFor(newValue)}
  }

  public var beginForIn: Fuzzilli_Protobuf_BeginForIn {
    get {
      if case .beginForIn(let v)? = operation {return v}
      return Fuzzilli_Protobuf_BeginForIn()
    }
    set {operation = .beginForIn(newValue)}
  }

  public var endForIn: Fuzzilli_Protobuf_EndForIn {
    get {
      if case .endForIn(let v)? = operation {return v}
      return Fuzzilli_Protobuf_EndForIn()
    }
    set {operation = .endForIn(newValue)}
  }

  public var beginForOf: Fuzzilli_Protobuf_BeginForOf {
    get {
      if case .beginForOf(let v)? = operation {return v}
      return Fuzzilli_Protobuf_BeginForOf()
    }
    set {operation = .beginForOf(newValue)}
  }

  public var beginForOfWithDestruct: Fuzzilli_Protobuf_BeginForOfWithDestruct {
    get {
      if case .beginForOfWithDestruct(let v)? = operation {return v}
      return Fuzzilli_Protobuf_BeginForOfWithDestruct()
    }
    set {operation = .beginForOfWithDestruct(newValue)}
  }

  public var endForOf: Fuzzilli_Protobuf_EndForOf {
    get {
      if case .endForOf(let v)? = operation {return v}
      return Fuzzilli_Protobuf_EndForOf()
    }
    set {operation = .endForOf(newValue)}
  }

  public var loopBreak: Fuzzilli_Protobuf_LoopBreak {
    get {
      if case .loopBreak(let v)? = operation {return v}
      return Fuzzilli_Protobuf_LoopBreak()
    }
    set {operation = .loopBreak(newValue)}
  }

  public var loopContinue: Fuzzilli_Protobuf_LoopContinue {
    get {
      if case .loopContinue(let v)? = operation {return v}
      return Fuzzilli_Protobuf_LoopContinue()
    }
    set {operation = .loopContinue(newValue)}
  }

  public var beginTry: Fuzzilli_Protobuf_BeginTry {
    get {
      if case .beginTry(let v)? = operation {return v}
      return Fuzzilli_Protobuf_BeginTry()
    }
    set {operation = .beginTry(newValue)}
  }

  public var beginCatch: Fuzzilli_Protobuf_BeginCatch {
    get {
      if case .beginCatch(let v)? = operation {return v}
      return Fuzzilli_Protobuf_BeginCatch()
    }
    set {operation = .beginCatch(newValue)}
  }

  public var beginFinally: Fuzzilli_Protobuf_BeginFinally {
    get {
      if case .beginFinally(let v)? = operation {return v}
      return Fuzzilli_Protobuf_BeginFinally()
    }
    set {operation = .beginFinally(newValue)}
  }

  public var endTryCatch: Fuzzilli_Protobuf_EndTryCatch {
    get {
      if case .endTryCatch(let v)? = operation {return v}
      return Fuzzilli_Protobuf_EndTryCatch()
    }
    set {operation = .endTryCatch(newValue)}
  }

  public var throwException: Fuzzilli_Protobuf_ThrowException {
    get {
      if case .throwException(let v)? = operation {return v}
      return Fuzzilli_Protobuf_ThrowException()
    }
    set {operation = .throwException(newValue)}
  }

  public var beginCodeString: Fuzzilli_Protobuf_BeginCodeString {
    get {
      if case .beginCodeString(let v)? = operation {return v}
      return Fuzzilli_Protobuf_BeginCodeString()
    }
    set {operation = .beginCodeString(newValue)}
  }

  public var endCodeString: Fuzzilli_Protobuf_EndCodeString {
    get {
      if case .endCodeString(let v)? = operation {return v}
      return Fuzzilli_Protobuf_EndCodeString()
    }
    set {operation = .endCodeString(newValue)}
  }

  public var beginBlockStatement: Fuzzilli_Protobuf_BeginBlockStatement {
    get {
      if case .beginBlockStatement(let v)? = operation {return v}
      return Fuzzilli_Protobuf_BeginBlockStatement()
    }
    set {operation = .beginBlockStatement(newValue)}
  }

  public var endBlockStatement: Fuzzilli_Protobuf_EndBlockStatement {
    get {
      if case .endBlockStatement(let v)? = operation {return v}
      return Fuzzilli_Protobuf_EndBlockStatement()
    }
    set {operation = .endBlockStatement(newValue)}
  }

  public var nop: Fuzzilli_Protobuf_Nop {
    get {
      if case .nop(let v)? = operation {return v}
      return Fuzzilli_Protobuf_Nop()
    }
    set {operation = .nop(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Operation: Equatable {
    case opIdx(UInt32)
    /// TODO fixup keys
    case loadInteger(Fuzzilli_Protobuf_LoadInteger)
    case loadBigInt(Fuzzilli_Protobuf_LoadBigInt)
    case loadFloat(Fuzzilli_Protobuf_LoadFloat)
    case loadString(Fuzzilli_Protobuf_LoadString)
    case loadBoolean(Fuzzilli_Protobuf_LoadBoolean)
    case loadUndefined(Fuzzilli_Protobuf_LoadUndefined)
    case loadNull(Fuzzilli_Protobuf_LoadNull)
    case loadThis(Fuzzilli_Protobuf_LoadThis)
    case loadArguments(Fuzzilli_Protobuf_LoadArguments)
    case loadRegExp(Fuzzilli_Protobuf_LoadRegExp)
    case createObject(Fuzzilli_Protobuf_CreateObject)
    case createArray(Fuzzilli_Protobuf_CreateArray)
    case createTemplateString(Fuzzilli_Protobuf_CreateTemplateString)
    case createObjectWithSpread(Fuzzilli_Protobuf_CreateObjectWithSpread)
    case createArrayWithSpread(Fuzzilli_Protobuf_CreateArrayWithSpread)
    case loadBuiltin(Fuzzilli_Protobuf_LoadBuiltin)
    case loadProperty(Fuzzilli_Protobuf_LoadProperty)
    case storeProperty(Fuzzilli_Protobuf_StoreProperty)
    case storePropertyWithBinop(Fuzzilli_Protobuf_StorePropertyWithBinop)
    case deleteProperty(Fuzzilli_Protobuf_DeleteProperty)
    case configureProperty(Fuzzilli_Protobuf_ConfigureProperty)
    case loadElement(Fuzzilli_Protobuf_LoadElement)
    case storeElement(Fuzzilli_Protobuf_StoreElement)
    case storeElementWithBinop(Fuzzilli_Protobuf_StoreElementWithBinop)
    case deleteElement(Fuzzilli_Protobuf_DeleteElement)
    case configureElement(Fuzzilli_Protobuf_ConfigureElement)
    case loadComputedProperty(Fuzzilli_Protobuf_LoadComputedProperty)
    case storeComputedProperty(Fuzzilli_Protobuf_StoreComputedProperty)
    case storeComputedPropertyWithBinop(Fuzzilli_Protobuf_StoreComputedPropertyWithBinop)
    case deleteComputedProperty(Fuzzilli_Protobuf_DeleteComputedProperty)
    case configureComputedProperty(Fuzzilli_Protobuf_ConfigureComputedProperty)
    case typeOf(Fuzzilli_Protobuf_TypeOf)
    case testInstanceOf(Fuzzilli_Protobuf_TestInstanceOf)
    case testIn(Fuzzilli_Protobuf_TestIn)
    case beginPlainFunction(Fuzzilli_Protobuf_BeginPlainFunction)
    case endPlainFunction(Fuzzilli_Protobuf_EndPlainFunction)
    case beginArrowFunction(Fuzzilli_Protobuf_BeginArrowFunction)
    case endArrowFunction(Fuzzilli_Protobuf_EndArrowFunction)
    case beginGeneratorFunction(Fuzzilli_Protobuf_BeginGeneratorFunction)
    case endGeneratorFunction(Fuzzilli_Protobuf_EndGeneratorFunction)
    case beginAsyncFunction(Fuzzilli_Protobuf_BeginAsyncFunction)
    case endAsyncFunction(Fuzzilli_Protobuf_EndAsyncFunction)
    case beginAsyncArrowFunction(Fuzzilli_Protobuf_BeginAsyncArrowFunction)
    case endAsyncArrowFunction(Fuzzilli_Protobuf_EndAsyncArrowFunction)
    case beginAsyncGeneratorFunction(Fuzzilli_Protobuf_BeginAsyncGeneratorFunction)
    case endAsyncGeneratorFunction(Fuzzilli_Protobuf_EndAsyncGeneratorFunction)
    case `return`(Fuzzilli_Protobuf_Return)
    case yield(Fuzzilli_Protobuf_Yield)
    case yieldEach(Fuzzilli_Protobuf_YieldEach)
    case await(Fuzzilli_Protobuf_Await)
    case callFunction(Fuzzilli_Protobuf_CallFunction)
    case callFunctionWithSpread(Fuzzilli_Protobuf_CallFunctionWithSpread)
    case construct(Fuzzilli_Protobuf_Construct)
    case constructWithSpread(Fuzzilli_Protobuf_ConstructWithSpread)
    case callMethod(Fuzzilli_Protobuf_CallMethod)
    case callMethodWithSpread(Fuzzilli_Protobuf_CallMethodWithSpread)
    case callComputedMethod(Fuzzilli_Protobuf_CallComputedMethod)
    case callComputedMethodWithSpread(Fuzzilli_Protobuf_CallComputedMethodWithSpread)
    case unaryOperation(Fuzzilli_Protobuf_UnaryOperation)
    case binaryOperation(Fuzzilli_Protobuf_BinaryOperation)
    case reassignWithBinop(Fuzzilli_Protobuf_ReassignWithBinop)
    case dup(Fuzzilli_Protobuf_Dup)
    case reassign(Fuzzilli_Protobuf_Reassign)
    case destructArray(Fuzzilli_Protobuf_DestructArray)
    case destructArrayAndReassign(Fuzzilli_Protobuf_DestructArrayAndReassign)
    case destructObject(Fuzzilli_Protobuf_DestructObject)
    case destructObjectAndReassign(Fuzzilli_Protobuf_DestructObjectAndReassign)
    case compare(Fuzzilli_Protobuf_Compare)
    case conditionalOperation(Fuzzilli_Protobuf_ConditionalOperation)
    case eval(Fuzzilli_Protobuf_Eval)
    case beginClass(Fuzzilli_Protobuf_BeginClass)
    case beginMethod(Fuzzilli_Protobuf_BeginMethod)
    case endClass(Fuzzilli_Protobuf_EndClass)
    case callSuperConstructor(Fuzzilli_Protobuf_CallSuperConstructor)
    case callSuperMethod(Fuzzilli_Protobuf_CallSuperMethod)
    case loadSuperProperty(Fuzzilli_Protobuf_LoadSuperProperty)
    case storeSuperProperty(Fuzzilli_Protobuf_StoreSuperProperty)
    case storeSuperPropertyWithBinop(Fuzzilli_Protobuf_StoreSuperPropertyWithBinop)
    case explore(Fuzzilli_Protobuf_Explore)
    case beginWith(Fuzzilli_Protobuf_BeginWith)
    case endWith(Fuzzilli_Protobuf_EndWith)
    case loadFromScope(Fuzzilli_Protobuf_LoadFromScope)
    case storeToScope(Fuzzilli_Protobuf_StoreToScope)
    case beginIf(Fuzzilli_Protobuf_BeginIf)
    case beginElse(Fuzzilli_Protobuf_BeginElse)
    case endIf(Fuzzilli_Protobuf_EndIf)
    case beginSwitch(Fuzzilli_Protobuf_BeginSwitch)
    case beginSwitchCase(Fuzzilli_Protobuf_BeginSwitchCase)
    case beginSwitchDefaultCase(Fuzzilli_Protobuf_BeginSwitchDefaultCase)
    case switchBreak(Fuzzilli_Protobuf_SwitchBreak)
    case endSwitch(Fuzzilli_Protobuf_EndSwitch)
    case endSwitchCase(Fuzzilli_Protobuf_EndSwitchCase)
    case beginWhile(Fuzzilli_Protobuf_BeginWhile)
    case endWhile(Fuzzilli_Protobuf_EndWhile)
    case beginDoWhile(Fuzzilli_Protobuf_BeginDoWhile)
    case endDoWhile(Fuzzilli_Protobuf_EndDoWhile)
    case beginFor(Fuzzilli_Protobuf_BeginFor)
    case endFor(Fuzzilli_Protobuf_EndFor)
    case beginForIn(Fuzzilli_Protobuf_BeginForIn)
    case endForIn(Fuzzilli_Protobuf_EndForIn)
    case beginForOf(Fuzzilli_Protobuf_BeginForOf)
    case beginForOfWithDestruct(Fuzzilli_Protobuf_BeginForOfWithDestruct)
    case endForOf(Fuzzilli_Protobuf_EndForOf)
    case loopBreak(Fuzzilli_Protobuf_LoopBreak)
    case loopContinue(Fuzzilli_Protobuf_LoopContinue)
    case beginTry(Fuzzilli_Protobuf_BeginTry)
    case beginCatch(Fuzzilli_Protobuf_BeginCatch)
    case beginFinally(Fuzzilli_Protobuf_BeginFinally)
    case endTryCatch(Fuzzilli_Protobuf_EndTryCatch)
    case throwException(Fuzzilli_Protobuf_ThrowException)
    case beginCodeString(Fuzzilli_Protobuf_BeginCodeString)
    case endCodeString(Fuzzilli_Protobuf_EndCodeString)
    case beginBlockStatement(Fuzzilli_Protobuf_BeginBlockStatement)
    case endBlockStatement(Fuzzilli_Protobuf_EndBlockStatement)
    case nop(Fuzzilli_Protobuf_Nop)

  #if !swift(>=4.1)
    public static func ==(lhs: Fuzzilli_Protobuf_Instruction.OneOf_Operation, rhs: Fuzzilli_Protobuf_Instruction.OneOf_Operation) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.opIdx, .opIdx): return {
        guard case .opIdx(let l) = lhs, case .opIdx(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.loadInteger, .loadInteger): return {
        guard case .loadInteger(let l) = lhs, case .loadInteger(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.loadBigInt, .loadBigInt): return {
        guard case .loadBigInt(let l) = lhs, case .loadBigInt(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.loadFloat, .loadFloat): return {
        guard case .loadFloat(let l) = lhs, case .loadFloat(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.loadString, .loadString): return {
        guard case .loadString(let l) = lhs, case .loadString(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.loadBoolean, .loadBoolean): return {
        guard case .loadBoolean(let l) = lhs, case .loadBoolean(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.loadUndefined, .loadUndefined): return {
        guard case .loadUndefined(let l) = lhs, case .loadUndefined(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.loadNull, .loadNull): return {
        guard case .loadNull(let l) = lhs, case .loadNull(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.loadThis, .loadThis): return {
        guard case .loadThis(let l) = lhs, case .loadThis(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.loadArguments, .loadArguments): return {
        guard case .loadArguments(let l) = lhs, case .loadArguments(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.loadRegExp, .loadRegExp): return {
        guard case .loadRegExp(let l) = lhs, case .loadRegExp(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.createObject, .createObject): return {
        guard case .createObject(let l) = lhs, case .createObject(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.createArray, .createArray): return {
        guard case .createArray(let l) = lhs, case .createArray(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.createTemplateString, .createTemplateString): return {
        guard case .createTemplateString(let l) = lhs, case .createTemplateString(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.createObjectWithSpread, .createObjectWithSpread): return {
        guard case .createObjectWithSpread(let l) = lhs, case .createObjectWithSpread(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.createArrayWithSpread, .createArrayWithSpread): return {
        guard case .createArrayWithSpread(let l) = lhs, case .createArrayWithSpread(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.loadBuiltin, .loadBuiltin): return {
        guard case .loadBuiltin(let l) = lhs, case .loadBuiltin(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.loadProperty, .loadProperty): return {
        guard case .loadProperty(let l) = lhs, case .loadProperty(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.storeProperty, .storeProperty): return {
        guard case .storeProperty(let l) = lhs, case .storeProperty(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.storePropertyWithBinop, .storePropertyWithBinop): return {
        guard case .storePropertyWithBinop(let l) = lhs, case .storePropertyWithBinop(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.deleteProperty, .deleteProperty): return {
        guard case .deleteProperty(let l) = lhs, case .deleteProperty(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.configureProperty, .configureProperty): return {
        guard case .configureProperty(let l) = lhs, case .configureProperty(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.loadElement, .loadElement): return {
        guard case .loadElement(let l) = lhs, case .loadElement(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.storeElement, .storeElement): return {
        guard case .storeElement(let l) = lhs, case .storeElement(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.storeElementWithBinop, .storeElementWithBinop): return {
        guard case .storeElementWithBinop(let l) = lhs, case .storeElementWithBinop(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.deleteElement, .deleteElement): return {
        guard case .deleteElement(let l) = lhs, case .deleteElement(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.configureElement, .configureElement): return {
        guard case .configureElement(let l) = lhs, case .configureElement(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.loadComputedProperty, .loadComputedProperty): return {
        guard case .loadComputedProperty(let l) = lhs, case .loadComputedProperty(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.storeComputedProperty, .storeComputedProperty): return {
        guard case .storeComputedProperty(let l) = lhs, case .storeComputedProperty(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.storeComputedPropertyWithBinop, .storeComputedPropertyWithBinop): return {
        guard case .storeComputedPropertyWithBinop(let l) = lhs, case .storeComputedPropertyWithBinop(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.deleteComputedProperty, .deleteComputedProperty): return {
        guard case .deleteComputedProperty(let l) = lhs, case .deleteComputedProperty(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.configureComputedProperty, .configureComputedProperty): return {
        guard case .configureComputedProperty(let l) = lhs, case .configureComputedProperty(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.typeOf, .typeOf): return {
        guard case .typeOf(let l) = lhs, case .typeOf(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.testInstanceOf, .testInstanceOf): return {
        guard case .testInstanceOf(let l) = lhs, case .testInstanceOf(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.testIn, .testIn): return {
        guard case .testIn(let l) = lhs, case .testIn(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.beginPlainFunction, .beginPlainFunction): return {
        guard case .beginPlainFunction(let l) = lhs, case .beginPlainFunction(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.endPlainFunction, .endPlainFunction): return {
        guard case .endPlainFunction(let l) = lhs, case .endPlainFunction(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.beginArrowFunction, .beginArrowFunction): return {
        guard case .beginArrowFunction(let l) = lhs, case .beginArrowFunction(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.endArrowFunction, .endArrowFunction): return {
        guard case .endArrowFunction(let l) = lhs, case .endArrowFunction(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.beginGeneratorFunction, .beginGeneratorFunction): return {
        guard case .beginGeneratorFunction(let l) = lhs, case .beginGeneratorFunction(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.endGeneratorFunction, .endGeneratorFunction): return {
        guard case .endGeneratorFunction(let l) = lhs, case .endGeneratorFunction(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.beginAsyncFunction, .beginAsyncFunction): return {
        guard case .beginAsyncFunction(let l) = lhs, case .beginAsyncFunction(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.endAsyncFunction, .endAsyncFunction): return {
        guard case .endAsyncFunction(let l) = lhs, case .endAsyncFunction(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.beginAsyncArrowFunction, .beginAsyncArrowFunction): return {
        guard case .beginAsyncArrowFunction(let l) = lhs, case .beginAsyncArrowFunction(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.endAsyncArrowFunction, .endAsyncArrowFunction): return {
        guard case .endAsyncArrowFunction(let l) = lhs, case .endAsyncArrowFunction(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.beginAsyncGeneratorFunction, .beginAsyncGeneratorFunction): return {
        guard case .beginAsyncGeneratorFunction(let l) = lhs, case .beginAsyncGeneratorFunction(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.endAsyncGeneratorFunction, .endAsyncGeneratorFunction): return {
        guard case .endAsyncGeneratorFunction(let l) = lhs, case .endAsyncGeneratorFunction(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.return, .return): return {
        guard case .return(let l) = lhs, case .return(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.yield, .yield): return {
        guard case .yield(let l) = lhs, case .yield(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.yieldEach, .yieldEach): return {
        guard case .yieldEach(let l) = lhs, case .yieldEach(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.await, .await): return {
        guard case .await(let l) = lhs, case .await(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.callFunction, .callFunction): return {
        guard case .callFunction(let l) = lhs, case .callFunction(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.callFunctionWithSpread, .callFunctionWithSpread): return {
        guard case .callFunctionWithSpread(let l) = lhs, case .callFunctionWithSpread(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.construct, .construct): return {
        guard case .construct(let l) = lhs, case .construct(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.constructWithSpread, .constructWithSpread): return {
        guard case .constructWithSpread(let l) = lhs, case .constructWithSpread(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.callMethod, .callMethod): return {
        guard case .callMethod(let l) = lhs, case .callMethod(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.callMethodWithSpread, .callMethodWithSpread): return {
        guard case .callMethodWithSpread(let l) = lhs, case .callMethodWithSpread(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.callComputedMethod, .callComputedMethod): return {
        guard case .callComputedMethod(let l) = lhs, case .callComputedMethod(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.callComputedMethodWithSpread, .callComputedMethodWithSpread): return {
        guard case .callComputedMethodWithSpread(let l) = lhs, case .callComputedMethodWithSpread(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.unaryOperation, .unaryOperation): return {
        guard case .unaryOperation(let l) = lhs, case .unaryOperation(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.binaryOperation, .binaryOperation): return {
        guard case .binaryOperation(let l) = lhs, case .binaryOperation(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.reassignWithBinop, .reassignWithBinop): return {
        guard case .reassignWithBinop(let l) = lhs, case .reassignWithBinop(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.dup, .dup): return {
        guard case .dup(let l) = lhs, case .dup(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.reassign, .reassign): return {
        guard case .reassign(let l) = lhs, case .reassign(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.destructArray, .destructArray): return {
        guard case .destructArray(let l) = lhs, case .destructArray(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.destructArrayAndReassign, .destructArrayAndReassign): return {
        guard case .destructArrayAndReassign(let l) = lhs, case .destructArrayAndReassign(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.destructObject, .destructObject): return {
        guard case .destructObject(let l) = lhs, case .destructObject(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.destructObjectAndReassign, .destructObjectAndReassign): return {
        guard case .destructObjectAndReassign(let l) = lhs, case .destructObjectAndReassign(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.compare, .compare): return {
        guard case .compare(let l) = lhs, case .compare(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.conditionalOperation, .conditionalOperation): return {
        guard case .conditionalOperation(let l) = lhs, case .conditionalOperation(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.eval, .eval): return {
        guard case .eval(let l) = lhs, case .eval(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.beginClass, .beginClass): return {
        guard case .beginClass(let l) = lhs, case .beginClass(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.beginMethod, .beginMethod): return {
        guard case .beginMethod(let l) = lhs, case .beginMethod(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.endClass, .endClass): return {
        guard case .endClass(let l) = lhs, case .endClass(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.callSuperConstructor, .callSuperConstructor): return {
        guard case .callSuperConstructor(let l) = lhs, case .callSuperConstructor(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.callSuperMethod, .callSuperMethod): return {
        guard case .callSuperMethod(let l) = lhs, case .callSuperMethod(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.loadSuperProperty, .loadSuperProperty): return {
        guard case .loadSuperProperty(let l) = lhs, case .loadSuperProperty(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.storeSuperProperty, .storeSuperProperty): return {
        guard case .storeSuperProperty(let l) = lhs, case .storeSuperProperty(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.storeSuperPropertyWithBinop, .storeSuperPropertyWithBinop): return {
        guard case .storeSuperPropertyWithBinop(let l) = lhs, case .storeSuperPropertyWithBinop(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.explore, .explore): return {
        guard case .explore(let l) = lhs, case .explore(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.beginWith, .beginWith): return {
        guard case .beginWith(let l) = lhs, case .beginWith(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.endWith, .endWith): return {
        guard case .endWith(let l) = lhs, case .endWith(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.loadFromScope, .loadFromScope): return {
        guard case .loadFromScope(let l) = lhs, case .loadFromScope(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.storeToScope, .storeToScope): return {
        guard case .storeToScope(let l) = lhs, case .storeToScope(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.beginIf, .beginIf): return {
        guard case .beginIf(let l) = lhs, case .beginIf(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.beginElse, .beginElse): return {
        guard case .beginElse(let l) = lhs, case .beginElse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.endIf, .endIf): return {
        guard case .endIf(let l) = lhs, case .endIf(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.beginSwitch, .beginSwitch): return {
        guard case .beginSwitch(let l) = lhs, case .beginSwitch(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.beginSwitchCase, .beginSwitchCase): return {
        guard case .beginSwitchCase(let l) = lhs, case .beginSwitchCase(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.beginSwitchDefaultCase, .beginSwitchDefaultCase): return {
        guard case .beginSwitchDefaultCase(let l) = lhs, case .beginSwitchDefaultCase(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.switchBreak, .switchBreak): return {
        guard case .switchBreak(let l) = lhs, case .switchBreak(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.endSwitch, .endSwitch): return {
        guard case .endSwitch(let l) = lhs, case .endSwitch(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.endSwitchCase, .endSwitchCase): return {
        guard case .endSwitchCase(let l) = lhs, case .endSwitchCase(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.beginWhile, .beginWhile): return {
        guard case .beginWhile(let l) = lhs, case .beginWhile(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.endWhile, .endWhile): return {
        guard case .endWhile(let l) = lhs, case .endWhile(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.beginDoWhile, .beginDoWhile): return {
        guard case .beginDoWhile(let l) = lhs, case .beginDoWhile(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.endDoWhile, .endDoWhile): return {
        guard case .endDoWhile(let l) = lhs, case .endDoWhile(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.beginFor, .beginFor): return {
        guard case .beginFor(let l) = lhs, case .beginFor(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.endFor, .endFor): return {
        guard case .endFor(let l) = lhs, case .endFor(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.beginForIn, .beginForIn): return {
        guard case .beginForIn(let l) = lhs, case .beginForIn(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.endForIn, .endForIn): return {
        guard case .endForIn(let l) = lhs, case .endForIn(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.beginForOf, .beginForOf): return {
        guard case .beginForOf(let l) = lhs, case .beginForOf(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.beginForOfWithDestruct, .beginForOfWithDestruct): return {
        guard case .beginForOfWithDestruct(let l) = lhs, case .beginForOfWithDestruct(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.endForOf, .endForOf): return {
        guard case .endForOf(let l) = lhs, case .endForOf(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.loopBreak, .loopBreak): return {
        guard case .loopBreak(let l) = lhs, case .loopBreak(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.loopContinue, .loopContinue): return {
        guard case .loopContinue(let l) = lhs, case .loopContinue(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.beginTry, .beginTry): return {
        guard case .beginTry(let l) = lhs, case .beginTry(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.beginCatch, .beginCatch): return {
        guard case .beginCatch(let l) = lhs, case .beginCatch(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.beginFinally, .beginFinally): return {
        guard case .beginFinally(let l) = lhs, case .beginFinally(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.endTryCatch, .endTryCatch): return {
        guard case .endTryCatch(let l) = lhs, case .endTryCatch(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.throwException, .throwException): return {
        guard case .throwException(let l) = lhs, case .throwException(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.beginCodeString, .beginCodeString): return {
        guard case .beginCodeString(let l) = lhs, case .beginCodeString(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.endCodeString, .endCodeString): return {
        guard case .endCodeString(let l) = lhs, case .endCodeString(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.beginBlockStatement, .beginBlockStatement): return {
        guard case .beginBlockStatement(let l) = lhs, case .beginBlockStatement(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.endBlockStatement, .endBlockStatement): return {
        guard case .endBlockStatement(let l) = lhs, case .endBlockStatement(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.nop, .nop): return {
        guard case .nop(let l) = lhs, case .nop(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

public struct Fuzzilli_Protobuf_Program {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var uuid: Data {
    get {return _storage._uuid}
    set {_uniqueStorage()._uuid = newValue}
  }

  public var code: [Fuzzilli_Protobuf_Instruction] {
    get {return _storage._code}
    set {_uniqueStorage()._code = newValue}
  }

  public var comments: Dictionary<Int32,String> {
    get {return _storage._comments}
    set {_uniqueStorage()._comments = newValue}
  }

  public var parent: Fuzzilli_Protobuf_Program {
    get {return _storage._parent ?? Fuzzilli_Protobuf_Program()}
    set {_uniqueStorage()._parent = newValue}
  }
  /// Returns true if `parent` has been explicitly set.
  public var hasParent: Bool {return _storage._parent != nil}
  /// Clears the value of `parent`. Subsequent reads from it will return its default value.
  public mutating func clearParent() {_uniqueStorage()._parent = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Fuzzilli_Protobuf_Instruction: @unchecked Sendable {}
extension Fuzzilli_Protobuf_Instruction.OneOf_Operation: @unchecked Sendable {}
extension Fuzzilli_Protobuf_Program: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "fuzzilli.protobuf"

extension Fuzzilli_Protobuf_Instruction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Instruction"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "inouts"),
    2: .same(proto: "opIdx"),
    5: .same(proto: "loadInteger"),
    76: .same(proto: "loadBigInt"),
    6: .same(proto: "loadFloat"),
    7: .same(proto: "loadString"),
    8: .same(proto: "loadBoolean"),
    9: .same(proto: "loadUndefined"),
    10: .same(proto: "loadNull"),
    65: .same(proto: "loadThis"),
    66: .same(proto: "loadArguments"),
    77: .same(proto: "loadRegExp"),
    11: .same(proto: "createObject"),
    12: .same(proto: "createArray"),
    102: .same(proto: "createTemplateString"),
    13: .same(proto: "createObjectWithSpread"),
    14: .same(proto: "createArrayWithSpread"),
    15: .same(proto: "loadBuiltin"),
    16: .same(proto: "loadProperty"),
    17: .same(proto: "storeProperty"),
    112: .same(proto: "storePropertyWithBinop"),
    18: .same(proto: "deleteProperty"),
    127: .same(proto: "configureProperty"),
    19: .same(proto: "loadElement"),
    20: .same(proto: "storeElement"),
    113: .same(proto: "storeElementWithBinop"),
    21: .same(proto: "deleteElement"),
    128: .same(proto: "configureElement"),
    22: .same(proto: "loadComputedProperty"),
    23: .same(proto: "storeComputedProperty"),
    114: .same(proto: "storeComputedPropertyWithBinop"),
    24: .same(proto: "deleteComputedProperty"),
    129: .same(proto: "configureComputedProperty"),
    25: .same(proto: "typeOf"),
    26: .same(proto: "testInstanceOf"),
    27: .same(proto: "testIn"),
    28: .same(proto: "beginPlainFunction"),
    30: .same(proto: "endPlainFunction"),
    67: .same(proto: "beginArrowFunction"),
    68: .same(proto: "endArrowFunction"),
    69: .same(proto: "beginGeneratorFunction"),
    70: .same(proto: "endGeneratorFunction"),
    71: .same(proto: "beginAsyncFunction"),
    72: .same(proto: "endAsyncFunction"),
    79: .same(proto: "beginAsyncArrowFunction"),
    80: .same(proto: "endAsyncArrowFunction"),
    85: .same(proto: "beginAsyncGeneratorFunction"),
    86: .same(proto: "endAsyncGeneratorFunction"),
    29: .same(proto: "return"),
    73: .same(proto: "yield"),
    74: .same(proto: "yieldEach"),
    75: .same(proto: "await"),
    32: .same(proto: "callFunction"),
    120: .same(proto: "callFunctionWithSpread"),
    33: .same(proto: "construct"),
    121: .same(proto: "constructWithSpread"),
    31: .same(proto: "callMethod"),
    122: .same(proto: "callMethodWithSpread"),
    34: .same(proto: "callComputedMethod"),
    123: .same(proto: "callComputedMethodWithSpread"),
    35: .same(proto: "unaryOperation"),
    36: .same(proto: "binaryOperation"),
    95: .same(proto: "reassignWithBinop"),
    37: .same(proto: "dup"),
    38: .same(proto: "reassign"),
    116: .same(proto: "destructArray"),
    117: .same(proto: "destructArrayAndReassign"),
    118: .same(proto: "destructObject"),
    119: .same(proto: "destructObjectAndReassign"),
    39: .same(proto: "compare"),
    96: .same(proto: "conditionalOperation"),
    40: .same(proto: "eval"),
    87: .same(proto: "beginClass"),
    88: .same(proto: "beginMethod"),
    89: .same(proto: "endClass"),
    90: .same(proto: "callSuperConstructor"),
    91: .same(proto: "callSuperMethod"),
    92: .same(proto: "loadSuperProperty"),
    93: .same(proto: "storeSuperProperty"),
    115: .same(proto: "storeSuperPropertyWithBinop"),
    124: .same(proto: "explore"),
    41: .same(proto: "beginWith"),
    42: .same(proto: "endWith"),
    43: .same(proto: "loadFromScope"),
    44: .same(proto: "storeToScope"),
    45: .same(proto: "beginIf"),
    46: .same(proto: "beginElse"),
    47: .same(proto: "endIf"),
    97: .same(proto: "beginSwitch"),
    98: .same(proto: "beginSwitchCase"),
    126: .same(proto: "beginSwitchDefaultCase"),
    104: .same(proto: "switchBreak"),
    99: .same(proto: "endSwitch"),
    125: .same(proto: "endSwitchCase"),
    48: .same(proto: "beginWhile"),
    49: .same(proto: "endWhile"),
    50: .same(proto: "beginDoWhile"),
    51: .same(proto: "endDoWhile"),
    52: .same(proto: "beginFor"),
    53: .same(proto: "endFor"),
    54: .same(proto: "beginForIn"),
    55: .same(proto: "endForIn"),
    56: .same(proto: "beginForOf"),
    103: .same(proto: "beginForOfWithDestruct"),
    57: .same(proto: "endForOf"),
    58: .same(proto: "loopBreak"),
    59: .same(proto: "loopContinue"),
    60: .same(proto: "beginTry"),
    61: .same(proto: "beginCatch"),
    94: .same(proto: "beginFinally"),
    62: .same(proto: "endTryCatch"),
    63: .same(proto: "throwException"),
    81: .same(proto: "beginCodeString"),
    82: .same(proto: "endCodeString"),
    83: .same(proto: "beginBlockStatement"),
    84: .same(proto: "endBlockStatement"),
    64: .same(proto: "nop"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedUInt32Field(value: &self.inouts) }()
      case 2: try {
        var v: UInt32?
        try decoder.decodeSingularUInt32Field(value: &v)
        if let v = v {
          if self.operation != nil {try decoder.handleConflictingOneOf()}
          self.operation = .opIdx(v)
        }
      }()
      case 5: try {
        var v: Fuzzilli_Protobuf_LoadInteger?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .loadInteger(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .loadInteger(v)
        }
      }()
      case 6: try {
        var v: Fuzzilli_Protobuf_LoadFloat?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .loadFloat(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .loadFloat(v)
        }
      }()
      case 7: try {
        var v: Fuzzilli_Protobuf_LoadString?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .loadString(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .loadString(v)
        }
      }()
      case 8: try {
        var v: Fuzzilli_Protobuf_LoadBoolean?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .loadBoolean(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .loadBoolean(v)
        }
      }()
      case 9: try {
        var v: Fuzzilli_Protobuf_LoadUndefined?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .loadUndefined(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .loadUndefined(v)
        }
      }()
      case 10: try {
        var v: Fuzzilli_Protobuf_LoadNull?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .loadNull(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .loadNull(v)
        }
      }()
      case 11: try {
        var v: Fuzzilli_Protobuf_CreateObject?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .createObject(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .createObject(v)
        }
      }()
      case 12: try {
        var v: Fuzzilli_Protobuf_CreateArray?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .createArray(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .createArray(v)
        }
      }()
      case 13: try {
        var v: Fuzzilli_Protobuf_CreateObjectWithSpread?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .createObjectWithSpread(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .createObjectWithSpread(v)
        }
      }()
      case 14: try {
        var v: Fuzzilli_Protobuf_CreateArrayWithSpread?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .createArrayWithSpread(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .createArrayWithSpread(v)
        }
      }()
      case 15: try {
        var v: Fuzzilli_Protobuf_LoadBuiltin?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .loadBuiltin(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .loadBuiltin(v)
        }
      }()
      case 16: try {
        var v: Fuzzilli_Protobuf_LoadProperty?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .loadProperty(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .loadProperty(v)
        }
      }()
      case 17: try {
        var v: Fuzzilli_Protobuf_StoreProperty?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .storeProperty(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .storeProperty(v)
        }
      }()
      case 18: try {
        var v: Fuzzilli_Protobuf_DeleteProperty?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .deleteProperty(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .deleteProperty(v)
        }
      }()
      case 19: try {
        var v: Fuzzilli_Protobuf_LoadElement?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .loadElement(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .loadElement(v)
        }
      }()
      case 20: try {
        var v: Fuzzilli_Protobuf_StoreElement?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .storeElement(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .storeElement(v)
        }
      }()
      case 21: try {
        var v: Fuzzilli_Protobuf_DeleteElement?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .deleteElement(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .deleteElement(v)
        }
      }()
      case 22: try {
        var v: Fuzzilli_Protobuf_LoadComputedProperty?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .loadComputedProperty(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .loadComputedProperty(v)
        }
      }()
      case 23: try {
        var v: Fuzzilli_Protobuf_StoreComputedProperty?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .storeComputedProperty(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .storeComputedProperty(v)
        }
      }()
      case 24: try {
        var v: Fuzzilli_Protobuf_DeleteComputedProperty?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .deleteComputedProperty(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .deleteComputedProperty(v)
        }
      }()
      case 25: try {
        var v: Fuzzilli_Protobuf_TypeOf?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .typeOf(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .typeOf(v)
        }
      }()
      case 26: try {
        var v: Fuzzilli_Protobuf_TestInstanceOf?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .testInstanceOf(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .testInstanceOf(v)
        }
      }()
      case 27: try {
        var v: Fuzzilli_Protobuf_TestIn?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .testIn(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .testIn(v)
        }
      }()
      case 28: try {
        var v: Fuzzilli_Protobuf_BeginPlainFunction?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .beginPlainFunction(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .beginPlainFunction(v)
        }
      }()
      case 29: try {
        var v: Fuzzilli_Protobuf_Return?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .return(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .return(v)
        }
      }()
      case 30: try {
        var v: Fuzzilli_Protobuf_EndPlainFunction?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .endPlainFunction(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .endPlainFunction(v)
        }
      }()
      case 31: try {
        var v: Fuzzilli_Protobuf_CallMethod?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .callMethod(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .callMethod(v)
        }
      }()
      case 32: try {
        var v: Fuzzilli_Protobuf_CallFunction?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .callFunction(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .callFunction(v)
        }
      }()
      case 33: try {
        var v: Fuzzilli_Protobuf_Construct?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .construct(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .construct(v)
        }
      }()
      case 34: try {
        var v: Fuzzilli_Protobuf_CallComputedMethod?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .callComputedMethod(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .callComputedMethod(v)
        }
      }()
      case 35: try {
        var v: Fuzzilli_Protobuf_UnaryOperation?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .unaryOperation(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .unaryOperation(v)
        }
      }()
      case 36: try {
        var v: Fuzzilli_Protobuf_BinaryOperation?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .binaryOperation(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .binaryOperation(v)
        }
      }()
      case 37: try {
        var v: Fuzzilli_Protobuf_Dup?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .dup(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .dup(v)
        }
      }()
      case 38: try {
        var v: Fuzzilli_Protobuf_Reassign?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .reassign(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .reassign(v)
        }
      }()
      case 39: try {
        var v: Fuzzilli_Protobuf_Compare?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .compare(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .compare(v)
        }
      }()
      case 40: try {
        var v: Fuzzilli_Protobuf_Eval?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .eval(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .eval(v)
        }
      }()
      case 41: try {
        var v: Fuzzilli_Protobuf_BeginWith?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .beginWith(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .beginWith(v)
        }
      }()
      case 42: try {
        var v: Fuzzilli_Protobuf_EndWith?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .endWith(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .endWith(v)
        }
      }()
      case 43: try {
        var v: Fuzzilli_Protobuf_LoadFromScope?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .loadFromScope(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .loadFromScope(v)
        }
      }()
      case 44: try {
        var v: Fuzzilli_Protobuf_StoreToScope?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .storeToScope(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .storeToScope(v)
        }
      }()
      case 45: try {
        var v: Fuzzilli_Protobuf_BeginIf?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .beginIf(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .beginIf(v)
        }
      }()
      case 46: try {
        var v: Fuzzilli_Protobuf_BeginElse?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .beginElse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .beginElse(v)
        }
      }()
      case 47: try {
        var v: Fuzzilli_Protobuf_EndIf?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .endIf(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .endIf(v)
        }
      }()
      case 48: try {
        var v: Fuzzilli_Protobuf_BeginWhile?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .beginWhile(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .beginWhile(v)
        }
      }()
      case 49: try {
        var v: Fuzzilli_Protobuf_EndWhile?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .endWhile(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .endWhile(v)
        }
      }()
      case 50: try {
        var v: Fuzzilli_Protobuf_BeginDoWhile?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .beginDoWhile(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .beginDoWhile(v)
        }
      }()
      case 51: try {
        var v: Fuzzilli_Protobuf_EndDoWhile?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .endDoWhile(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .endDoWhile(v)
        }
      }()
      case 52: try {
        var v: Fuzzilli_Protobuf_BeginFor?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .beginFor(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .beginFor(v)
        }
      }()
      case 53: try {
        var v: Fuzzilli_Protobuf_EndFor?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .endFor(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .endFor(v)
        }
      }()
      case 54: try {
        var v: Fuzzilli_Protobuf_BeginForIn?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .beginForIn(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .beginForIn(v)
        }
      }()
      case 55: try {
        var v: Fuzzilli_Protobuf_EndForIn?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .endForIn(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .endForIn(v)
        }
      }()
      case 56: try {
        var v: Fuzzilli_Protobuf_BeginForOf?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .beginForOf(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .beginForOf(v)
        }
      }()
      case 57: try {
        var v: Fuzzilli_Protobuf_EndForOf?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .endForOf(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .endForOf(v)
        }
      }()
      case 58: try {
        var v: Fuzzilli_Protobuf_LoopBreak?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .loopBreak(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .loopBreak(v)
        }
      }()
      case 59: try {
        var v: Fuzzilli_Protobuf_LoopContinue?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .loopContinue(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .loopContinue(v)
        }
      }()
      case 60: try {
        var v: Fuzzilli_Protobuf_BeginTry?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .beginTry(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .beginTry(v)
        }
      }()
      case 61: try {
        var v: Fuzzilli_Protobuf_BeginCatch?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .beginCatch(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .beginCatch(v)
        }
      }()
      case 62: try {
        var v: Fuzzilli_Protobuf_EndTryCatch?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .endTryCatch(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .endTryCatch(v)
        }
      }()
      case 63: try {
        var v: Fuzzilli_Protobuf_ThrowException?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .throwException(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .throwException(v)
        }
      }()
      case 64: try {
        var v: Fuzzilli_Protobuf_Nop?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .nop(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .nop(v)
        }
      }()
      case 65: try {
        var v: Fuzzilli_Protobuf_LoadThis?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .loadThis(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .loadThis(v)
        }
      }()
      case 66: try {
        var v: Fuzzilli_Protobuf_LoadArguments?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .loadArguments(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .loadArguments(v)
        }
      }()
      case 67: try {
        var v: Fuzzilli_Protobuf_BeginArrowFunction?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .beginArrowFunction(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .beginArrowFunction(v)
        }
      }()
      case 68: try {
        var v: Fuzzilli_Protobuf_EndArrowFunction?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .endArrowFunction(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .endArrowFunction(v)
        }
      }()
      case 69: try {
        var v: Fuzzilli_Protobuf_BeginGeneratorFunction?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .beginGeneratorFunction(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .beginGeneratorFunction(v)
        }
      }()
      case 70: try {
        var v: Fuzzilli_Protobuf_EndGeneratorFunction?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .endGeneratorFunction(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .endGeneratorFunction(v)
        }
      }()
      case 71: try {
        var v: Fuzzilli_Protobuf_BeginAsyncFunction?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .beginAsyncFunction(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .beginAsyncFunction(v)
        }
      }()
      case 72: try {
        var v: Fuzzilli_Protobuf_EndAsyncFunction?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .endAsyncFunction(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .endAsyncFunction(v)
        }
      }()
      case 73: try {
        var v: Fuzzilli_Protobuf_Yield?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .yield(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .yield(v)
        }
      }()
      case 74: try {
        var v: Fuzzilli_Protobuf_YieldEach?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .yieldEach(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .yieldEach(v)
        }
      }()
      case 75: try {
        var v: Fuzzilli_Protobuf_Await?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .await(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .await(v)
        }
      }()
      case 76: try {
        var v: Fuzzilli_Protobuf_LoadBigInt?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .loadBigInt(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .loadBigInt(v)
        }
      }()
      case 77: try {
        var v: Fuzzilli_Protobuf_LoadRegExp?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .loadRegExp(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .loadRegExp(v)
        }
      }()
      case 79: try {
        var v: Fuzzilli_Protobuf_BeginAsyncArrowFunction?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .beginAsyncArrowFunction(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .beginAsyncArrowFunction(v)
        }
      }()
      case 80: try {
        var v: Fuzzilli_Protobuf_EndAsyncArrowFunction?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .endAsyncArrowFunction(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .endAsyncArrowFunction(v)
        }
      }()
      case 81: try {
        var v: Fuzzilli_Protobuf_BeginCodeString?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .beginCodeString(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .beginCodeString(v)
        }
      }()
      case 82: try {
        var v: Fuzzilli_Protobuf_EndCodeString?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .endCodeString(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .endCodeString(v)
        }
      }()
      case 83: try {
        var v: Fuzzilli_Protobuf_BeginBlockStatement?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .beginBlockStatement(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .beginBlockStatement(v)
        }
      }()
      case 84: try {
        var v: Fuzzilli_Protobuf_EndBlockStatement?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .endBlockStatement(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .endBlockStatement(v)
        }
      }()
      case 85: try {
        var v: Fuzzilli_Protobuf_BeginAsyncGeneratorFunction?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .beginAsyncGeneratorFunction(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .beginAsyncGeneratorFunction(v)
        }
      }()
      case 86: try {
        var v: Fuzzilli_Protobuf_EndAsyncGeneratorFunction?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .endAsyncGeneratorFunction(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .endAsyncGeneratorFunction(v)
        }
      }()
      case 87: try {
        var v: Fuzzilli_Protobuf_BeginClass?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .beginClass(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .beginClass(v)
        }
      }()
      case 88: try {
        var v: Fuzzilli_Protobuf_BeginMethod?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .beginMethod(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .beginMethod(v)
        }
      }()
      case 89: try {
        var v: Fuzzilli_Protobuf_EndClass?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .endClass(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .endClass(v)
        }
      }()
      case 90: try {
        var v: Fuzzilli_Protobuf_CallSuperConstructor?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .callSuperConstructor(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .callSuperConstructor(v)
        }
      }()
      case 91: try {
        var v: Fuzzilli_Protobuf_CallSuperMethod?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .callSuperMethod(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .callSuperMethod(v)
        }
      }()
      case 92: try {
        var v: Fuzzilli_Protobuf_LoadSuperProperty?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .loadSuperProperty(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .loadSuperProperty(v)
        }
      }()
      case 93: try {
        var v: Fuzzilli_Protobuf_StoreSuperProperty?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .storeSuperProperty(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .storeSuperProperty(v)
        }
      }()
      case 94: try {
        var v: Fuzzilli_Protobuf_BeginFinally?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .beginFinally(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .beginFinally(v)
        }
      }()
      case 95: try {
        var v: Fuzzilli_Protobuf_ReassignWithBinop?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .reassignWithBinop(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .reassignWithBinop(v)
        }
      }()
      case 96: try {
        var v: Fuzzilli_Protobuf_ConditionalOperation?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .conditionalOperation(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .conditionalOperation(v)
        }
      }()
      case 97: try {
        var v: Fuzzilli_Protobuf_BeginSwitch?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .beginSwitch(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .beginSwitch(v)
        }
      }()
      case 98: try {
        var v: Fuzzilli_Protobuf_BeginSwitchCase?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .beginSwitchCase(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .beginSwitchCase(v)
        }
      }()
      case 99: try {
        var v: Fuzzilli_Protobuf_EndSwitch?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .endSwitch(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .endSwitch(v)
        }
      }()
      case 102: try {
        var v: Fuzzilli_Protobuf_CreateTemplateString?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .createTemplateString(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .createTemplateString(v)
        }
      }()
      case 103: try {
        var v: Fuzzilli_Protobuf_BeginForOfWithDestruct?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .beginForOfWithDestruct(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .beginForOfWithDestruct(v)
        }
      }()
      case 104: try {
        var v: Fuzzilli_Protobuf_SwitchBreak?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .switchBreak(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .switchBreak(v)
        }
      }()
      case 112: try {
        var v: Fuzzilli_Protobuf_StorePropertyWithBinop?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .storePropertyWithBinop(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .storePropertyWithBinop(v)
        }
      }()
      case 113: try {
        var v: Fuzzilli_Protobuf_StoreElementWithBinop?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .storeElementWithBinop(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .storeElementWithBinop(v)
        }
      }()
      case 114: try {
        var v: Fuzzilli_Protobuf_StoreComputedPropertyWithBinop?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .storeComputedPropertyWithBinop(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .storeComputedPropertyWithBinop(v)
        }
      }()
      case 115: try {
        var v: Fuzzilli_Protobuf_StoreSuperPropertyWithBinop?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .storeSuperPropertyWithBinop(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .storeSuperPropertyWithBinop(v)
        }
      }()
      case 116: try {
        var v: Fuzzilli_Protobuf_DestructArray?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .destructArray(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .destructArray(v)
        }
      }()
      case 117: try {
        var v: Fuzzilli_Protobuf_DestructArrayAndReassign?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .destructArrayAndReassign(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .destructArrayAndReassign(v)
        }
      }()
      case 118: try {
        var v: Fuzzilli_Protobuf_DestructObject?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .destructObject(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .destructObject(v)
        }
      }()
      case 119: try {
        var v: Fuzzilli_Protobuf_DestructObjectAndReassign?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .destructObjectAndReassign(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .destructObjectAndReassign(v)
        }
      }()
      case 120: try {
        var v: Fuzzilli_Protobuf_CallFunctionWithSpread?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .callFunctionWithSpread(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .callFunctionWithSpread(v)
        }
      }()
      case 121: try {
        var v: Fuzzilli_Protobuf_ConstructWithSpread?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .constructWithSpread(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .constructWithSpread(v)
        }
      }()
      case 122: try {
        var v: Fuzzilli_Protobuf_CallMethodWithSpread?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .callMethodWithSpread(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .callMethodWithSpread(v)
        }
      }()
      case 123: try {
        var v: Fuzzilli_Protobuf_CallComputedMethodWithSpread?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .callComputedMethodWithSpread(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .callComputedMethodWithSpread(v)
        }
      }()
      case 124: try {
        var v: Fuzzilli_Protobuf_Explore?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .explore(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .explore(v)
        }
      }()
      case 125: try {
        var v: Fuzzilli_Protobuf_EndSwitchCase?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .endSwitchCase(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .endSwitchCase(v)
        }
      }()
      case 126: try {
        var v: Fuzzilli_Protobuf_BeginSwitchDefaultCase?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .beginSwitchDefaultCase(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .beginSwitchDefaultCase(v)
        }
      }()
      case 127: try {
        var v: Fuzzilli_Protobuf_ConfigureProperty?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .configureProperty(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .configureProperty(v)
        }
      }()
      case 128: try {
        var v: Fuzzilli_Protobuf_ConfigureElement?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .configureElement(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .configureElement(v)
        }
      }()
      case 129: try {
        var v: Fuzzilli_Protobuf_ConfigureComputedProperty?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .configureComputedProperty(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .configureComputedProperty(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.inouts.isEmpty {
      try visitor.visitPackedUInt32Field(value: self.inouts, fieldNumber: 1)
    }
    switch self.operation {
    case .opIdx?: try {
      guard case .opIdx(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    }()
    case .loadInteger?: try {
      guard case .loadInteger(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .loadFloat?: try {
      guard case .loadFloat(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .loadString?: try {
      guard case .loadString(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .loadBoolean?: try {
      guard case .loadBoolean(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .loadUndefined?: try {
      guard case .loadUndefined(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .loadNull?: try {
      guard case .loadNull(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case .createObject?: try {
      guard case .createObject(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }()
    case .createArray?: try {
      guard case .createArray(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    }()
    case .createObjectWithSpread?: try {
      guard case .createObjectWithSpread(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
    }()
    case .createArrayWithSpread?: try {
      guard case .createArrayWithSpread(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
    }()
    case .loadBuiltin?: try {
      guard case .loadBuiltin(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
    }()
    case .loadProperty?: try {
      guard case .loadProperty(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
    }()
    case .storeProperty?: try {
      guard case .storeProperty(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
    }()
    case .deleteProperty?: try {
      guard case .deleteProperty(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
    }()
    case .loadElement?: try {
      guard case .loadElement(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
    }()
    case .storeElement?: try {
      guard case .storeElement(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
    }()
    case .deleteElement?: try {
      guard case .deleteElement(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
    }()
    case .loadComputedProperty?: try {
      guard case .loadComputedProperty(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
    }()
    case .storeComputedProperty?: try {
      guard case .storeComputedProperty(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 23)
    }()
    case .deleteComputedProperty?: try {
      guard case .deleteComputedProperty(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 24)
    }()
    case .typeOf?: try {
      guard case .typeOf(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 25)
    }()
    case .testInstanceOf?: try {
      guard case .testInstanceOf(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 26)
    }()
    case .testIn?: try {
      guard case .testIn(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 27)
    }()
    case .beginPlainFunction?: try {
      guard case .beginPlainFunction(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 28)
    }()
    case .return?: try {
      guard case .return(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 29)
    }()
    case .endPlainFunction?: try {
      guard case .endPlainFunction(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 30)
    }()
    case .callMethod?: try {
      guard case .callMethod(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 31)
    }()
    case .callFunction?: try {
      guard case .callFunction(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 32)
    }()
    case .construct?: try {
      guard case .construct(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 33)
    }()
    case .callComputedMethod?: try {
      guard case .callComputedMethod(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 34)
    }()
    case .unaryOperation?: try {
      guard case .unaryOperation(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 35)
    }()
    case .binaryOperation?: try {
      guard case .binaryOperation(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 36)
    }()
    case .dup?: try {
      guard case .dup(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 37)
    }()
    case .reassign?: try {
      guard case .reassign(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 38)
    }()
    case .compare?: try {
      guard case .compare(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 39)
    }()
    case .eval?: try {
      guard case .eval(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 40)
    }()
    case .beginWith?: try {
      guard case .beginWith(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 41)
    }()
    case .endWith?: try {
      guard case .endWith(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 42)
    }()
    case .loadFromScope?: try {
      guard case .loadFromScope(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 43)
    }()
    case .storeToScope?: try {
      guard case .storeToScope(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 44)
    }()
    case .beginIf?: try {
      guard case .beginIf(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 45)
    }()
    case .beginElse?: try {
      guard case .beginElse(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 46)
    }()
    case .endIf?: try {
      guard case .endIf(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 47)
    }()
    case .beginWhile?: try {
      guard case .beginWhile(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 48)
    }()
    case .endWhile?: try {
      guard case .endWhile(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 49)
    }()
    case .beginDoWhile?: try {
      guard case .beginDoWhile(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 50)
    }()
    case .endDoWhile?: try {
      guard case .endDoWhile(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 51)
    }()
    case .beginFor?: try {
      guard case .beginFor(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 52)
    }()
    case .endFor?: try {
      guard case .endFor(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 53)
    }()
    case .beginForIn?: try {
      guard case .beginForIn(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 54)
    }()
    case .endForIn?: try {
      guard case .endForIn(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 55)
    }()
    case .beginForOf?: try {
      guard case .beginForOf(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 56)
    }()
    case .endForOf?: try {
      guard case .endForOf(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 57)
    }()
    case .loopBreak?: try {
      guard case .loopBreak(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 58)
    }()
    case .loopContinue?: try {
      guard case .loopContinue(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 59)
    }()
    case .beginTry?: try {
      guard case .beginTry(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 60)
    }()
    case .beginCatch?: try {
      guard case .beginCatch(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 61)
    }()
    case .endTryCatch?: try {
      guard case .endTryCatch(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 62)
    }()
    case .throwException?: try {
      guard case .throwException(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 63)
    }()
    case .nop?: try {
      guard case .nop(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 64)
    }()
    case .loadThis?: try {
      guard case .loadThis(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 65)
    }()
    case .loadArguments?: try {
      guard case .loadArguments(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 66)
    }()
    case .beginArrowFunction?: try {
      guard case .beginArrowFunction(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 67)
    }()
    case .endArrowFunction?: try {
      guard case .endArrowFunction(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 68)
    }()
    case .beginGeneratorFunction?: try {
      guard case .beginGeneratorFunction(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 69)
    }()
    case .endGeneratorFunction?: try {
      guard case .endGeneratorFunction(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 70)
    }()
    case .beginAsyncFunction?: try {
      guard case .beginAsyncFunction(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 71)
    }()
    case .endAsyncFunction?: try {
      guard case .endAsyncFunction(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 72)
    }()
    case .yield?: try {
      guard case .yield(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 73)
    }()
    case .yieldEach?: try {
      guard case .yieldEach(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 74)
    }()
    case .await?: try {
      guard case .await(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 75)
    }()
    case .loadBigInt?: try {
      guard case .loadBigInt(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 76)
    }()
    case .loadRegExp?: try {
      guard case .loadRegExp(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 77)
    }()
    case .beginAsyncArrowFunction?: try {
      guard case .beginAsyncArrowFunction(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 79)
    }()
    case .endAsyncArrowFunction?: try {
      guard case .endAsyncArrowFunction(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 80)
    }()
    case .beginCodeString?: try {
      guard case .beginCodeString(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 81)
    }()
    case .endCodeString?: try {
      guard case .endCodeString(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 82)
    }()
    case .beginBlockStatement?: try {
      guard case .beginBlockStatement(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 83)
    }()
    case .endBlockStatement?: try {
      guard case .endBlockStatement(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 84)
    }()
    case .beginAsyncGeneratorFunction?: try {
      guard case .beginAsyncGeneratorFunction(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 85)
    }()
    case .endAsyncGeneratorFunction?: try {
      guard case .endAsyncGeneratorFunction(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 86)
    }()
    case .beginClass?: try {
      guard case .beginClass(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 87)
    }()
    case .beginMethod?: try {
      guard case .beginMethod(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 88)
    }()
    case .endClass?: try {
      guard case .endClass(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 89)
    }()
    case .callSuperConstructor?: try {
      guard case .callSuperConstructor(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 90)
    }()
    case .callSuperMethod?: try {
      guard case .callSuperMethod(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 91)
    }()
    case .loadSuperProperty?: try {
      guard case .loadSuperProperty(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 92)
    }()
    case .storeSuperProperty?: try {
      guard case .storeSuperProperty(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 93)
    }()
    case .beginFinally?: try {
      guard case .beginFinally(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 94)
    }()
    case .reassignWithBinop?: try {
      guard case .reassignWithBinop(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 95)
    }()
    case .conditionalOperation?: try {
      guard case .conditionalOperation(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 96)
    }()
    case .beginSwitch?: try {
      guard case .beginSwitch(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 97)
    }()
    case .beginSwitchCase?: try {
      guard case .beginSwitchCase(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 98)
    }()
    case .endSwitch?: try {
      guard case .endSwitch(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 99)
    }()
    case .createTemplateString?: try {
      guard case .createTemplateString(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 102)
    }()
    case .beginForOfWithDestruct?: try {
      guard case .beginForOfWithDestruct(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 103)
    }()
    case .switchBreak?: try {
      guard case .switchBreak(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 104)
    }()
    case .storePropertyWithBinop?: try {
      guard case .storePropertyWithBinop(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 112)
    }()
    case .storeElementWithBinop?: try {
      guard case .storeElementWithBinop(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 113)
    }()
    case .storeComputedPropertyWithBinop?: try {
      guard case .storeComputedPropertyWithBinop(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 114)
    }()
    case .storeSuperPropertyWithBinop?: try {
      guard case .storeSuperPropertyWithBinop(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 115)
    }()
    case .destructArray?: try {
      guard case .destructArray(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 116)
    }()
    case .destructArrayAndReassign?: try {
      guard case .destructArrayAndReassign(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 117)
    }()
    case .destructObject?: try {
      guard case .destructObject(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 118)
    }()
    case .destructObjectAndReassign?: try {
      guard case .destructObjectAndReassign(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 119)
    }()
    case .callFunctionWithSpread?: try {
      guard case .callFunctionWithSpread(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 120)
    }()
    case .constructWithSpread?: try {
      guard case .constructWithSpread(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 121)
    }()
    case .callMethodWithSpread?: try {
      guard case .callMethodWithSpread(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 122)
    }()
    case .callComputedMethodWithSpread?: try {
      guard case .callComputedMethodWithSpread(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 123)
    }()
    case .explore?: try {
      guard case .explore(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 124)
    }()
    case .endSwitchCase?: try {
      guard case .endSwitchCase(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 125)
    }()
    case .beginSwitchDefaultCase?: try {
      guard case .beginSwitchDefaultCase(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 126)
    }()
    case .configureProperty?: try {
      guard case .configureProperty(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 127)
    }()
    case .configureElement?: try {
      guard case .configureElement(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 128)
    }()
    case .configureComputedProperty?: try {
      guard case .configureComputedProperty(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 129)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Fuzzilli_Protobuf_Instruction, rhs: Fuzzilli_Protobuf_Instruction) -> Bool {
    if lhs.inouts != rhs.inouts {return false}
    if lhs.operation != rhs.operation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Fuzzilli_Protobuf_Program: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Program"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uuid"),
    2: .same(proto: "code"),
    3: .same(proto: "comments"),
    4: .same(proto: "parent"),
  ]

  fileprivate class _StorageClass {
    var _uuid: Data = Data()
    var _code: [Fuzzilli_Protobuf_Instruction] = []
    var _comments: Dictionary<Int32,String> = [:]
    var _parent: Fuzzilli_Protobuf_Program? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _uuid = source._uuid
      _code = source._code
      _comments = source._comments
      _parent = source._parent
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularBytesField(value: &_storage._uuid) }()
        case 2: try { try decoder.decodeRepeatedMessageField(value: &_storage._code) }()
        case 3: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufSInt32,SwiftProtobuf.ProtobufString>.self, value: &_storage._comments) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._parent) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._uuid.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._uuid, fieldNumber: 1)
      }
      if !_storage._code.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._code, fieldNumber: 2)
      }
      if !_storage._comments.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufSInt32,SwiftProtobuf.ProtobufString>.self, value: _storage._comments, fieldNumber: 3)
      }
      try { if let v = _storage._parent {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Fuzzilli_Protobuf_Program, rhs: Fuzzilli_Protobuf_Program) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._uuid != rhs_storage._uuid {return false}
        if _storage._code != rhs_storage._code {return false}
        if _storage._comments != rhs_storage._comments {return false}
        if _storage._parent != rhs_storage._parent {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
