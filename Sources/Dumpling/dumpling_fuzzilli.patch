diff --git a/Package.swift b/Package.swift
index 05e5dc1..540b552 100644
--- a/Package.swift
+++ b/Package.swift
@@ -56,18 +56,22 @@ let package = Package(
                     .copy("Protobuf/ast.proto"),
                     .copy("Compiler/Parser")]),
 
+        .target(name: "FuzzILTool",
+                dependencies: ["Fuzzilli"]),
+        
         .target(name: "REPRLRun",
                 dependencies: ["libreprl"]),
 
         .target(name: "FuzzilliCli",
                 dependencies: ["Fuzzilli"]),
-        .target(name: "FuzzILTool",
+        
+        .target(name: "RelateTool",
                 dependencies: ["Fuzzilli"]),
 
+
         .testTarget(name: "FuzzilliTests",
                     dependencies: ["Fuzzilli"],
-                    resources: [.copy("CompilerTests")]),
+                    resources: [ .copy("CompilerTests"), ]),
     ],
     swiftLanguageVersions: [.v5]
 )
diff --git a/Sources/Fuzzilli/Base/Contributor.swift b/Sources/Fuzzilli/Base/Contributor.swift
index fd0af2a..6497f83 100644
--- a/Sources/Fuzzilli/Base/Contributor.swift
+++ b/Sources/Fuzzilli/Base/Contributor.swift
@@ -29,6 +29,14 @@ public class Contributor: Hashable {
     // Number of crashing programs produced.
     private var crashingSamples = 0
 
+    private var differentialSamples = 0
+
+    private var turbofanSamples = 0
+
+    private var maglevSamples = 0
+
+    private var sparkplugSamples = 0
+
     // Number of times this instance failed to generate/mutate code.
     private var failures = 0
     // Total number of instructions added to programs by this contributor.
@@ -58,6 +66,21 @@ public class Contributor: Hashable {
         crashingSamples += 1
     }
 
+    func generatedDifferentialSample() {
+        differentialSamples += 1
+    }
+
+    func generatedTurbofanSample() {
+        turbofanSamples += 1
+    }
+
+    func generatedMaglevSample() {
+        maglevSamples += 1
+    }
+
+    func generatedSparkplugSample() {
+        sparkplugSamples += 1
+    }
 
     func addedInstructions(_ n: Int) {
         guard n > 0 else { return }
@@ -72,6 +95,22 @@ public class Contributor: Hashable {
         return crashingSamples
     }
 
+    public var differentialsFound: Int {
+        return differentialSamples
+    }
+
+    public var turbofanSamplesFound: Int {
+        return turbofanSamples
+    }
+
+    public var maglevSamplesFound: Int {
+        return maglevSamples
+    }
+
+    public var sparkplugSamplesFound: Int {
+        return sparkplugSamples
+    }
+
     public var totalSamples: Int {
         return validSamples + interestingSamples + invalidSamples + timedOutSamples + crashingSamples
     }
@@ -135,4 +174,20 @@ extension Contributors {
     public func generatedTimeOutSample() {
         forEach { $0.generatedTimeOutSample() }
     }
+
+    public func generatedDifferentialSample() {
+        forEach { $0.generatedDifferentialSample() }
+    }
+
+    public func generatedTurbofanSample() {
+        forEach { $0.generatedTurbofanSample() }
+    }
+
+    public func generatedMaglevSample() {
+        forEach { $0.generatedMaglevSample() }
+    }
+
+    public func generatedSparkplugSample() {
+        forEach { $0.generatedSparkplugSample() }
+    }
 }
diff --git a/Sources/Fuzzilli/Base/Events.swift b/Sources/Fuzzilli/Base/Events.swift
index 7063add..4d5d2ad 100644
--- a/Sources/Fuzzilli/Base/Events.swift
+++ b/Sources/Fuzzilli/Base/Events.swift
@@ -55,6 +55,12 @@ public class Events {
     /// Signals that a crashing program has been found. Dispatched after the crashing program has been minimized.
     public let CrashFound = Event<(program: Program, behaviour: CrashBehaviour, isUnique: Bool, origin: ProgramOrigin)>()
 
+    public let DifferentialFound = Event<(program: Program, behaviour: CrashBehaviour, origin: ProgramOrigin, opt_stdout: String?, unopt_stdout: String, reproducesInNonReplMode: Bool)>()
+
+    public let JITExecutingProgramFound = Event<(program: Program, compilers: [JITType], is_optimizing: Bool)>()
+
+    public let RelationPerformed = Event<(program: Program, execution: Execution)>()
+
     /// Signals that a program causing a timeout has been found.
     public let TimeOutFound = Event<Program>()
 
@@ -88,6 +94,12 @@ public class Events {
     public let CorpusImportComplete = Event<()>()
 }
 
+public enum JITType: String {
+    case sparkplug = "sparkplug"
+    case maglev    = "maglev"
+    case turbofan  = "turbofan"
+}
+
 /// Crash behavior of a program.
 public enum CrashBehaviour: String {
     case deterministic = "deterministic"
diff --git a/Sources/Fuzzilli/Configuration.swift b/Sources/Fuzzilli/Configuration.swift
index 6429536..b57e3d5 100644
--- a/Sources/Fuzzilli/Configuration.swift
+++ b/Sources/Fuzzilli/Configuration.swift
@@ -12,6 +12,37 @@
 // See the License for the specific language governing permissions and
 // limitations under the License.
 
+public struct V8DifferentialConfig {
+    public let commonArgs: [String] = [
+        "--expose-gc",
+        "--omit-quit",
+        "--allow-natives-for-differential-fuzzing",
+        "--fuzzing",
+        "--future",
+        "--harmony",
+        "--predictable",
+        "--trace",
+        "--correctness-fuzzer-suppressions",
+        "--no-lazy-feedback-allocation",
+    ]
+
+    public let differentialArgs: [String] = [
+        "--turbofan-dumping",
+        "--generate-dump-positions",
+        // "--verify-heap-on-jit-dump",
+        "--turbofan-dumping-print-deopt-frames",
+        "--jit-return-dump",
+        "--maglev-dumping",
+        "--no-sparkplug",
+        "--jit-fuzzing",
+    ]
+
+    public let referenceArgs: [String] = ["--no-turbofan", "--no-maglev", "--load-dump-positions", "--sparkplug-dumping", "--interpreter-dumping"]
+
+    public init() {}
+}
+
+
 public struct Configuration {
     /// The commandline arguments used by this instance.
     public let arguments: [String]
@@ -26,6 +57,15 @@ public struct Configuration {
     /// Used to verify that crashes can be detected.
     public let crashTests: [String]
 
+    /// Code snippets that cause an observable difference of output
+    /// in the target engine. Used to verify that crashes can be detected.
+    public let differentialTests: [String]
+
+    /// Code snippets that must not cause an observable difference of output
+    /// in the target engine. Used to verify that common sources of
+    /// entropy (Math.random, ...) are deterministic.
+    public let differentialTestsInvariant: [String]
+
     /// The fraction of instruction to keep from the original program when minimizing.
     /// This setting is useful to avoid "over-minimization", which can negatively impact the fuzzer's
     /// performance if program features are removed that could later be mutated to trigger new
@@ -57,28 +97,48 @@ public struct Configuration {
     /// also appended as a comment in the footer of crashing samples.
     public let tag: String?
 
+    public let relateToolPath: String?
+
+    public let dumplingDepth: UInt32?
+
+    public let dumplingPropCount: UInt32?
+
+    public let storagePath: String?
+
     public init(arguments: [String] = [],
                 timeout: UInt32 = 250,
                 skipStartupTests: Bool = false,
                 logLevel: LogLevel = .info,
                 crashTests: [String] = [],
+                differentialTests: [String] = [],
+                differentialTestsInvariant: [String] = [],
                 minimizationLimit: Double = 0.0,
                 dropoutRate: Double = 0,
                 collectRuntimeTypes: Bool = false,
                 enableDiagnostics: Bool = false,
                 enableInspection: Bool = false,
                 staticCorpus: Bool = false,
-                tag: String? = nil) {
+                tag: String? = nil,
+                relateToolPath: String? = nil,
+                dumplingDepth: UInt32 = 3,
+                dumplingPropCount: UInt32 = 5,
+                storagePath: String? = nil) {
         self.arguments = arguments
         self.timeout = timeout
         self.logLevel = logLevel
         self.crashTests = crashTests
+        self.differentialTests = differentialTests
+        self.differentialTestsInvariant = differentialTestsInvariant
         self.dropoutRate = dropoutRate
         self.minimizationLimit = minimizationLimit
         self.enableDiagnostics = enableDiagnostics
         self.enableInspection = enableInspection
         self.staticCorpus = staticCorpus
         self.tag = tag
+        self.relateToolPath = relateToolPath
+        self.dumplingDepth = dumplingDepth
+        self.dumplingPropCount = dumplingPropCount
+        self.storagePath = storagePath
     }
 }
 
diff --git a/Sources/Fuzzilli/DifferentialOracle/Oracle.swift b/Sources/Fuzzilli/DifferentialOracle/Oracle.swift
new file mode 100644
index 0000000..1d91f18
--- /dev/null
+++ b/Sources/Fuzzilli/DifferentialOracle/Oracle.swift
@@ -0,0 +1,211 @@
+import Foundation
+
+public enum FrameType {
+    case interpreter
+    case sparkplug
+    case maglev
+    case turbofan
+    case deopt
+    case jitReturn
+}
+
+
+public struct Frame: Equatable {
+    let bytecode_offset: Int
+    let acc: String
+    let args: [String]
+    let regs: [String]
+    let function_id: Int
+    let frame_type: FrameType
+}
+
+public enum OracleLogLevel {
+    case none
+    case info
+    case debug
+}
+
+/// Compare two frames for equality
+/// Warning: It is not communtative! The opt frame must be lhs.
+/// A string value of "<optimized_out>" in lhs is equal to every other string
+/// value in acc, args, and regs
+/// - Parameters:
+///  - lhs: The unopt frame
+///  - rhs: The opt frame
+public func == (lhs: Frame, rhs: Frame) -> Bool {
+    return lhs.bytecode_offset == rhs.bytecode_offset &&
+           (lhs.acc == rhs.acc || lhs.acc == "<optimized_out>") &&
+           lhs.args.count == rhs.args.count &&
+           lhs.regs.count == rhs.regs.count &&
+           (0..<lhs.args.count).allSatisfy { lhs.args[$0] == rhs.args[$0] || lhs.args[$0] == "<optimized_out>" } &&
+           (0..<lhs.regs.count).allSatisfy { lhs.regs[$0] == rhs.regs[$0] || lhs.regs[$0] == "<optimized_out>" } &&
+           lhs.function_id == rhs.function_id
+}
+
+
+
+
+public func parseDiffFrame(_ frameArr: ArraySlice<Substring>, _ lastFrame: inout Frame?,
+                           _ prevRegs: inout [String], _ prevArgs: inout [String]) -> Frame {
+    func parseValue<T>(prefix: String, defaultValue: T, index: inout Int, conversion: (Substring) -> T) -> T {
+        if index < frameArr.endIndex, frameArr[index].starts(with: prefix) {
+            let value = conversion(frameArr[index].dropFirst(prefix.count))
+            index += 1
+            return value
+        }
+        return defaultValue
+    }
+
+    let frameType: FrameType
+    var i = frameArr.startIndex
+    switch frameArr[i] {
+        case "---I":
+            frameType = .interpreter
+        case "---S":
+            frameType = .sparkplug
+        case "---M":
+            frameType = .maglev
+        case "---T":
+            frameType = .turbofan
+        case "---D":
+            frameType = .deopt
+        case "---R":
+            frameType = .jitReturn
+        default:
+            fatalError("Unknown frame type")
+    }
+    i += 1
+
+    let bytecode_offset = parseValue(prefix: "b:", defaultValue: lastFrame?.bytecode_offset ?? 4242, index: &i){ Int($0)! }
+    let function_id = parseValue(prefix: "f:", defaultValue: lastFrame?.function_id ?? 4242, index: &i){ Int($0)! }
+    let arg_count = parseValue(prefix: "n:", defaultValue: lastFrame?.args.count ?? 4242, index: &i){ Int($0)! }
+    let reg_count = parseValue(prefix: "m:", defaultValue: lastFrame?.regs.count ?? 4242, index: &i){ Int($0)! }
+    let acc = parseValue(prefix: "x:", defaultValue: lastFrame?.acc ?? "", index: &i){ String($0) }
+
+    func updateValues(prefix: String, totalCount: Int, oldValues: [String], prevValues: inout [String]) -> [String] {
+        var newValues: [String]
+        // performance improvement to use Swifts copy on write
+        if oldValues.count == totalCount {
+            newValues = oldValues
+        }
+        else {
+            newValues = [String]()
+            newValues.reserveCapacity(totalCount)
+            // copy up to totalCount from prevValues into newValues
+            for j in 0..<min(prevValues.count, totalCount) {
+                newValues.append(prevValues[j])
+            }
+            // make sure newValues has totalCount elements
+            while newValues.count < totalCount {
+                newValues.append("")
+            }
+        }
+
+        // make sure prevValues is at least totalCount elements in size
+        while prevValues.count < totalCount {
+            prevValues.append("")
+        }
+
+        while i < frameArr.endIndex && frameArr[i].starts(with: prefix) {
+            let data = frameArr[i].dropFirst(1).split(separator: ":", maxSplits: 1)
+            let number = Int(data[0])!
+            let value = String(data[1])
+            newValues[number] = value
+            prevValues[number] = value
+            i += 1
+        }
+        return newValues
+
+    }
+
+    let args = updateValues(prefix: "a", totalCount: arg_count, oldValues: lastFrame?.args ?? [], prevValues: &prevArgs)
+    let regs = updateValues(prefix: "r", totalCount: reg_count, oldValues: lastFrame?.regs ?? [], prevValues: &prevRegs)
+
+
+    let frame = Frame(bytecode_offset: bytecode_offset,
+                      acc: acc,
+                      args: args,
+                      regs: regs,
+                      function_id: function_id,
+                      frame_type: frameType)
+    return frame
+}
+
+public func parseToLinear(_ stdout: String) -> [[Frame]] {
+    var stack: [[Frame]] = [[], []]
+    var linearized: [[Frame]] = []
+    var lastFrame: Frame? = nil
+
+    var prevArgs: [String] = [String]()
+    var prevRegs: [String] = [String]()
+    prevArgs.reserveCapacity(64)
+    prevRegs.reserveCapacity(128)
+
+    let split = stdout.split(separator: "\n", omittingEmptySubsequences: false)
+    var i = 0
+
+    while i < split.count {
+        if split[i] == ">" {
+            stack.append([])
+        }
+        else if split[i] == "<" {
+            linearized.append(stack.removeLast())
+        }
+        else if split[i].starts(with: "---") {
+            let start = i
+            while (split[i] != "") {
+                i += 1
+            }
+            let end = i-1
+            let frame = split[start...end]
+            // append to last stack frame
+            lastFrame = parseDiffFrame(frame, &lastFrame, &prevArgs, &prevRegs)
+            stack[stack.count - 1].append(lastFrame!)
+        }
+        i += 1
+    }
+    for _ in stack {
+        linearized.append(stack.removeLast())
+    }
+    return linearized
+}
+
+public func relate(_ optIn: String, with unoptIn: String, _ logLevel: OracleLogLevel = .none) -> Bool {
+    // Quick and dirty way to not get NaN vs <uninitialized_value> spam
+    let optChunks = parseToLinear(optIn.replacingOccurrences(of: "<uninitialized_value>", with: "NaN"))
+    let unoptChunks = parseToLinear(unoptIn.replacingOccurrences(of: "<uninitialized_value>", with: "NaN"))
+
+
+    if logLevel == .debug {
+            print("opt Chunks:")
+            print(optChunks as AnyObject)
+            print("unopt Chunks:")
+            print(unoptChunks as AnyObject)
+        }
+    if optChunks.count != unoptChunks.count {
+        if logLevel != .none {
+            print("Difference in chunk count \(optChunks.count) != \(unoptChunks.count)")
+        }
+        return false
+    }
+    for (optChunk, unoptChunk) in zip(optChunks, unoptChunks) {
+        for optFrame in optChunk {
+            // check if optFrame is in unoptChunk
+            if !unoptChunk.contains(where: {optFrame == $0}) {
+                if logLevel != .none {
+                    print(optFrame as AnyObject)
+                    print("--------------------------")
+                    print("[")
+                    for unoptFrame in unoptChunk {
+                        if unoptFrame.bytecode_offset == optFrame.bytecode_offset {
+                            print(unoptFrame as AnyObject)
+                        }
+                    }
+                    print("]")
+                }
+                return false
+            }
+        }
+    }
+    return true
+}
diff --git a/Sources/Fuzzilli/Engines/FuzzEngine.swift b/Sources/Fuzzilli/Engines/FuzzEngine.swift
index 1b5a610..3a5e76d 100644
--- a/Sources/Fuzzilli/Engines/FuzzEngine.swift
+++ b/Sources/Fuzzilli/Engines/FuzzEngine.swift
@@ -32,17 +32,27 @@ public class FuzzEngine: ComponentBase {
         fatalError("Must be implemented by child classes")
     }
 
-    final func execute(_ program: Program, withTimeout timeout: UInt32? = nil) -> ExecutionOutcome {
+}
+
+extension FuzzEngine {
+    public func execute(_ program: Program, withTimeout timeout: UInt32? = nil) -> ExecutionOutcome {
         let program = postProcessor?.process(program, for: fuzzer) ?? program
 
         fuzzer.dispatchEvent(fuzzer.events.ProgramGenerated, data: program)
 
-        let execution = fuzzer.execute(program, withTimeout: timeout, purpose: .fuzzing)
+        let postprocessedProgram: Program
+        postprocessedProgram = program
+
+        let execution = fuzzer.execute(postprocessedProgram, withTimeout: timeout, purpose: .fuzzing, differentialExecute: .force)
 
         switch execution.outcome {
             case .crashed(let termsig):
-                fuzzer.processCrash(program, withSignal: termsig, withStderr: execution.stderr, withStdout: execution.stdout, origin: .local, withExectime: execution.execTime)
-                program.contributors.generatedCrashingSample()
+                fuzzer.processCrash(postprocessedProgram, withSignal: termsig, withStderr: execution.stderr, withStdout: execution.stdout, origin: .local, withExectime: execution.execTime)
+                postprocessedProgram.contributors.generatedCrashingSample()
+
+            case .differential:
+            fuzzer.processDifferential(postprocessedProgram, withStderr: execution.stderr, withStdout: execution.unOptStdout!, origin: .local, optStdout: execution.optStdout!)
+                postprocessedProgram.contributors.generatedDifferentialSample()
 
             case .succeeded:
                 fuzzer.dispatchEvent(fuzzer.events.ValidProgramFound, data: program)
@@ -63,19 +73,19 @@ public class FuzzEngine: ComponentBase {
 
             case .failed(_):
                 if fuzzer.config.enableDiagnostics {
-                    program.comments.add("Stdout:\n" + execution.stdout, at: .footer)
+                    postprocessedProgram.comments.add("Stdout:\n" + execution.stdout, at: .footer)
                 }
-                fuzzer.dispatchEvent(fuzzer.events.InvalidProgramFound, data: program)
-                program.contributors.generatedInvalidSample()
+                fuzzer.dispatchEvent(fuzzer.events.InvalidProgramFound, data: postprocessedProgram)
+                postprocessedProgram.contributors.generatedInvalidSample()
 
             case .timedOut:
-                fuzzer.dispatchEvent(fuzzer.events.TimeOutFound, data: program)
-                program.contributors.generatedTimeOutSample()
+                fuzzer.dispatchEvent(fuzzer.events.TimeOutFound, data: postprocessedProgram)
+                postprocessedProgram.contributors.generatedTimeOutSample()
         }
 
         if fuzzer.config.enableDiagnostics {
             // Ensure deterministic execution behaviour. This can for example help detect and debug REPRL issues.
-            ensureDeterministicExecutionOutcomeForDiagnostic(of: program)
+            ensureDeterministicExecutionOutcomeForDiagnostic(of: postprocessedProgram)
         }
 
         return execution.outcome
diff --git a/Sources/Fuzzilli/Engines/HybridEngine.swift b/Sources/Fuzzilli/Engines/HybridEngine.swift
index f25ab27..4bd0885 100644
--- a/Sources/Fuzzilli/Engines/HybridEngine.swift
+++ b/Sources/Fuzzilli/Engines/HybridEngine.swift
@@ -24,6 +24,7 @@ public class HybridEngine: FuzzEngine {
         case generatedCodeFailed = "Generated code failed"
         case generatedCodeTimedOut = "Generated code timed out"
         case generatedCodeCrashed = "Generated code crashed"
+        case generatedCodeDifferential = "Generated code differential"
     }
     private var outcomeCounts = [CodeGenerationOutcome: Int]()
 
@@ -112,6 +113,8 @@ public class HybridEngine: FuzzEngine {
             return recordOutcome(.generatedCodeTimedOut)
         case .crashed:
             return recordOutcome(.generatedCodeCrashed)
+        case .differential:
+            return recordOutcome(.generatedCodeDifferential)
         }
 
         // Now perform one round of fixup to improve the generated program based on runtime information and in particular remove all try-catch guards that are not needed.
diff --git a/Sources/Fuzzilli/Evaluation/ProgramAspects.swift b/Sources/Fuzzilli/Evaluation/ProgramAspects.swift
index 7098e72..7cdb6bd 100644
--- a/Sources/Fuzzilli/Evaluation/ProgramAspects.swift
+++ b/Sources/Fuzzilli/Evaluation/ProgramAspects.swift
@@ -12,12 +12,21 @@
 // See the License for the specific language governing permissions and
 // limitations under the License.
 
+public enum ExecutionType {
+    case unknown
+    case interpreter
+    case maglev
+    case turbofan
+}
+
 /// Aspects of a program that make it special.
 public class ProgramAspects: CustomStringConvertible {
     let outcome: ExecutionOutcome
+    public var jitExecution: ExecutionType
 
-    public init(outcome: ExecutionOutcome) {
+    public init(outcome: ExecutionOutcome, jitExecution: ExecutionType = .unknown) {
         self.outcome = outcome
+        self.jitExecution = jitExecution
     }
 
     public var description: String {
diff --git a/Sources/Fuzzilli/Evaluation/ProgramCoverageEvaluator.swift b/Sources/Fuzzilli/Evaluation/ProgramCoverageEvaluator.swift
index c365ff1..0ed5e61 100644
--- a/Sources/Fuzzilli/Evaluation/ProgramCoverageEvaluator.swift
+++ b/Sources/Fuzzilli/Evaluation/ProgramCoverageEvaluator.swift
@@ -19,11 +19,12 @@ import libcoverage
 public class CovEdgeSet: ProgramAspects {
     private var numEdges: UInt32
     fileprivate var edges: UnsafeMutablePointer<UInt32>?
+    
 
-    init(edges: UnsafeMutablePointer<UInt32>?, numEdges: UInt32) {
+    init(edges: UnsafeMutablePointer<UInt32>?, numEdges: UInt32, jitExecution: ExecutionType = .unknown) {
         self.numEdges = numEdges
         self.edges = edges
-        super.init(outcome: .succeeded)
+        super.init(outcome: .succeeded, jitExecution: jitExecution)
     }
 
     deinit {
@@ -192,8 +193,8 @@ public class ProgramCoverageEvaluator: ComponentBase, ProgramEvaluator {
             return false
         }
 
-        if execution.outcome.isCrash() {
-            // For crashes, we don't care about the edges that were triggered, just about the outcome itself.
+        if execution.outcome.isCrash() || execution.outcome == .differential {
+            // For crashes and differentials?, we don't care about the edges that were triggered, just about the outcome itself.
             return true
         }
 
@@ -237,6 +238,15 @@ public class ProgramCoverageEvaluator: ComponentBase, ProgramEvaluator {
         let intersectedCovEdgeSet = secondCovEdgeSet
         intersectedCovEdgeSet.setEdges(intersectedEdgeSet)
 
+        if execution.compilersUsed.count != 0 {
+            if execution.compilersUsed.contains(.turbofan) {
+                intersectedCovEdgeSet.jitExecution = .turbofan
+            }
+            else if execution.compilersUsed.contains(.maglev) {
+                intersectedCovEdgeSet.jitExecution = .maglev
+            }
+            // dont care about sparkplug here
+        }
         return intersectedCovEdgeSet
     }
 
diff --git a/Sources/Fuzzilli/Execution/Execution.swift b/Sources/Fuzzilli/Execution/Execution.swift
index 746b446..b6e6e76 100644
--- a/Sources/Fuzzilli/Execution/Execution.swift
+++ b/Sources/Fuzzilli/Execution/Execution.swift
@@ -20,6 +20,7 @@ public enum ExecutionOutcome: CustomStringConvertible, Equatable, Hashable {
     case failed(Int)
     case succeeded
     case timedOut
+    case differential
 
     public var description: String {
         switch self {
@@ -31,6 +32,8 @@ public enum ExecutionOutcome: CustomStringConvertible, Equatable, Hashable {
             return "Succeeded"
         case .timedOut:
             return "TimedOut"
+        case .differential:
+            return "Differential"
         }
     }
 
@@ -43,11 +46,23 @@ public enum ExecutionOutcome: CustomStringConvertible, Equatable, Hashable {
     }
 }
 
+// has to be kept in sync with V8
+enum JITTypeBits: Int {
+    case turbofanB = 1  // 1 << 0
+    case maglevB = 2    // 1 << 1
+    case sparkplugB = 4 // 1 << 2
+}
+
 /// The result of executing a program.
 public protocol Execution {
-    var outcome: ExecutionOutcome { get }
+    var outcome: ExecutionOutcome { get set }
     var stdout: String { get }
     var stderr: String { get }
     var fuzzout: String { get }
-    var execTime: TimeInterval { get }
+    var execTime: TimeInterval { get set }
+    var compilersUsed: [JITType] { get set }
+    var unOptStdout: String? { get set }
+    var optStdout: String? { get set }
+    var reproducesInNonReplMode: Bool? { get set }
+    var bugOracleTime: TimeInterval? { get set }
 }
diff --git a/Sources/Fuzzilli/Execution/REPRL.swift b/Sources/Fuzzilli/Execution/REPRL.swift
index 185d1f8..1ec60d4 100644
--- a/Sources/Fuzzilli/Execution/REPRL.swift
+++ b/Sources/Fuzzilli/Execution/REPRL.swift
@@ -19,7 +19,7 @@ import libreprl
 /// scripts, but resets the global state in between executions.
 public class REPRL: ComponentBase, ScriptRunner {
     /// Kill and restart the child process after this many script executions
-    private let maxExecsBeforeRespawn: Int
+    public let maxExecsBeforeRespawn: Int
 
     /// Commandline arguments for the executable
     public private(set) var processArguments: [String]
@@ -79,7 +79,7 @@ public class REPRL: ComponentBase, ScriptRunner {
         env.append(key + "=" + value)
     }
 
-    public func run(_ script: String, withTimeout timeout: UInt32) -> Execution {
+    public func run(_ script: String, withTimeout timeout: UInt32, differentialFuzzingPositionDumpSeed: UInt32) -> Execution {
         // Log the current script into the buffer if diagnostics are enabled.
         if fuzzer.config.enableDiagnostics {
             self.scriptBuffer += script + "\n"
@@ -108,8 +108,11 @@ public class REPRL: ComponentBase, ScriptRunner {
         var execTime: UInt64 = 0        // In microseconds
         let timeout = UInt64(timeout) * 1000        // In microseconds
         var status: Int32 = 0
+        var encodedJitState: UInt8 = 0
         script.withCString {
-            status = reprl_execute(reprlContext, $0, UInt64(script.count), UInt64(timeout), &execTime, freshInstance)
+            status = reprl_execute(reprlContext, $0, UInt64(script.count), UInt64(timeout), &execTime, freshInstance,
+                differentialFuzzingPositionDumpSeed, &encodedJitState)
+
             // If we fail, we retry after a short timeout and with a fresh instance. If we still fail, we give up trying
             // to execute this program. If we repeatedly fail to execute any program, we abort.
             if status < 0 {
@@ -118,7 +121,9 @@ public class REPRL: ComponentBase, ScriptRunner {
                     fuzzer.dispatchEvent(fuzzer.events.DiagnosticsEvent, data: (name: "REPRLFail", content: scriptBuffer))
                 }
                 Thread.sleep(forTimeInterval: 1)
-                status = reprl_execute(reprlContext, $0, UInt64(script.count), UInt64(timeout), &execTime, 1)
+                status = reprl_execute(reprlContext, $0, UInt64(script.count), UInt64(timeout), &execTime, 1,
+                    differentialFuzzingPositionDumpSeed, &encodedJitState)
+
             }
         }
 
@@ -150,6 +155,16 @@ public class REPRL: ComponentBase, ScriptRunner {
         }
         execution.execTime = Double(execTime) / 1_000_000
 
+        if encodedJitState & UInt8(JITTypeBits.turbofanB.rawValue) != 0 {
+            execution.compilersUsed.append(.turbofan)
+        }
+        if encodedJitState & UInt8(JITTypeBits.maglevB.rawValue) != 0 {
+            execution.compilersUsed.append(.maglev)
+        }
+        if encodedJitState & UInt8(JITTypeBits.sparkplugB.rawValue) != 0 {
+            execution.compilersUsed.append(.sparkplug)
+        }
+
         return execution
     }
 }
@@ -163,7 +178,12 @@ class REPRLExecution: Execution {
     private let execId: Int
 
     var outcome = ExecutionOutcome.succeeded
+    var compilersUsed: [JITType] = []
     var execTime: TimeInterval = 0
+    var unOptStdout: String? = nil
+    var optStdout: String? = nil
+    var reproducesInNonReplMode: Bool? = nil
+    var bugOracleTime: TimeInterval? = nil
 
     init(from reprl: REPRL) {
         self.reprl = reprl
@@ -178,8 +198,14 @@ class REPRLExecution: Execution {
 
     var stdout: String {
         assert(outputStreamsAreValid)
+        let x = String(cString: reprl_fetch_stdout(reprl.reprlContext))
         if cachedStdout == nil {
             cachedStdout = String(cString: reprl_fetch_stdout(reprl.reprlContext))
+        } else if (cachedStdout!) != x {
+            print(cachedStdout!)
+            print("-----------------------------------")
+            print(x)
+            fatalError("repl is bricked!")
         }
         return cachedStdout!
     }
diff --git a/Sources/Fuzzilli/Execution/ScriptRunner.swift b/Sources/Fuzzilli/Execution/ScriptRunner.swift
index 36bccf7..8a7ee2d 100644
--- a/Sources/Fuzzilli/Execution/ScriptRunner.swift
+++ b/Sources/Fuzzilli/Execution/ScriptRunner.swift
@@ -16,7 +16,7 @@ public protocol ScriptRunner: Component {
     var processArguments: [String] { get }
 
     /// Executes a script, waits for it to complete, and returns the result.
-    func run(_ script: String, withTimeout timeout: UInt32) -> Execution
+    func run(_ script: String, withTimeout timeout: UInt32, differentialFuzzingPositionDumpSeed: UInt32) -> Execution
 
     /// Sets an environment variable for the child process. Must only be called before initialization.
     func setEnvironmentVariable(_ key: String, to value: String)
diff --git a/Sources/Fuzzilli/Fuzzer.swift b/Sources/Fuzzilli/Fuzzer.swift
index b854f63..dc93021 100644
--- a/Sources/Fuzzilli/Fuzzer.swift
+++ b/Sources/Fuzzilli/Fuzzer.swift
@@ -14,6 +14,14 @@
 
 import Foundation
 
+
+fileprivate let prependJS = try! String(contentsOfFile: "prepend.js")
+fileprivate let B = 1;
+fileprivate let KB = 1024 * B;
+fileprivate let MB = 1024 * KB;
+
+fileprivate let execPoison = ["(see crbug.com/", "Aborting on ", "Fatal JavaScript out of memory:"];
+
 public class Fuzzer {
     /// Id of this fuzzer.
     public let id: UUID
@@ -36,6 +44,9 @@ public class Fuzzer {
     /// The script runner used to execute generated scripts.
     public let runner: ScriptRunner
 
+    /// The script runners used to compare against in differential executions.
+    public let referenceRunner: ScriptRunner
+
     /// The fuzzer engine producing new programs from existing ones and executing them.
     public let engine: FuzzEngine
 
@@ -63,6 +74,8 @@ public class Fuzzer {
     /// The minimizer to shrink programs that cause crashes or trigger new interesting behaviour.
     public let minimizer: Minimizer
 
+    private let localId: UInt32
+
     /// The engine used for initial corpus generation (if performed).
     public let corpusGenerationEngine = GenerativeEngine()
 
@@ -155,9 +168,9 @@ public class Fuzzer {
 
     /// Constructs a new fuzzer instance with the provided components.
     public init(
-        configuration: Configuration, scriptRunner: ScriptRunner, engine: FuzzEngine, mutators: WeightedList<Mutator>,
+        configuration: Configuration, scriptRunner: ScriptRunner, referenceRunner: ScriptRunner, engine: FuzzEngine, mutators: WeightedList<Mutator>,
         codeGenerators: WeightedList<CodeGenerator>, programTemplates: WeightedList<ProgramTemplate>, evaluator: ProgramEvaluator,
-        environment: Environment, lifter: Lifter, corpus: Corpus, minimizer: Minimizer, queue: DispatchQueue? = nil
+        environment: Environment, lifter: Lifter, corpus: Corpus, minimizer: Minimizer, localId: UInt32, queue: DispatchQueue? = nil
     ) {
         let uniqueId = UUID()
         self.id = uniqueId
@@ -175,9 +188,13 @@ public class Fuzzer {
         self.lifter = lifter
         self.corpus = corpus
         self.runner = scriptRunner
+        self.referenceRunner = referenceRunner
         self.minimizer = minimizer
+        self.localId = localId
         self.logger = Logger(withLabel: "Fuzzer")
 
+        // self.removeMetadataFilesIfExist()
+
         // Register this fuzzer instance with its queue so that it is possible to
         // obtain a reference to the Fuzzer instance when running on its queue.
         // This creates a reference cycle, but Fuzzer instances aren't expected
@@ -185,6 +202,36 @@ public class Fuzzer {
         self.queue.setSpecific(key: Fuzzer.dispatchQueueKey, value: self)
     }
 
+    private func jitMetadataFileURL(_ seed: UInt32) -> URL {
+        let jitMetadataFileName = String(format: "%u_position_dump.json", seed)
+        return URL(fileURLWithPath: "/tmp").appendingPathComponent(jitMetadataFileName)
+    }
+
+    private func outputMetadataFileURL(_ seed: UInt32) -> URL {
+        let jitMetadataFileName = String(format: "%u_output_dump.txt", seed)
+        return URL(fileURLWithPath: "/tmp").appendingPathComponent(jitMetadataFileName)
+    }
+
+    private func jitMetadataFileExists(_ seed: UInt32) -> Bool {
+        return FileManager.default.fileExists(atPath: self.jitMetadataFileURL(seed).path)
+    }
+
+    private func outputMetadataFileExists(_ seed: UInt32) -> Bool {
+        return FileManager.default.fileExists(atPath: self.outputMetadataFileURL(seed).path)
+    }
+
+
+    private func removeMetadataFilesIfExist(_ seed: UInt32) {
+        if self.jitMetadataFileExists(seed) {
+            let fileURL = jitMetadataFileURL(seed);
+            try? FileManager.default.removeItem(atPath: fileURL.path)
+        }
+        if self.outputMetadataFileExists(seed) {
+            let fileURL = outputMetadataFileURL(seed);
+            try? FileManager.default.removeItem(atPath: fileURL.path)
+        }
+    }
+
     /// Returns the fuzzer for the active DispatchQueue.
     public static var current: Fuzzer? {
         return DispatchQueue.getSpecific(key: Fuzzer.dispatchQueueKey)
@@ -235,6 +282,7 @@ public class Fuzzer {
         assert(!isInitialized)
 
         // Initialize the script runner first so we are able to execute programs.
+        referenceRunner.initialize(with: self)
         runner.initialize(with: self)
 
         // Then initialize all components.
@@ -383,6 +431,9 @@ public class Fuzzer {
             // from another instance triggers a crash in this instance.
             processCrash(program, withSignal: termsig, withStderr: execution.stderr, withStdout: execution.stdout, origin: origin, withExectime: execution.execTime)
 
+        case .differential:
+            processDifferential(program, withStderr: execution.stderr, withStdout: execution.unOptStdout!, origin: origin, optStdout: execution.optStdout!)
+
         case .succeeded:
             var imported = false
             if let aspects = evaluator.evaluate(execution) {
@@ -403,6 +454,18 @@ public class Fuzzer {
         return execution.outcome
     }
 
+    public func importDifferential(_ program: Program, origin: ProgramOrigin) {
+        dispatchPrecondition(condition: .onQueue(queue))
+        let execution = execute(program, purpose: .other)
+        if case .differential = execution.outcome {
+            processDifferential(program, withStderr: execution.stderr, withStdout: execution.unOptStdout!, origin: origin, optStdout: execution.optStdout!)
+        } else {
+            // Non-deterministic differential
+            dispatchEvent(events.DifferentialFound, data: (program, behaviour: .flaky, origin: origin, opt_stdout: "remote import", unopt_stdout: "remote import", reproducesInNonReplMode: false))
+        }
+    }
+
+
     /// Imports a crashing program into this fuzzer.
     ///
     /// Similar to importProgram, but will make sure to generate a CrashFound event even if the crash does not reproduce.
@@ -449,6 +512,133 @@ public class Fuzzer {
         return currentCorpusImportJob.progress()
     }
 
+    public enum DifferentialExecute {
+        case force
+        case disabled
+        case auto
+    }
+
+
+    private func formatDate() -> String {
+        let formatter = DateFormatter()
+        formatter.dateFormat = "yyyyMMddHHmmss"
+        return formatter.string(from: Date())
+    }
+
+    func crashReproducesWithoutDumping(_ program: Program, _ script: String) -> Bool {
+        // write script to tmp file
+        let filename = "crash_repro_program_\(self.formatDate())_\(program.id).js"
+        let fileURL = URL(fileURLWithPath: "/tmp").appendingPathComponent(filename)
+
+        do {
+            try script.write(to: fileURL, atomically: false, encoding: String.Encoding.utf8)
+        } catch {
+            logger.error("Failed to write file \(fileURL): \(error)")
+            try? FileManager.default.removeItem(atPath: fileURL.path)
+            return false
+        }
+
+        let task = Process()
+
+        let d8Path = self.runner.processArguments[0]
+        let d8SDumpingFlags = ["--turbofan-dumping", "--generate-dump-positions", "--verify-heap-on-jit-dump", "--maglev-dumping", "--sparkplug-dumping"]
+        let d8FlagsWithoutDumping = self.runner.processArguments.filter { !d8SDumpingFlags.contains($0) && $0 != d8Path }
+
+        let errorPipe = Pipe()
+
+        task.executableURL = URL(fileURLWithPath: "/usr/bin/timeout")
+        task.arguments = ["15", d8Path] + d8FlagsWithoutDumping + [fileURL.path]
+        task.standardOutput = FileHandle.nullDevice
+        task.standardError = errorPipe
+
+        do {
+            try task.run()
+        } catch let error {
+            logger.error(error.localizedDescription)
+            try? FileManager.default.removeItem(atPath: fileURL.path)
+            return false
+        }
+
+        task.waitUntilExit()
+
+        if task.isRunning {
+            task.terminate()
+            try? FileManager.default.removeItem(atPath: fileURL.path)
+            return false
+        }
+
+        try? FileManager.default.removeItem(atPath: fileURL.path)
+
+        let stderr = String(data: errorPipe.fileHandleForReading.readDataToEndOfFile(), encoding: String.Encoding.utf8)
+
+        if stderr == nil {
+            return false
+        }
+        for p in execPoison {
+            if stderr!.contains(p) {
+                return false
+            }
+        }
+        return task.terminationStatus != 0 && task.terminationStatus != 124
+    }
+
+    func differentialReproducesInNonReplMode(_ program: Program, _ script: String, _ differentialFuzzingPositionDumpSeed: UInt32) -> Bool {
+        // write script to tmp file
+        let filename = "program_\(self.formatDate())_\(program.id)_\(differentialFuzzingPositionDumpSeed).js"
+        let fileURL = URL(fileURLWithPath: "/tmp").appendingPathComponent(filename)
+
+        // also prepend a filter for benign differentials here
+        let prependedScript = prependJS + script
+
+        do {
+            try prependedScript.write(to: fileURL, atomically: false, encoding: String.Encoding.utf8)
+        } catch {
+            logger.error("Failed to write file \(fileURL): \(error)")
+            return false
+        }
+
+        let task = Process()
+
+        let d8Path = self.runner.processArguments[0]
+
+        task.executableURL = URL(fileURLWithPath: "/usr/bin/timeout")
+        task.arguments = ["15", self.config.relateToolPath!, "--validate", "--d8=\(d8Path)", "--poc=\(fileURL.path)"]
+        task.standardOutput = FileHandle.nullDevice
+        task.standardError = FileHandle.nullDevice
+
+        do {
+            try task.run()
+        } catch let error {
+            logger.error(error.localizedDescription)
+            try? FileManager.default.removeItem(atPath: fileURL.path)
+            return false
+        }
+
+        task.waitUntilExit()
+
+        if task.isRunning {
+            task.terminate()
+            try? FileManager.default.removeItem(atPath: fileURL.path)
+            return false
+        }
+        try? FileManager.default.removeItem(atPath: fileURL.path)
+        return task.terminationStatus != 0 && task.terminationStatus != 124
+    }
+
+    private func readOutputDump(_ seed: UInt32) -> String? {
+        let filename = "/tmp/\(seed)_output_dump.txt"
+        let fileURL = URL(fileURLWithPath: filename)
+
+        guard let data = try? Data(contentsOf: fileURL) else {
+            logger.warning("Failed to read output file at \(fileURL)")
+            return nil
+        }
+
+        let asciiData = Data(data.filter { byte in byte <= 127 })
+
+        return String(data: asciiData, encoding: .utf8)!
+    }
+
     /// Executes a program.
     ///
     /// This will first lift the given FuzzIL program to the target language, then use the configured script runner to execute it.
@@ -457,17 +647,113 @@ public class Fuzzer {
     ///   - program: The FuzzIL program to execute.
     ///   - timeout: The timeout after which to abort execution. If nil, the default timeout of this fuzzer will be used.
     ///   - purpose: The purpose of this program execution.
+    ///   - differentialExecute: force disabled or auto (default)
     /// - Returns: An Execution structure representing the execution outcome.
-    public func execute(_ program: Program, withTimeout timeout: UInt32? = nil, purpose: ExecutionPurpose) -> Execution {
+    public func execute(_ program: Program, withTimeout timeout: UInt32? = nil,
+                        purpose: ExecutionPurpose,
+                        differentialExecute: DifferentialExecute = .auto) -> Execution {
         dispatchPrecondition(condition: .onQueue(queue))
         assert(runner.isInitialized)
 
-        let script = lifter.lift(program)
+        let startTime = Date();
+
+        var g = SystemRandomNumberGenerator()
+
+        // use unique localId for the seed
+        let differentialFuzzingPositionDumpSeed = localId * 100000 + UInt32(Int.random(in: 1...99999, using: &g));
+
+        self.removeMetadataFilesIfExist(differentialFuzzingPositionDumpSeed)
 
+        let script = lifter.lift(program)
         dispatchEvent(events.PreExecute, data: (program, purpose))
-        let execution = runner.run(script, withTimeout: timeout ?? config.timeout)
+
+        var execution = runner.run(script, withTimeout: timeout ?? config.timeout,
+            differentialFuzzingPositionDumpSeed: differentialFuzzingPositionDumpSeed)
         dispatchEvent(events.PostExecute, data: execution)
 
+
+        if execution.execTime * 1000 >= Double((timeout ?? config.timeout) + 500) {
+            logger.warning("execution took longer than expected \(execution.execTime * 1000)")
+        }
+
+        let isJitExecution = execution.compilersUsed.count >= 1
+
+        if isJitExecution && execution.outcome == .succeeded {
+            dispatchEvent(events.JITExecutingProgramFound, data: (program, execution.compilersUsed, true))
+        }
+
+        if execution.outcome == .succeeded && isJitExecution && self.jitMetadataFileExists(differentialFuzzingPositionDumpSeed) &&
+         differentialExecute != .disabled && purpose != .runtimeAssistedMutation {
+            assert(referenceRunner.isInitialized)
+
+            // read the file /tmp/{dumpling_seed}_output_dump.txt as a string
+            let opt_stdout = readOutputDump(differentialFuzzingPositionDumpSeed)
+            if opt_stdout == nil {
+                self.removeMetadataFilesIfExist(differentialFuzzingPositionDumpSeed)
+                return execution
+            }
+
+            let diff = referenceRunner.run(script, withTimeout: (timeout ?? config.timeout) * 2,
+                differentialFuzzingPositionDumpSeed: differentialFuzzingPositionDumpSeed)
+            // sparkplug is enabled in unopt runs so log that usage as well
+
+            if diff.compilersUsed.contains(.sparkplug) {
+                assert(!diff.compilersUsed.contains(.maglev) && !diff.compilersUsed.contains(.turbofan))
+                dispatchEvent(events.JITExecutingProgramFound, data: (program, diff.compilersUsed, false))
+            }
+
+            dispatchEvent(events.PostExecute, data: diff)
+
+            if (diff.outcome == .timedOut) {
+                // treat this as a timeout here so that we can
+                execution.outcome = .timedOut
+            }
+            if Double(diff.execTime * 1000) >= Double((timeout ?? config.timeout)*2 + 500) {
+                logger.warning("diff execution took longer than expected \(diff.execTime * 1000)")
+            }
+
+            // execution.execTime += diff.execTime
+            if (diff.outcome == .succeeded) {
+                let unopt_stdout = readOutputDump(differentialFuzzingPositionDumpSeed)
+                if unopt_stdout == nil {
+                    self.removeMetadataFilesIfExist(differentialFuzzingPositionDumpSeed)
+                    return execution
+                }
+                execution.unOptStdout = unopt_stdout
+                execution.optStdout = opt_stdout
+                if !relate(opt_stdout!, with: unopt_stdout!) {
+                    execution.outcome = .differential
+                    execution.reproducesInNonReplMode = differentialReproducesInNonReplMode(program, script, differentialFuzzingPositionDumpSeed)
+                }
+                let now = Date()
+                execution.bugOracleTime = now.timeIntervalSince(startTime)
+                if (execution.bugOracleTime!) * 1000 >= 8000.0 {
+                    logger.warning("bugOracle took longer than expected \(execution.bugOracleTime! * 1000)")
+                }
+                dispatchEvent(events.RelationPerformed, data: (program, execution))
+            } else {
+                // return diff
+            }
+
+            self.removeMetadataFilesIfExist(differentialFuzzingPositionDumpSeed)
+        } else {
+            self.removeMetadataFilesIfExist(differentialFuzzingPositionDumpSeed)
+
+            if case .crashed(_) = execution.outcome {
+                var poisoned = false
+                for p in execPoison {
+                    if execution.stderr.contains(p) {
+                        execution.outcome = .failed(1)
+                        poisoned = true
+                    }
+                }
+                if !poisoned && !crashReproducesWithoutDumping(program, script) {
+                    execution.outcome = .failed(2)
+                }
+            }
+        }
+
+        // assert(!self.jitMetadataFileExists(differentialFuzzingPositionDumpSeed))
         return execution
     }
 
@@ -553,11 +839,10 @@ public class Fuzzer {
                 program.comments.add("TERMSIG: \(termsig)", at: .footer)
                 program.comments.add("STDERR:", at: .footer)
                 program.comments.add(stderr.trimmingCharacters(in: .newlines), at: .footer)
-                program.comments.add("STDOUT:", at: .footer)
-                program.comments.add(stdout.trimmingCharacters(in: .newlines), at: .footer)
                 program.comments.add("FUZZER ARGS: \(config.arguments.joined(separator: " "))", at: .footer)
                 program.comments.add("TARGET ARGS: \(runner.processArguments.joined(separator: " "))", at: .footer)
                 program.comments.add("CONTRIBUTORS: \(program.contributors.map({ $0.name }).joined(separator: ", "))", at: .footer)
+                program.comments.add("REFERENCE ARGS: \(referenceRunner.processArguments.joined(separator: " "))\n", at: .footer)
                 program.comments.add("EXECUTION TIME: \(Int(exectime * 1000))ms", at: .footer)
             }
             assert(program.comments.at(.footer)?.contains("CRASH INFO") ?? false)
@@ -583,6 +868,38 @@ public class Fuzzer {
         }
     }
 
+    func processDifferential(_ program: Program, withStderr stderr: String, withStdout stdout: String, origin: ProgramOrigin, optStdout: String) {
+        func processCommon(_ program: Program) {
+            let hasDiffInfo = program.comments.at(.footer)?.contains("DIFFERENTIAL INFO") ?? false
+            if !hasDiffInfo {
+                program.comments.add("DIFFERENTIAL INFO\n==========\n", at: .footer)
+
+                program.comments.add("STDERR:\n" + stderr, at: .footer)
+                program.comments.add("ARGS: \(runner.processArguments.joined(separator: " "))\n", at: .footer)
+                program.comments.add("REFERENCE ARGS: \(referenceRunner.processArguments.joined(separator: " "))\n", at: .footer)
+            }
+            assert(program.comments.at(.footer)?.contains("DIFFERENTIAL INFO") ?? false)
+
+            // Check for uniqueness only after minimization
+            let execution = execute(program, withTimeout: self.config.timeout * 2, purpose: .other)
+            if case .differential = execution.outcome {
+                dispatchEvent(events.DifferentialFound, data: (program, .deterministic, origin, optStdout, stdout, execution.reproducesInNonReplMode!))
+            } else {
+                dispatchEvent(events.DifferentialFound, data: (program, .flaky, origin, optStdout, stdout, false))
+            }
+        }
+
+        if !origin.requiresMinimization() {
+            return processCommon(program)
+        }
+
+        fuzzGroup.enter()
+        minimizer.withMinimizedCopy(program, withAspects: ProgramAspects(outcome: .differential)) { minimizedProgram in
+            self.fuzzGroup.leave()
+             processCommon(minimizedProgram)
+        }
+    }
+
     /// Constructs a new ProgramBuilder using this fuzzing context.
     public func makeBuilder(forMutating parent: Program? = nil, mode: ProgramBuilder.Mode = .aggressive) -> ProgramBuilder {
         dispatchPrecondition(condition: .onQueue(queue))
@@ -699,20 +1016,6 @@ public class Fuzzer {
         return b.finalize()
     }
 
-    // Verifies that the fuzzer is not creating a large number of core dumps
-    public func checkCoreFileGeneration() {
-        #if os(Linux)
-        do {
-            let corePattern = try String(contentsOfFile: "/proc/sys/kernel/core_pattern", encoding: String.Encoding.ascii)
-            if !corePattern.hasPrefix("|/bin/false") {
-                logger.fatal("Please run: sudo sysctl -w 'kernel.core_pattern=|/bin/false'")
-            }
-        } catch {
-            logger.warning("Could not check core dump behaviour. Please ensure core_pattern is set to '|/bin/false'")
-        }
-        #endif
-    }
-
     /// Runs a number of startup tests to check whether everything is configured correctly.
     public func runStartupTests() {
         assert(isInitialized)
@@ -737,6 +1040,7 @@ public class Fuzzer {
         let complexProgram = makeComplexProgram()
         for _ in 0..<5 {
             let execution = execute(complexProgram, purpose: .startup)
+            logger.info("Execution time: \(execution.execTime * 1000)ms")
             maxExecutionTime = max(maxExecutionTime, execution.execTime)
         }
 
@@ -801,7 +1105,7 @@ public class Fuzzer {
 
         mutating func notifyImportOutcome(_ outcome: ExecutionOutcome) {
             switch outcome {
-            case .crashed:
+            case .crashed, .differential:
                 // This is unexpected so we don't track these
                 break
             case .failed:
diff --git a/Sources/Fuzzilli/Modules/Statistics.swift b/Sources/Fuzzilli/Modules/Statistics.swift
index 225cea6..d81f1cf 100644
--- a/Sources/Fuzzilli/Modules/Statistics.swift
+++ b/Sources/Fuzzilli/Modules/Statistics.swift
@@ -50,6 +50,14 @@ public class Statistics: Module {
     /// This is only computed for successful executions, and so excludes e.g. samples that timed out.
     private var executionTimeAvg = MovingAverage(n: 1000)
 
+    /// Moving average over the cummulative time it takes in the fuzzer to get through a bug oracle run
+    /// This will consider both executions and the time spent in the python script
+    private var cumbugOracleTimeAvg = MovingAverage(n: 1000)
+
+    private var optDumpSizeAvg = MovingAverage(n: 10000)
+    private var unOptDumpSizeAvg = MovingAverage(n: 10000)
+
+
     /// Moving average of the number of valid programs in the last 1000 generated programs.
     private var correctnessRate = MovingAverage(n: 1000)
 
@@ -73,6 +81,9 @@ public class Statistics: Module {
         ownData.avgProgramSize = programSizeAvg.currentValue
         ownData.avgCorpusProgramSize = corpusProgramSizeAvg.currentValue
         ownData.avgExecutionTime = executionTimeAvg.currentValue
+        ownData.avgBugOracleTime = cumbugOracleTimeAvg.currentValue
+        ownData.avgDumpSizeOpt = optDumpSizeAvg.currentValue
+        ownData.avgDumpSizeUnOpt = unOptDumpSizeAvg.currentValue
         ownData.fuzzerOverhead = fuzzerOverheadAvg.currentValue
         ownData.minimizationOverhead = minimizationOverheadAvg.currentValue
         ownData.correctnessRate = correctnessRate.currentValue
@@ -88,6 +99,13 @@ public class Statistics: Module {
             data.timedOutSamples += node.timedOutSamples
             data.totalExecs += node.totalExecs
 
+            data.relationsPerformed += node.relationsPerformed
+            data.sparkplugSamples += node.sparkplugSamples
+            data.maglevSamples += node.maglevSamples
+            data.turbofanSamples += node.turbofanSamples
+            data.jitSamples += node.jitSamples
+
+
             if !inactiveNodes.contains(id) {
                 // Add fields that only have meaning for active nodes
 
@@ -100,6 +118,9 @@ public class Statistics: Module {
                 data.avgProgramSize += node.avgProgramSize * numNodesRepresentedByData
                 data.avgCorpusProgramSize += node.avgCorpusProgramSize * numNodesRepresentedByData
                 data.avgExecutionTime += node.avgExecutionTime * numNodesRepresentedByData
+                data.avgBugOracleTime += node.avgBugOracleTime * numNodesRepresentedByData
+                data.avgDumpSizeOpt += node.avgDumpSizeOpt * numNodesRepresentedByData
+                data.avgDumpSizeUnOpt += node.avgDumpSizeUnOpt * numNodesRepresentedByData
                 data.execsPerSecond += node.execsPerSecond
                 data.fuzzerOverhead += node.fuzzerOverhead * numNodesRepresentedByData
                 data.minimizationOverhead += node.minimizationOverhead * numNodesRepresentedByData
@@ -116,6 +137,9 @@ public class Statistics: Module {
         data.avgProgramSize /= totalNumberOfNodes
         data.avgCorpusProgramSize /= totalNumberOfNodes
         data.avgExecutionTime /= totalNumberOfNodes
+        data.avgBugOracleTime /= totalNumberOfNodes
+        data.avgDumpSizeOpt /= totalNumberOfNodes
+        data.avgDumpSizeUnOpt /= totalNumberOfNodes
         data.fuzzerOverhead /= totalNumberOfNodes
         data.minimizationOverhead /= totalNumberOfNodes
         data.correctnessRate /= totalNumberOfNodes
@@ -127,6 +151,40 @@ public class Statistics: Module {
     public func initialize(with fuzzer: Fuzzer) {
         fuzzer.registerEventListener(for: fuzzer.events.CrashFound) { _ in
             self.ownData.crashingSamples += 1
+
+        }
+        fuzzer.registerEventListener(for: fuzzer.events.JITExecutingProgramFound) { ev in
+            for cu in ev.compilers {
+                if (cu == .turbofan) {
+                    self.ownData.turbofanSamples += 1
+                } else if (cu == .maglev) {
+                    self.ownData.maglevSamples += 1
+                } else {
+                    assert(cu == .sparkplug)
+                    self.ownData.sparkplugSamples += 1
+                }
+            }
+            if (ev.is_optimizing) {
+                assert(!ev.compilers.contains(.sparkplug))
+                self.ownData.jitSamples += 1
+            }
+        }
+        fuzzer.registerEventListener(for: fuzzer.events.RelationPerformed) { ev in
+            self.cumbugOracleTimeAvg.add(ev.execution.bugOracleTime!)
+            self.optDumpSizeAvg.add(ev.execution.optStdout!.count)
+            self.unOptDumpSizeAvg.add(ev.execution.unOptStdout!.count)
+
+            self.ownData.relationsPerformed += 1
+        }
+        fuzzer.registerEventListener(for: fuzzer.events.DifferentialFound) { ev in
+            if (ev.reproducesInNonReplMode) {
+                self.ownData.differentialSamples += 1
+            }
+            /*
+            if self.ownData.differentialSamples > 200 {
+                fatalError("Found more than 200 differentials, stopping")
+            }
+            */
         }
         fuzzer.registerEventListener(for: fuzzer.events.TimeOutFound) { _ in
             self.ownData.timedOutSamples += 1
@@ -164,6 +222,7 @@ public class Statistics: Module {
             let totalTime = now.timeIntervalSince(self.lastExecDate)
             self.lastExecDate = now
 
+
             let overhead = 1.0 - (exec.execTime / totalTime)
             self.fuzzerOverheadAvg.add(overhead)
         }
diff --git a/Sources/Fuzzilli/Modules/Storage.swift b/Sources/Fuzzilli/Modules/Storage.swift
index 3600507..40581cd 100644
--- a/Sources/Fuzzilli/Modules/Storage.swift
+++ b/Sources/Fuzzilli/Modules/Storage.swift
@@ -19,6 +19,7 @@ public class Storage: Module {
     private let storageDir: String
     private let crashesDir: String
     private let duplicateCrashesDir: String
+    private let differentialsDir: String
     private let corpusDir: String
     private let statisticsDir: String
     private let stateFile: String
@@ -35,6 +36,7 @@ public class Storage: Module {
         self.storageDir = storageDir
         self.crashesDir = storageDir + "/crashes"
         self.duplicateCrashesDir = storageDir + "/crashes/duplicates"
+        self.differentialsDir = storageDir + "/differentials"
         self.corpusDir = storageDir + "/corpus"
         self.failedDir = storageDir + "/failed"
         self.timeOutDir = storageDir + "/timeouts"
@@ -52,6 +54,7 @@ public class Storage: Module {
         do {
             try FileManager.default.createDirectory(atPath: crashesDir, withIntermediateDirectories: true)
             try FileManager.default.createDirectory(atPath: duplicateCrashesDir, withIntermediateDirectories: true)
+            try FileManager.default.createDirectory(atPath: differentialsDir, withIntermediateDirectories: true)
             try FileManager.default.createDirectory(atPath: corpusDir, withIntermediateDirectories: true)
             try FileManager.default.createDirectory(atPath: statisticsDir, withIntermediateDirectories: true)
             if fuzzer.config.enableDiagnostics {
@@ -95,6 +98,21 @@ public class Storage: Module {
             }
         }
 
+        fuzzer.registerEventListener(for: fuzzer.events.DifferentialFound) { ev in
+            let filename = "program_\(self.formatDate())_\(ev.program.id)_\(ev.behaviour.rawValue)"
+            var storeDir: String;
+            if (ev.reproducesInNonReplMode) {
+                storeDir = self.differentialsDir
+            } else {
+                return
+            }
+
+            self.storeProgram(ev.program, as: filename, in: storeDir)
+            if ev.opt_stdout != nil {
+                self.storeDifferentialDump(ev.opt_stdout!, and: ev.unopt_stdout, as: filename, in: storeDir)
+            }
+        }
+
         fuzzer.registerEventListener(for: fuzzer.events.InterestingProgramFound) { ev in
             let filename = "program_\(self.formatDate())_\(ev.program.id)"
             self.storeProgram(ev.program, as: filename, in: self.corpusDir)
@@ -103,7 +121,7 @@ public class Storage: Module {
         if fuzzer.config.enableDiagnostics {
             fuzzer.registerEventListener(for: fuzzer.events.DiagnosticsEvent) { ev in
                 let filename = "\(self.formatDate())_\(ev.name)_\(String(currentMillis()))"
-                let url = URL(fileURLWithPath: self.diagnosticsDir + filename + ".diag")
+                let url = URL(fileURLWithPath: self.diagnosticsDir + "/" + filename + ".diag")
                 self.createFile(url, withContent: ev.content)
             }
 
@@ -144,6 +162,13 @@ public class Storage: Module {
         }
     }
 
+    private func storeDifferentialDump(_ opt: String, and unopt: String, as filename: String, in directory: String) {
+            let opt_url = URL(fileURLWithPath: "\(directory)/\(filename)_opt.txt")
+            let unopt_url = URL(fileURLWithPath: "\(directory)/\(filename)_unopt.txt")
+            createFile(opt_url, withContent: opt)
+            createFile(unopt_url, withContent: unopt)
+        }
+
     private func storeProgram(_ program: Program, as filename: String, in directory: String) {
         // Always include comments when writing programs to disk
         let options = LiftingOptions.includeComments
diff --git a/Sources/Fuzzilli/Modules/Sync.swift b/Sources/Fuzzilli/Modules/Sync.swift
index 241b5f4..dbf074e 100644
--- a/Sources/Fuzzilli/Modules/Sync.swift
+++ b/Sources/Fuzzilli/Modules/Sync.swift
@@ -83,6 +83,10 @@ enum MessageType: UInt32 {
 
     // Log messages are forwarded from child to parent nides.
     case log                 = 6
+
+    // A program that caused a differential.
+    // Only sent from a children to their parent.
+    case differentialProgram = 7
 }
 
 /// Distributed fuzzing nodes can be configured to only share their corpus in one direction in the tree.
@@ -243,6 +247,15 @@ public class DistributedFuzzingParentNode: DistributedFuzzingNode, Module {
                 logger.warning("Received malformed program from child node: \(error)")
             }
 
+        case .differentialProgram:
+            do {
+                let proto = try Fuzzilli_Protobuf_Program(serializedData: data)
+                let program = try Program(from: proto)
+                fuzzer.importDifferential(program, origin: .child(id: child))
+            } catch {
+                logger.warning("Received malformed program from child node: \(error)")
+            }
+
         case .interestingProgram:
             guard shouldAcceptCorpusSamplesFromChildren() else {
                 logger.warning("Received corpus sample from child node but not configured to accept them (corpus synchronization mode is \(corpusSynchronizationMode)). Ignoring message.")
@@ -357,6 +370,10 @@ public class DistributedFuzzingChildNode: DistributedFuzzingNode, Module {
             self.sendProgram(ev.program, as: .crashingProgram)
         }
 
+        fuzzer.registerEventListener(for: fuzzer.events.DifferentialFound) { ev in
+            self.sendProgram(ev.program, as: .differentialProgram)
+        }
+
         fuzzer.registerEventListener(for: fuzzer.events.Shutdown) { _ in
             if !self.parentIsShuttingDown {
                 let shutdownGroup = DispatchGroup()
@@ -390,6 +407,26 @@ public class DistributedFuzzingChildNode: DistributedFuzzingNode, Module {
             }
         }
 
+        // remove every *_output_dump.txt and *_position_dump.json that are older than 5mins
+        fuzzer.timers.scheduleTask(every: 10 * Minutes) {
+            let dumpFilesRegex = try! Regex("^\\d+_(output|position)_dump\\.(txt|json)$")
+
+            let items = try! FileManager.default.contentsOfDirectory(atPath: "/tmp")
+
+            for item in items {
+                if item.contains(dumpFilesRegex) {
+                    do {
+                        let itemPath = "/tmp/\(item)";
+                        let attr = try FileManager.default.attributesOfItem(atPath: itemPath)
+                        let date = attr[FileAttributeKey.modificationDate] as? Date
+                        if (-(date!.timeIntervalSinceNow) >= 5 * Minutes) {
+                            try? FileManager.default.removeItem(atPath: itemPath)
+                        }
+                    } catch {}
+                }
+            }
+        }
+
         // Forward log events to our parent node.
         fuzzer.registerEventListener(for: fuzzer.events.Log) { ev in
             let msg = Fuzzilli_Protobuf_LogMessage.with {
@@ -461,6 +498,7 @@ public class DistributedFuzzingChildNode: DistributedFuzzingNode, Module {
             }
 
         case .crashingProgram,
+             .differentialProgram,
              .statistics,
              .log:
             logger.error("Received unexpected message: \(messageType)")
@@ -468,7 +506,7 @@ public class DistributedFuzzingChildNode: DistributedFuzzingNode, Module {
     }
 
     private func sendProgram(_ program: Program, as type: MessageType) {
-        assert(type == .interestingProgram || type == .crashingProgram)
+        assert(type == .interestingProgram || type == .crashingProgram || type == .differentialProgram)
         let proto = program.asProtobuf()
         guard let payload = try? proto.serializedData() else {
             return logger.error("Failed to serialize program")
diff --git a/Sources/Fuzzilli/Mutators/RuntimeAssistedMutator.swift b/Sources/Fuzzilli/Mutators/RuntimeAssistedMutator.swift
index 67498ea..1926cf4 100644
--- a/Sources/Fuzzilli/Mutators/RuntimeAssistedMutator.swift
+++ b/Sources/Fuzzilli/Mutators/RuntimeAssistedMutator.swift
@@ -89,7 +89,7 @@ public class RuntimeAssistedMutator: Mutator {
         assert(instrumentedProgram.code.contains(where: { $0.op is JsInternalOperation }))
 
         // Execute the instrumented program (with a higher timeout) and collect the output.
-        let execution = fuzzer.execute(instrumentedProgram, withTimeout: fuzzer.config.timeout * 4, purpose: .runtimeAssistedMutation)
+        let execution = fuzzer.execute(instrumentedProgram, withTimeout: fuzzer.config.timeout * 4, purpose: .runtimeAssistedMutation, differentialExecute: .disabled)
         switch execution.outcome {
         case .failed(_):
             // We generally do not expect the instrumentation code itself to cause runtime exceptions. Even if it performs new actions those should be guarded with try-catch.
@@ -114,6 +114,8 @@ public class RuntimeAssistedMutator: Mutator {
         case .succeeded:
             // The expected case.
             break
+        case .differential:
+            fatalError("Differential result impossible")
         }
 
         // Process the output to build the mutated program.
diff --git a/Sources/Fuzzilli/Protobuf/operations.pb.swift b/Sources/Fuzzilli/Protobuf/operations.pb.swift
index f01037f..f40ff9b 100644
--- a/Sources/Fuzzilli/Protobuf/operations.pb.swift
+++ b/Sources/Fuzzilli/Protobuf/operations.pb.swift
@@ -72,7 +72,7 @@ public enum Fuzzilli_Protobuf_PropertyType: SwiftProtobuf.Enum {
 
 extension Fuzzilli_Protobuf_PropertyType: CaseIterable {
   // The compiler won't synthesize support with the UNRECOGNIZED case.
-  public static let allCases: [Fuzzilli_Protobuf_PropertyType] = [
+  public static var allCases: [Fuzzilli_Protobuf_PropertyType] = [
     .value,
     .getter,
     .setter,
@@ -132,7 +132,7 @@ public enum Fuzzilli_Protobuf_UnaryOperator: SwiftProtobuf.Enum {
 
 extension Fuzzilli_Protobuf_UnaryOperator: CaseIterable {
   // The compiler won't synthesize support with the UNRECOGNIZED case.
-  public static let allCases: [Fuzzilli_Protobuf_UnaryOperator] = [
+  public static var allCases: [Fuzzilli_Protobuf_UnaryOperator] = [
     .preInc,
     .preDec,
     .postInc,
@@ -214,7 +214,7 @@ public enum Fuzzilli_Protobuf_BinaryOperator: SwiftProtobuf.Enum {
 
 extension Fuzzilli_Protobuf_BinaryOperator: CaseIterable {
   // The compiler won't synthesize support with the UNRECOGNIZED case.
-  public static let allCases: [Fuzzilli_Protobuf_BinaryOperator] = [
+  public static var allCases: [Fuzzilli_Protobuf_BinaryOperator] = [
     .add,
     .sub,
     .mul,
@@ -284,7 +284,7 @@ public enum Fuzzilli_Protobuf_Comparator: SwiftProtobuf.Enum {
 
 extension Fuzzilli_Protobuf_Comparator: CaseIterable {
   // The compiler won't synthesize support with the UNRECOGNIZED case.
-  public static let allCases: [Fuzzilli_Protobuf_Comparator] = [
+  public static var allCases: [Fuzzilli_Protobuf_Comparator] = [
     .equal,
     .strictEqual,
     .notEqual,
@@ -1561,6 +1561,16 @@ public struct Fuzzilli_Protobuf_Return {
   public init() {}
 }
 
+public struct Fuzzilli_Protobuf_DifferentialHash {
+  // SwiftProtobuf.Message conformance is added in an extension below. See the
+  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
+  // methods supported on all messages.
+
+  public var unknownFields = SwiftProtobuf.UnknownStorage()
+
+  public init() {}
+}
+
 public struct Fuzzilli_Protobuf_Yield {
   // SwiftProtobuf.Message conformance is added in an extension below. See the
   // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
@@ -2511,192 +2521,6 @@ public struct Fuzzilli_Protobuf_Print {
   public init() {}
 }
 
-#if swift(>=5.5) && canImport(_Concurrency)
-extension Fuzzilli_Protobuf_PropertyType: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_UnaryOperator: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_BinaryOperator: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_Comparator: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_Parameters: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_LoadInteger: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_LoadBigInt: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_LoadFloat: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_LoadString: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_LoadBoolean: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_LoadUndefined: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_LoadNull: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_LoadThis: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_LoadArguments: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_LoadRegExp: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_BeginObjectLiteral: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_ObjectLiteralAddProperty: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_ObjectLiteralAddElement: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_ObjectLiteralAddComputedProperty: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_ObjectLiteralCopyProperties: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_ObjectLiteralSetPrototype: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_BeginObjectLiteralMethod: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_EndObjectLiteralMethod: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_BeginObjectLiteralComputedMethod: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_EndObjectLiteralComputedMethod: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_BeginObjectLiteralGetter: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_EndObjectLiteralGetter: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_BeginObjectLiteralSetter: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_EndObjectLiteralSetter: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_EndObjectLiteral: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_BeginClassDefinition: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_BeginClassConstructor: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_EndClassConstructor: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_ClassAddInstanceProperty: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_ClassAddInstanceElement: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_ClassAddInstanceComputedProperty: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_BeginClassInstanceMethod: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_EndClassInstanceMethod: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_BeginClassInstanceGetter: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_EndClassInstanceGetter: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_BeginClassInstanceSetter: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_EndClassInstanceSetter: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_ClassAddStaticProperty: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_ClassAddStaticElement: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_ClassAddStaticComputedProperty: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_BeginClassStaticInitializer: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_EndClassStaticInitializer: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_BeginClassStaticMethod: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_EndClassStaticMethod: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_BeginClassStaticGetter: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_EndClassStaticGetter: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_BeginClassStaticSetter: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_EndClassStaticSetter: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_ClassAddPrivateInstanceProperty: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_BeginClassPrivateInstanceMethod: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_EndClassPrivateInstanceMethod: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_ClassAddPrivateStaticProperty: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_BeginClassPrivateStaticMethod: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_EndClassPrivateStaticMethod: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_EndClassDefinition: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_CreateArray: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_CreateIntArray: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_CreateFloatArray: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_CreateTemplateString: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_CreateArrayWithSpread: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_LoadBuiltin: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_GetProperty: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_SetProperty: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_UpdateProperty: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_DeleteProperty: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_ConfigureProperty: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_GetElement: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_SetElement: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_UpdateElement: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_DeleteElement: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_ConfigureElement: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_GetComputedProperty: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_SetComputedProperty: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_UpdateComputedProperty: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_DeleteComputedProperty: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_ConfigureComputedProperty: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_TypeOf: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_TestInstanceOf: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_TestIn: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_BeginPlainFunction: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_EndPlainFunction: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_BeginArrowFunction: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_EndArrowFunction: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_BeginGeneratorFunction: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_EndGeneratorFunction: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_BeginAsyncFunction: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_EndAsyncFunction: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_BeginAsyncArrowFunction: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_EndAsyncArrowFunction: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_BeginAsyncGeneratorFunction: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_EndAsyncGeneratorFunction: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_BeginConstructor: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_EndConstructor: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_Return: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_Yield: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_YieldEach: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_Await: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_CallFunction: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_CallFunctionWithSpread: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_Construct: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_ConstructWithSpread: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_CallMethod: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_CallMethodWithSpread: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_CallComputedMethod: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_CallComputedMethodWithSpread: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_UnaryOperation: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_BinaryOperation: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_TernaryOperation: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_Update: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_Dup: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_Reassign: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_DestructArray: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_DestructArrayAndReassign: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_DestructObject: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_DestructObjectAndReassign: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_Compare: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_LoadNamedVariable: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_StoreNamedVariable: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_DefineNamedVariable: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_Eval: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_CallSuperConstructor: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_CallSuperMethod: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_GetPrivateProperty: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_SetPrivateProperty: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_UpdatePrivateProperty: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_CallPrivateMethod: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_GetSuperProperty: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_SetSuperProperty: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_GetComputedSuperProperty: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_SetComputedSuperProperty: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_UpdateSuperProperty: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_LoadNewTarget: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_Explore: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_Probe: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_Fixup: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_BeginWith: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_EndWith: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_BeginIf: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_BeginElse: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_EndIf: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_BeginSwitch: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_BeginSwitchCase: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_BeginSwitchDefaultCase: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_SwitchBreak: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_EndSwitchCase: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_EndSwitch: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_BeginWhileLoopHeader: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_BeginWhileLoopBody: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_EndWhileLoop: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_BeginDoWhileLoopBody: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_BeginDoWhileLoopHeader: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_EndDoWhileLoop: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_BeginForLoopInitializer: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_BeginForLoopCondition: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_BeginForLoopAfterthought: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_BeginForLoopBody: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_EndForLoop: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_BeginForInLoop: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_EndForInLoop: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_BeginForOfLoop: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_BeginForOfLoopWithDestruct: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_EndForOfLoop: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_BeginRepeatLoop: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_EndRepeatLoop: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_LoopBreak: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_LoopContinue: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_BeginTry: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_BeginCatch: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_BeginFinally: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_EndTryCatch: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_EndTryCatchFinally: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_ThrowException: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_BeginCodeString: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_EndCodeString: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_BeginBlockStatement: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_EndBlockStatement: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_Nop: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_Print: @unchecked Sendable {}
-#endif  // swift(>=5.5) && canImport(_Concurrency)
-
 // MARK: - Code below here is support for the SwiftProtobuf runtime.
 
 fileprivate let _protobuf_package = "fuzzilli.protobuf"
@@ -2764,12 +2588,9 @@ extension Fuzzilli_Protobuf_Parameters: SwiftProtobuf.Message, SwiftProtobuf._Me
 
   public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
     while let fieldNumber = try decoder.nextFieldNumber() {
-      // The use of inline closures is to circumvent an issue where the compiler
-      // allocates stack space for every case branch when no optimizations are
-      // enabled. https://github.com/apple/swift-protobuf/issues/1034
       switch fieldNumber {
-      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.count) }()
-      case 2: try { try decoder.decodeSingularBoolField(value: &self.hasRest_p) }()
+      case 1: try decoder.decodeSingularUInt32Field(value: &self.count)
+      case 2: try decoder.decodeSingularBoolField(value: &self.hasRest_p)
       default: break
       }
     }
@@ -2801,11 +2622,8 @@ extension Fuzzilli_Protobuf_LoadInteger: SwiftProtobuf.Message, SwiftProtobuf._M
 
   public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
     while let fieldNumber = try decoder.nextFieldNumber() {
-      // The use of inline closures is to circumvent an issue where the compiler
-      // allocates stack space for every case branch when no optimizations are
-      // enabled. https://github.com/apple/swift-protobuf/issues/1034
       switch fieldNumber {
-      case 1: try { try decoder.decodeSingularInt64Field(value: &self.value) }()
+      case 1: try decoder.decodeSingularInt64Field(value: &self.value)
       default: break
       }
     }
@@ -2833,11 +2651,8 @@ extension Fuzzilli_Protobuf_LoadBigInt: SwiftProtobuf.Message, SwiftProtobuf._Me
 
   public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
     while let fieldNumber = try decoder.nextFieldNumber() {
-      // The use of inline closures is to circumvent an issue where the compiler
-      // allocates stack space for every case branch when no optimizations are
-      // enabled. https://github.com/apple/swift-protobuf/issues/1034
       switch fieldNumber {
-      case 1: try { try decoder.decodeSingularInt64Field(value: &self.value) }()
+      case 1: try decoder.decodeSingularInt64Field(value: &self.value)
       default: break
       }
     }
@@ -2865,11 +2680,8 @@ extension Fuzzilli_Protobuf_LoadFloat: SwiftProtobuf.Message, SwiftProtobuf._Mes
 
   public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
     while let fieldNumber = try decoder.nextFieldNumber() {
-      // The use of inline closures is to circumvent an issue where the compiler
-      // allocates stack space for every case branch when no optimizations are
-      // enabled. https://github.com/apple/swift-protobuf/issues/1034
       switch fieldNumber {
-      case 1: try { try decoder.decodeSingularDoubleField(value: &self.value) }()
+      case 1: try decoder.decodeSingularDoubleField(value: &self.value)
       default: break
       }
     }
@@ -2897,11 +2709,8 @@ extension Fuzzilli_Protobuf_LoadString: SwiftProtobuf.Message, SwiftProtobuf._Me
 
   public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
     while let fieldNumber = try decoder.nextFieldNumber() {
-      // The use of inline closures is to circumvent an issue where the compiler
-      // allocates stack space for every case branch when no optimizations are
-      // enabled. https://github.com/apple/swift-protobuf/issues/1034
       switch fieldNumber {
-      case 1: try { try decoder.decodeSingularStringField(value: &self.value) }()
+      case 1: try decoder.decodeSingularStringField(value: &self.value)
       default: break
       }
     }
@@ -2929,11 +2738,8 @@ extension Fuzzilli_Protobuf_LoadBoolean: SwiftProtobuf.Message, SwiftProtobuf._M
 
   public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
     while let fieldNumber = try decoder.nextFieldNumber() {
-      // The use of inline closures is to circumvent an issue where the compiler
-      // allocates stack space for every case branch when no optimizations are
-      // enabled. https://github.com/apple/swift-protobuf/issues/1034
       switch fieldNumber {
-      case 1: try { try decoder.decodeSingularBoolField(value: &self.value) }()
+      case 1: try decoder.decodeSingularBoolField(value: &self.value)
       default: break
       }
     }
@@ -3038,12 +2844,9 @@ extension Fuzzilli_Protobuf_LoadRegExp: SwiftProtobuf.Message, SwiftProtobuf._Me
 
   public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
     while let fieldNumber = try decoder.nextFieldNumber() {
-      // The use of inline closures is to circumvent an issue where the compiler
-      // allocates stack space for every case branch when no optimizations are
-      // enabled. https://github.com/apple/swift-protobuf/issues/1034
       switch fieldNumber {
-      case 1: try { try decoder.decodeSingularStringField(value: &self.pattern) }()
-      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.flags) }()
+      case 1: try decoder.decodeSingularStringField(value: &self.pattern)
+      case 2: try decoder.decodeSingularUInt32Field(value: &self.flags)
       default: break
       }
     }
@@ -3094,11 +2897,8 @@ extension Fuzzilli_Protobuf_ObjectLiteralAddProperty: SwiftProtobuf.Message, Swi
 
   public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
     while let fieldNumber = try decoder.nextFieldNumber() {
-      // The use of inline closures is to circumvent an issue where the compiler
-      // allocates stack space for every case branch when no optimizations are
-      // enabled. https://github.com/apple/swift-protobuf/issues/1034
       switch fieldNumber {
-      case 1: try { try decoder.decodeSingularStringField(value: &self.propertyName) }()
+      case 1: try decoder.decodeSingularStringField(value: &self.propertyName)
       default: break
       }
     }
@@ -3126,11 +2926,8 @@ extension Fuzzilli_Protobuf_ObjectLiteralAddElement: SwiftProtobuf.Message, Swif
 
   public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
     while let fieldNumber = try decoder.nextFieldNumber() {
-      // The use of inline closures is to circumvent an issue where the compiler
-      // allocates stack space for every case branch when no optimizations are
-      // enabled. https://github.com/apple/swift-protobuf/issues/1034
       switch fieldNumber {
-      case 1: try { try decoder.decodeSingularInt64Field(value: &self.index) }()
+      case 1: try decoder.decodeSingularInt64Field(value: &self.index)
       default: break
       }
     }
@@ -3216,28 +3013,21 @@ extension Fuzzilli_Protobuf_BeginObjectLiteralMethod: SwiftProtobuf.Message, Swi
 
   public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
     while let fieldNumber = try decoder.nextFieldNumber() {
-      // The use of inline closures is to circumvent an issue where the compiler
-      // allocates stack space for every case branch when no optimizations are
-      // enabled. https://github.com/apple/swift-protobuf/issues/1034
       switch fieldNumber {
-      case 1: try { try decoder.decodeSingularStringField(value: &self.methodName) }()
-      case 2: try { try decoder.decodeSingularMessageField(value: &self._parameters) }()
+      case 1: try decoder.decodeSingularStringField(value: &self.methodName)
+      case 2: try decoder.decodeSingularMessageField(value: &self._parameters)
       default: break
       }
     }
   }
 
   public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
-    // The use of inline closures is to circumvent an issue where the compiler
-    // allocates stack space for every if/case branch local when no optimizations
-    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
-    // https://github.com/apple/swift-protobuf/issues/1182
     if !self.methodName.isEmpty {
       try visitor.visitSingularStringField(value: self.methodName, fieldNumber: 1)
     }
-    try { if let v = self._parameters {
+    if let v = self._parameters {
       try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
-    } }()
+    }
     try unknownFields.traverse(visitor: &visitor)
   }
 
@@ -3276,24 +3066,17 @@ extension Fuzzilli_Protobuf_BeginObjectLiteralComputedMethod: SwiftProtobuf.Mess
 
   public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
     while let fieldNumber = try decoder.nextFieldNumber() {
-      // The use of inline closures is to circumvent an issue where the compiler
-      // allocates stack space for every case branch when no optimizations are
-      // enabled. https://github.com/apple/swift-protobuf/issues/1034
       switch fieldNumber {
-      case 1: try { try decoder.decodeSingularMessageField(value: &self._parameters) }()
+      case 1: try decoder.decodeSingularMessageField(value: &self._parameters)
       default: break
       }
     }
   }
 
   public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
-    // The use of inline closures is to circumvent an issue where the compiler
-    // allocates stack space for every if/case branch local when no optimizations
-    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
-    // https://github.com/apple/swift-protobuf/issues/1182
-    try { if let v = self._parameters {
+    if let v = self._parameters {
       try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
-    } }()
+    }
     try unknownFields.traverse(visitor: &visitor)
   }
 
@@ -3331,11 +3114,8 @@ extension Fuzzilli_Protobuf_BeginObjectLiteralGetter: SwiftProtobuf.Message, Swi
 
   public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
     while let fieldNumber = try decoder.nextFieldNumber() {
-      // The use of inline closures is to circumvent an issue where the compiler
-      // allocates stack space for every case branch when no optimizations are
-      // enabled. https://github.com/apple/swift-protobuf/issues/1034
       switch fieldNumber {
-      case 1: try { try decoder.decodeSingularStringField(value: &self.propertyName) }()
+      case 1: try decoder.decodeSingularStringField(value: &self.propertyName)
       default: break
       }
     }
@@ -3382,11 +3162,8 @@ extension Fuzzilli_Protobuf_BeginObjectLiteralSetter: SwiftProtobuf.Message, Swi
 
   public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
     while let fieldNumber = try decoder.nextFieldNumber() {
-      // The use of inline closures is to circumvent an issue where the compiler
-      // allocates stack space for every case branch when no optimizations are
-      // enabled. https://github.com/apple/swift-protobuf/issues/1034
       switch fieldNumber {
-      case 1: try { try decoder.decodeSingularStringField(value: &self.propertyName) }()
+      case 1: try decoder.decodeSingularStringField(value: &self.propertyName)
       default: break
       }
     }
@@ -3452,11 +3229,8 @@ extension Fuzzilli_Protobuf_BeginClassDefinition: SwiftProtobuf.Message, SwiftPr
 
   public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
     while let fieldNumber = try decoder.nextFieldNumber() {
-      // The use of inline closures is to circumvent an issue where the compiler
-      // allocates stack space for every case branch when no optimizations are
-      // enabled. https://github.com/apple/swift-protobuf/issues/1034
       switch fieldNumber {
-      case 1: try { try decoder.decodeSingularBoolField(value: &self.hasSuperclass_p) }()
+      case 1: try decoder.decodeSingularBoolField(value: &self.hasSuperclass_p)
       default: break
       }
     }
@@ -3484,24 +3258,17 @@ extension Fuzzilli_Protobuf_BeginClassConstructor: SwiftProtobuf.Message, SwiftP
 
   public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
     while let fieldNumber = try decoder.nextFieldNumber() {
-      // The use of inline closures is to circumvent an issue where the compiler
-      // allocates stack space for every case branch when no optimizations are
-      // enabled. https://github.com/apple/swift-protobuf/issues/1034
       switch fieldNumber {
-      case 1: try { try decoder.decodeSingularMessageField(value: &self._parameters) }()
+      case 1: try decoder.decodeSingularMessageField(value: &self._parameters)
       default: break
       }
     }
   }
 
   public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
-    // The use of inline closures is to circumvent an issue where the compiler
-    // allocates stack space for every if/case branch local when no optimizations
-    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
-    // https://github.com/apple/swift-protobuf/issues/1182
-    try { if let v = self._parameters {
+    if let v = self._parameters {
       try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
-    } }()
+    }
     try unknownFields.traverse(visitor: &visitor)
   }
 
@@ -3540,12 +3307,9 @@ extension Fuzzilli_Protobuf_ClassAddInstanceProperty: SwiftProtobuf.Message, Swi
 
   public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
     while let fieldNumber = try decoder.nextFieldNumber() {
-      // The use of inline closures is to circumvent an issue where the compiler
-      // allocates stack space for every case branch when no optimizations are
-      // enabled. https://github.com/apple/swift-protobuf/issues/1034
       switch fieldNumber {
-      case 1: try { try decoder.decodeSingularStringField(value: &self.propertyName) }()
-      case 2: try { try decoder.decodeSingularBoolField(value: &self.hasValue_p) }()
+      case 1: try decoder.decodeSingularStringField(value: &self.propertyName)
+      case 2: try decoder.decodeSingularBoolField(value: &self.hasValue_p)
       default: break
       }
     }
@@ -3578,12 +3342,9 @@ extension Fuzzilli_Protobuf_ClassAddInstanceElement: SwiftProtobuf.Message, Swif
 
   public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
     while let fieldNumber = try decoder.nextFieldNumber() {
-      // The use of inline closures is to circumvent an issue where the compiler
-      // allocates stack space for every case branch when no optimizations are
-      // enabled. https://github.com/apple/swift-protobuf/issues/1034
       switch fieldNumber {
-      case 1: try { try decoder.decodeSingularInt64Field(value: &self.index) }()
-      case 2: try { try decoder.decodeSingularBoolField(value: &self.hasValue_p) }()
+      case 1: try decoder.decodeSingularInt64Field(value: &self.index)
+      case 2: try decoder.decodeSingularBoolField(value: &self.hasValue_p)
       default: break
       }
     }
@@ -3615,11 +3376,8 @@ extension Fuzzilli_Protobuf_ClassAddInstanceComputedProperty: SwiftProtobuf.Mess
 
   public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
     while let fieldNumber = try decoder.nextFieldNumber() {
-      // The use of inline closures is to circumvent an issue where the compiler
-      // allocates stack space for every case branch when no optimizations are
-      // enabled. https://github.com/apple/swift-protobuf/issues/1034
       switch fieldNumber {
-      case 1: try { try decoder.decodeSingularBoolField(value: &self.hasValue_p) }()
+      case 1: try decoder.decodeSingularBoolField(value: &self.hasValue_p)
       default: break
       }
     }
@@ -3648,28 +3406,21 @@ extension Fuzzilli_Protobuf_BeginClassInstanceMethod: SwiftProtobuf.Message, Swi
 
   public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
     while let fieldNumber = try decoder.nextFieldNumber() {
-      // The use of inline closures is to circumvent an issue where the compiler
-      // allocates stack space for every case branch when no optimizations are
-      // enabled. https://github.com/apple/swift-protobuf/issues/1034
       switch fieldNumber {
-      case 1: try { try decoder.decodeSingularStringField(value: &self.methodName) }()
-      case 2: try { try decoder.decodeSingularMessageField(value: &self._parameters) }()
+      case 1: try decoder.decodeSingularStringField(value: &self.methodName)
+      case 2: try decoder.decodeSingularMessageField(value: &self._parameters)
       default: break
       }
     }
   }
 
   public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
-    // The use of inline closures is to circumvent an issue where the compiler
-    // allocates stack space for every if/case branch local when no optimizations
-    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
-    // https://github.com/apple/swift-protobuf/issues/1182
     if !self.methodName.isEmpty {
       try visitor.visitSingularStringField(value: self.methodName, fieldNumber: 1)
     }
-    try { if let v = self._parameters {
+    if let v = self._parameters {
       try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
-    } }()
+    }
     try unknownFields.traverse(visitor: &visitor)
   }
 
@@ -3708,11 +3459,8 @@ extension Fuzzilli_Protobuf_BeginClassInstanceGetter: SwiftProtobuf.Message, Swi
 
   public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
     while let fieldNumber = try decoder.nextFieldNumber() {
-      // The use of inline closures is to circumvent an issue where the compiler
-      // allocates stack space for every case branch when no optimizations are
-      // enabled. https://github.com/apple/swift-protobuf/issues/1034
       switch fieldNumber {
-      case 1: try { try decoder.decodeSingularStringField(value: &self.propertyName) }()
+      case 1: try decoder.decodeSingularStringField(value: &self.propertyName)
       default: break
       }
     }
@@ -3759,11 +3507,8 @@ extension Fuzzilli_Protobuf_BeginClassInstanceSetter: SwiftProtobuf.Message, Swi
 
   public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
     while let fieldNumber = try decoder.nextFieldNumber() {
-      // The use of inline closures is to circumvent an issue where the compiler
-      // allocates stack space for every case branch when no optimizations are
-      // enabled. https://github.com/apple/swift-protobuf/issues/1034
       switch fieldNumber {
-      case 1: try { try decoder.decodeSingularStringField(value: &self.propertyName) }()
+      case 1: try decoder.decodeSingularStringField(value: &self.propertyName)
       default: break
       }
     }
@@ -3811,12 +3556,9 @@ extension Fuzzilli_Protobuf_ClassAddStaticProperty: SwiftProtobuf.Message, Swift
 
   public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
     while let fieldNumber = try decoder.nextFieldNumber() {
-      // The use of inline closures is to circumvent an issue where the compiler
-      // allocates stack space for every case branch when no optimizations are
-      // enabled. https://github.com/apple/swift-protobuf/issues/1034
       switch fieldNumber {
-      case 1: try { try decoder.decodeSingularStringField(value: &self.propertyName) }()
-      case 2: try { try decoder.decodeSingularBoolField(value: &self.hasValue_p) }()
+      case 1: try decoder.decodeSingularStringField(value: &self.propertyName)
+      case 2: try decoder.decodeSingularBoolField(value: &self.hasValue_p)
       default: break
       }
     }
@@ -3849,12 +3591,9 @@ extension Fuzzilli_Protobuf_ClassAddStaticElement: SwiftProtobuf.Message, SwiftP
 
   public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
     while let fieldNumber = try decoder.nextFieldNumber() {
-      // The use of inline closures is to circumvent an issue where the compiler
-      // allocates stack space for every case branch when no optimizations are
-      // enabled. https://github.com/apple/swift-protobuf/issues/1034
       switch fieldNumber {
-      case 1: try { try decoder.decodeSingularInt64Field(value: &self.index) }()
-      case 2: try { try decoder.decodeSingularBoolField(value: &self.hasValue_p) }()
+      case 1: try decoder.decodeSingularInt64Field(value: &self.index)
+      case 2: try decoder.decodeSingularBoolField(value: &self.hasValue_p)
       default: break
       }
     }
@@ -3886,11 +3625,8 @@ extension Fuzzilli_Protobuf_ClassAddStaticComputedProperty: SwiftProtobuf.Messag
 
   public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
     while let fieldNumber = try decoder.nextFieldNumber() {
-      // The use of inline closures is to circumvent an issue where the compiler
-      // allocates stack space for every case branch when no optimizations are
-      // enabled. https://github.com/apple/swift-protobuf/issues/1034
       switch fieldNumber {
-      case 1: try { try decoder.decodeSingularBoolField(value: &self.hasValue_p) }()
+      case 1: try decoder.decodeSingularBoolField(value: &self.hasValue_p)
       default: break
       }
     }
@@ -3957,28 +3693,21 @@ extension Fuzzilli_Protobuf_BeginClassStaticMethod: SwiftProtobuf.Message, Swift
 
   public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
     while let fieldNumber = try decoder.nextFieldNumber() {
-      // The use of inline closures is to circumvent an issue where the compiler
-      // allocates stack space for every case branch when no optimizations are
-      // enabled. https://github.com/apple/swift-protobuf/issues/1034
       switch fieldNumber {
-      case 1: try { try decoder.decodeSingularStringField(value: &self.methodName) }()
-      case 2: try { try decoder.decodeSingularMessageField(value: &self._parameters) }()
+      case 1: try decoder.decodeSingularStringField(value: &self.methodName)
+      case 2: try decoder.decodeSingularMessageField(value: &self._parameters)
       default: break
       }
     }
   }
 
   public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
-    // The use of inline closures is to circumvent an issue where the compiler
-    // allocates stack space for every if/case branch local when no optimizations
-    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
-    // https://github.com/apple/swift-protobuf/issues/1182
     if !self.methodName.isEmpty {
       try visitor.visitSingularStringField(value: self.methodName, fieldNumber: 1)
     }
-    try { if let v = self._parameters {
+    if let v = self._parameters {
       try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
-    } }()
+    }
     try unknownFields.traverse(visitor: &visitor)
   }
 
@@ -4017,11 +3746,8 @@ extension Fuzzilli_Protobuf_BeginClassStaticGetter: SwiftProtobuf.Message, Swift
 
   public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
     while let fieldNumber = try decoder.nextFieldNumber() {
-      // The use of inline closures is to circumvent an issue where the compiler
-      // allocates stack space for every case branch when no optimizations are
-      // enabled. https://github.com/apple/swift-protobuf/issues/1034
       switch fieldNumber {
-      case 1: try { try decoder.decodeSingularStringField(value: &self.propertyName) }()
+      case 1: try decoder.decodeSingularStringField(value: &self.propertyName)
       default: break
       }
     }
@@ -4068,11 +3794,8 @@ extension Fuzzilli_Protobuf_BeginClassStaticSetter: SwiftProtobuf.Message, Swift
 
   public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
     while let fieldNumber = try decoder.nextFieldNumber() {
-      // The use of inline closures is to circumvent an issue where the compiler
-      // allocates stack space for every case branch when no optimizations are
-      // enabled. https://github.com/apple/swift-protobuf/issues/1034
       switch fieldNumber {
-      case 1: try { try decoder.decodeSingularStringField(value: &self.propertyName) }()
+      case 1: try decoder.decodeSingularStringField(value: &self.propertyName)
       default: break
       }
     }
@@ -4120,12 +3843,9 @@ extension Fuzzilli_Protobuf_ClassAddPrivateInstanceProperty: SwiftProtobuf.Messa
 
   public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
     while let fieldNumber = try decoder.nextFieldNumber() {
-      // The use of inline closures is to circumvent an issue where the compiler
-      // allocates stack space for every case branch when no optimizations are
-      // enabled. https://github.com/apple/swift-protobuf/issues/1034
       switch fieldNumber {
-      case 1: try { try decoder.decodeSingularStringField(value: &self.propertyName) }()
-      case 2: try { try decoder.decodeSingularBoolField(value: &self.hasValue_p) }()
+      case 1: try decoder.decodeSingularStringField(value: &self.propertyName)
+      case 2: try decoder.decodeSingularBoolField(value: &self.hasValue_p)
       default: break
       }
     }
@@ -4158,28 +3878,21 @@ extension Fuzzilli_Protobuf_BeginClassPrivateInstanceMethod: SwiftProtobuf.Messa
 
   public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
     while let fieldNumber = try decoder.nextFieldNumber() {
-      // The use of inline closures is to circumvent an issue where the compiler
-      // allocates stack space for every case branch when no optimizations are
-      // enabled. https://github.com/apple/swift-protobuf/issues/1034
       switch fieldNumber {
-      case 1: try { try decoder.decodeSingularStringField(value: &self.methodName) }()
-      case 2: try { try decoder.decodeSingularMessageField(value: &self._parameters) }()
+      case 1: try decoder.decodeSingularStringField(value: &self.methodName)
+      case 2: try decoder.decodeSingularMessageField(value: &self._parameters)
       default: break
       }
     }
   }
 
   public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
-    // The use of inline closures is to circumvent an issue where the compiler
-    // allocates stack space for every if/case branch local when no optimizations
-    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
-    // https://github.com/apple/swift-protobuf/issues/1182
     if !self.methodName.isEmpty {
       try visitor.visitSingularStringField(value: self.methodName, fieldNumber: 1)
     }
-    try { if let v = self._parameters {
+    if let v = self._parameters {
       try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
-    } }()
+    }
     try unknownFields.traverse(visitor: &visitor)
   }
 
@@ -4219,12 +3932,9 @@ extension Fuzzilli_Protobuf_ClassAddPrivateStaticProperty: SwiftProtobuf.Message
 
   public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
     while let fieldNumber = try decoder.nextFieldNumber() {
-      // The use of inline closures is to circumvent an issue where the compiler
-      // allocates stack space for every case branch when no optimizations are
-      // enabled. https://github.com/apple/swift-protobuf/issues/1034
       switch fieldNumber {
-      case 1: try { try decoder.decodeSingularStringField(value: &self.propertyName) }()
-      case 2: try { try decoder.decodeSingularBoolField(value: &self.hasValue_p) }()
+      case 1: try decoder.decodeSingularStringField(value: &self.propertyName)
+      case 2: try decoder.decodeSingularBoolField(value: &self.hasValue_p)
       default: break
       }
     }
@@ -4257,28 +3967,21 @@ extension Fuzzilli_Protobuf_BeginClassPrivateStaticMethod: SwiftProtobuf.Message
 
   public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
     while let fieldNumber = try decoder.nextFieldNumber() {
-      // The use of inline closures is to circumvent an issue where the compiler
-      // allocates stack space for every case branch when no optimizations are
-      // enabled. https://github.com/apple/swift-protobuf/issues/1034
       switch fieldNumber {
-      case 1: try { try decoder.decodeSingularStringField(value: &self.methodName) }()
-      case 2: try { try decoder.decodeSingularMessageField(value: &self._parameters) }()
+      case 1: try decoder.decodeSingularStringField(value: &self.methodName)
+      case 2: try decoder.decodeSingularMessageField(value: &self._parameters)
       default: break
       }
     }
   }
 
   public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
-    // The use of inline closures is to circumvent an issue where the compiler
-    // allocates stack space for every if/case branch local when no optimizations
-    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
-    // https://github.com/apple/swift-protobuf/issues/1182
     if !self.methodName.isEmpty {
       try visitor.visitSingularStringField(value: self.methodName, fieldNumber: 1)
     }
-    try { if let v = self._parameters {
+    if let v = self._parameters {
       try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
-    } }()
+    }
     try unknownFields.traverse(visitor: &visitor)
   }
 
@@ -4355,11 +4058,8 @@ extension Fuzzilli_Protobuf_CreateIntArray: SwiftProtobuf.Message, SwiftProtobuf
 
   public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
     while let fieldNumber = try decoder.nextFieldNumber() {
-      // The use of inline closures is to circumvent an issue where the compiler
-      // allocates stack space for every case branch when no optimizations are
-      // enabled. https://github.com/apple/swift-protobuf/issues/1034
       switch fieldNumber {
-      case 1: try { try decoder.decodeRepeatedInt64Field(value: &self.values) }()
+      case 1: try decoder.decodeRepeatedInt64Field(value: &self.values)
       default: break
       }
     }
@@ -4387,11 +4087,8 @@ extension Fuzzilli_Protobuf_CreateFloatArray: SwiftProtobuf.Message, SwiftProtob
 
   public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
     while let fieldNumber = try decoder.nextFieldNumber() {
-      // The use of inline closures is to circumvent an issue where the compiler
-      // allocates stack space for every case branch when no optimizations are
-      // enabled. https://github.com/apple/swift-protobuf/issues/1034
       switch fieldNumber {
-      case 1: try { try decoder.decodeRepeatedDoubleField(value: &self.values) }()
+      case 1: try decoder.decodeRepeatedDoubleField(value: &self.values)
       default: break
       }
     }
@@ -4419,11 +4116,8 @@ extension Fuzzilli_Protobuf_CreateTemplateString: SwiftProtobuf.Message, SwiftPr
 
   public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
     while let fieldNumber = try decoder.nextFieldNumber() {
-      // The use of inline closures is to circumvent an issue where the compiler
-      // allocates stack space for every case branch when no optimizations are
-      // enabled. https://github.com/apple/swift-protobuf/issues/1034
       switch fieldNumber {
-      case 1: try { try decoder.decodeRepeatedStringField(value: &self.parts) }()
+      case 1: try decoder.decodeRepeatedStringField(value: &self.parts)
       default: break
       }
     }
@@ -4451,11 +4145,8 @@ extension Fuzzilli_Protobuf_CreateArrayWithSpread: SwiftProtobuf.Message, SwiftP
 
   public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
     while let fieldNumber = try decoder.nextFieldNumber() {
-      // The use of inline closures is to circumvent an issue where the compiler
-      // allocates stack space for every case branch when no optimizations are
-      // enabled. https://github.com/apple/swift-protobuf/issues/1034
       switch fieldNumber {
-      case 1: try { try decoder.decodeRepeatedBoolField(value: &self.spreads) }()
+      case 1: try decoder.decodeRepeatedBoolField(value: &self.spreads)
       default: break
       }
     }
@@ -4483,11 +4174,8 @@ extension Fuzzilli_Protobuf_LoadBuiltin: SwiftProtobuf.Message, SwiftProtobuf._M
 
   public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
     while let fieldNumber = try decoder.nextFieldNumber() {
-      // The use of inline closures is to circumvent an issue where the compiler
-      // allocates stack space for every case branch when no optimizations are
-      // enabled. https://github.com/apple/swift-protobuf/issues/1034
       switch fieldNumber {
-      case 1: try { try decoder.decodeSingularStringField(value: &self.builtinName) }()
+      case 1: try decoder.decodeSingularStringField(value: &self.builtinName)
       default: break
       }
     }
@@ -4516,12 +4204,9 @@ extension Fuzzilli_Protobuf_GetProperty: SwiftProtobuf.Message, SwiftProtobuf._M
 
   public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
     while let fieldNumber = try decoder.nextFieldNumber() {
-      // The use of inline closures is to circumvent an issue where the compiler
-      // allocates stack space for every case branch when no optimizations are
-      // enabled. https://github.com/apple/swift-protobuf/issues/1034
       switch fieldNumber {
-      case 1: try { try decoder.decodeSingularStringField(value: &self.propertyName) }()
-      case 2: try { try decoder.decodeSingularBoolField(value: &self.isGuarded) }()
+      case 1: try decoder.decodeSingularStringField(value: &self.propertyName)
+      case 2: try decoder.decodeSingularBoolField(value: &self.isGuarded)
       default: break
       }
     }
@@ -4553,11 +4238,8 @@ extension Fuzzilli_Protobuf_SetProperty: SwiftProtobuf.Message, SwiftProtobuf._M
 
   public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
     while let fieldNumber = try decoder.nextFieldNumber() {
-      // The use of inline closures is to circumvent an issue where the compiler
-      // allocates stack space for every case branch when no optimizations are
-      // enabled. https://github.com/apple/swift-protobuf/issues/1034
       switch fieldNumber {
-      case 1: try { try decoder.decodeSingularStringField(value: &self.propertyName) }()
+      case 1: try decoder.decodeSingularStringField(value: &self.propertyName)
       default: break
       }
     }
@@ -4586,12 +4268,9 @@ extension Fuzzilli_Protobuf_UpdateProperty: SwiftProtobuf.Message, SwiftProtobuf
 
   public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
     while let fieldNumber = try decoder.nextFieldNumber() {
-      // The use of inline closures is to circumvent an issue where the compiler
-      // allocates stack space for every case branch when no optimizations are
-      // enabled. https://github.com/apple/swift-protobuf/issues/1034
       switch fieldNumber {
-      case 1: try { try decoder.decodeSingularStringField(value: &self.propertyName) }()
-      case 2: try { try decoder.decodeSingularEnumField(value: &self.op) }()
+      case 1: try decoder.decodeSingularStringField(value: &self.propertyName)
+      case 2: try decoder.decodeSingularEnumField(value: &self.op)
       default: break
       }
     }
@@ -4624,12 +4303,9 @@ extension Fuzzilli_Protobuf_DeleteProperty: SwiftProtobuf.Message, SwiftProtobuf
 
   public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
     while let fieldNumber = try decoder.nextFieldNumber() {
-      // The use of inline closures is to circumvent an issue where the compiler
-      // allocates stack space for every case branch when no optimizations are
-      // enabled. https://github.com/apple/swift-protobuf/issues/1034
       switch fieldNumber {
-      case 1: try { try decoder.decodeSingularStringField(value: &self.propertyName) }()
-      case 2: try { try decoder.decodeSingularBoolField(value: &self.isGuarded) }()
+      case 1: try decoder.decodeSingularStringField(value: &self.propertyName)
+      case 2: try decoder.decodeSingularBoolField(value: &self.isGuarded)
       default: break
       }
     }
@@ -4665,15 +4341,12 @@ extension Fuzzilli_Protobuf_ConfigureProperty: SwiftProtobuf.Message, SwiftProto
 
   public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
     while let fieldNumber = try decoder.nextFieldNumber() {
-      // The use of inline closures is to circumvent an issue where the compiler
-      // allocates stack space for every case branch when no optimizations are
-      // enabled. https://github.com/apple/swift-protobuf/issues/1034
       switch fieldNumber {
-      case 1: try { try decoder.decodeSingularStringField(value: &self.propertyName) }()
-      case 2: try { try decoder.decodeSingularBoolField(value: &self.isWritable) }()
-      case 3: try { try decoder.decodeSingularBoolField(value: &self.isConfigurable) }()
-      case 4: try { try decoder.decodeSingularBoolField(value: &self.isEnumerable) }()
-      case 5: try { try decoder.decodeSingularEnumField(value: &self.type) }()
+      case 1: try decoder.decodeSingularStringField(value: &self.propertyName)
+      case 2: try decoder.decodeSingularBoolField(value: &self.isWritable)
+      case 3: try decoder.decodeSingularBoolField(value: &self.isConfigurable)
+      case 4: try decoder.decodeSingularBoolField(value: &self.isEnumerable)
+      case 5: try decoder.decodeSingularEnumField(value: &self.type)
       default: break
       }
     }
@@ -4718,12 +4391,9 @@ extension Fuzzilli_Protobuf_GetElement: SwiftProtobuf.Message, SwiftProtobuf._Me
 
   public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
     while let fieldNumber = try decoder.nextFieldNumber() {
-      // The use of inline closures is to circumvent an issue where the compiler
-      // allocates stack space for every case branch when no optimizations are
-      // enabled. https://github.com/apple/swift-protobuf/issues/1034
       switch fieldNumber {
-      case 1: try { try decoder.decodeSingularInt64Field(value: &self.index) }()
-      case 2: try { try decoder.decodeSingularBoolField(value: &self.isGuarded) }()
+      case 1: try decoder.decodeSingularInt64Field(value: &self.index)
+      case 2: try decoder.decodeSingularBoolField(value: &self.isGuarded)
       default: break
       }
     }
@@ -4755,11 +4425,8 @@ extension Fuzzilli_Protobuf_SetElement: SwiftProtobuf.Message, SwiftProtobuf._Me
 
   public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
     while let fieldNumber = try decoder.nextFieldNumber() {
-      // The use of inline closures is to circumvent an issue where the compiler
-      // allocates stack space for every case branch when no optimizations are
-      // enabled. https://github.com/apple/swift-protobuf/issues/1034
       switch fieldNumber {
-      case 1: try { try decoder.decodeSingularInt64Field(value: &self.index) }()
+      case 1: try decoder.decodeSingularInt64Field(value: &self.index)
       default: break
       }
     }
@@ -4788,12 +4455,9 @@ extension Fuzzilli_Protobuf_UpdateElement: SwiftProtobuf.Message, SwiftProtobuf.
 
   public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
     while let fieldNumber = try decoder.nextFieldNumber() {
-      // The use of inline closures is to circumvent an issue where the compiler
-      // allocates stack space for every case branch when no optimizations are
-      // enabled. https://github.com/apple/swift-protobuf/issues/1034
       switch fieldNumber {
-      case 1: try { try decoder.decodeSingularInt64Field(value: &self.index) }()
-      case 2: try { try decoder.decodeSingularEnumField(value: &self.op) }()
+      case 1: try decoder.decodeSingularInt64Field(value: &self.index)
+      case 2: try decoder.decodeSingularEnumField(value: &self.op)
       default: break
       }
     }
@@ -4826,12 +4490,9 @@ extension Fuzzilli_Protobuf_DeleteElement: SwiftProtobuf.Message, SwiftProtobuf.
 
   public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
     while let fieldNumber = try decoder.nextFieldNumber() {
-      // The use of inline closures is to circumvent an issue where the compiler
-      // allocates stack space for every case branch when no optimizations are
-      // enabled. https://github.com/apple/swift-protobuf/issues/1034
       switch fieldNumber {
-      case 1: try { try decoder.decodeSingularInt64Field(value: &self.index) }()
-      case 2: try { try decoder.decodeSingularBoolField(value: &self.isGuarded) }()
+      case 1: try decoder.decodeSingularInt64Field(value: &self.index)
+      case 2: try decoder.decodeSingularBoolField(value: &self.isGuarded)
       default: break
       }
     }
@@ -4867,15 +4528,12 @@ extension Fuzzilli_Protobuf_ConfigureElement: SwiftProtobuf.Message, SwiftProtob
 
   public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
     while let fieldNumber = try decoder.nextFieldNumber() {
-      // The use of inline closures is to circumvent an issue where the compiler
-      // allocates stack space for every case branch when no optimizations are
-      // enabled. https://github.com/apple/swift-protobuf/issues/1034
       switch fieldNumber {
-      case 1: try { try decoder.decodeSingularInt64Field(value: &self.index) }()
-      case 2: try { try decoder.decodeSingularBoolField(value: &self.isWritable) }()
-      case 3: try { try decoder.decodeSingularBoolField(value: &self.isConfigurable) }()
-      case 4: try { try decoder.decodeSingularBoolField(value: &self.isEnumerable) }()
-      case 5: try { try decoder.decodeSingularEnumField(value: &self.type) }()
+      case 1: try decoder.decodeSingularInt64Field(value: &self.index)
+      case 2: try decoder.decodeSingularBoolField(value: &self.isWritable)
+      case 3: try decoder.decodeSingularBoolField(value: &self.isConfigurable)
+      case 4: try decoder.decodeSingularBoolField(value: &self.isEnumerable)
+      case 5: try decoder.decodeSingularEnumField(value: &self.type)
       default: break
       }
     }
@@ -4919,11 +4577,8 @@ extension Fuzzilli_Protobuf_GetComputedProperty: SwiftProtobuf.Message, SwiftPro
 
   public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
     while let fieldNumber = try decoder.nextFieldNumber() {
-      // The use of inline closures is to circumvent an issue where the compiler
-      // allocates stack space for every case branch when no optimizations are
-      // enabled. https://github.com/apple/swift-protobuf/issues/1034
       switch fieldNumber {
-      case 1: try { try decoder.decodeSingularBoolField(value: &self.isGuarded) }()
+      case 1: try decoder.decodeSingularBoolField(value: &self.isGuarded)
       default: break
       }
     }
@@ -4970,11 +4625,8 @@ extension Fuzzilli_Protobuf_UpdateComputedProperty: SwiftProtobuf.Message, Swift
 
   public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
     while let fieldNumber = try decoder.nextFieldNumber() {
-      // The use of inline closures is to circumvent an issue where the compiler
-      // allocates stack space for every case branch when no optimizations are
-      // enabled. https://github.com/apple/swift-protobuf/issues/1034
       switch fieldNumber {
-      case 1: try { try decoder.decodeSingularEnumField(value: &self.op) }()
+      case 1: try decoder.decodeSingularEnumField(value: &self.op)
       default: break
       }
     }
@@ -5002,11 +4654,8 @@ extension Fuzzilli_Protobuf_DeleteComputedProperty: SwiftProtobuf.Message, Swift
 
   public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
     while let fieldNumber = try decoder.nextFieldNumber() {
-      // The use of inline closures is to circumvent an issue where the compiler
-      // allocates stack space for every case branch when no optimizations are
-      // enabled. https://github.com/apple/swift-protobuf/issues/1034
       switch fieldNumber {
-      case 1: try { try decoder.decodeSingularBoolField(value: &self.isGuarded) }()
+      case 1: try decoder.decodeSingularBoolField(value: &self.isGuarded)
       default: break
       }
     }
@@ -5037,14 +4686,11 @@ extension Fuzzilli_Protobuf_ConfigureComputedProperty: SwiftProtobuf.Message, Sw
 
   public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
     while let fieldNumber = try decoder.nextFieldNumber() {
-      // The use of inline closures is to circumvent an issue where the compiler
-      // allocates stack space for every case branch when no optimizations are
-      // enabled. https://github.com/apple/swift-protobuf/issues/1034
       switch fieldNumber {
-      case 1: try { try decoder.decodeSingularBoolField(value: &self.isWritable) }()
-      case 2: try { try decoder.decodeSingularBoolField(value: &self.isConfigurable) }()
-      case 3: try { try decoder.decodeSingularBoolField(value: &self.isEnumerable) }()
-      case 4: try { try decoder.decodeSingularEnumField(value: &self.type) }()
+      case 1: try decoder.decodeSingularBoolField(value: &self.isWritable)
+      case 2: try decoder.decodeSingularBoolField(value: &self.isConfigurable)
+      case 3: try decoder.decodeSingularBoolField(value: &self.isEnumerable)
+      case 4: try decoder.decodeSingularEnumField(value: &self.type)
       default: break
       }
     }
@@ -5142,25 +4788,18 @@ extension Fuzzilli_Protobuf_BeginPlainFunction: SwiftProtobuf.Message, SwiftProt
 
   public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
     while let fieldNumber = try decoder.nextFieldNumber() {
-      // The use of inline closures is to circumvent an issue where the compiler
-      // allocates stack space for every case branch when no optimizations are
-      // enabled. https://github.com/apple/swift-protobuf/issues/1034
       switch fieldNumber {
-      case 1: try { try decoder.decodeSingularMessageField(value: &self._parameters) }()
-      case 2: try { try decoder.decodeSingularBoolField(value: &self.isStrict) }()
+      case 1: try decoder.decodeSingularMessageField(value: &self._parameters)
+      case 2: try decoder.decodeSingularBoolField(value: &self.isStrict)
       default: break
       }
     }
   }
 
   public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
-    // The use of inline closures is to circumvent an issue where the compiler
-    // allocates stack space for every if/case branch local when no optimizations
-    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
-    // https://github.com/apple/swift-protobuf/issues/1182
-    try { if let v = self._parameters {
+    if let v = self._parameters {
       try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
-    } }()
+    }
     if self.isStrict != false {
       try visitor.visitSingularBoolField(value: self.isStrict, fieldNumber: 2)
     }
@@ -5203,25 +4842,18 @@ extension Fuzzilli_Protobuf_BeginArrowFunction: SwiftProtobuf.Message, SwiftProt
 
   public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
     while let fieldNumber = try decoder.nextFieldNumber() {
-      // The use of inline closures is to circumvent an issue where the compiler
-      // allocates stack space for every case branch when no optimizations are
-      // enabled. https://github.com/apple/swift-protobuf/issues/1034
       switch fieldNumber {
-      case 1: try { try decoder.decodeSingularMessageField(value: &self._parameters) }()
-      case 2: try { try decoder.decodeSingularBoolField(value: &self.isStrict) }()
+      case 1: try decoder.decodeSingularMessageField(value: &self._parameters)
+      case 2: try decoder.decodeSingularBoolField(value: &self.isStrict)
       default: break
       }
     }
   }
 
   public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
-    // The use of inline closures is to circumvent an issue where the compiler
-    // allocates stack space for every if/case branch local when no optimizations
-    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
-    // https://github.com/apple/swift-protobuf/issues/1182
-    try { if let v = self._parameters {
+    if let v = self._parameters {
       try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
-    } }()
+    }
     if self.isStrict != false {
       try visitor.visitSingularBoolField(value: self.isStrict, fieldNumber: 2)
     }
@@ -5264,25 +4896,18 @@ extension Fuzzilli_Protobuf_BeginGeneratorFunction: SwiftProtobuf.Message, Swift
 
   public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
     while let fieldNumber = try decoder.nextFieldNumber() {
-      // The use of inline closures is to circumvent an issue where the compiler
-      // allocates stack space for every case branch when no optimizations are
-      // enabled. https://github.com/apple/swift-protobuf/issues/1034
       switch fieldNumber {
-      case 1: try { try decoder.decodeSingularMessageField(value: &self._parameters) }()
-      case 2: try { try decoder.decodeSingularBoolField(value: &self.isStrict) }()
+      case 1: try decoder.decodeSingularMessageField(value: &self._parameters)
+      case 2: try decoder.decodeSingularBoolField(value: &self.isStrict)
       default: break
       }
     }
   }
 
   public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
-    // The use of inline closures is to circumvent an issue where the compiler
-    // allocates stack space for every if/case branch local when no optimizations
-    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
-    // https://github.com/apple/swift-protobuf/issues/1182
-    try { if let v = self._parameters {
+    if let v = self._parameters {
       try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
-    } }()
+    }
     if self.isStrict != false {
       try visitor.visitSingularBoolField(value: self.isStrict, fieldNumber: 2)
     }
@@ -5325,25 +4950,18 @@ extension Fuzzilli_Protobuf_BeginAsyncFunction: SwiftProtobuf.Message, SwiftProt
 
   public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
     while let fieldNumber = try decoder.nextFieldNumber() {
-      // The use of inline closures is to circumvent an issue where the compiler
-      // allocates stack space for every case branch when no optimizations are
-      // enabled. https://github.com/apple/swift-protobuf/issues/1034
       switch fieldNumber {
-      case 1: try { try decoder.decodeSingularMessageField(value: &self._parameters) }()
-      case 2: try { try decoder.decodeSingularBoolField(value: &self.isStrict) }()
+      case 1: try decoder.decodeSingularMessageField(value: &self._parameters)
+      case 2: try decoder.decodeSingularBoolField(value: &self.isStrict)
       default: break
       }
     }
   }
 
   public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
-    // The use of inline closures is to circumvent an issue where the compiler
-    // allocates stack space for every if/case branch local when no optimizations
-    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
-    // https://github.com/apple/swift-protobuf/issues/1182
-    try { if let v = self._parameters {
+    if let v = self._parameters {
       try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
-    } }()
+    }
     if self.isStrict != false {
       try visitor.visitSingularBoolField(value: self.isStrict, fieldNumber: 2)
     }
@@ -5386,25 +5004,18 @@ extension Fuzzilli_Protobuf_BeginAsyncArrowFunction: SwiftProtobuf.Message, Swif
 
   public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
     while let fieldNumber = try decoder.nextFieldNumber() {
-      // The use of inline closures is to circumvent an issue where the compiler
-      // allocates stack space for every case branch when no optimizations are
-      // enabled. https://github.com/apple/swift-protobuf/issues/1034
       switch fieldNumber {
-      case 1: try { try decoder.decodeSingularMessageField(value: &self._parameters) }()
-      case 2: try { try decoder.decodeSingularBoolField(value: &self.isStrict) }()
+      case 1: try decoder.decodeSingularMessageField(value: &self._parameters)
+      case 2: try decoder.decodeSingularBoolField(value: &self.isStrict)
       default: break
       }
     }
   }
 
   public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
-    // The use of inline closures is to circumvent an issue where the compiler
-    // allocates stack space for every if/case branch local when no optimizations
-    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
-    // https://github.com/apple/swift-protobuf/issues/1182
-    try { if let v = self._parameters {
+    if let v = self._parameters {
       try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
-    } }()
+    }
     if self.isStrict != false {
       try visitor.visitSingularBoolField(value: self.isStrict, fieldNumber: 2)
     }
@@ -5447,25 +5058,18 @@ extension Fuzzilli_Protobuf_BeginAsyncGeneratorFunction: SwiftProtobuf.Message,
 
   public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
     while let fieldNumber = try decoder.nextFieldNumber() {
-      // The use of inline closures is to circumvent an issue where the compiler
-      // allocates stack space for every case branch when no optimizations are
-      // enabled. https://github.com/apple/swift-protobuf/issues/1034
       switch fieldNumber {
-      case 1: try { try decoder.decodeSingularMessageField(value: &self._parameters) }()
-      case 2: try { try decoder.decodeSingularBoolField(value: &self.isStrict) }()
+      case 1: try decoder.decodeSingularMessageField(value: &self._parameters)
+      case 2: try decoder.decodeSingularBoolField(value: &self.isStrict)
       default: break
       }
     }
   }
 
   public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
-    // The use of inline closures is to circumvent an issue where the compiler
-    // allocates stack space for every if/case branch local when no optimizations
-    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
-    // https://github.com/apple/swift-protobuf/issues/1182
-    try { if let v = self._parameters {
+    if let v = self._parameters {
       try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
-    } }()
+    }
     if self.isStrict != false {
       try visitor.visitSingularBoolField(value: self.isStrict, fieldNumber: 2)
     }
@@ -5507,24 +5111,17 @@ extension Fuzzilli_Protobuf_BeginConstructor: SwiftProtobuf.Message, SwiftProtob
 
   public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
     while let fieldNumber = try decoder.nextFieldNumber() {
-      // The use of inline closures is to circumvent an issue where the compiler
-      // allocates stack space for every case branch when no optimizations are
-      // enabled. https://github.com/apple/swift-protobuf/issues/1034
       switch fieldNumber {
-      case 1: try { try decoder.decodeSingularMessageField(value: &self._parameters) }()
+      case 1: try decoder.decodeSingularMessageField(value: &self._parameters)
       default: break
       }
     }
   }
 
   public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
-    // The use of inline closures is to circumvent an issue where the compiler
-    // allocates stack space for every if/case branch local when no optimizations
-    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
-    // https://github.com/apple/swift-protobuf/issues/1182
-    try { if let v = self._parameters {
+    if let v = self._parameters {
       try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
-    } }()
+    }
     try unknownFields.traverse(visitor: &visitor)
   }
 
@@ -5573,6 +5170,25 @@ extension Fuzzilli_Protobuf_Return: SwiftProtobuf.Message, SwiftProtobuf._Messag
   }
 }
 
+extension Fuzzilli_Protobuf_DifferentialHash: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
+  public static let protoMessageName: String = _protobuf_package + ".DifferentialHash"
+  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()
+
+  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
+    while let _ = try decoder.nextFieldNumber() {
+    }
+  }
+
+  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
+    try unknownFields.traverse(visitor: &visitor)
+  }
+
+  public static func ==(lhs: Fuzzilli_Protobuf_DifferentialHash, rhs: Fuzzilli_Protobuf_DifferentialHash) -> Bool {
+    if lhs.unknownFields != rhs.unknownFields {return false}
+    return true
+  }
+}
+
 extension Fuzzilli_Protobuf_Yield: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
   public static let protoMessageName: String = _protobuf_package + ".Yield"
   public static let _protobuf_nameMap = SwiftProtobuf._NameMap()
@@ -5638,11 +5254,8 @@ extension Fuzzilli_Protobuf_CallFunction: SwiftProtobuf.Message, SwiftProtobuf._
 
   public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
     while let fieldNumber = try decoder.nextFieldNumber() {
-      // The use of inline closures is to circumvent an issue where the compiler
-      // allocates stack space for every case branch when no optimizations are
-      // enabled. https://github.com/apple/swift-protobuf/issues/1034
       switch fieldNumber {
-      case 1: try { try decoder.decodeSingularBoolField(value: &self.isGuarded) }()
+      case 1: try decoder.decodeSingularBoolField(value: &self.isGuarded)
       default: break
       }
     }
@@ -5671,12 +5284,9 @@ extension Fuzzilli_Protobuf_CallFunctionWithSpread: SwiftProtobuf.Message, Swift
 
   public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
     while let fieldNumber = try decoder.nextFieldNumber() {
-      // The use of inline closures is to circumvent an issue where the compiler
-      // allocates stack space for every case branch when no optimizations are
-      // enabled. https://github.com/apple/swift-protobuf/issues/1034
       switch fieldNumber {
-      case 1: try { try decoder.decodeRepeatedBoolField(value: &self.spreads) }()
-      case 2: try { try decoder.decodeSingularBoolField(value: &self.isGuarded) }()
+      case 1: try decoder.decodeRepeatedBoolField(value: &self.spreads)
+      case 2: try decoder.decodeSingularBoolField(value: &self.isGuarded)
       default: break
       }
     }
@@ -5708,11 +5318,8 @@ extension Fuzzilli_Protobuf_Construct: SwiftProtobuf.Message, SwiftProtobuf._Mes
 
   public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
     while let fieldNumber = try decoder.nextFieldNumber() {
-      // The use of inline closures is to circumvent an issue where the compiler
-      // allocates stack space for every case branch when no optimizations are
-      // enabled. https://github.com/apple/swift-protobuf/issues/1034
       switch fieldNumber {
-      case 1: try { try decoder.decodeSingularBoolField(value: &self.isGuarded) }()
+      case 1: try decoder.decodeSingularBoolField(value: &self.isGuarded)
       default: break
       }
     }
@@ -5741,12 +5348,9 @@ extension Fuzzilli_Protobuf_ConstructWithSpread: SwiftProtobuf.Message, SwiftPro
 
   public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
     while let fieldNumber = try decoder.nextFieldNumber() {
-      // The use of inline closures is to circumvent an issue where the compiler
-      // allocates stack space for every case branch when no optimizations are
-      // enabled. https://github.com/apple/swift-protobuf/issues/1034
       switch fieldNumber {
-      case 1: try { try decoder.decodeRepeatedBoolField(value: &self.spreads) }()
-      case 2: try { try decoder.decodeSingularBoolField(value: &self.isGuarded) }()
+      case 1: try decoder.decodeRepeatedBoolField(value: &self.spreads)
+      case 2: try decoder.decodeSingularBoolField(value: &self.isGuarded)
       default: break
       }
     }
@@ -5779,12 +5383,9 @@ extension Fuzzilli_Protobuf_CallMethod: SwiftProtobuf.Message, SwiftProtobuf._Me
 
   public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
     while let fieldNumber = try decoder.nextFieldNumber() {
-      // The use of inline closures is to circumvent an issue where the compiler
-      // allocates stack space for every case branch when no optimizations are
-      // enabled. https://github.com/apple/swift-protobuf/issues/1034
       switch fieldNumber {
-      case 1: try { try decoder.decodeSingularStringField(value: &self.methodName) }()
-      case 2: try { try decoder.decodeSingularBoolField(value: &self.isGuarded) }()
+      case 1: try decoder.decodeSingularStringField(value: &self.methodName)
+      case 2: try decoder.decodeSingularBoolField(value: &self.isGuarded)
       default: break
       }
     }
@@ -5818,13 +5419,10 @@ extension Fuzzilli_Protobuf_CallMethodWithSpread: SwiftProtobuf.Message, SwiftPr
 
   public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
     while let fieldNumber = try decoder.nextFieldNumber() {
-      // The use of inline closures is to circumvent an issue where the compiler
-      // allocates stack space for every case branch when no optimizations are
-      // enabled. https://github.com/apple/swift-protobuf/issues/1034
       switch fieldNumber {
-      case 1: try { try decoder.decodeSingularStringField(value: &self.methodName) }()
-      case 2: try { try decoder.decodeRepeatedBoolField(value: &self.spreads) }()
-      case 3: try { try decoder.decodeSingularBoolField(value: &self.isGuarded) }()
+      case 1: try decoder.decodeSingularStringField(value: &self.methodName)
+      case 2: try decoder.decodeRepeatedBoolField(value: &self.spreads)
+      case 3: try decoder.decodeSingularBoolField(value: &self.isGuarded)
       default: break
       }
     }
@@ -5860,11 +5458,8 @@ extension Fuzzilli_Protobuf_CallComputedMethod: SwiftProtobuf.Message, SwiftProt
 
   public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
     while let fieldNumber = try decoder.nextFieldNumber() {
-      // The use of inline closures is to circumvent an issue where the compiler
-      // allocates stack space for every case branch when no optimizations are
-      // enabled. https://github.com/apple/swift-protobuf/issues/1034
       switch fieldNumber {
-      case 1: try { try decoder.decodeSingularBoolField(value: &self.isGuarded) }()
+      case 1: try decoder.decodeSingularBoolField(value: &self.isGuarded)
       default: break
       }
     }
@@ -5893,12 +5488,9 @@ extension Fuzzilli_Protobuf_CallComputedMethodWithSpread: SwiftProtobuf.Message,
 
   public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
     while let fieldNumber = try decoder.nextFieldNumber() {
-      // The use of inline closures is to circumvent an issue where the compiler
-      // allocates stack space for every case branch when no optimizations are
-      // enabled. https://github.com/apple/swift-protobuf/issues/1034
       switch fieldNumber {
-      case 1: try { try decoder.decodeRepeatedBoolField(value: &self.spreads) }()
-      case 2: try { try decoder.decodeSingularBoolField(value: &self.isGuarded) }()
+      case 1: try decoder.decodeRepeatedBoolField(value: &self.spreads)
+      case 2: try decoder.decodeSingularBoolField(value: &self.isGuarded)
       default: break
       }
     }
@@ -5930,11 +5522,8 @@ extension Fuzzilli_Protobuf_UnaryOperation: SwiftProtobuf.Message, SwiftProtobuf
 
   public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
     while let fieldNumber = try decoder.nextFieldNumber() {
-      // The use of inline closures is to circumvent an issue where the compiler
-      // allocates stack space for every case branch when no optimizations are
-      // enabled. https://github.com/apple/swift-protobuf/issues/1034
       switch fieldNumber {
-      case 1: try { try decoder.decodeSingularEnumField(value: &self.op) }()
+      case 1: try decoder.decodeSingularEnumField(value: &self.op)
       default: break
       }
     }
@@ -5962,11 +5551,8 @@ extension Fuzzilli_Protobuf_BinaryOperation: SwiftProtobuf.Message, SwiftProtobu
 
   public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
     while let fieldNumber = try decoder.nextFieldNumber() {
-      // The use of inline closures is to circumvent an issue where the compiler
-      // allocates stack space for every case branch when no optimizations are
-      // enabled. https://github.com/apple/swift-protobuf/issues/1034
       switch fieldNumber {
-      case 1: try { try decoder.decodeSingularEnumField(value: &self.op) }()
+      case 1: try decoder.decodeSingularEnumField(value: &self.op)
       default: break
       }
     }
@@ -6013,11 +5599,8 @@ extension Fuzzilli_Protobuf_Update: SwiftProtobuf.Message, SwiftProtobuf._Messag
 
   public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
     while let fieldNumber = try decoder.nextFieldNumber() {
-      // The use of inline closures is to circumvent an issue where the compiler
-      // allocates stack space for every case branch when no optimizations are
-      // enabled. https://github.com/apple/swift-protobuf/issues/1034
       switch fieldNumber {
-      case 1: try { try decoder.decodeSingularEnumField(value: &self.op) }()
+      case 1: try decoder.decodeSingularEnumField(value: &self.op)
       default: break
       }
     }
@@ -6084,12 +5667,9 @@ extension Fuzzilli_Protobuf_DestructArray: SwiftProtobuf.Message, SwiftProtobuf.
 
   public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
     while let fieldNumber = try decoder.nextFieldNumber() {
-      // The use of inline closures is to circumvent an issue where the compiler
-      // allocates stack space for every case branch when no optimizations are
-      // enabled. https://github.com/apple/swift-protobuf/issues/1034
       switch fieldNumber {
-      case 1: try { try decoder.decodeRepeatedInt32Field(value: &self.indices) }()
-      case 2: try { try decoder.decodeSingularBoolField(value: &self.lastIsRest) }()
+      case 1: try decoder.decodeRepeatedInt32Field(value: &self.indices)
+      case 2: try decoder.decodeSingularBoolField(value: &self.lastIsRest)
       default: break
       }
     }
@@ -6122,12 +5702,9 @@ extension Fuzzilli_Protobuf_DestructArrayAndReassign: SwiftProtobuf.Message, Swi
 
   public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
     while let fieldNumber = try decoder.nextFieldNumber() {
-      // The use of inline closures is to circumvent an issue where the compiler
-      // allocates stack space for every case branch when no optimizations are
-      // enabled. https://github.com/apple/swift-protobuf/issues/1034
       switch fieldNumber {
-      case 1: try { try decoder.decodeRepeatedInt32Field(value: &self.indices) }()
-      case 2: try { try decoder.decodeSingularBoolField(value: &self.lastIsRest) }()
+      case 1: try decoder.decodeRepeatedInt32Field(value: &self.indices)
+      case 2: try decoder.decodeSingularBoolField(value: &self.lastIsRest)
       default: break
       }
     }
@@ -6160,12 +5737,9 @@ extension Fuzzilli_Protobuf_DestructObject: SwiftProtobuf.Message, SwiftProtobuf
 
   public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
     while let fieldNumber = try decoder.nextFieldNumber() {
-      // The use of inline closures is to circumvent an issue where the compiler
-      // allocates stack space for every case branch when no optimizations are
-      // enabled. https://github.com/apple/swift-protobuf/issues/1034
       switch fieldNumber {
-      case 1: try { try decoder.decodeRepeatedStringField(value: &self.properties) }()
-      case 2: try { try decoder.decodeSingularBoolField(value: &self.hasRestElement_p) }()
+      case 1: try decoder.decodeRepeatedStringField(value: &self.properties)
+      case 2: try decoder.decodeSingularBoolField(value: &self.hasRestElement_p)
       default: break
       }
     }
@@ -6198,12 +5772,9 @@ extension Fuzzilli_Protobuf_DestructObjectAndReassign: SwiftProtobuf.Message, Sw
 
   public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
     while let fieldNumber = try decoder.nextFieldNumber() {
-      // The use of inline closures is to circumvent an issue where the compiler
-      // allocates stack space for every case branch when no optimizations are
-      // enabled. https://github.com/apple/swift-protobuf/issues/1034
       switch fieldNumber {
-      case 1: try { try decoder.decodeRepeatedStringField(value: &self.properties) }()
-      case 2: try { try decoder.decodeSingularBoolField(value: &self.hasRestElement_p) }()
+      case 1: try decoder.decodeRepeatedStringField(value: &self.properties)
+      case 2: try decoder.decodeSingularBoolField(value: &self.hasRestElement_p)
       default: break
       }
     }
@@ -6235,11 +5806,8 @@ extension Fuzzilli_Protobuf_Compare: SwiftProtobuf.Message, SwiftProtobuf._Messa
 
   public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
     while let fieldNumber = try decoder.nextFieldNumber() {
-      // The use of inline closures is to circumvent an issue where the compiler
-      // allocates stack space for every case branch when no optimizations are
-      // enabled. https://github.com/apple/swift-protobuf/issues/1034
       switch fieldNumber {
-      case 1: try { try decoder.decodeSingularEnumField(value: &self.op) }()
+      case 1: try decoder.decodeSingularEnumField(value: &self.op)
       default: break
       }
     }
@@ -6267,11 +5835,8 @@ extension Fuzzilli_Protobuf_LoadNamedVariable: SwiftProtobuf.Message, SwiftProto
 
   public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
     while let fieldNumber = try decoder.nextFieldNumber() {
-      // The use of inline closures is to circumvent an issue where the compiler
-      // allocates stack space for every case branch when no optimizations are
-      // enabled. https://github.com/apple/swift-protobuf/issues/1034
       switch fieldNumber {
-      case 1: try { try decoder.decodeSingularStringField(value: &self.variableName) }()
+      case 1: try decoder.decodeSingularStringField(value: &self.variableName)
       default: break
       }
     }
@@ -6299,11 +5864,8 @@ extension Fuzzilli_Protobuf_StoreNamedVariable: SwiftProtobuf.Message, SwiftProt
 
   public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
     while let fieldNumber = try decoder.nextFieldNumber() {
-      // The use of inline closures is to circumvent an issue where the compiler
-      // allocates stack space for every case branch when no optimizations are
-      // enabled. https://github.com/apple/swift-protobuf/issues/1034
       switch fieldNumber {
-      case 1: try { try decoder.decodeSingularStringField(value: &self.variableName) }()
+      case 1: try decoder.decodeSingularStringField(value: &self.variableName)
       default: break
       }
     }
@@ -6331,11 +5893,8 @@ extension Fuzzilli_Protobuf_DefineNamedVariable: SwiftProtobuf.Message, SwiftPro
 
   public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
     while let fieldNumber = try decoder.nextFieldNumber() {
-      // The use of inline closures is to circumvent an issue where the compiler
-      // allocates stack space for every case branch when no optimizations are
-      // enabled. https://github.com/apple/swift-protobuf/issues/1034
       switch fieldNumber {
-      case 1: try { try decoder.decodeSingularStringField(value: &self.variableName) }()
+      case 1: try decoder.decodeSingularStringField(value: &self.variableName)
       default: break
       }
     }
@@ -6364,12 +5923,9 @@ extension Fuzzilli_Protobuf_Eval: SwiftProtobuf.Message, SwiftProtobuf._MessageI
 
   public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
     while let fieldNumber = try decoder.nextFieldNumber() {
-      // The use of inline closures is to circumvent an issue where the compiler
-      // allocates stack space for every case branch when no optimizations are
-      // enabled. https://github.com/apple/swift-protobuf/issues/1034
       switch fieldNumber {
-      case 1: try { try decoder.decodeSingularStringField(value: &self.code) }()
-      case 2: try { try decoder.decodeSingularBoolField(value: &self.hasOutput_p) }()
+      case 1: try decoder.decodeSingularStringField(value: &self.code)
+      case 2: try decoder.decodeSingularBoolField(value: &self.hasOutput_p)
       default: break
       }
     }
@@ -6401,11 +5957,8 @@ extension Fuzzilli_Protobuf_CallSuperConstructor: SwiftProtobuf.Message, SwiftPr
 
   public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
     while let fieldNumber = try decoder.nextFieldNumber() {
-      // The use of inline closures is to circumvent an issue where the compiler
-      // allocates stack space for every case branch when no optimizations are
-      // enabled. https://github.com/apple/swift-protobuf/issues/1034
       switch fieldNumber {
-      case 1: try { try decoder.decodeRepeatedBoolField(value: &self.spreads) }()
+      case 1: try decoder.decodeRepeatedBoolField(value: &self.spreads)
       default: break
       }
     }
@@ -6433,11 +5986,8 @@ extension Fuzzilli_Protobuf_CallSuperMethod: SwiftProtobuf.Message, SwiftProtobu
 
   public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
     while let fieldNumber = try decoder.nextFieldNumber() {
-      // The use of inline closures is to circumvent an issue where the compiler
-      // allocates stack space for every case branch when no optimizations are
-      // enabled. https://github.com/apple/swift-protobuf/issues/1034
       switch fieldNumber {
-      case 1: try { try decoder.decodeSingularStringField(value: &self.methodName) }()
+      case 1: try decoder.decodeSingularStringField(value: &self.methodName)
       default: break
       }
     }
@@ -6465,11 +6015,8 @@ extension Fuzzilli_Protobuf_GetPrivateProperty: SwiftProtobuf.Message, SwiftProt
 
   public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
     while let fieldNumber = try decoder.nextFieldNumber() {
-      // The use of inline closures is to circumvent an issue where the compiler
-      // allocates stack space for every case branch when no optimizations are
-      // enabled. https://github.com/apple/swift-protobuf/issues/1034
       switch fieldNumber {
-      case 1: try { try decoder.decodeSingularStringField(value: &self.propertyName) }()
+      case 1: try decoder.decodeSingularStringField(value: &self.propertyName)
       default: break
       }
     }
@@ -6497,11 +6044,8 @@ extension Fuzzilli_Protobuf_SetPrivateProperty: SwiftProtobuf.Message, SwiftProt
 
   public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
     while let fieldNumber = try decoder.nextFieldNumber() {
-      // The use of inline closures is to circumvent an issue where the compiler
-      // allocates stack space for every case branch when no optimizations are
-      // enabled. https://github.com/apple/swift-protobuf/issues/1034
       switch fieldNumber {
-      case 1: try { try decoder.decodeSingularStringField(value: &self.propertyName) }()
+      case 1: try decoder.decodeSingularStringField(value: &self.propertyName)
       default: break
       }
     }
@@ -6530,12 +6074,9 @@ extension Fuzzilli_Protobuf_UpdatePrivateProperty: SwiftProtobuf.Message, SwiftP
 
   public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
     while let fieldNumber = try decoder.nextFieldNumber() {
-      // The use of inline closures is to circumvent an issue where the compiler
-      // allocates stack space for every case branch when no optimizations are
-      // enabled. https://github.com/apple/swift-protobuf/issues/1034
       switch fieldNumber {
-      case 1: try { try decoder.decodeSingularStringField(value: &self.propertyName) }()
-      case 2: try { try decoder.decodeSingularEnumField(value: &self.op) }()
+      case 1: try decoder.decodeSingularStringField(value: &self.propertyName)
+      case 2: try decoder.decodeSingularEnumField(value: &self.op)
       default: break
       }
     }
@@ -6567,11 +6108,8 @@ extension Fuzzilli_Protobuf_CallPrivateMethod: SwiftProtobuf.Message, SwiftProto
 
   public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
     while let fieldNumber = try decoder.nextFieldNumber() {
-      // The use of inline closures is to circumvent an issue where the compiler
-      // allocates stack space for every case branch when no optimizations are
-      // enabled. https://github.com/apple/swift-protobuf/issues/1034
       switch fieldNumber {
-      case 1: try { try decoder.decodeSingularStringField(value: &self.methodName) }()
+      case 1: try decoder.decodeSingularStringField(value: &self.methodName)
       default: break
       }
     }
@@ -6599,11 +6137,8 @@ extension Fuzzilli_Protobuf_GetSuperProperty: SwiftProtobuf.Message, SwiftProtob
 
   public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
     while let fieldNumber = try decoder.nextFieldNumber() {
-      // The use of inline closures is to circumvent an issue where the compiler
-      // allocates stack space for every case branch when no optimizations are
-      // enabled. https://github.com/apple/swift-protobuf/issues/1034
       switch fieldNumber {
-      case 1: try { try decoder.decodeSingularStringField(value: &self.propertyName) }()
+      case 1: try decoder.decodeSingularStringField(value: &self.propertyName)
       default: break
       }
     }
@@ -6631,11 +6166,8 @@ extension Fuzzilli_Protobuf_SetSuperProperty: SwiftProtobuf.Message, SwiftProtob
 
   public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
     while let fieldNumber = try decoder.nextFieldNumber() {
-      // The use of inline closures is to circumvent an issue where the compiler
-      // allocates stack space for every case branch when no optimizations are
-      // enabled. https://github.com/apple/swift-protobuf/issues/1034
       switch fieldNumber {
-      case 1: try { try decoder.decodeSingularStringField(value: &self.propertyName) }()
+      case 1: try decoder.decodeSingularStringField(value: &self.propertyName)
       default: break
       }
     }
@@ -6702,12 +6234,9 @@ extension Fuzzilli_Protobuf_UpdateSuperProperty: SwiftProtobuf.Message, SwiftPro
 
   public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
     while let fieldNumber = try decoder.nextFieldNumber() {
-      // The use of inline closures is to circumvent an issue where the compiler
-      // allocates stack space for every case branch when no optimizations are
-      // enabled. https://github.com/apple/swift-protobuf/issues/1034
       switch fieldNumber {
-      case 1: try { try decoder.decodeSingularStringField(value: &self.propertyName) }()
-      case 2: try { try decoder.decodeSingularEnumField(value: &self.op) }()
+      case 1: try decoder.decodeSingularStringField(value: &self.propertyName)
+      case 2: try decoder.decodeSingularEnumField(value: &self.op)
       default: break
       }
     }
@@ -6759,12 +6288,9 @@ extension Fuzzilli_Protobuf_Explore: SwiftProtobuf.Message, SwiftProtobuf._Messa
 
   public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
     while let fieldNumber = try decoder.nextFieldNumber() {
-      // The use of inline closures is to circumvent an issue where the compiler
-      // allocates stack space for every case branch when no optimizations are
-      // enabled. https://github.com/apple/swift-protobuf/issues/1034
       switch fieldNumber {
-      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
-      case 2: try { try decoder.decodeSingularInt64Field(value: &self.rngSeed) }()
+      case 1: try decoder.decodeSingularStringField(value: &self.id)
+      case 2: try decoder.decodeSingularInt64Field(value: &self.rngSeed)
       default: break
       }
     }
@@ -6796,11 +6322,8 @@ extension Fuzzilli_Protobuf_Probe: SwiftProtobuf.Message, SwiftProtobuf._Message
 
   public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
     while let fieldNumber = try decoder.nextFieldNumber() {
-      // The use of inline closures is to circumvent an issue where the compiler
-      // allocates stack space for every case branch when no optimizations are
-      // enabled. https://github.com/apple/swift-protobuf/issues/1034
       switch fieldNumber {
-      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
+      case 1: try decoder.decodeSingularStringField(value: &self.id)
       default: break
       }
     }
@@ -6831,14 +6354,11 @@ extension Fuzzilli_Protobuf_Fixup: SwiftProtobuf.Message, SwiftProtobuf._Message
 
   public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
     while let fieldNumber = try decoder.nextFieldNumber() {
-      // The use of inline closures is to circumvent an issue where the compiler
-      // allocates stack space for every case branch when no optimizations are
-      // enabled. https://github.com/apple/swift-protobuf/issues/1034
       switch fieldNumber {
-      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
-      case 2: try { try decoder.decodeSingularStringField(value: &self.action) }()
-      case 3: try { try decoder.decodeSingularStringField(value: &self.originalOperation) }()
-      case 4: try { try decoder.decodeSingularBoolField(value: &self.hasOutput_p) }()
+      case 1: try decoder.decodeSingularStringField(value: &self.id)
+      case 2: try decoder.decodeSingularStringField(value: &self.action)
+      case 3: try decoder.decodeSingularStringField(value: &self.originalOperation)
+      case 4: try decoder.decodeSingularBoolField(value: &self.hasOutput_p)
       default: break
       }
     }
@@ -6916,11 +6436,8 @@ extension Fuzzilli_Protobuf_BeginIf: SwiftProtobuf.Message, SwiftProtobuf._Messa
 
   public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
     while let fieldNumber = try decoder.nextFieldNumber() {
-      // The use of inline closures is to circumvent an issue where the compiler
-      // allocates stack space for every case branch when no optimizations are
-      // enabled. https://github.com/apple/swift-protobuf/issues/1034
       switch fieldNumber {
-      case 1: try { try decoder.decodeSingularBoolField(value: &self.inverted) }()
+      case 1: try decoder.decodeSingularBoolField(value: &self.inverted)
       default: break
       }
     }
@@ -7062,11 +6579,8 @@ extension Fuzzilli_Protobuf_EndSwitchCase: SwiftProtobuf.Message, SwiftProtobuf.
 
   public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
     while let fieldNumber = try decoder.nextFieldNumber() {
-      // The use of inline closures is to circumvent an issue where the compiler
-      // allocates stack space for every case branch when no optimizations are
-      // enabled. https://github.com/apple/swift-protobuf/issues/1034
       switch fieldNumber {
-      case 1: try { try decoder.decodeSingularBoolField(value: &self.fallsThrough) }()
+      case 1: try decoder.decodeSingularBoolField(value: &self.fallsThrough)
       default: break
       }
     }
@@ -7380,12 +6894,9 @@ extension Fuzzilli_Protobuf_BeginForOfLoopWithDestruct: SwiftProtobuf.Message, S
 
   public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
     while let fieldNumber = try decoder.nextFieldNumber() {
-      // The use of inline closures is to circumvent an issue where the compiler
-      // allocates stack space for every case branch when no optimizations are
-      // enabled. https://github.com/apple/swift-protobuf/issues/1034
       switch fieldNumber {
-      case 1: try { try decoder.decodeRepeatedInt32Field(value: &self.indices) }()
-      case 2: try { try decoder.decodeSingularBoolField(value: &self.hasRestElement_p) }()
+      case 1: try decoder.decodeRepeatedInt32Field(value: &self.indices)
+      case 2: try decoder.decodeSingularBoolField(value: &self.hasRestElement_p)
       default: break
       }
     }
@@ -7437,12 +6948,9 @@ extension Fuzzilli_Protobuf_BeginRepeatLoop: SwiftProtobuf.Message, SwiftProtobu
 
   public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
     while let fieldNumber = try decoder.nextFieldNumber() {
-      // The use of inline closures is to circumvent an issue where the compiler
-      // allocates stack space for every case branch when no optimizations are
-      // enabled. https://github.com/apple/swift-protobuf/issues/1034
       switch fieldNumber {
-      case 1: try { try decoder.decodeSingularInt64Field(value: &self.iterations) }()
-      case 2: try { try decoder.decodeSingularBoolField(value: &self.exposesLoopCounter) }()
+      case 1: try decoder.decodeSingularInt64Field(value: &self.iterations)
+      case 2: try decoder.decodeSingularBoolField(value: &self.exposesLoopCounter)
       default: break
       }
     }
diff --git a/Sources/Fuzzilli/Protobuf/operations.proto b/Sources/Fuzzilli/Protobuf/operations.proto
index 524e45a..35069b8 100644
--- a/Sources/Fuzzilli/Protobuf/operations.proto
+++ b/Sources/Fuzzilli/Protobuf/operations.proto
@@ -401,6 +401,9 @@ message EndConstructor {
 message Return {
 }
 
+message DifferentialHash {
+}
+
 message Yield {
 }
 
diff --git a/Sources/Fuzzilli/Protobuf/program.pb.swift b/Sources/Fuzzilli/Protobuf/program.pb.swift
index 1d4af9a..bd3fdc0 100644
--- a/Sources/Fuzzilli/Protobuf/program.pb.swift
+++ b/Sources/Fuzzilli/Protobuf/program.pb.swift
@@ -7,7 +7,7 @@
 // For information on using the generated types, please see the documentation:
 //   https://github.com/apple/swift-protobuf/
 
-// Copyright 2023 Google LLC
+// Copyright 2024 Google LLC
 //
 // Licensed under the Apache License, Version 2.0 (the "License");
 // you may not use this file except in compliance with the License.
@@ -44,1432 +44,1438 @@ public struct Fuzzilli_Protobuf_Instruction {
   /// The operation is either encoded as an index, referring to the nth operation
   /// (so that shared operations are also only present once in the protobuf), or
   /// as one of the many concrete Operation messages.
-  public var inouts: [UInt32] = []
+  public var inouts: [UInt32] {
+    get {return _storage._inouts}
+    set {_uniqueStorage()._inouts = newValue}
+  }
 
-  public var operation: Fuzzilli_Protobuf_Instruction.OneOf_Operation? = nil
+  public var operation: OneOf_Operation? {
+    get {return _storage._operation}
+    set {_uniqueStorage()._operation = newValue}
+  }
 
   public var opIdx: UInt32 {
     get {
-      if case .opIdx(let v)? = operation {return v}
+      if case .opIdx(let v)? = _storage._operation {return v}
       return 0
     }
-    set {operation = .opIdx(newValue)}
+    set {_uniqueStorage()._operation = .opIdx(newValue)}
   }
 
   public var nop: Fuzzilli_Protobuf_Nop {
     get {
-      if case .nop(let v)? = operation {return v}
+      if case .nop(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_Nop()
     }
-    set {operation = .nop(newValue)}
+    set {_uniqueStorage()._operation = .nop(newValue)}
   }
 
   public var loadInteger: Fuzzilli_Protobuf_LoadInteger {
     get {
-      if case .loadInteger(let v)? = operation {return v}
+      if case .loadInteger(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_LoadInteger()
     }
-    set {operation = .loadInteger(newValue)}
+    set {_uniqueStorage()._operation = .loadInteger(newValue)}
   }
 
   public var loadBigInt: Fuzzilli_Protobuf_LoadBigInt {
     get {
-      if case .loadBigInt(let v)? = operation {return v}
+      if case .loadBigInt(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_LoadBigInt()
     }
-    set {operation = .loadBigInt(newValue)}
+    set {_uniqueStorage()._operation = .loadBigInt(newValue)}
   }
 
   public var loadFloat: Fuzzilli_Protobuf_LoadFloat {
     get {
-      if case .loadFloat(let v)? = operation {return v}
+      if case .loadFloat(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_LoadFloat()
     }
-    set {operation = .loadFloat(newValue)}
+    set {_uniqueStorage()._operation = .loadFloat(newValue)}
   }
 
   public var loadString: Fuzzilli_Protobuf_LoadString {
     get {
-      if case .loadString(let v)? = operation {return v}
+      if case .loadString(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_LoadString()
     }
-    set {operation = .loadString(newValue)}
+    set {_uniqueStorage()._operation = .loadString(newValue)}
   }
 
   public var loadBoolean: Fuzzilli_Protobuf_LoadBoolean {
     get {
-      if case .loadBoolean(let v)? = operation {return v}
+      if case .loadBoolean(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_LoadBoolean()
     }
-    set {operation = .loadBoolean(newValue)}
+    set {_uniqueStorage()._operation = .loadBoolean(newValue)}
   }
 
   public var loadUndefined: Fuzzilli_Protobuf_LoadUndefined {
     get {
-      if case .loadUndefined(let v)? = operation {return v}
+      if case .loadUndefined(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_LoadUndefined()
     }
-    set {operation = .loadUndefined(newValue)}
+    set {_uniqueStorage()._operation = .loadUndefined(newValue)}
   }
 
   public var loadNull: Fuzzilli_Protobuf_LoadNull {
     get {
-      if case .loadNull(let v)? = operation {return v}
+      if case .loadNull(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_LoadNull()
     }
-    set {operation = .loadNull(newValue)}
+    set {_uniqueStorage()._operation = .loadNull(newValue)}
   }
 
   public var loadThis: Fuzzilli_Protobuf_LoadThis {
     get {
-      if case .loadThis(let v)? = operation {return v}
+      if case .loadThis(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_LoadThis()
     }
-    set {operation = .loadThis(newValue)}
+    set {_uniqueStorage()._operation = .loadThis(newValue)}
   }
 
   public var loadArguments: Fuzzilli_Protobuf_LoadArguments {
     get {
-      if case .loadArguments(let v)? = operation {return v}
+      if case .loadArguments(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_LoadArguments()
     }
-    set {operation = .loadArguments(newValue)}
+    set {_uniqueStorage()._operation = .loadArguments(newValue)}
   }
 
   public var loadRegExp: Fuzzilli_Protobuf_LoadRegExp {
     get {
-      if case .loadRegExp(let v)? = operation {return v}
+      if case .loadRegExp(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_LoadRegExp()
     }
-    set {operation = .loadRegExp(newValue)}
+    set {_uniqueStorage()._operation = .loadRegExp(newValue)}
   }
 
   public var beginObjectLiteral: Fuzzilli_Protobuf_BeginObjectLiteral {
     get {
-      if case .beginObjectLiteral(let v)? = operation {return v}
+      if case .beginObjectLiteral(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_BeginObjectLiteral()
     }
-    set {operation = .beginObjectLiteral(newValue)}
+    set {_uniqueStorage()._operation = .beginObjectLiteral(newValue)}
   }
 
   public var objectLiteralAddProperty: Fuzzilli_Protobuf_ObjectLiteralAddProperty {
     get {
-      if case .objectLiteralAddProperty(let v)? = operation {return v}
+      if case .objectLiteralAddProperty(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_ObjectLiteralAddProperty()
     }
-    set {operation = .objectLiteralAddProperty(newValue)}
+    set {_uniqueStorage()._operation = .objectLiteralAddProperty(newValue)}
   }
 
   public var objectLiteralAddElement: Fuzzilli_Protobuf_ObjectLiteralAddElement {
     get {
-      if case .objectLiteralAddElement(let v)? = operation {return v}
+      if case .objectLiteralAddElement(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_ObjectLiteralAddElement()
     }
-    set {operation = .objectLiteralAddElement(newValue)}
+    set {_uniqueStorage()._operation = .objectLiteralAddElement(newValue)}
   }
 
   public var objectLiteralAddComputedProperty: Fuzzilli_Protobuf_ObjectLiteralAddComputedProperty {
     get {
-      if case .objectLiteralAddComputedProperty(let v)? = operation {return v}
+      if case .objectLiteralAddComputedProperty(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_ObjectLiteralAddComputedProperty()
     }
-    set {operation = .objectLiteralAddComputedProperty(newValue)}
+    set {_uniqueStorage()._operation = .objectLiteralAddComputedProperty(newValue)}
   }
 
   public var objectLiteralCopyProperties: Fuzzilli_Protobuf_ObjectLiteralCopyProperties {
     get {
-      if case .objectLiteralCopyProperties(let v)? = operation {return v}
+      if case .objectLiteralCopyProperties(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_ObjectLiteralCopyProperties()
     }
-    set {operation = .objectLiteralCopyProperties(newValue)}
+    set {_uniqueStorage()._operation = .objectLiteralCopyProperties(newValue)}
   }
 
   public var objectLiteralSetPrototype: Fuzzilli_Protobuf_ObjectLiteralSetPrototype {
     get {
-      if case .objectLiteralSetPrototype(let v)? = operation {return v}
+      if case .objectLiteralSetPrototype(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_ObjectLiteralSetPrototype()
     }
-    set {operation = .objectLiteralSetPrototype(newValue)}
+    set {_uniqueStorage()._operation = .objectLiteralSetPrototype(newValue)}
   }
 
   public var beginObjectLiteralMethod: Fuzzilli_Protobuf_BeginObjectLiteralMethod {
     get {
-      if case .beginObjectLiteralMethod(let v)? = operation {return v}
+      if case .beginObjectLiteralMethod(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_BeginObjectLiteralMethod()
     }
-    set {operation = .beginObjectLiteralMethod(newValue)}
+    set {_uniqueStorage()._operation = .beginObjectLiteralMethod(newValue)}
   }
 
   public var endObjectLiteralMethod: Fuzzilli_Protobuf_EndObjectLiteralMethod {
     get {
-      if case .endObjectLiteralMethod(let v)? = operation {return v}
+      if case .endObjectLiteralMethod(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_EndObjectLiteralMethod()
     }
-    set {operation = .endObjectLiteralMethod(newValue)}
+    set {_uniqueStorage()._operation = .endObjectLiteralMethod(newValue)}
   }
 
   public var beginObjectLiteralComputedMethod: Fuzzilli_Protobuf_BeginObjectLiteralComputedMethod {
     get {
-      if case .beginObjectLiteralComputedMethod(let v)? = operation {return v}
+      if case .beginObjectLiteralComputedMethod(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_BeginObjectLiteralComputedMethod()
     }
-    set {operation = .beginObjectLiteralComputedMethod(newValue)}
+    set {_uniqueStorage()._operation = .beginObjectLiteralComputedMethod(newValue)}
   }
 
   public var endObjectLiteralComputedMethod: Fuzzilli_Protobuf_EndObjectLiteralComputedMethod {
     get {
-      if case .endObjectLiteralComputedMethod(let v)? = operation {return v}
+      if case .endObjectLiteralComputedMethod(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_EndObjectLiteralComputedMethod()
     }
-    set {operation = .endObjectLiteralComputedMethod(newValue)}
+    set {_uniqueStorage()._operation = .endObjectLiteralComputedMethod(newValue)}
   }
 
   public var beginObjectLiteralGetter: Fuzzilli_Protobuf_BeginObjectLiteralGetter {
     get {
-      if case .beginObjectLiteralGetter(let v)? = operation {return v}
+      if case .beginObjectLiteralGetter(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_BeginObjectLiteralGetter()
     }
-    set {operation = .beginObjectLiteralGetter(newValue)}
+    set {_uniqueStorage()._operation = .beginObjectLiteralGetter(newValue)}
   }
 
   public var endObjectLiteralGetter: Fuzzilli_Protobuf_EndObjectLiteralGetter {
     get {
-      if case .endObjectLiteralGetter(let v)? = operation {return v}
+      if case .endObjectLiteralGetter(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_EndObjectLiteralGetter()
     }
-    set {operation = .endObjectLiteralGetter(newValue)}
+    set {_uniqueStorage()._operation = .endObjectLiteralGetter(newValue)}
   }
 
   public var beginObjectLiteralSetter: Fuzzilli_Protobuf_BeginObjectLiteralSetter {
     get {
-      if case .beginObjectLiteralSetter(let v)? = operation {return v}
+      if case .beginObjectLiteralSetter(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_BeginObjectLiteralSetter()
     }
-    set {operation = .beginObjectLiteralSetter(newValue)}
+    set {_uniqueStorage()._operation = .beginObjectLiteralSetter(newValue)}
   }
 
   public var endObjectLiteralSetter: Fuzzilli_Protobuf_EndObjectLiteralSetter {
     get {
-      if case .endObjectLiteralSetter(let v)? = operation {return v}
+      if case .endObjectLiteralSetter(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_EndObjectLiteralSetter()
     }
-    set {operation = .endObjectLiteralSetter(newValue)}
+    set {_uniqueStorage()._operation = .endObjectLiteralSetter(newValue)}
   }
 
   public var endObjectLiteral: Fuzzilli_Protobuf_EndObjectLiteral {
     get {
-      if case .endObjectLiteral(let v)? = operation {return v}
+      if case .endObjectLiteral(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_EndObjectLiteral()
     }
-    set {operation = .endObjectLiteral(newValue)}
+    set {_uniqueStorage()._operation = .endObjectLiteral(newValue)}
   }
 
   public var beginClassDefinition: Fuzzilli_Protobuf_BeginClassDefinition {
     get {
-      if case .beginClassDefinition(let v)? = operation {return v}
+      if case .beginClassDefinition(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_BeginClassDefinition()
     }
-    set {operation = .beginClassDefinition(newValue)}
+    set {_uniqueStorage()._operation = .beginClassDefinition(newValue)}
   }
 
   public var beginClassConstructor: Fuzzilli_Protobuf_BeginClassConstructor {
     get {
-      if case .beginClassConstructor(let v)? = operation {return v}
+      if case .beginClassConstructor(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_BeginClassConstructor()
     }
-    set {operation = .beginClassConstructor(newValue)}
+    set {_uniqueStorage()._operation = .beginClassConstructor(newValue)}
   }
 
   public var endClassConstructor: Fuzzilli_Protobuf_EndClassConstructor {
     get {
-      if case .endClassConstructor(let v)? = operation {return v}
+      if case .endClassConstructor(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_EndClassConstructor()
     }
-    set {operation = .endClassConstructor(newValue)}
+    set {_uniqueStorage()._operation = .endClassConstructor(newValue)}
   }
 
   public var classAddInstanceProperty: Fuzzilli_Protobuf_ClassAddInstanceProperty {
     get {
-      if case .classAddInstanceProperty(let v)? = operation {return v}
+      if case .classAddInstanceProperty(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_ClassAddInstanceProperty()
     }
-    set {operation = .classAddInstanceProperty(newValue)}
+    set {_uniqueStorage()._operation = .classAddInstanceProperty(newValue)}
   }
 
   public var classAddInstanceElement: Fuzzilli_Protobuf_ClassAddInstanceElement {
     get {
-      if case .classAddInstanceElement(let v)? = operation {return v}
+      if case .classAddInstanceElement(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_ClassAddInstanceElement()
     }
-    set {operation = .classAddInstanceElement(newValue)}
+    set {_uniqueStorage()._operation = .classAddInstanceElement(newValue)}
   }
 
   public var classAddInstanceComputedProperty: Fuzzilli_Protobuf_ClassAddInstanceComputedProperty {
     get {
-      if case .classAddInstanceComputedProperty(let v)? = operation {return v}
+      if case .classAddInstanceComputedProperty(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_ClassAddInstanceComputedProperty()
     }
-    set {operation = .classAddInstanceComputedProperty(newValue)}
+    set {_uniqueStorage()._operation = .classAddInstanceComputedProperty(newValue)}
   }
 
   public var beginClassInstanceMethod: Fuzzilli_Protobuf_BeginClassInstanceMethod {
     get {
-      if case .beginClassInstanceMethod(let v)? = operation {return v}
+      if case .beginClassInstanceMethod(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_BeginClassInstanceMethod()
     }
-    set {operation = .beginClassInstanceMethod(newValue)}
+    set {_uniqueStorage()._operation = .beginClassInstanceMethod(newValue)}
   }
 
   public var endClassInstanceMethod: Fuzzilli_Protobuf_EndClassInstanceMethod {
     get {
-      if case .endClassInstanceMethod(let v)? = operation {return v}
+      if case .endClassInstanceMethod(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_EndClassInstanceMethod()
     }
-    set {operation = .endClassInstanceMethod(newValue)}
+    set {_uniqueStorage()._operation = .endClassInstanceMethod(newValue)}
   }
 
   public var beginClassInstanceGetter: Fuzzilli_Protobuf_BeginClassInstanceGetter {
     get {
-      if case .beginClassInstanceGetter(let v)? = operation {return v}
+      if case .beginClassInstanceGetter(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_BeginClassInstanceGetter()
     }
-    set {operation = .beginClassInstanceGetter(newValue)}
+    set {_uniqueStorage()._operation = .beginClassInstanceGetter(newValue)}
   }
 
   public var endClassInstanceGetter: Fuzzilli_Protobuf_EndClassInstanceGetter {
     get {
-      if case .endClassInstanceGetter(let v)? = operation {return v}
+      if case .endClassInstanceGetter(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_EndClassInstanceGetter()
     }
-    set {operation = .endClassInstanceGetter(newValue)}
+    set {_uniqueStorage()._operation = .endClassInstanceGetter(newValue)}
   }
 
   public var beginClassInstanceSetter: Fuzzilli_Protobuf_BeginClassInstanceSetter {
     get {
-      if case .beginClassInstanceSetter(let v)? = operation {return v}
+      if case .beginClassInstanceSetter(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_BeginClassInstanceSetter()
     }
-    set {operation = .beginClassInstanceSetter(newValue)}
+    set {_uniqueStorage()._operation = .beginClassInstanceSetter(newValue)}
   }
 
   public var endClassInstanceSetter: Fuzzilli_Protobuf_EndClassInstanceSetter {
     get {
-      if case .endClassInstanceSetter(let v)? = operation {return v}
+      if case .endClassInstanceSetter(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_EndClassInstanceSetter()
     }
-    set {operation = .endClassInstanceSetter(newValue)}
+    set {_uniqueStorage()._operation = .endClassInstanceSetter(newValue)}
   }
 
   public var classAddStaticProperty: Fuzzilli_Protobuf_ClassAddStaticProperty {
     get {
-      if case .classAddStaticProperty(let v)? = operation {return v}
+      if case .classAddStaticProperty(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_ClassAddStaticProperty()
     }
-    set {operation = .classAddStaticProperty(newValue)}
+    set {_uniqueStorage()._operation = .classAddStaticProperty(newValue)}
   }
 
   public var classAddStaticElement: Fuzzilli_Protobuf_ClassAddStaticElement {
     get {
-      if case .classAddStaticElement(let v)? = operation {return v}
+      if case .classAddStaticElement(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_ClassAddStaticElement()
     }
-    set {operation = .classAddStaticElement(newValue)}
+    set {_uniqueStorage()._operation = .classAddStaticElement(newValue)}
   }
 
   public var classAddStaticComputedProperty: Fuzzilli_Protobuf_ClassAddStaticComputedProperty {
     get {
-      if case .classAddStaticComputedProperty(let v)? = operation {return v}
+      if case .classAddStaticComputedProperty(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_ClassAddStaticComputedProperty()
     }
-    set {operation = .classAddStaticComputedProperty(newValue)}
+    set {_uniqueStorage()._operation = .classAddStaticComputedProperty(newValue)}
   }
 
   public var beginClassStaticInitializer: Fuzzilli_Protobuf_BeginClassStaticInitializer {
     get {
-      if case .beginClassStaticInitializer(let v)? = operation {return v}
+      if case .beginClassStaticInitializer(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_BeginClassStaticInitializer()
     }
-    set {operation = .beginClassStaticInitializer(newValue)}
+    set {_uniqueStorage()._operation = .beginClassStaticInitializer(newValue)}
   }
 
   public var endClassStaticInitializer: Fuzzilli_Protobuf_EndClassStaticInitializer {
     get {
-      if case .endClassStaticInitializer(let v)? = operation {return v}
+      if case .endClassStaticInitializer(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_EndClassStaticInitializer()
     }
-    set {operation = .endClassStaticInitializer(newValue)}
+    set {_uniqueStorage()._operation = .endClassStaticInitializer(newValue)}
   }
 
   public var beginClassStaticMethod: Fuzzilli_Protobuf_BeginClassStaticMethod {
     get {
-      if case .beginClassStaticMethod(let v)? = operation {return v}
+      if case .beginClassStaticMethod(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_BeginClassStaticMethod()
     }
-    set {operation = .beginClassStaticMethod(newValue)}
+    set {_uniqueStorage()._operation = .beginClassStaticMethod(newValue)}
   }
 
   public var endClassStaticMethod: Fuzzilli_Protobuf_EndClassStaticMethod {
     get {
-      if case .endClassStaticMethod(let v)? = operation {return v}
+      if case .endClassStaticMethod(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_EndClassStaticMethod()
     }
-    set {operation = .endClassStaticMethod(newValue)}
+    set {_uniqueStorage()._operation = .endClassStaticMethod(newValue)}
   }
 
   public var beginClassStaticGetter: Fuzzilli_Protobuf_BeginClassStaticGetter {
     get {
-      if case .beginClassStaticGetter(let v)? = operation {return v}
+      if case .beginClassStaticGetter(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_BeginClassStaticGetter()
     }
-    set {operation = .beginClassStaticGetter(newValue)}
+    set {_uniqueStorage()._operation = .beginClassStaticGetter(newValue)}
   }
 
   public var endClassStaticGetter: Fuzzilli_Protobuf_EndClassStaticGetter {
     get {
-      if case .endClassStaticGetter(let v)? = operation {return v}
+      if case .endClassStaticGetter(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_EndClassStaticGetter()
     }
-    set {operation = .endClassStaticGetter(newValue)}
+    set {_uniqueStorage()._operation = .endClassStaticGetter(newValue)}
   }
 
   public var beginClassStaticSetter: Fuzzilli_Protobuf_BeginClassStaticSetter {
     get {
-      if case .beginClassStaticSetter(let v)? = operation {return v}
+      if case .beginClassStaticSetter(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_BeginClassStaticSetter()
     }
-    set {operation = .beginClassStaticSetter(newValue)}
+    set {_uniqueStorage()._operation = .beginClassStaticSetter(newValue)}
   }
 
   public var endClassStaticSetter: Fuzzilli_Protobuf_EndClassStaticSetter {
     get {
-      if case .endClassStaticSetter(let v)? = operation {return v}
+      if case .endClassStaticSetter(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_EndClassStaticSetter()
     }
-    set {operation = .endClassStaticSetter(newValue)}
+    set {_uniqueStorage()._operation = .endClassStaticSetter(newValue)}
   }
 
   public var classAddPrivateInstanceProperty: Fuzzilli_Protobuf_ClassAddPrivateInstanceProperty {
     get {
-      if case .classAddPrivateInstanceProperty(let v)? = operation {return v}
+      if case .classAddPrivateInstanceProperty(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_ClassAddPrivateInstanceProperty()
     }
-    set {operation = .classAddPrivateInstanceProperty(newValue)}
+    set {_uniqueStorage()._operation = .classAddPrivateInstanceProperty(newValue)}
   }
 
   public var beginClassPrivateInstanceMethod: Fuzzilli_Protobuf_BeginClassPrivateInstanceMethod {
     get {
-      if case .beginClassPrivateInstanceMethod(let v)? = operation {return v}
+      if case .beginClassPrivateInstanceMethod(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_BeginClassPrivateInstanceMethod()
     }
-    set {operation = .beginClassPrivateInstanceMethod(newValue)}
+    set {_uniqueStorage()._operation = .beginClassPrivateInstanceMethod(newValue)}
   }
 
   public var endClassPrivateInstanceMethod: Fuzzilli_Protobuf_EndClassPrivateInstanceMethod {
     get {
-      if case .endClassPrivateInstanceMethod(let v)? = operation {return v}
+      if case .endClassPrivateInstanceMethod(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_EndClassPrivateInstanceMethod()
     }
-    set {operation = .endClassPrivateInstanceMethod(newValue)}
+    set {_uniqueStorage()._operation = .endClassPrivateInstanceMethod(newValue)}
   }
 
   public var classAddPrivateStaticProperty: Fuzzilli_Protobuf_ClassAddPrivateStaticProperty {
     get {
-      if case .classAddPrivateStaticProperty(let v)? = operation {return v}
+      if case .classAddPrivateStaticProperty(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_ClassAddPrivateStaticProperty()
     }
-    set {operation = .classAddPrivateStaticProperty(newValue)}
+    set {_uniqueStorage()._operation = .classAddPrivateStaticProperty(newValue)}
   }
 
   public var beginClassPrivateStaticMethod: Fuzzilli_Protobuf_BeginClassPrivateStaticMethod {
     get {
-      if case .beginClassPrivateStaticMethod(let v)? = operation {return v}
+      if case .beginClassPrivateStaticMethod(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_BeginClassPrivateStaticMethod()
     }
-    set {operation = .beginClassPrivateStaticMethod(newValue)}
+    set {_uniqueStorage()._operation = .beginClassPrivateStaticMethod(newValue)}
   }
 
   public var endClassPrivateStaticMethod: Fuzzilli_Protobuf_EndClassPrivateStaticMethod {
     get {
-      if case .endClassPrivateStaticMethod(let v)? = operation {return v}
+      if case .endClassPrivateStaticMethod(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_EndClassPrivateStaticMethod()
     }
-    set {operation = .endClassPrivateStaticMethod(newValue)}
+    set {_uniqueStorage()._operation = .endClassPrivateStaticMethod(newValue)}
   }
 
   public var endClassDefinition: Fuzzilli_Protobuf_EndClassDefinition {
     get {
-      if case .endClassDefinition(let v)? = operation {return v}
+      if case .endClassDefinition(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_EndClassDefinition()
     }
-    set {operation = .endClassDefinition(newValue)}
+    set {_uniqueStorage()._operation = .endClassDefinition(newValue)}
   }
 
   public var createArray: Fuzzilli_Protobuf_CreateArray {
     get {
-      if case .createArray(let v)? = operation {return v}
+      if case .createArray(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_CreateArray()
     }
-    set {operation = .createArray(newValue)}
+    set {_uniqueStorage()._operation = .createArray(newValue)}
   }
 
   public var createIntArray: Fuzzilli_Protobuf_CreateIntArray {
     get {
-      if case .createIntArray(let v)? = operation {return v}
+      if case .createIntArray(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_CreateIntArray()
     }
-    set {operation = .createIntArray(newValue)}
+    set {_uniqueStorage()._operation = .createIntArray(newValue)}
   }
 
   public var createFloatArray: Fuzzilli_Protobuf_CreateFloatArray {
     get {
-      if case .createFloatArray(let v)? = operation {return v}
+      if case .createFloatArray(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_CreateFloatArray()
     }
-    set {operation = .createFloatArray(newValue)}
+    set {_uniqueStorage()._operation = .createFloatArray(newValue)}
   }
 
   public var createArrayWithSpread: Fuzzilli_Protobuf_CreateArrayWithSpread {
     get {
-      if case .createArrayWithSpread(let v)? = operation {return v}
+      if case .createArrayWithSpread(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_CreateArrayWithSpread()
     }
-    set {operation = .createArrayWithSpread(newValue)}
+    set {_uniqueStorage()._operation = .createArrayWithSpread(newValue)}
   }
 
   public var createTemplateString: Fuzzilli_Protobuf_CreateTemplateString {
     get {
-      if case .createTemplateString(let v)? = operation {return v}
+      if case .createTemplateString(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_CreateTemplateString()
     }
-    set {operation = .createTemplateString(newValue)}
+    set {_uniqueStorage()._operation = .createTemplateString(newValue)}
   }
 
   public var loadBuiltin: Fuzzilli_Protobuf_LoadBuiltin {
     get {
-      if case .loadBuiltin(let v)? = operation {return v}
+      if case .loadBuiltin(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_LoadBuiltin()
     }
-    set {operation = .loadBuiltin(newValue)}
+    set {_uniqueStorage()._operation = .loadBuiltin(newValue)}
   }
 
   public var getProperty: Fuzzilli_Protobuf_GetProperty {
     get {
-      if case .getProperty(let v)? = operation {return v}
+      if case .getProperty(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_GetProperty()
     }
-    set {operation = .getProperty(newValue)}
+    set {_uniqueStorage()._operation = .getProperty(newValue)}
   }
 
   public var setProperty: Fuzzilli_Protobuf_SetProperty {
     get {
-      if case .setProperty(let v)? = operation {return v}
+      if case .setProperty(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_SetProperty()
     }
-    set {operation = .setProperty(newValue)}
+    set {_uniqueStorage()._operation = .setProperty(newValue)}
   }
 
   public var updateProperty: Fuzzilli_Protobuf_UpdateProperty {
     get {
-      if case .updateProperty(let v)? = operation {return v}
+      if case .updateProperty(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_UpdateProperty()
     }
-    set {operation = .updateProperty(newValue)}
+    set {_uniqueStorage()._operation = .updateProperty(newValue)}
   }
 
   public var deleteProperty: Fuzzilli_Protobuf_DeleteProperty {
     get {
-      if case .deleteProperty(let v)? = operation {return v}
+      if case .deleteProperty(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_DeleteProperty()
     }
-    set {operation = .deleteProperty(newValue)}
+    set {_uniqueStorage()._operation = .deleteProperty(newValue)}
   }
 
   public var configureProperty: Fuzzilli_Protobuf_ConfigureProperty {
     get {
-      if case .configureProperty(let v)? = operation {return v}
+      if case .configureProperty(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_ConfigureProperty()
     }
-    set {operation = .configureProperty(newValue)}
+    set {_uniqueStorage()._operation = .configureProperty(newValue)}
   }
 
   public var getElement: Fuzzilli_Protobuf_GetElement {
     get {
-      if case .getElement(let v)? = operation {return v}
+      if case .getElement(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_GetElement()
     }
-    set {operation = .getElement(newValue)}
+    set {_uniqueStorage()._operation = .getElement(newValue)}
   }
 
   public var setElement: Fuzzilli_Protobuf_SetElement {
     get {
-      if case .setElement(let v)? = operation {return v}
+      if case .setElement(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_SetElement()
     }
-    set {operation = .setElement(newValue)}
+    set {_uniqueStorage()._operation = .setElement(newValue)}
   }
 
   public var updateElement: Fuzzilli_Protobuf_UpdateElement {
     get {
-      if case .updateElement(let v)? = operation {return v}
+      if case .updateElement(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_UpdateElement()
     }
-    set {operation = .updateElement(newValue)}
+    set {_uniqueStorage()._operation = .updateElement(newValue)}
   }
 
   public var deleteElement: Fuzzilli_Protobuf_DeleteElement {
     get {
-      if case .deleteElement(let v)? = operation {return v}
+      if case .deleteElement(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_DeleteElement()
     }
-    set {operation = .deleteElement(newValue)}
+    set {_uniqueStorage()._operation = .deleteElement(newValue)}
   }
 
   public var configureElement: Fuzzilli_Protobuf_ConfigureElement {
     get {
-      if case .configureElement(let v)? = operation {return v}
+      if case .configureElement(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_ConfigureElement()
     }
-    set {operation = .configureElement(newValue)}
+    set {_uniqueStorage()._operation = .configureElement(newValue)}
   }
 
   public var getComputedProperty: Fuzzilli_Protobuf_GetComputedProperty {
     get {
-      if case .getComputedProperty(let v)? = operation {return v}
+      if case .getComputedProperty(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_GetComputedProperty()
     }
-    set {operation = .getComputedProperty(newValue)}
+    set {_uniqueStorage()._operation = .getComputedProperty(newValue)}
   }
 
   public var setComputedProperty: Fuzzilli_Protobuf_SetComputedProperty {
     get {
-      if case .setComputedProperty(let v)? = operation {return v}
+      if case .setComputedProperty(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_SetComputedProperty()
     }
-    set {operation = .setComputedProperty(newValue)}
+    set {_uniqueStorage()._operation = .setComputedProperty(newValue)}
   }
 
   public var updateComputedProperty: Fuzzilli_Protobuf_UpdateComputedProperty {
     get {
-      if case .updateComputedProperty(let v)? = operation {return v}
+      if case .updateComputedProperty(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_UpdateComputedProperty()
     }
-    set {operation = .updateComputedProperty(newValue)}
+    set {_uniqueStorage()._operation = .updateComputedProperty(newValue)}
   }
 
   public var deleteComputedProperty: Fuzzilli_Protobuf_DeleteComputedProperty {
     get {
-      if case .deleteComputedProperty(let v)? = operation {return v}
+      if case .deleteComputedProperty(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_DeleteComputedProperty()
     }
-    set {operation = .deleteComputedProperty(newValue)}
+    set {_uniqueStorage()._operation = .deleteComputedProperty(newValue)}
   }
 
   public var configureComputedProperty: Fuzzilli_Protobuf_ConfigureComputedProperty {
     get {
-      if case .configureComputedProperty(let v)? = operation {return v}
+      if case .configureComputedProperty(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_ConfigureComputedProperty()
     }
-    set {operation = .configureComputedProperty(newValue)}
+    set {_uniqueStorage()._operation = .configureComputedProperty(newValue)}
   }
 
   public var typeOf: Fuzzilli_Protobuf_TypeOf {
     get {
-      if case .typeOf(let v)? = operation {return v}
+      if case .typeOf(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_TypeOf()
     }
-    set {operation = .typeOf(newValue)}
+    set {_uniqueStorage()._operation = .typeOf(newValue)}
   }
 
   public var testInstanceOf: Fuzzilli_Protobuf_TestInstanceOf {
     get {
-      if case .testInstanceOf(let v)? = operation {return v}
+      if case .testInstanceOf(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_TestInstanceOf()
     }
-    set {operation = .testInstanceOf(newValue)}
+    set {_uniqueStorage()._operation = .testInstanceOf(newValue)}
   }
 
   public var testIn: Fuzzilli_Protobuf_TestIn {
     get {
-      if case .testIn(let v)? = operation {return v}
+      if case .testIn(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_TestIn()
     }
-    set {operation = .testIn(newValue)}
+    set {_uniqueStorage()._operation = .testIn(newValue)}
   }
 
   public var beginPlainFunction: Fuzzilli_Protobuf_BeginPlainFunction {
     get {
-      if case .beginPlainFunction(let v)? = operation {return v}
+      if case .beginPlainFunction(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_BeginPlainFunction()
     }
-    set {operation = .beginPlainFunction(newValue)}
+    set {_uniqueStorage()._operation = .beginPlainFunction(newValue)}
   }
 
   public var endPlainFunction: Fuzzilli_Protobuf_EndPlainFunction {
     get {
-      if case .endPlainFunction(let v)? = operation {return v}
+      if case .endPlainFunction(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_EndPlainFunction()
     }
-    set {operation = .endPlainFunction(newValue)}
+    set {_uniqueStorage()._operation = .endPlainFunction(newValue)}
   }
 
   public var beginArrowFunction: Fuzzilli_Protobuf_BeginArrowFunction {
     get {
-      if case .beginArrowFunction(let v)? = operation {return v}
+      if case .beginArrowFunction(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_BeginArrowFunction()
     }
-    set {operation = .beginArrowFunction(newValue)}
+    set {_uniqueStorage()._operation = .beginArrowFunction(newValue)}
   }
 
   public var endArrowFunction: Fuzzilli_Protobuf_EndArrowFunction {
     get {
-      if case .endArrowFunction(let v)? = operation {return v}
+      if case .endArrowFunction(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_EndArrowFunction()
     }
-    set {operation = .endArrowFunction(newValue)}
+    set {_uniqueStorage()._operation = .endArrowFunction(newValue)}
   }
 
   public var beginGeneratorFunction: Fuzzilli_Protobuf_BeginGeneratorFunction {
     get {
-      if case .beginGeneratorFunction(let v)? = operation {return v}
+      if case .beginGeneratorFunction(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_BeginGeneratorFunction()
     }
-    set {operation = .beginGeneratorFunction(newValue)}
+    set {_uniqueStorage()._operation = .beginGeneratorFunction(newValue)}
   }
 
   public var endGeneratorFunction: Fuzzilli_Protobuf_EndGeneratorFunction {
     get {
-      if case .endGeneratorFunction(let v)? = operation {return v}
+      if case .endGeneratorFunction(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_EndGeneratorFunction()
     }
-    set {operation = .endGeneratorFunction(newValue)}
+    set {_uniqueStorage()._operation = .endGeneratorFunction(newValue)}
   }
 
   public var beginAsyncFunction: Fuzzilli_Protobuf_BeginAsyncFunction {
     get {
-      if case .beginAsyncFunction(let v)? = operation {return v}
+      if case .beginAsyncFunction(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_BeginAsyncFunction()
     }
-    set {operation = .beginAsyncFunction(newValue)}
+    set {_uniqueStorage()._operation = .beginAsyncFunction(newValue)}
   }
 
   public var endAsyncFunction: Fuzzilli_Protobuf_EndAsyncFunction {
     get {
-      if case .endAsyncFunction(let v)? = operation {return v}
+      if case .endAsyncFunction(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_EndAsyncFunction()
     }
-    set {operation = .endAsyncFunction(newValue)}
+    set {_uniqueStorage()._operation = .endAsyncFunction(newValue)}
   }
 
   public var beginAsyncArrowFunction: Fuzzilli_Protobuf_BeginAsyncArrowFunction {
     get {
-      if case .beginAsyncArrowFunction(let v)? = operation {return v}
+      if case .beginAsyncArrowFunction(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_BeginAsyncArrowFunction()
     }
-    set {operation = .beginAsyncArrowFunction(newValue)}
+    set {_uniqueStorage()._operation = .beginAsyncArrowFunction(newValue)}
   }
 
   public var endAsyncArrowFunction: Fuzzilli_Protobuf_EndAsyncArrowFunction {
     get {
-      if case .endAsyncArrowFunction(let v)? = operation {return v}
+      if case .endAsyncArrowFunction(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_EndAsyncArrowFunction()
     }
-    set {operation = .endAsyncArrowFunction(newValue)}
+    set {_uniqueStorage()._operation = .endAsyncArrowFunction(newValue)}
   }
 
   public var beginAsyncGeneratorFunction: Fuzzilli_Protobuf_BeginAsyncGeneratorFunction {
     get {
-      if case .beginAsyncGeneratorFunction(let v)? = operation {return v}
+      if case .beginAsyncGeneratorFunction(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_BeginAsyncGeneratorFunction()
     }
-    set {operation = .beginAsyncGeneratorFunction(newValue)}
+    set {_uniqueStorage()._operation = .beginAsyncGeneratorFunction(newValue)}
   }
 
   public var endAsyncGeneratorFunction: Fuzzilli_Protobuf_EndAsyncGeneratorFunction {
     get {
-      if case .endAsyncGeneratorFunction(let v)? = operation {return v}
+      if case .endAsyncGeneratorFunction(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_EndAsyncGeneratorFunction()
     }
-    set {operation = .endAsyncGeneratorFunction(newValue)}
+    set {_uniqueStorage()._operation = .endAsyncGeneratorFunction(newValue)}
   }
 
   public var beginConstructor: Fuzzilli_Protobuf_BeginConstructor {
     get {
-      if case .beginConstructor(let v)? = operation {return v}
+      if case .beginConstructor(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_BeginConstructor()
     }
-    set {operation = .beginConstructor(newValue)}
+    set {_uniqueStorage()._operation = .beginConstructor(newValue)}
   }
 
   public var endConstructor: Fuzzilli_Protobuf_EndConstructor {
     get {
-      if case .endConstructor(let v)? = operation {return v}
+      if case .endConstructor(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_EndConstructor()
     }
-    set {operation = .endConstructor(newValue)}
+    set {_uniqueStorage()._operation = .endConstructor(newValue)}
   }
 
   public var `return`: Fuzzilli_Protobuf_Return {
     get {
-      if case .return(let v)? = operation {return v}
+      if case .return(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_Return()
     }
-    set {operation = .return(newValue)}
+    set {_uniqueStorage()._operation = .return(newValue)}
   }
 
   public var yield: Fuzzilli_Protobuf_Yield {
     get {
-      if case .yield(let v)? = operation {return v}
+      if case .yield(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_Yield()
     }
-    set {operation = .yield(newValue)}
+    set {_uniqueStorage()._operation = .yield(newValue)}
   }
 
   public var yieldEach: Fuzzilli_Protobuf_YieldEach {
     get {
-      if case .yieldEach(let v)? = operation {return v}
+      if case .yieldEach(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_YieldEach()
     }
-    set {operation = .yieldEach(newValue)}
+    set {_uniqueStorage()._operation = .yieldEach(newValue)}
   }
 
   public var await: Fuzzilli_Protobuf_Await {
     get {
-      if case .await(let v)? = operation {return v}
+      if case .await(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_Await()
     }
-    set {operation = .await(newValue)}
+    set {_uniqueStorage()._operation = .await(newValue)}
   }
 
   public var callFunction: Fuzzilli_Protobuf_CallFunction {
     get {
-      if case .callFunction(let v)? = operation {return v}
+      if case .callFunction(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_CallFunction()
     }
-    set {operation = .callFunction(newValue)}
+    set {_uniqueStorage()._operation = .callFunction(newValue)}
   }
 
   public var callFunctionWithSpread: Fuzzilli_Protobuf_CallFunctionWithSpread {
     get {
-      if case .callFunctionWithSpread(let v)? = operation {return v}
+      if case .callFunctionWithSpread(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_CallFunctionWithSpread()
     }
-    set {operation = .callFunctionWithSpread(newValue)}
+    set {_uniqueStorage()._operation = .callFunctionWithSpread(newValue)}
   }
 
   public var construct: Fuzzilli_Protobuf_Construct {
     get {
-      if case .construct(let v)? = operation {return v}
+      if case .construct(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_Construct()
     }
-    set {operation = .construct(newValue)}
+    set {_uniqueStorage()._operation = .construct(newValue)}
   }
 
   public var constructWithSpread: Fuzzilli_Protobuf_ConstructWithSpread {
     get {
-      if case .constructWithSpread(let v)? = operation {return v}
+      if case .constructWithSpread(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_ConstructWithSpread()
     }
-    set {operation = .constructWithSpread(newValue)}
+    set {_uniqueStorage()._operation = .constructWithSpread(newValue)}
   }
 
   public var callMethod: Fuzzilli_Protobuf_CallMethod {
     get {
-      if case .callMethod(let v)? = operation {return v}
+      if case .callMethod(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_CallMethod()
     }
-    set {operation = .callMethod(newValue)}
+    set {_uniqueStorage()._operation = .callMethod(newValue)}
   }
 
   public var callMethodWithSpread: Fuzzilli_Protobuf_CallMethodWithSpread {
     get {
-      if case .callMethodWithSpread(let v)? = operation {return v}
+      if case .callMethodWithSpread(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_CallMethodWithSpread()
     }
-    set {operation = .callMethodWithSpread(newValue)}
+    set {_uniqueStorage()._operation = .callMethodWithSpread(newValue)}
   }
 
   public var callComputedMethod: Fuzzilli_Protobuf_CallComputedMethod {
     get {
-      if case .callComputedMethod(let v)? = operation {return v}
+      if case .callComputedMethod(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_CallComputedMethod()
     }
-    set {operation = .callComputedMethod(newValue)}
+    set {_uniqueStorage()._operation = .callComputedMethod(newValue)}
   }
 
   public var callComputedMethodWithSpread: Fuzzilli_Protobuf_CallComputedMethodWithSpread {
     get {
-      if case .callComputedMethodWithSpread(let v)? = operation {return v}
+      if case .callComputedMethodWithSpread(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_CallComputedMethodWithSpread()
     }
-    set {operation = .callComputedMethodWithSpread(newValue)}
+    set {_uniqueStorage()._operation = .callComputedMethodWithSpread(newValue)}
   }
 
   public var unaryOperation: Fuzzilli_Protobuf_UnaryOperation {
     get {
-      if case .unaryOperation(let v)? = operation {return v}
+      if case .unaryOperation(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_UnaryOperation()
     }
-    set {operation = .unaryOperation(newValue)}
+    set {_uniqueStorage()._operation = .unaryOperation(newValue)}
   }
 
   public var binaryOperation: Fuzzilli_Protobuf_BinaryOperation {
     get {
-      if case .binaryOperation(let v)? = operation {return v}
+      if case .binaryOperation(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_BinaryOperation()
     }
-    set {operation = .binaryOperation(newValue)}
+    set {_uniqueStorage()._operation = .binaryOperation(newValue)}
   }
 
   public var ternaryOperation: Fuzzilli_Protobuf_TernaryOperation {
     get {
-      if case .ternaryOperation(let v)? = operation {return v}
+      if case .ternaryOperation(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_TernaryOperation()
     }
-    set {operation = .ternaryOperation(newValue)}
+    set {_uniqueStorage()._operation = .ternaryOperation(newValue)}
   }
 
   public var update: Fuzzilli_Protobuf_Update {
     get {
-      if case .update(let v)? = operation {return v}
+      if case .update(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_Update()
     }
-    set {operation = .update(newValue)}
+    set {_uniqueStorage()._operation = .update(newValue)}
   }
 
   public var dup: Fuzzilli_Protobuf_Dup {
     get {
-      if case .dup(let v)? = operation {return v}
+      if case .dup(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_Dup()
     }
-    set {operation = .dup(newValue)}
+    set {_uniqueStorage()._operation = .dup(newValue)}
   }
 
   public var reassign: Fuzzilli_Protobuf_Reassign {
     get {
-      if case .reassign(let v)? = operation {return v}
+      if case .reassign(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_Reassign()
     }
-    set {operation = .reassign(newValue)}
+    set {_uniqueStorage()._operation = .reassign(newValue)}
   }
 
   public var destructArray: Fuzzilli_Protobuf_DestructArray {
     get {
-      if case .destructArray(let v)? = operation {return v}
+      if case .destructArray(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_DestructArray()
     }
-    set {operation = .destructArray(newValue)}
+    set {_uniqueStorage()._operation = .destructArray(newValue)}
   }
 
   public var destructArrayAndReassign: Fuzzilli_Protobuf_DestructArrayAndReassign {
     get {
-      if case .destructArrayAndReassign(let v)? = operation {return v}
+      if case .destructArrayAndReassign(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_DestructArrayAndReassign()
     }
-    set {operation = .destructArrayAndReassign(newValue)}
+    set {_uniqueStorage()._operation = .destructArrayAndReassign(newValue)}
   }
 
   public var destructObject: Fuzzilli_Protobuf_DestructObject {
     get {
-      if case .destructObject(let v)? = operation {return v}
+      if case .destructObject(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_DestructObject()
     }
-    set {operation = .destructObject(newValue)}
+    set {_uniqueStorage()._operation = .destructObject(newValue)}
   }
 
   public var destructObjectAndReassign: Fuzzilli_Protobuf_DestructObjectAndReassign {
     get {
-      if case .destructObjectAndReassign(let v)? = operation {return v}
+      if case .destructObjectAndReassign(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_DestructObjectAndReassign()
     }
-    set {operation = .destructObjectAndReassign(newValue)}
+    set {_uniqueStorage()._operation = .destructObjectAndReassign(newValue)}
   }
 
   public var compare: Fuzzilli_Protobuf_Compare {
     get {
-      if case .compare(let v)? = operation {return v}
+      if case .compare(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_Compare()
     }
-    set {operation = .compare(newValue)}
+    set {_uniqueStorage()._operation = .compare(newValue)}
   }
 
   public var loadNamedVariable: Fuzzilli_Protobuf_LoadNamedVariable {
     get {
-      if case .loadNamedVariable(let v)? = operation {return v}
+      if case .loadNamedVariable(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_LoadNamedVariable()
     }
-    set {operation = .loadNamedVariable(newValue)}
+    set {_uniqueStorage()._operation = .loadNamedVariable(newValue)}
   }
 
   public var storeNamedVariable: Fuzzilli_Protobuf_StoreNamedVariable {
     get {
-      if case .storeNamedVariable(let v)? = operation {return v}
+      if case .storeNamedVariable(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_StoreNamedVariable()
     }
-    set {operation = .storeNamedVariable(newValue)}
+    set {_uniqueStorage()._operation = .storeNamedVariable(newValue)}
   }
 
   public var defineNamedVariable: Fuzzilli_Protobuf_DefineNamedVariable {
     get {
-      if case .defineNamedVariable(let v)? = operation {return v}
+      if case .defineNamedVariable(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_DefineNamedVariable()
     }
-    set {operation = .defineNamedVariable(newValue)}
+    set {_uniqueStorage()._operation = .defineNamedVariable(newValue)}
   }
 
   public var eval: Fuzzilli_Protobuf_Eval {
     get {
-      if case .eval(let v)? = operation {return v}
+      if case .eval(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_Eval()
     }
-    set {operation = .eval(newValue)}
+    set {_uniqueStorage()._operation = .eval(newValue)}
   }
 
   public var beginWith: Fuzzilli_Protobuf_BeginWith {
     get {
-      if case .beginWith(let v)? = operation {return v}
+      if case .beginWith(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_BeginWith()
     }
-    set {operation = .beginWith(newValue)}
+    set {_uniqueStorage()._operation = .beginWith(newValue)}
   }
 
   public var endWith: Fuzzilli_Protobuf_EndWith {
     get {
-      if case .endWith(let v)? = operation {return v}
+      if case .endWith(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_EndWith()
     }
-    set {operation = .endWith(newValue)}
+    set {_uniqueStorage()._operation = .endWith(newValue)}
   }
 
   public var callSuperConstructor: Fuzzilli_Protobuf_CallSuperConstructor {
     get {
-      if case .callSuperConstructor(let v)? = operation {return v}
+      if case .callSuperConstructor(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_CallSuperConstructor()
     }
-    set {operation = .callSuperConstructor(newValue)}
+    set {_uniqueStorage()._operation = .callSuperConstructor(newValue)}
   }
 
   public var callSuperMethod: Fuzzilli_Protobuf_CallSuperMethod {
     get {
-      if case .callSuperMethod(let v)? = operation {return v}
+      if case .callSuperMethod(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_CallSuperMethod()
     }
-    set {operation = .callSuperMethod(newValue)}
+    set {_uniqueStorage()._operation = .callSuperMethod(newValue)}
   }
 
   public var getPrivateProperty: Fuzzilli_Protobuf_GetPrivateProperty {
     get {
-      if case .getPrivateProperty(let v)? = operation {return v}
+      if case .getPrivateProperty(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_GetPrivateProperty()
     }
-    set {operation = .getPrivateProperty(newValue)}
+    set {_uniqueStorage()._operation = .getPrivateProperty(newValue)}
   }
 
   public var setPrivateProperty: Fuzzilli_Protobuf_SetPrivateProperty {
     get {
-      if case .setPrivateProperty(let v)? = operation {return v}
+      if case .setPrivateProperty(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_SetPrivateProperty()
     }
-    set {operation = .setPrivateProperty(newValue)}
+    set {_uniqueStorage()._operation = .setPrivateProperty(newValue)}
   }
 
   public var updatePrivateProperty: Fuzzilli_Protobuf_UpdatePrivateProperty {
     get {
-      if case .updatePrivateProperty(let v)? = operation {return v}
+      if case .updatePrivateProperty(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_UpdatePrivateProperty()
     }
-    set {operation = .updatePrivateProperty(newValue)}
+    set {_uniqueStorage()._operation = .updatePrivateProperty(newValue)}
   }
 
   public var callPrivateMethod: Fuzzilli_Protobuf_CallPrivateMethod {
     get {
-      if case .callPrivateMethod(let v)? = operation {return v}
+      if case .callPrivateMethod(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_CallPrivateMethod()
     }
-    set {operation = .callPrivateMethod(newValue)}
+    set {_uniqueStorage()._operation = .callPrivateMethod(newValue)}
   }
 
   public var getSuperProperty: Fuzzilli_Protobuf_GetSuperProperty {
     get {
-      if case .getSuperProperty(let v)? = operation {return v}
+      if case .getSuperProperty(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_GetSuperProperty()
     }
-    set {operation = .getSuperProperty(newValue)}
+    set {_uniqueStorage()._operation = .getSuperProperty(newValue)}
   }
 
   public var setSuperProperty: Fuzzilli_Protobuf_SetSuperProperty {
     get {
-      if case .setSuperProperty(let v)? = operation {return v}
+      if case .setSuperProperty(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_SetSuperProperty()
     }
-    set {operation = .setSuperProperty(newValue)}
+    set {_uniqueStorage()._operation = .setSuperProperty(newValue)}
   }
 
   public var getComputedSuperProperty: Fuzzilli_Protobuf_GetComputedSuperProperty {
     get {
-      if case .getComputedSuperProperty(let v)? = operation {return v}
+      if case .getComputedSuperProperty(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_GetComputedSuperProperty()
     }
-    set {operation = .getComputedSuperProperty(newValue)}
+    set {_uniqueStorage()._operation = .getComputedSuperProperty(newValue)}
   }
 
   public var setComputedSuperProperty: Fuzzilli_Protobuf_SetComputedSuperProperty {
     get {
-      if case .setComputedSuperProperty(let v)? = operation {return v}
+      if case .setComputedSuperProperty(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_SetComputedSuperProperty()
     }
-    set {operation = .setComputedSuperProperty(newValue)}
+    set {_uniqueStorage()._operation = .setComputedSuperProperty(newValue)}
   }
 
   public var updateSuperProperty: Fuzzilli_Protobuf_UpdateSuperProperty {
     get {
-      if case .updateSuperProperty(let v)? = operation {return v}
+      if case .updateSuperProperty(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_UpdateSuperProperty()
     }
-    set {operation = .updateSuperProperty(newValue)}
+    set {_uniqueStorage()._operation = .updateSuperProperty(newValue)}
   }
 
   public var beginIf: Fuzzilli_Protobuf_BeginIf {
     get {
-      if case .beginIf(let v)? = operation {return v}
+      if case .beginIf(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_BeginIf()
     }
-    set {operation = .beginIf(newValue)}
+    set {_uniqueStorage()._operation = .beginIf(newValue)}
   }
 
   public var beginElse: Fuzzilli_Protobuf_BeginElse {
     get {
-      if case .beginElse(let v)? = operation {return v}
+      if case .beginElse(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_BeginElse()
     }
-    set {operation = .beginElse(newValue)}
+    set {_uniqueStorage()._operation = .beginElse(newValue)}
   }
 
   public var endIf: Fuzzilli_Protobuf_EndIf {
     get {
-      if case .endIf(let v)? = operation {return v}
+      if case .endIf(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_EndIf()
     }
-    set {operation = .endIf(newValue)}
+    set {_uniqueStorage()._operation = .endIf(newValue)}
   }
 
   public var beginWhileLoopHeader: Fuzzilli_Protobuf_BeginWhileLoopHeader {
     get {
-      if case .beginWhileLoopHeader(let v)? = operation {return v}
+      if case .beginWhileLoopHeader(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_BeginWhileLoopHeader()
     }
-    set {operation = .beginWhileLoopHeader(newValue)}
+    set {_uniqueStorage()._operation = .beginWhileLoopHeader(newValue)}
   }
 
   public var beginWhileLoopBody: Fuzzilli_Protobuf_BeginWhileLoopBody {
     get {
-      if case .beginWhileLoopBody(let v)? = operation {return v}
+      if case .beginWhileLoopBody(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_BeginWhileLoopBody()
     }
-    set {operation = .beginWhileLoopBody(newValue)}
+    set {_uniqueStorage()._operation = .beginWhileLoopBody(newValue)}
   }
 
   public var endWhileLoop: Fuzzilli_Protobuf_EndWhileLoop {
     get {
-      if case .endWhileLoop(let v)? = operation {return v}
+      if case .endWhileLoop(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_EndWhileLoop()
     }
-    set {operation = .endWhileLoop(newValue)}
+    set {_uniqueStorage()._operation = .endWhileLoop(newValue)}
   }
 
   public var beginDoWhileLoopBody: Fuzzilli_Protobuf_BeginDoWhileLoopBody {
     get {
-      if case .beginDoWhileLoopBody(let v)? = operation {return v}
+      if case .beginDoWhileLoopBody(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_BeginDoWhileLoopBody()
     }
-    set {operation = .beginDoWhileLoopBody(newValue)}
+    set {_uniqueStorage()._operation = .beginDoWhileLoopBody(newValue)}
   }
 
   public var beginDoWhileLoopHeader: Fuzzilli_Protobuf_BeginDoWhileLoopHeader {
     get {
-      if case .beginDoWhileLoopHeader(let v)? = operation {return v}
+      if case .beginDoWhileLoopHeader(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_BeginDoWhileLoopHeader()
     }
-    set {operation = .beginDoWhileLoopHeader(newValue)}
+    set {_uniqueStorage()._operation = .beginDoWhileLoopHeader(newValue)}
   }
 
   public var endDoWhileLoop: Fuzzilli_Protobuf_EndDoWhileLoop {
     get {
-      if case .endDoWhileLoop(let v)? = operation {return v}
+      if case .endDoWhileLoop(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_EndDoWhileLoop()
     }
-    set {operation = .endDoWhileLoop(newValue)}
+    set {_uniqueStorage()._operation = .endDoWhileLoop(newValue)}
   }
 
   public var beginForLoopInitializer: Fuzzilli_Protobuf_BeginForLoopInitializer {
     get {
-      if case .beginForLoopInitializer(let v)? = operation {return v}
+      if case .beginForLoopInitializer(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_BeginForLoopInitializer()
     }
-    set {operation = .beginForLoopInitializer(newValue)}
+    set {_uniqueStorage()._operation = .beginForLoopInitializer(newValue)}
   }
 
   public var beginForLoopCondition: Fuzzilli_Protobuf_BeginForLoopCondition {
     get {
-      if case .beginForLoopCondition(let v)? = operation {return v}
+      if case .beginForLoopCondition(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_BeginForLoopCondition()
     }
-    set {operation = .beginForLoopCondition(newValue)}
+    set {_uniqueStorage()._operation = .beginForLoopCondition(newValue)}
   }
 
   public var beginForLoopAfterthought: Fuzzilli_Protobuf_BeginForLoopAfterthought {
     get {
-      if case .beginForLoopAfterthought(let v)? = operation {return v}
+      if case .beginForLoopAfterthought(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_BeginForLoopAfterthought()
     }
-    set {operation = .beginForLoopAfterthought(newValue)}
+    set {_uniqueStorage()._operation = .beginForLoopAfterthought(newValue)}
   }
 
   public var beginForLoopBody: Fuzzilli_Protobuf_BeginForLoopBody {
     get {
-      if case .beginForLoopBody(let v)? = operation {return v}
+      if case .beginForLoopBody(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_BeginForLoopBody()
     }
-    set {operation = .beginForLoopBody(newValue)}
+    set {_uniqueStorage()._operation = .beginForLoopBody(newValue)}
   }
 
   public var endForLoop: Fuzzilli_Protobuf_EndForLoop {
     get {
-      if case .endForLoop(let v)? = operation {return v}
+      if case .endForLoop(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_EndForLoop()
     }
-    set {operation = .endForLoop(newValue)}
+    set {_uniqueStorage()._operation = .endForLoop(newValue)}
   }
 
   public var beginForInLoop: Fuzzilli_Protobuf_BeginForInLoop {
     get {
-      if case .beginForInLoop(let v)? = operation {return v}
+      if case .beginForInLoop(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_BeginForInLoop()
     }
-    set {operation = .beginForInLoop(newValue)}
+    set {_uniqueStorage()._operation = .beginForInLoop(newValue)}
   }
 
   public var endForInLoop: Fuzzilli_Protobuf_EndForInLoop {
     get {
-      if case .endForInLoop(let v)? = operation {return v}
+      if case .endForInLoop(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_EndForInLoop()
     }
-    set {operation = .endForInLoop(newValue)}
+    set {_uniqueStorage()._operation = .endForInLoop(newValue)}
   }
 
   public var beginForOfLoop: Fuzzilli_Protobuf_BeginForOfLoop {
     get {
-      if case .beginForOfLoop(let v)? = operation {return v}
+      if case .beginForOfLoop(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_BeginForOfLoop()
     }
-    set {operation = .beginForOfLoop(newValue)}
+    set {_uniqueStorage()._operation = .beginForOfLoop(newValue)}
   }
 
   public var beginForOfLoopWithDestruct: Fuzzilli_Protobuf_BeginForOfLoopWithDestruct {
     get {
-      if case .beginForOfLoopWithDestruct(let v)? = operation {return v}
+      if case .beginForOfLoopWithDestruct(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_BeginForOfLoopWithDestruct()
     }
-    set {operation = .beginForOfLoopWithDestruct(newValue)}
+    set {_uniqueStorage()._operation = .beginForOfLoopWithDestruct(newValue)}
   }
 
   public var endForOfLoop: Fuzzilli_Protobuf_EndForOfLoop {
     get {
-      if case .endForOfLoop(let v)? = operation {return v}
+      if case .endForOfLoop(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_EndForOfLoop()
     }
-    set {operation = .endForOfLoop(newValue)}
+    set {_uniqueStorage()._operation = .endForOfLoop(newValue)}
   }
 
   public var beginRepeatLoop: Fuzzilli_Protobuf_BeginRepeatLoop {
     get {
-      if case .beginRepeatLoop(let v)? = operation {return v}
+      if case .beginRepeatLoop(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_BeginRepeatLoop()
     }
-    set {operation = .beginRepeatLoop(newValue)}
+    set {_uniqueStorage()._operation = .beginRepeatLoop(newValue)}
   }
 
   public var endRepeatLoop: Fuzzilli_Protobuf_EndRepeatLoop {
     get {
-      if case .endRepeatLoop(let v)? = operation {return v}
+      if case .endRepeatLoop(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_EndRepeatLoop()
     }
-    set {operation = .endRepeatLoop(newValue)}
+    set {_uniqueStorage()._operation = .endRepeatLoop(newValue)}
   }
 
   public var loopBreak: Fuzzilli_Protobuf_LoopBreak {
     get {
-      if case .loopBreak(let v)? = operation {return v}
+      if case .loopBreak(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_LoopBreak()
     }
-    set {operation = .loopBreak(newValue)}
+    set {_uniqueStorage()._operation = .loopBreak(newValue)}
   }
 
   public var loopContinue: Fuzzilli_Protobuf_LoopContinue {
     get {
-      if case .loopContinue(let v)? = operation {return v}
+      if case .loopContinue(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_LoopContinue()
     }
-    set {operation = .loopContinue(newValue)}
+    set {_uniqueStorage()._operation = .loopContinue(newValue)}
   }
 
   public var beginTry: Fuzzilli_Protobuf_BeginTry {
     get {
-      if case .beginTry(let v)? = operation {return v}
+      if case .beginTry(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_BeginTry()
     }
-    set {operation = .beginTry(newValue)}
+    set {_uniqueStorage()._operation = .beginTry(newValue)}
   }
 
   public var beginCatch: Fuzzilli_Protobuf_BeginCatch {
     get {
-      if case .beginCatch(let v)? = operation {return v}
+      if case .beginCatch(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_BeginCatch()
     }
-    set {operation = .beginCatch(newValue)}
+    set {_uniqueStorage()._operation = .beginCatch(newValue)}
   }
 
   public var beginFinally: Fuzzilli_Protobuf_BeginFinally {
     get {
-      if case .beginFinally(let v)? = operation {return v}
+      if case .beginFinally(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_BeginFinally()
     }
-    set {operation = .beginFinally(newValue)}
+    set {_uniqueStorage()._operation = .beginFinally(newValue)}
   }
 
   public var endTryCatchFinally: Fuzzilli_Protobuf_EndTryCatchFinally {
     get {
-      if case .endTryCatchFinally(let v)? = operation {return v}
+      if case .endTryCatchFinally(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_EndTryCatchFinally()
     }
-    set {operation = .endTryCatchFinally(newValue)}
+    set {_uniqueStorage()._operation = .endTryCatchFinally(newValue)}
   }
 
   public var throwException: Fuzzilli_Protobuf_ThrowException {
     get {
-      if case .throwException(let v)? = operation {return v}
+      if case .throwException(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_ThrowException()
     }
-    set {operation = .throwException(newValue)}
+    set {_uniqueStorage()._operation = .throwException(newValue)}
   }
 
   public var beginCodeString: Fuzzilli_Protobuf_BeginCodeString {
     get {
-      if case .beginCodeString(let v)? = operation {return v}
+      if case .beginCodeString(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_BeginCodeString()
     }
-    set {operation = .beginCodeString(newValue)}
+    set {_uniqueStorage()._operation = .beginCodeString(newValue)}
   }
 
   public var endCodeString: Fuzzilli_Protobuf_EndCodeString {
     get {
-      if case .endCodeString(let v)? = operation {return v}
+      if case .endCodeString(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_EndCodeString()
     }
-    set {operation = .endCodeString(newValue)}
+    set {_uniqueStorage()._operation = .endCodeString(newValue)}
   }
 
   public var beginBlockStatement: Fuzzilli_Protobuf_BeginBlockStatement {
     get {
-      if case .beginBlockStatement(let v)? = operation {return v}
+      if case .beginBlockStatement(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_BeginBlockStatement()
     }
-    set {operation = .beginBlockStatement(newValue)}
+    set {_uniqueStorage()._operation = .beginBlockStatement(newValue)}
   }
 
   public var endBlockStatement: Fuzzilli_Protobuf_EndBlockStatement {
     get {
-      if case .endBlockStatement(let v)? = operation {return v}
+      if case .endBlockStatement(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_EndBlockStatement()
     }
-    set {operation = .endBlockStatement(newValue)}
+    set {_uniqueStorage()._operation = .endBlockStatement(newValue)}
   }
 
   public var beginSwitch: Fuzzilli_Protobuf_BeginSwitch {
     get {
-      if case .beginSwitch(let v)? = operation {return v}
+      if case .beginSwitch(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_BeginSwitch()
     }
-    set {operation = .beginSwitch(newValue)}
+    set {_uniqueStorage()._operation = .beginSwitch(newValue)}
   }
 
   public var beginSwitchCase: Fuzzilli_Protobuf_BeginSwitchCase {
     get {
-      if case .beginSwitchCase(let v)? = operation {return v}
+      if case .beginSwitchCase(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_BeginSwitchCase()
     }
-    set {operation = .beginSwitchCase(newValue)}
+    set {_uniqueStorage()._operation = .beginSwitchCase(newValue)}
   }
 
   public var beginSwitchDefaultCase: Fuzzilli_Protobuf_BeginSwitchDefaultCase {
     get {
-      if case .beginSwitchDefaultCase(let v)? = operation {return v}
+      if case .beginSwitchDefaultCase(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_BeginSwitchDefaultCase()
     }
-    set {operation = .beginSwitchDefaultCase(newValue)}
+    set {_uniqueStorage()._operation = .beginSwitchDefaultCase(newValue)}
   }
 
   public var endSwitchCase: Fuzzilli_Protobuf_EndSwitchCase {
     get {
-      if case .endSwitchCase(let v)? = operation {return v}
+      if case .endSwitchCase(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_EndSwitchCase()
     }
-    set {operation = .endSwitchCase(newValue)}
+    set {_uniqueStorage()._operation = .endSwitchCase(newValue)}
   }
 
   public var endSwitch: Fuzzilli_Protobuf_EndSwitch {
     get {
-      if case .endSwitch(let v)? = operation {return v}
+      if case .endSwitch(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_EndSwitch()
     }
-    set {operation = .endSwitch(newValue)}
+    set {_uniqueStorage()._operation = .endSwitch(newValue)}
   }
 
   public var switchBreak: Fuzzilli_Protobuf_SwitchBreak {
     get {
-      if case .switchBreak(let v)? = operation {return v}
+      if case .switchBreak(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_SwitchBreak()
     }
-    set {operation = .switchBreak(newValue)}
+    set {_uniqueStorage()._operation = .switchBreak(newValue)}
   }
 
   public var loadNewTarget: Fuzzilli_Protobuf_LoadNewTarget {
     get {
-      if case .loadNewTarget(let v)? = operation {return v}
+      if case .loadNewTarget(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_LoadNewTarget()
     }
-    set {operation = .loadNewTarget(newValue)}
+    set {_uniqueStorage()._operation = .loadNewTarget(newValue)}
   }
 
   public var print: Fuzzilli_Protobuf_Print {
     get {
-      if case .print(let v)? = operation {return v}
+      if case .print(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_Print()
     }
-    set {operation = .print(newValue)}
+    set {_uniqueStorage()._operation = .print(newValue)}
   }
 
   public var explore: Fuzzilli_Protobuf_Explore {
     get {
-      if case .explore(let v)? = operation {return v}
+      if case .explore(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_Explore()
     }
-    set {operation = .explore(newValue)}
+    set {_uniqueStorage()._operation = .explore(newValue)}
   }
 
   public var probe: Fuzzilli_Protobuf_Probe {
     get {
-      if case .probe(let v)? = operation {return v}
+      if case .probe(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_Probe()
     }
-    set {operation = .probe(newValue)}
+    set {_uniqueStorage()._operation = .probe(newValue)}
   }
 
   public var fixup: Fuzzilli_Protobuf_Fixup {
     get {
-      if case .fixup(let v)? = operation {return v}
+      if case .fixup(let v)? = _storage._operation {return v}
       return Fuzzilli_Protobuf_Fixup()
     }
-    set {operation = .fixup(newValue)}
+    set {_uniqueStorage()._operation = .fixup(newValue)}
   }
 
   public var unknownFields = SwiftProtobuf.UnknownStorage()
@@ -1656,722 +1662,185 @@ public struct Fuzzilli_Protobuf_Instruction {
 
   #if !swift(>=4.1)
     public static func ==(lhs: Fuzzilli_Protobuf_Instruction.OneOf_Operation, rhs: Fuzzilli_Protobuf_Instruction.OneOf_Operation) -> Bool {
-      // The use of inline closures is to circumvent an issue where the compiler
-      // allocates stack space for every case branch when no optimizations are
-      // enabled. https://github.com/apple/swift-protobuf/issues/1034
       switch (lhs, rhs) {
-      case (.opIdx, .opIdx): return {
-        guard case .opIdx(let l) = lhs, case .opIdx(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.nop, .nop): return {
-        guard case .nop(let l) = lhs, case .nop(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.loadInteger, .loadInteger): return {
-        guard case .loadInteger(let l) = lhs, case .loadInteger(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.loadBigInt, .loadBigInt): return {
-        guard case .loadBigInt(let l) = lhs, case .loadBigInt(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.loadFloat, .loadFloat): return {
-        guard case .loadFloat(let l) = lhs, case .loadFloat(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.loadString, .loadString): return {
-        guard case .loadString(let l) = lhs, case .loadString(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.loadBoolean, .loadBoolean): return {
-        guard case .loadBoolean(let l) = lhs, case .loadBoolean(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.loadUndefined, .loadUndefined): return {
-        guard case .loadUndefined(let l) = lhs, case .loadUndefined(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.loadNull, .loadNull): return {
-        guard case .loadNull(let l) = lhs, case .loadNull(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.loadThis, .loadThis): return {
-        guard case .loadThis(let l) = lhs, case .loadThis(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.loadArguments, .loadArguments): return {
-        guard case .loadArguments(let l) = lhs, case .loadArguments(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.loadRegExp, .loadRegExp): return {
-        guard case .loadRegExp(let l) = lhs, case .loadRegExp(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.beginObjectLiteral, .beginObjectLiteral): return {
-        guard case .beginObjectLiteral(let l) = lhs, case .beginObjectLiteral(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.objectLiteralAddProperty, .objectLiteralAddProperty): return {
-        guard case .objectLiteralAddProperty(let l) = lhs, case .objectLiteralAddProperty(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.objectLiteralAddElement, .objectLiteralAddElement): return {
-        guard case .objectLiteralAddElement(let l) = lhs, case .objectLiteralAddElement(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.objectLiteralAddComputedProperty, .objectLiteralAddComputedProperty): return {
-        guard case .objectLiteralAddComputedProperty(let l) = lhs, case .objectLiteralAddComputedProperty(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.objectLiteralCopyProperties, .objectLiteralCopyProperties): return {
-        guard case .objectLiteralCopyProperties(let l) = lhs, case .objectLiteralCopyProperties(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.objectLiteralSetPrototype, .objectLiteralSetPrototype): return {
-        guard case .objectLiteralSetPrototype(let l) = lhs, case .objectLiteralSetPrototype(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.beginObjectLiteralMethod, .beginObjectLiteralMethod): return {
-        guard case .beginObjectLiteralMethod(let l) = lhs, case .beginObjectLiteralMethod(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.endObjectLiteralMethod, .endObjectLiteralMethod): return {
-        guard case .endObjectLiteralMethod(let l) = lhs, case .endObjectLiteralMethod(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.beginObjectLiteralComputedMethod, .beginObjectLiteralComputedMethod): return {
-        guard case .beginObjectLiteralComputedMethod(let l) = lhs, case .beginObjectLiteralComputedMethod(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.endObjectLiteralComputedMethod, .endObjectLiteralComputedMethod): return {
-        guard case .endObjectLiteralComputedMethod(let l) = lhs, case .endObjectLiteralComputedMethod(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.beginObjectLiteralGetter, .beginObjectLiteralGetter): return {
-        guard case .beginObjectLiteralGetter(let l) = lhs, case .beginObjectLiteralGetter(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.endObjectLiteralGetter, .endObjectLiteralGetter): return {
-        guard case .endObjectLiteralGetter(let l) = lhs, case .endObjectLiteralGetter(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.beginObjectLiteralSetter, .beginObjectLiteralSetter): return {
-        guard case .beginObjectLiteralSetter(let l) = lhs, case .beginObjectLiteralSetter(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.endObjectLiteralSetter, .endObjectLiteralSetter): return {
-        guard case .endObjectLiteralSetter(let l) = lhs, case .endObjectLiteralSetter(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.endObjectLiteral, .endObjectLiteral): return {
-        guard case .endObjectLiteral(let l) = lhs, case .endObjectLiteral(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.beginClassDefinition, .beginClassDefinition): return {
-        guard case .beginClassDefinition(let l) = lhs, case .beginClassDefinition(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.beginClassConstructor, .beginClassConstructor): return {
-        guard case .beginClassConstructor(let l) = lhs, case .beginClassConstructor(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.endClassConstructor, .endClassConstructor): return {
-        guard case .endClassConstructor(let l) = lhs, case .endClassConstructor(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.classAddInstanceProperty, .classAddInstanceProperty): return {
-        guard case .classAddInstanceProperty(let l) = lhs, case .classAddInstanceProperty(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.classAddInstanceElement, .classAddInstanceElement): return {
-        guard case .classAddInstanceElement(let l) = lhs, case .classAddInstanceElement(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.classAddInstanceComputedProperty, .classAddInstanceComputedProperty): return {
-        guard case .classAddInstanceComputedProperty(let l) = lhs, case .classAddInstanceComputedProperty(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.beginClassInstanceMethod, .beginClassInstanceMethod): return {
-        guard case .beginClassInstanceMethod(let l) = lhs, case .beginClassInstanceMethod(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.endClassInstanceMethod, .endClassInstanceMethod): return {
-        guard case .endClassInstanceMethod(let l) = lhs, case .endClassInstanceMethod(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.beginClassInstanceGetter, .beginClassInstanceGetter): return {
-        guard case .beginClassInstanceGetter(let l) = lhs, case .beginClassInstanceGetter(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.endClassInstanceGetter, .endClassInstanceGetter): return {
-        guard case .endClassInstanceGetter(let l) = lhs, case .endClassInstanceGetter(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.beginClassInstanceSetter, .beginClassInstanceSetter): return {
-        guard case .beginClassInstanceSetter(let l) = lhs, case .beginClassInstanceSetter(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.endClassInstanceSetter, .endClassInstanceSetter): return {
-        guard case .endClassInstanceSetter(let l) = lhs, case .endClassInstanceSetter(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.classAddStaticProperty, .classAddStaticProperty): return {
-        guard case .classAddStaticProperty(let l) = lhs, case .classAddStaticProperty(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.classAddStaticElement, .classAddStaticElement): return {
-        guard case .classAddStaticElement(let l) = lhs, case .classAddStaticElement(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.classAddStaticComputedProperty, .classAddStaticComputedProperty): return {
-        guard case .classAddStaticComputedProperty(let l) = lhs, case .classAddStaticComputedProperty(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.beginClassStaticInitializer, .beginClassStaticInitializer): return {
-        guard case .beginClassStaticInitializer(let l) = lhs, case .beginClassStaticInitializer(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.endClassStaticInitializer, .endClassStaticInitializer): return {
-        guard case .endClassStaticInitializer(let l) = lhs, case .endClassStaticInitializer(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.beginClassStaticMethod, .beginClassStaticMethod): return {
-        guard case .beginClassStaticMethod(let l) = lhs, case .beginClassStaticMethod(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.endClassStaticMethod, .endClassStaticMethod): return {
-        guard case .endClassStaticMethod(let l) = lhs, case .endClassStaticMethod(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.beginClassStaticGetter, .beginClassStaticGetter): return {
-        guard case .beginClassStaticGetter(let l) = lhs, case .beginClassStaticGetter(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.endClassStaticGetter, .endClassStaticGetter): return {
-        guard case .endClassStaticGetter(let l) = lhs, case .endClassStaticGetter(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.beginClassStaticSetter, .beginClassStaticSetter): return {
-        guard case .beginClassStaticSetter(let l) = lhs, case .beginClassStaticSetter(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.endClassStaticSetter, .endClassStaticSetter): return {
-        guard case .endClassStaticSetter(let l) = lhs, case .endClassStaticSetter(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.classAddPrivateInstanceProperty, .classAddPrivateInstanceProperty): return {
-        guard case .classAddPrivateInstanceProperty(let l) = lhs, case .classAddPrivateInstanceProperty(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.beginClassPrivateInstanceMethod, .beginClassPrivateInstanceMethod): return {
-        guard case .beginClassPrivateInstanceMethod(let l) = lhs, case .beginClassPrivateInstanceMethod(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.endClassPrivateInstanceMethod, .endClassPrivateInstanceMethod): return {
-        guard case .endClassPrivateInstanceMethod(let l) = lhs, case .endClassPrivateInstanceMethod(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.classAddPrivateStaticProperty, .classAddPrivateStaticProperty): return {
-        guard case .classAddPrivateStaticProperty(let l) = lhs, case .classAddPrivateStaticProperty(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.beginClassPrivateStaticMethod, .beginClassPrivateStaticMethod): return {
-        guard case .beginClassPrivateStaticMethod(let l) = lhs, case .beginClassPrivateStaticMethod(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.endClassPrivateStaticMethod, .endClassPrivateStaticMethod): return {
-        guard case .endClassPrivateStaticMethod(let l) = lhs, case .endClassPrivateStaticMethod(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.endClassDefinition, .endClassDefinition): return {
-        guard case .endClassDefinition(let l) = lhs, case .endClassDefinition(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.createArray, .createArray): return {
-        guard case .createArray(let l) = lhs, case .createArray(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.createIntArray, .createIntArray): return {
-        guard case .createIntArray(let l) = lhs, case .createIntArray(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.createFloatArray, .createFloatArray): return {
-        guard case .createFloatArray(let l) = lhs, case .createFloatArray(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.createArrayWithSpread, .createArrayWithSpread): return {
-        guard case .createArrayWithSpread(let l) = lhs, case .createArrayWithSpread(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.createTemplateString, .createTemplateString): return {
-        guard case .createTemplateString(let l) = lhs, case .createTemplateString(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.loadBuiltin, .loadBuiltin): return {
-        guard case .loadBuiltin(let l) = lhs, case .loadBuiltin(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.getProperty, .getProperty): return {
-        guard case .getProperty(let l) = lhs, case .getProperty(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.setProperty, .setProperty): return {
-        guard case .setProperty(let l) = lhs, case .setProperty(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.updateProperty, .updateProperty): return {
-        guard case .updateProperty(let l) = lhs, case .updateProperty(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.deleteProperty, .deleteProperty): return {
-        guard case .deleteProperty(let l) = lhs, case .deleteProperty(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.configureProperty, .configureProperty): return {
-        guard case .configureProperty(let l) = lhs, case .configureProperty(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.getElement, .getElement): return {
-        guard case .getElement(let l) = lhs, case .getElement(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.setElement, .setElement): return {
-        guard case .setElement(let l) = lhs, case .setElement(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.updateElement, .updateElement): return {
-        guard case .updateElement(let l) = lhs, case .updateElement(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.deleteElement, .deleteElement): return {
-        guard case .deleteElement(let l) = lhs, case .deleteElement(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.configureElement, .configureElement): return {
-        guard case .configureElement(let l) = lhs, case .configureElement(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.getComputedProperty, .getComputedProperty): return {
-        guard case .getComputedProperty(let l) = lhs, case .getComputedProperty(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.setComputedProperty, .setComputedProperty): return {
-        guard case .setComputedProperty(let l) = lhs, case .setComputedProperty(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.updateComputedProperty, .updateComputedProperty): return {
-        guard case .updateComputedProperty(let l) = lhs, case .updateComputedProperty(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.deleteComputedProperty, .deleteComputedProperty): return {
-        guard case .deleteComputedProperty(let l) = lhs, case .deleteComputedProperty(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.configureComputedProperty, .configureComputedProperty): return {
-        guard case .configureComputedProperty(let l) = lhs, case .configureComputedProperty(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.typeOf, .typeOf): return {
-        guard case .typeOf(let l) = lhs, case .typeOf(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.testInstanceOf, .testInstanceOf): return {
-        guard case .testInstanceOf(let l) = lhs, case .testInstanceOf(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.testIn, .testIn): return {
-        guard case .testIn(let l) = lhs, case .testIn(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.beginPlainFunction, .beginPlainFunction): return {
-        guard case .beginPlainFunction(let l) = lhs, case .beginPlainFunction(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.endPlainFunction, .endPlainFunction): return {
-        guard case .endPlainFunction(let l) = lhs, case .endPlainFunction(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.beginArrowFunction, .beginArrowFunction): return {
-        guard case .beginArrowFunction(let l) = lhs, case .beginArrowFunction(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.endArrowFunction, .endArrowFunction): return {
-        guard case .endArrowFunction(let l) = lhs, case .endArrowFunction(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.beginGeneratorFunction, .beginGeneratorFunction): return {
-        guard case .beginGeneratorFunction(let l) = lhs, case .beginGeneratorFunction(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.endGeneratorFunction, .endGeneratorFunction): return {
-        guard case .endGeneratorFunction(let l) = lhs, case .endGeneratorFunction(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.beginAsyncFunction, .beginAsyncFunction): return {
-        guard case .beginAsyncFunction(let l) = lhs, case .beginAsyncFunction(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.endAsyncFunction, .endAsyncFunction): return {
-        guard case .endAsyncFunction(let l) = lhs, case .endAsyncFunction(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.beginAsyncArrowFunction, .beginAsyncArrowFunction): return {
-        guard case .beginAsyncArrowFunction(let l) = lhs, case .beginAsyncArrowFunction(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.endAsyncArrowFunction, .endAsyncArrowFunction): return {
-        guard case .endAsyncArrowFunction(let l) = lhs, case .endAsyncArrowFunction(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.beginAsyncGeneratorFunction, .beginAsyncGeneratorFunction): return {
-        guard case .beginAsyncGeneratorFunction(let l) = lhs, case .beginAsyncGeneratorFunction(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.endAsyncGeneratorFunction, .endAsyncGeneratorFunction): return {
-        guard case .endAsyncGeneratorFunction(let l) = lhs, case .endAsyncGeneratorFunction(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.beginConstructor, .beginConstructor): return {
-        guard case .beginConstructor(let l) = lhs, case .beginConstructor(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.endConstructor, .endConstructor): return {
-        guard case .endConstructor(let l) = lhs, case .endConstructor(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.return, .return): return {
-        guard case .return(let l) = lhs, case .return(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.yield, .yield): return {
-        guard case .yield(let l) = lhs, case .yield(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.yieldEach, .yieldEach): return {
-        guard case .yieldEach(let l) = lhs, case .yieldEach(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.await, .await): return {
-        guard case .await(let l) = lhs, case .await(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.callFunction, .callFunction): return {
-        guard case .callFunction(let l) = lhs, case .callFunction(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.callFunctionWithSpread, .callFunctionWithSpread): return {
-        guard case .callFunctionWithSpread(let l) = lhs, case .callFunctionWithSpread(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.construct, .construct): return {
-        guard case .construct(let l) = lhs, case .construct(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.constructWithSpread, .constructWithSpread): return {
-        guard case .constructWithSpread(let l) = lhs, case .constructWithSpread(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.callMethod, .callMethod): return {
-        guard case .callMethod(let l) = lhs, case .callMethod(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.callMethodWithSpread, .callMethodWithSpread): return {
-        guard case .callMethodWithSpread(let l) = lhs, case .callMethodWithSpread(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.callComputedMethod, .callComputedMethod): return {
-        guard case .callComputedMethod(let l) = lhs, case .callComputedMethod(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.callComputedMethodWithSpread, .callComputedMethodWithSpread): return {
-        guard case .callComputedMethodWithSpread(let l) = lhs, case .callComputedMethodWithSpread(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.unaryOperation, .unaryOperation): return {
-        guard case .unaryOperation(let l) = lhs, case .unaryOperation(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.binaryOperation, .binaryOperation): return {
-        guard case .binaryOperation(let l) = lhs, case .binaryOperation(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.ternaryOperation, .ternaryOperation): return {
-        guard case .ternaryOperation(let l) = lhs, case .ternaryOperation(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.update, .update): return {
-        guard case .update(let l) = lhs, case .update(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.dup, .dup): return {
-        guard case .dup(let l) = lhs, case .dup(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.reassign, .reassign): return {
-        guard case .reassign(let l) = lhs, case .reassign(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.destructArray, .destructArray): return {
-        guard case .destructArray(let l) = lhs, case .destructArray(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.destructArrayAndReassign, .destructArrayAndReassign): return {
-        guard case .destructArrayAndReassign(let l) = lhs, case .destructArrayAndReassign(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.destructObject, .destructObject): return {
-        guard case .destructObject(let l) = lhs, case .destructObject(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.destructObjectAndReassign, .destructObjectAndReassign): return {
-        guard case .destructObjectAndReassign(let l) = lhs, case .destructObjectAndReassign(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.compare, .compare): return {
-        guard case .compare(let l) = lhs, case .compare(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.loadNamedVariable, .loadNamedVariable): return {
-        guard case .loadNamedVariable(let l) = lhs, case .loadNamedVariable(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.storeNamedVariable, .storeNamedVariable): return {
-        guard case .storeNamedVariable(let l) = lhs, case .storeNamedVariable(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.defineNamedVariable, .defineNamedVariable): return {
-        guard case .defineNamedVariable(let l) = lhs, case .defineNamedVariable(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.eval, .eval): return {
-        guard case .eval(let l) = lhs, case .eval(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.beginWith, .beginWith): return {
-        guard case .beginWith(let l) = lhs, case .beginWith(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.endWith, .endWith): return {
-        guard case .endWith(let l) = lhs, case .endWith(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.callSuperConstructor, .callSuperConstructor): return {
-        guard case .callSuperConstructor(let l) = lhs, case .callSuperConstructor(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.callSuperMethod, .callSuperMethod): return {
-        guard case .callSuperMethod(let l) = lhs, case .callSuperMethod(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.getPrivateProperty, .getPrivateProperty): return {
-        guard case .getPrivateProperty(let l) = lhs, case .getPrivateProperty(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.setPrivateProperty, .setPrivateProperty): return {
-        guard case .setPrivateProperty(let l) = lhs, case .setPrivateProperty(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.updatePrivateProperty, .updatePrivateProperty): return {
-        guard case .updatePrivateProperty(let l) = lhs, case .updatePrivateProperty(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.callPrivateMethod, .callPrivateMethod): return {
-        guard case .callPrivateMethod(let l) = lhs, case .callPrivateMethod(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.getSuperProperty, .getSuperProperty): return {
-        guard case .getSuperProperty(let l) = lhs, case .getSuperProperty(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.setSuperProperty, .setSuperProperty): return {
-        guard case .setSuperProperty(let l) = lhs, case .setSuperProperty(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.getComputedSuperProperty, .getComputedSuperProperty): return {
-        guard case .getComputedSuperProperty(let l) = lhs, case .getComputedSuperProperty(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.setComputedSuperProperty, .setComputedSuperProperty): return {
-        guard case .setComputedSuperProperty(let l) = lhs, case .setComputedSuperProperty(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.updateSuperProperty, .updateSuperProperty): return {
-        guard case .updateSuperProperty(let l) = lhs, case .updateSuperProperty(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.beginIf, .beginIf): return {
-        guard case .beginIf(let l) = lhs, case .beginIf(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.beginElse, .beginElse): return {
-        guard case .beginElse(let l) = lhs, case .beginElse(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.endIf, .endIf): return {
-        guard case .endIf(let l) = lhs, case .endIf(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.beginWhileLoopHeader, .beginWhileLoopHeader): return {
-        guard case .beginWhileLoopHeader(let l) = lhs, case .beginWhileLoopHeader(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.beginWhileLoopBody, .beginWhileLoopBody): return {
-        guard case .beginWhileLoopBody(let l) = lhs, case .beginWhileLoopBody(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.endWhileLoop, .endWhileLoop): return {
-        guard case .endWhileLoop(let l) = lhs, case .endWhileLoop(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.beginDoWhileLoopBody, .beginDoWhileLoopBody): return {
-        guard case .beginDoWhileLoopBody(let l) = lhs, case .beginDoWhileLoopBody(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.beginDoWhileLoopHeader, .beginDoWhileLoopHeader): return {
-        guard case .beginDoWhileLoopHeader(let l) = lhs, case .beginDoWhileLoopHeader(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.endDoWhileLoop, .endDoWhileLoop): return {
-        guard case .endDoWhileLoop(let l) = lhs, case .endDoWhileLoop(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.beginForLoopInitializer, .beginForLoopInitializer): return {
-        guard case .beginForLoopInitializer(let l) = lhs, case .beginForLoopInitializer(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.beginForLoopCondition, .beginForLoopCondition): return {
-        guard case .beginForLoopCondition(let l) = lhs, case .beginForLoopCondition(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.beginForLoopAfterthought, .beginForLoopAfterthought): return {
-        guard case .beginForLoopAfterthought(let l) = lhs, case .beginForLoopAfterthought(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.beginForLoopBody, .beginForLoopBody): return {
-        guard case .beginForLoopBody(let l) = lhs, case .beginForLoopBody(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.endForLoop, .endForLoop): return {
-        guard case .endForLoop(let l) = lhs, case .endForLoop(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.beginForInLoop, .beginForInLoop): return {
-        guard case .beginForInLoop(let l) = lhs, case .beginForInLoop(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.endForInLoop, .endForInLoop): return {
-        guard case .endForInLoop(let l) = lhs, case .endForInLoop(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.beginForOfLoop, .beginForOfLoop): return {
-        guard case .beginForOfLoop(let l) = lhs, case .beginForOfLoop(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.beginForOfLoopWithDestruct, .beginForOfLoopWithDestruct): return {
-        guard case .beginForOfLoopWithDestruct(let l) = lhs, case .beginForOfLoopWithDestruct(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.endForOfLoop, .endForOfLoop): return {
-        guard case .endForOfLoop(let l) = lhs, case .endForOfLoop(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.beginRepeatLoop, .beginRepeatLoop): return {
-        guard case .beginRepeatLoop(let l) = lhs, case .beginRepeatLoop(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.endRepeatLoop, .endRepeatLoop): return {
-        guard case .endRepeatLoop(let l) = lhs, case .endRepeatLoop(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.loopBreak, .loopBreak): return {
-        guard case .loopBreak(let l) = lhs, case .loopBreak(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.loopContinue, .loopContinue): return {
-        guard case .loopContinue(let l) = lhs, case .loopContinue(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.beginTry, .beginTry): return {
-        guard case .beginTry(let l) = lhs, case .beginTry(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.beginCatch, .beginCatch): return {
-        guard case .beginCatch(let l) = lhs, case .beginCatch(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.beginFinally, .beginFinally): return {
-        guard case .beginFinally(let l) = lhs, case .beginFinally(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.endTryCatchFinally, .endTryCatchFinally): return {
-        guard case .endTryCatchFinally(let l) = lhs, case .endTryCatchFinally(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.throwException, .throwException): return {
-        guard case .throwException(let l) = lhs, case .throwException(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.beginCodeString, .beginCodeString): return {
-        guard case .beginCodeString(let l) = lhs, case .beginCodeString(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.endCodeString, .endCodeString): return {
-        guard case .endCodeString(let l) = lhs, case .endCodeString(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.beginBlockStatement, .beginBlockStatement): return {
-        guard case .beginBlockStatement(let l) = lhs, case .beginBlockStatement(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.endBlockStatement, .endBlockStatement): return {
-        guard case .endBlockStatement(let l) = lhs, case .endBlockStatement(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.beginSwitch, .beginSwitch): return {
-        guard case .beginSwitch(let l) = lhs, case .beginSwitch(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.beginSwitchCase, .beginSwitchCase): return {
-        guard case .beginSwitchCase(let l) = lhs, case .beginSwitchCase(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.beginSwitchDefaultCase, .beginSwitchDefaultCase): return {
-        guard case .beginSwitchDefaultCase(let l) = lhs, case .beginSwitchDefaultCase(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.endSwitchCase, .endSwitchCase): return {
-        guard case .endSwitchCase(let l) = lhs, case .endSwitchCase(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.endSwitch, .endSwitch): return {
-        guard case .endSwitch(let l) = lhs, case .endSwitch(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.switchBreak, .switchBreak): return {
-        guard case .switchBreak(let l) = lhs, case .switchBreak(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.loadNewTarget, .loadNewTarget): return {
-        guard case .loadNewTarget(let l) = lhs, case .loadNewTarget(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.print, .print): return {
-        guard case .print(let l) = lhs, case .print(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.explore, .explore): return {
-        guard case .explore(let l) = lhs, case .explore(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.probe, .probe): return {
-        guard case .probe(let l) = lhs, case .probe(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
-      case (.fixup, .fixup): return {
-        guard case .fixup(let l) = lhs, case .fixup(let r) = rhs else { preconditionFailure() }
-        return l == r
-      }()
+      case (.opIdx(let l), .opIdx(let r)): return l == r
+      case (.nop(let l), .nop(let r)): return l == r
+      case (.loadInteger(let l), .loadInteger(let r)): return l == r
+      case (.loadBigInt(let l), .loadBigInt(let r)): return l == r
+      case (.loadFloat(let l), .loadFloat(let r)): return l == r
+      case (.loadString(let l), .loadString(let r)): return l == r
+      case (.loadBoolean(let l), .loadBoolean(let r)): return l == r
+      case (.loadUndefined(let l), .loadUndefined(let r)): return l == r
+      case (.loadNull(let l), .loadNull(let r)): return l == r
+      case (.loadThis(let l), .loadThis(let r)): return l == r
+      case (.loadArguments(let l), .loadArguments(let r)): return l == r
+      case (.loadRegExp(let l), .loadRegExp(let r)): return l == r
+      case (.beginObjectLiteral(let l), .beginObjectLiteral(let r)): return l == r
+      case (.objectLiteralAddProperty(let l), .objectLiteralAddProperty(let r)): return l == r
+      case (.objectLiteralAddElement(let l), .objectLiteralAddElement(let r)): return l == r
+      case (.objectLiteralAddComputedProperty(let l), .objectLiteralAddComputedProperty(let r)): return l == r
+      case (.objectLiteralCopyProperties(let l), .objectLiteralCopyProperties(let r)): return l == r
+      case (.objectLiteralSetPrototype(let l), .objectLiteralSetPrototype(let r)): return l == r
+      case (.beginObjectLiteralMethod(let l), .beginObjectLiteralMethod(let r)): return l == r
+      case (.endObjectLiteralMethod(let l), .endObjectLiteralMethod(let r)): return l == r
+      case (.beginObjectLiteralComputedMethod(let l), .beginObjectLiteralComputedMethod(let r)): return l == r
+      case (.endObjectLiteralComputedMethod(let l), .endObjectLiteralComputedMethod(let r)): return l == r
+      case (.beginObjectLiteralGetter(let l), .beginObjectLiteralGetter(let r)): return l == r
+      case (.endObjectLiteralGetter(let l), .endObjectLiteralGetter(let r)): return l == r
+      case (.beginObjectLiteralSetter(let l), .beginObjectLiteralSetter(let r)): return l == r
+      case (.endObjectLiteralSetter(let l), .endObjectLiteralSetter(let r)): return l == r
+      case (.endObjectLiteral(let l), .endObjectLiteral(let r)): return l == r
+      case (.beginClassDefinition(let l), .beginClassDefinition(let r)): return l == r
+      case (.beginClassConstructor(let l), .beginClassConstructor(let r)): return l == r
+      case (.endClassConstructor(let l), .endClassConstructor(let r)): return l == r
+      case (.classAddInstanceProperty(let l), .classAddInstanceProperty(let r)): return l == r
+      case (.classAddInstanceElement(let l), .classAddInstanceElement(let r)): return l == r
+      case (.classAddInstanceComputedProperty(let l), .classAddInstanceComputedProperty(let r)): return l == r
+      case (.beginClassInstanceMethod(let l), .beginClassInstanceMethod(let r)): return l == r
+      case (.endClassInstanceMethod(let l), .endClassInstanceMethod(let r)): return l == r
+      case (.beginClassInstanceGetter(let l), .beginClassInstanceGetter(let r)): return l == r
+      case (.endClassInstanceGetter(let l), .endClassInstanceGetter(let r)): return l == r
+      case (.beginClassInstanceSetter(let l), .beginClassInstanceSetter(let r)): return l == r
+      case (.endClassInstanceSetter(let l), .endClassInstanceSetter(let r)): return l == r
+      case (.classAddStaticProperty(let l), .classAddStaticProperty(let r)): return l == r
+      case (.classAddStaticElement(let l), .classAddStaticElement(let r)): return l == r
+      case (.classAddStaticComputedProperty(let l), .classAddStaticComputedProperty(let r)): return l == r
+      case (.beginClassStaticInitializer(let l), .beginClassStaticInitializer(let r)): return l == r
+      case (.endClassStaticInitializer(let l), .endClassStaticInitializer(let r)): return l == r
+      case (.beginClassStaticMethod(let l), .beginClassStaticMethod(let r)): return l == r
+      case (.endClassStaticMethod(let l), .endClassStaticMethod(let r)): return l == r
+      case (.beginClassStaticGetter(let l), .beginClassStaticGetter(let r)): return l == r
+      case (.endClassStaticGetter(let l), .endClassStaticGetter(let r)): return l == r
+      case (.beginClassStaticSetter(let l), .beginClassStaticSetter(let r)): return l == r
+      case (.endClassStaticSetter(let l), .endClassStaticSetter(let r)): return l == r
+      case (.classAddPrivateInstanceProperty(let l), .classAddPrivateInstanceProperty(let r)): return l == r
+      case (.beginClassPrivateInstanceMethod(let l), .beginClassPrivateInstanceMethod(let r)): return l == r
+      case (.endClassPrivateInstanceMethod(let l), .endClassPrivateInstanceMethod(let r)): return l == r
+      case (.classAddPrivateStaticProperty(let l), .classAddPrivateStaticProperty(let r)): return l == r
+      case (.beginClassPrivateStaticMethod(let l), .beginClassPrivateStaticMethod(let r)): return l == r
+      case (.endClassPrivateStaticMethod(let l), .endClassPrivateStaticMethod(let r)): return l == r
+      case (.endClassDefinition(let l), .endClassDefinition(let r)): return l == r
+      case (.createArray(let l), .createArray(let r)): return l == r
+      case (.createIntArray(let l), .createIntArray(let r)): return l == r
+      case (.createFloatArray(let l), .createFloatArray(let r)): return l == r
+      case (.createArrayWithSpread(let l), .createArrayWithSpread(let r)): return l == r
+      case (.createTemplateString(let l), .createTemplateString(let r)): return l == r
+      case (.loadBuiltin(let l), .loadBuiltin(let r)): return l == r
+      case (.getProperty(let l), .getProperty(let r)): return l == r
+      case (.setProperty(let l), .setProperty(let r)): return l == r
+      case (.updateProperty(let l), .updateProperty(let r)): return l == r
+      case (.deleteProperty(let l), .deleteProperty(let r)): return l == r
+      case (.configureProperty(let l), .configureProperty(let r)): return l == r
+      case (.getElement(let l), .getElement(let r)): return l == r
+      case (.setElement(let l), .setElement(let r)): return l == r
+      case (.updateElement(let l), .updateElement(let r)): return l == r
+      case (.deleteElement(let l), .deleteElement(let r)): return l == r
+      case (.configureElement(let l), .configureElement(let r)): return l == r
+      case (.getComputedProperty(let l), .getComputedProperty(let r)): return l == r
+      case (.setComputedProperty(let l), .setComputedProperty(let r)): return l == r
+      case (.updateComputedProperty(let l), .updateComputedProperty(let r)): return l == r
+      case (.deleteComputedProperty(let l), .deleteComputedProperty(let r)): return l == r
+      case (.configureComputedProperty(let l), .configureComputedProperty(let r)): return l == r
+      case (.typeOf(let l), .typeOf(let r)): return l == r
+      case (.testInstanceOf(let l), .testInstanceOf(let r)): return l == r
+      case (.testIn(let l), .testIn(let r)): return l == r
+      case (.beginPlainFunction(let l), .beginPlainFunction(let r)): return l == r
+      case (.endPlainFunction(let l), .endPlainFunction(let r)): return l == r
+      case (.beginArrowFunction(let l), .beginArrowFunction(let r)): return l == r
+      case (.endArrowFunction(let l), .endArrowFunction(let r)): return l == r
+      case (.beginGeneratorFunction(let l), .beginGeneratorFunction(let r)): return l == r
+      case (.endGeneratorFunction(let l), .endGeneratorFunction(let r)): return l == r
+      case (.beginAsyncFunction(let l), .beginAsyncFunction(let r)): return l == r
+      case (.endAsyncFunction(let l), .endAsyncFunction(let r)): return l == r
+      case (.beginAsyncArrowFunction(let l), .beginAsyncArrowFunction(let r)): return l == r
+      case (.endAsyncArrowFunction(let l), .endAsyncArrowFunction(let r)): return l == r
+      case (.beginAsyncGeneratorFunction(let l), .beginAsyncGeneratorFunction(let r)): return l == r
+      case (.endAsyncGeneratorFunction(let l), .endAsyncGeneratorFunction(let r)): return l == r
+      case (.beginConstructor(let l), .beginConstructor(let r)): return l == r
+      case (.endConstructor(let l), .endConstructor(let r)): return l == r
+      case (.return(let l), .return(let r)): return l == r
+      case (.yield(let l), .yield(let r)): return l == r
+      case (.yieldEach(let l), .yieldEach(let r)): return l == r
+      case (.await(let l), .await(let r)): return l == r
+      case (.callFunction(let l), .callFunction(let r)): return l == r
+      case (.callFunctionWithSpread(let l), .callFunctionWithSpread(let r)): return l == r
+      case (.construct(let l), .construct(let r)): return l == r
+      case (.constructWithSpread(let l), .constructWithSpread(let r)): return l == r
+      case (.callMethod(let l), .callMethod(let r)): return l == r
+      case (.callMethodWithSpread(let l), .callMethodWithSpread(let r)): return l == r
+      case (.callComputedMethod(let l), .callComputedMethod(let r)): return l == r
+      case (.callComputedMethodWithSpread(let l), .callComputedMethodWithSpread(let r)): return l == r
+      case (.unaryOperation(let l), .unaryOperation(let r)): return l == r
+      case (.binaryOperation(let l), .binaryOperation(let r)): return l == r
+      case (.ternaryOperation(let l), .ternaryOperation(let r)): return l == r
+      case (.update(let l), .update(let r)): return l == r
+      case (.dup(let l), .dup(let r)): return l == r
+      case (.reassign(let l), .reassign(let r)): return l == r
+      case (.destructArray(let l), .destructArray(let r)): return l == r
+      case (.destructArrayAndReassign(let l), .destructArrayAndReassign(let r)): return l == r
+      case (.destructObject(let l), .destructObject(let r)): return l == r
+      case (.destructObjectAndReassign(let l), .destructObjectAndReassign(let r)): return l == r
+      case (.compare(let l), .compare(let r)): return l == r
+      case (.loadNamedVariable(let l), .loadNamedVariable(let r)): return l == r
+      case (.storeNamedVariable(let l), .storeNamedVariable(let r)): return l == r
+      case (.defineNamedVariable(let l), .defineNamedVariable(let r)): return l == r
+      case (.eval(let l), .eval(let r)): return l == r
+      case (.beginWith(let l), .beginWith(let r)): return l == r
+      case (.endWith(let l), .endWith(let r)): return l == r
+      case (.callSuperConstructor(let l), .callSuperConstructor(let r)): return l == r
+      case (.callSuperMethod(let l), .callSuperMethod(let r)): return l == r
+      case (.getPrivateProperty(let l), .getPrivateProperty(let r)): return l == r
+      case (.setPrivateProperty(let l), .setPrivateProperty(let r)): return l == r
+      case (.updatePrivateProperty(let l), .updatePrivateProperty(let r)): return l == r
+      case (.callPrivateMethod(let l), .callPrivateMethod(let r)): return l == r
+      case (.getSuperProperty(let l), .getSuperProperty(let r)): return l == r
+      case (.setSuperProperty(let l), .setSuperProperty(let r)): return l == r
+      case (.getComputedSuperProperty(let l), .getComputedSuperProperty(let r)): return l == r
+      case (.setComputedSuperProperty(let l), .setComputedSuperProperty(let r)): return l == r
+      case (.updateSuperProperty(let l), .updateSuperProperty(let r)): return l == r
+      case (.beginIf(let l), .beginIf(let r)): return l == r
+      case (.beginElse(let l), .beginElse(let r)): return l == r
+      case (.endIf(let l), .endIf(let r)): return l == r
+      case (.beginWhileLoopHeader(let l), .beginWhileLoopHeader(let r)): return l == r
+      case (.beginWhileLoopBody(let l), .beginWhileLoopBody(let r)): return l == r
+      case (.endWhileLoop(let l), .endWhileLoop(let r)): return l == r
+      case (.beginDoWhileLoopBody(let l), .beginDoWhileLoopBody(let r)): return l == r
+      case (.beginDoWhileLoopHeader(let l), .beginDoWhileLoopHeader(let r)): return l == r
+      case (.endDoWhileLoop(let l), .endDoWhileLoop(let r)): return l == r
+      case (.beginForLoopInitializer(let l), .beginForLoopInitializer(let r)): return l == r
+      case (.beginForLoopCondition(let l), .beginForLoopCondition(let r)): return l == r
+      case (.beginForLoopAfterthought(let l), .beginForLoopAfterthought(let r)): return l == r
+      case (.beginForLoopBody(let l), .beginForLoopBody(let r)): return l == r
+      case (.endForLoop(let l), .endForLoop(let r)): return l == r
+      case (.beginForInLoop(let l), .beginForInLoop(let r)): return l == r
+      case (.endForInLoop(let l), .endForInLoop(let r)): return l == r
+      case (.beginForOfLoop(let l), .beginForOfLoop(let r)): return l == r
+      case (.beginForOfLoopWithDestruct(let l), .beginForOfLoopWithDestruct(let r)): return l == r
+      case (.endForOfLoop(let l), .endForOfLoop(let r)): return l == r
+      case (.beginRepeatLoop(let l), .beginRepeatLoop(let r)): return l == r
+      case (.endRepeatLoop(let l), .endRepeatLoop(let r)): return l == r
+      case (.loopBreak(let l), .loopBreak(let r)): return l == r
+      case (.loopContinue(let l), .loopContinue(let r)): return l == r
+      case (.beginTry(let l), .beginTry(let r)): return l == r
+      case (.beginCatch(let l), .beginCatch(let r)): return l == r
+      case (.beginFinally(let l), .beginFinally(let r)): return l == r
+      case (.endTryCatchFinally(let l), .endTryCatchFinally(let r)): return l == r
+      case (.throwException(let l), .throwException(let r)): return l == r
+      case (.beginCodeString(let l), .beginCodeString(let r)): return l == r
+      case (.endCodeString(let l), .endCodeString(let r)): return l == r
+      case (.beginBlockStatement(let l), .beginBlockStatement(let r)): return l == r
+      case (.endBlockStatement(let l), .endBlockStatement(let r)): return l == r
+      case (.beginSwitch(let l), .beginSwitch(let r)): return l == r
+      case (.beginSwitchCase(let l), .beginSwitchCase(let r)): return l == r
+      case (.beginSwitchDefaultCase(let l), .beginSwitchDefaultCase(let r)): return l == r
+      case (.endSwitchCase(let l), .endSwitchCase(let r)): return l == r
+      case (.endSwitch(let l), .endSwitch(let r)): return l == r
+      case (.switchBreak(let l), .switchBreak(let r)): return l == r
+      case (.loadNewTarget(let l), .loadNewTarget(let r)): return l == r
+      case (.print(let l), .print(let r)): return l == r
+      case (.explore(let l), .explore(let r)): return l == r
+      case (.probe(let l), .probe(let r)): return l == r
+      case (.fixup(let l), .fixup(let r)): return l == r
       default: return false
       }
     }
@@ -2379,6 +1848,8 @@ public struct Fuzzilli_Protobuf_Instruction {
   }
 
   public init() {}
+
+  fileprivate var _storage = _StorageClass.defaultInstance
 }
 
 public struct Fuzzilli_Protobuf_Program {
@@ -2417,12 +1888,6 @@ public struct Fuzzilli_Protobuf_Program {
   fileprivate var _storage = _StorageClass.defaultInstance
 }
 
-#if swift(>=5.5) && canImport(_Concurrency)
-extension Fuzzilli_Protobuf_Instruction: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_Instruction.OneOf_Operation: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_Program: @unchecked Sendable {}
-#endif  // swift(>=5.5) && canImport(_Concurrency)
-
 // MARK: - Code below here is support for the SwiftProtobuf runtime.
 
 fileprivate let _protobuf_package = "fuzzilli.protobuf"
@@ -2611,3056 +2076,1839 @@ extension Fuzzilli_Protobuf_Instruction: SwiftProtobuf.Message, SwiftProtobuf._M
     179: .same(proto: "fixup"),
   ]
 
+  fileprivate class _StorageClass {
+    var _inouts: [UInt32] = []
+    var _operation: Fuzzilli_Protobuf_Instruction.OneOf_Operation?
+
+    static let defaultInstance = _StorageClass()
+
+    private init() {}
+
+    init(copying source: _StorageClass) {
+      _inouts = source._inouts
+      _operation = source._operation
+    }
+  }
+
+  fileprivate mutating func _uniqueStorage() -> _StorageClass {
+    if !isKnownUniquelyReferenced(&_storage) {
+      _storage = _StorageClass(copying: _storage)
+    }
+    return _storage
+  }
+
   public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
-    while let fieldNumber = try decoder.nextFieldNumber() {
-      // The use of inline closures is to circumvent an issue where the compiler
-      // allocates stack space for every case branch when no optimizations are
-      // enabled. https://github.com/apple/swift-protobuf/issues/1034
-      switch fieldNumber {
-      case 1: try { try decoder.decodeRepeatedUInt32Field(value: &self.inouts) }()
-      case 2: try {
-        var v: UInt32?
-        try decoder.decodeSingularUInt32Field(value: &v)
-        if let v = v {
-          if self.operation != nil {try decoder.handleConflictingOneOf()}
-          self.operation = .opIdx(v)
-        }
-      }()
-      case 3: try {
-        var v: Fuzzilli_Protobuf_Nop?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .nop(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .nop(v)
-        }
-      }()
-      case 4: try {
-        var v: Fuzzilli_Protobuf_LoadInteger?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .loadInteger(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .loadInteger(v)
-        }
-      }()
-      case 5: try {
-        var v: Fuzzilli_Protobuf_LoadBigInt?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .loadBigInt(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .loadBigInt(v)
-        }
-      }()
-      case 6: try {
-        var v: Fuzzilli_Protobuf_LoadFloat?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .loadFloat(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .loadFloat(v)
-        }
-      }()
-      case 7: try {
-        var v: Fuzzilli_Protobuf_LoadString?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .loadString(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .loadString(v)
-        }
-      }()
-      case 8: try {
-        var v: Fuzzilli_Protobuf_LoadBoolean?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .loadBoolean(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .loadBoolean(v)
-        }
-      }()
-      case 9: try {
-        var v: Fuzzilli_Protobuf_LoadUndefined?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .loadUndefined(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .loadUndefined(v)
-        }
-      }()
-      case 10: try {
-        var v: Fuzzilli_Protobuf_LoadNull?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .loadNull(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .loadNull(v)
-        }
-      }()
-      case 11: try {
-        var v: Fuzzilli_Protobuf_LoadThis?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .loadThis(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .loadThis(v)
-        }
-      }()
-      case 12: try {
-        var v: Fuzzilli_Protobuf_LoadArguments?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .loadArguments(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .loadArguments(v)
-        }
-      }()
-      case 13: try {
-        var v: Fuzzilli_Protobuf_LoadRegExp?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .loadRegExp(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .loadRegExp(v)
-        }
-      }()
-      case 14: try {
-        var v: Fuzzilli_Protobuf_BeginObjectLiteral?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .beginObjectLiteral(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .beginObjectLiteral(v)
-        }
-      }()
-      case 15: try {
-        var v: Fuzzilli_Protobuf_ObjectLiteralAddProperty?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .objectLiteralAddProperty(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .objectLiteralAddProperty(v)
-        }
-      }()
-      case 16: try {
-        var v: Fuzzilli_Protobuf_ObjectLiteralAddElement?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .objectLiteralAddElement(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .objectLiteralAddElement(v)
-        }
-      }()
-      case 17: try {
-        var v: Fuzzilli_Protobuf_ObjectLiteralAddComputedProperty?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .objectLiteralAddComputedProperty(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .objectLiteralAddComputedProperty(v)
-        }
-      }()
-      case 18: try {
-        var v: Fuzzilli_Protobuf_ObjectLiteralCopyProperties?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .objectLiteralCopyProperties(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .objectLiteralCopyProperties(v)
-        }
-      }()
-      case 19: try {
-        var v: Fuzzilli_Protobuf_ObjectLiteralSetPrototype?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .objectLiteralSetPrototype(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .objectLiteralSetPrototype(v)
-        }
-      }()
-      case 20: try {
-        var v: Fuzzilli_Protobuf_BeginObjectLiteralMethod?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .beginObjectLiteralMethod(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .beginObjectLiteralMethod(v)
-        }
-      }()
-      case 21: try {
-        var v: Fuzzilli_Protobuf_EndObjectLiteralMethod?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .endObjectLiteralMethod(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .endObjectLiteralMethod(v)
-        }
-      }()
-      case 22: try {
-        var v: Fuzzilli_Protobuf_BeginObjectLiteralComputedMethod?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .beginObjectLiteralComputedMethod(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .beginObjectLiteralComputedMethod(v)
-        }
-      }()
-      case 23: try {
-        var v: Fuzzilli_Protobuf_EndObjectLiteralComputedMethod?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .endObjectLiteralComputedMethod(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .endObjectLiteralComputedMethod(v)
-        }
-      }()
-      case 24: try {
-        var v: Fuzzilli_Protobuf_BeginObjectLiteralGetter?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .beginObjectLiteralGetter(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .beginObjectLiteralGetter(v)
-        }
-      }()
-      case 25: try {
-        var v: Fuzzilli_Protobuf_EndObjectLiteralGetter?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .endObjectLiteralGetter(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .endObjectLiteralGetter(v)
-        }
-      }()
-      case 26: try {
-        var v: Fuzzilli_Protobuf_BeginObjectLiteralSetter?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .beginObjectLiteralSetter(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .beginObjectLiteralSetter(v)
-        }
-      }()
-      case 27: try {
-        var v: Fuzzilli_Protobuf_EndObjectLiteralSetter?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .endObjectLiteralSetter(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .endObjectLiteralSetter(v)
-        }
-      }()
-      case 28: try {
-        var v: Fuzzilli_Protobuf_EndObjectLiteral?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .endObjectLiteral(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .endObjectLiteral(v)
-        }
-      }()
-      case 29: try {
-        var v: Fuzzilli_Protobuf_BeginClassDefinition?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .beginClassDefinition(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .beginClassDefinition(v)
-        }
-      }()
-      case 30: try {
-        var v: Fuzzilli_Protobuf_BeginClassConstructor?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .beginClassConstructor(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .beginClassConstructor(v)
-        }
-      }()
-      case 31: try {
-        var v: Fuzzilli_Protobuf_EndClassConstructor?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .endClassConstructor(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .endClassConstructor(v)
-        }
-      }()
-      case 32: try {
-        var v: Fuzzilli_Protobuf_ClassAddInstanceProperty?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .classAddInstanceProperty(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .classAddInstanceProperty(v)
-        }
-      }()
-      case 33: try {
-        var v: Fuzzilli_Protobuf_ClassAddInstanceElement?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .classAddInstanceElement(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .classAddInstanceElement(v)
-        }
-      }()
-      case 34: try {
-        var v: Fuzzilli_Protobuf_ClassAddInstanceComputedProperty?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .classAddInstanceComputedProperty(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .classAddInstanceComputedProperty(v)
-        }
-      }()
-      case 35: try {
-        var v: Fuzzilli_Protobuf_BeginClassInstanceMethod?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .beginClassInstanceMethod(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .beginClassInstanceMethod(v)
-        }
-      }()
-      case 36: try {
-        var v: Fuzzilli_Protobuf_EndClassInstanceMethod?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .endClassInstanceMethod(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .endClassInstanceMethod(v)
-        }
-      }()
-      case 37: try {
-        var v: Fuzzilli_Protobuf_BeginClassInstanceGetter?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .beginClassInstanceGetter(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .beginClassInstanceGetter(v)
-        }
-      }()
-      case 38: try {
-        var v: Fuzzilli_Protobuf_EndClassInstanceGetter?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .endClassInstanceGetter(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .endClassInstanceGetter(v)
-        }
-      }()
-      case 39: try {
-        var v: Fuzzilli_Protobuf_BeginClassInstanceSetter?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .beginClassInstanceSetter(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .beginClassInstanceSetter(v)
-        }
-      }()
-      case 40: try {
-        var v: Fuzzilli_Protobuf_EndClassInstanceSetter?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .endClassInstanceSetter(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .endClassInstanceSetter(v)
-        }
-      }()
-      case 41: try {
-        var v: Fuzzilli_Protobuf_ClassAddStaticProperty?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .classAddStaticProperty(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .classAddStaticProperty(v)
-        }
-      }()
-      case 42: try {
-        var v: Fuzzilli_Protobuf_ClassAddStaticElement?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .classAddStaticElement(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .classAddStaticElement(v)
-        }
-      }()
-      case 43: try {
-        var v: Fuzzilli_Protobuf_ClassAddStaticComputedProperty?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .classAddStaticComputedProperty(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .classAddStaticComputedProperty(v)
-        }
-      }()
-      case 44: try {
-        var v: Fuzzilli_Protobuf_BeginClassStaticInitializer?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .beginClassStaticInitializer(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .beginClassStaticInitializer(v)
-        }
-      }()
-      case 45: try {
-        var v: Fuzzilli_Protobuf_EndClassStaticInitializer?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .endClassStaticInitializer(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .endClassStaticInitializer(v)
-        }
-      }()
-      case 46: try {
-        var v: Fuzzilli_Protobuf_BeginClassStaticMethod?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .beginClassStaticMethod(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .beginClassStaticMethod(v)
-        }
-      }()
-      case 47: try {
-        var v: Fuzzilli_Protobuf_EndClassStaticMethod?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .endClassStaticMethod(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .endClassStaticMethod(v)
-        }
-      }()
-      case 48: try {
-        var v: Fuzzilli_Protobuf_BeginClassStaticGetter?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .beginClassStaticGetter(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .beginClassStaticGetter(v)
-        }
-      }()
-      case 49: try {
-        var v: Fuzzilli_Protobuf_EndClassStaticGetter?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .endClassStaticGetter(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .endClassStaticGetter(v)
-        }
-      }()
-      case 50: try {
-        var v: Fuzzilli_Protobuf_BeginClassStaticSetter?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .beginClassStaticSetter(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .beginClassStaticSetter(v)
-        }
-      }()
-      case 51: try {
-        var v: Fuzzilli_Protobuf_EndClassStaticSetter?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .endClassStaticSetter(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .endClassStaticSetter(v)
-        }
-      }()
-      case 52: try {
-        var v: Fuzzilli_Protobuf_ClassAddPrivateInstanceProperty?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .classAddPrivateInstanceProperty(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .classAddPrivateInstanceProperty(v)
-        }
-      }()
-      case 53: try {
-        var v: Fuzzilli_Protobuf_BeginClassPrivateInstanceMethod?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .beginClassPrivateInstanceMethod(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .beginClassPrivateInstanceMethod(v)
-        }
-      }()
-      case 54: try {
-        var v: Fuzzilli_Protobuf_EndClassPrivateInstanceMethod?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .endClassPrivateInstanceMethod(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .endClassPrivateInstanceMethod(v)
-        }
-      }()
-      case 55: try {
-        var v: Fuzzilli_Protobuf_ClassAddPrivateStaticProperty?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .classAddPrivateStaticProperty(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .classAddPrivateStaticProperty(v)
-        }
-      }()
-      case 56: try {
-        var v: Fuzzilli_Protobuf_BeginClassPrivateStaticMethod?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .beginClassPrivateStaticMethod(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .beginClassPrivateStaticMethod(v)
-        }
-      }()
-      case 57: try {
-        var v: Fuzzilli_Protobuf_EndClassPrivateStaticMethod?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .endClassPrivateStaticMethod(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .endClassPrivateStaticMethod(v)
-        }
-      }()
-      case 58: try {
-        var v: Fuzzilli_Protobuf_EndClassDefinition?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .endClassDefinition(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .endClassDefinition(v)
-        }
-      }()
-      case 59: try {
-        var v: Fuzzilli_Protobuf_CreateArray?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .createArray(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .createArray(v)
-        }
-      }()
-      case 60: try {
-        var v: Fuzzilli_Protobuf_CreateIntArray?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .createIntArray(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .createIntArray(v)
-        }
-      }()
-      case 61: try {
-        var v: Fuzzilli_Protobuf_CreateFloatArray?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .createFloatArray(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .createFloatArray(v)
-        }
-      }()
-      case 62: try {
-        var v: Fuzzilli_Protobuf_CreateArrayWithSpread?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .createArrayWithSpread(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .createArrayWithSpread(v)
-        }
-      }()
-      case 63: try {
-        var v: Fuzzilli_Protobuf_CreateTemplateString?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .createTemplateString(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .createTemplateString(v)
-        }
-      }()
-      case 64: try {
-        var v: Fuzzilli_Protobuf_LoadBuiltin?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .loadBuiltin(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .loadBuiltin(v)
-        }
-      }()
-      case 65: try {
-        var v: Fuzzilli_Protobuf_GetProperty?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .getProperty(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .getProperty(v)
-        }
-      }()
-      case 66: try {
-        var v: Fuzzilli_Protobuf_SetProperty?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .setProperty(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .setProperty(v)
-        }
-      }()
-      case 67: try {
-        var v: Fuzzilli_Protobuf_UpdateProperty?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .updateProperty(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .updateProperty(v)
-        }
-      }()
-      case 68: try {
-        var v: Fuzzilli_Protobuf_DeleteProperty?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .deleteProperty(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .deleteProperty(v)
-        }
-      }()
-      case 69: try {
-        var v: Fuzzilli_Protobuf_ConfigureProperty?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .configureProperty(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .configureProperty(v)
-        }
-      }()
-      case 70: try {
-        var v: Fuzzilli_Protobuf_GetElement?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .getElement(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .getElement(v)
-        }
-      }()
-      case 71: try {
-        var v: Fuzzilli_Protobuf_SetElement?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .setElement(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .setElement(v)
-        }
-      }()
-      case 72: try {
-        var v: Fuzzilli_Protobuf_UpdateElement?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .updateElement(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .updateElement(v)
-        }
-      }()
-      case 73: try {
-        var v: Fuzzilli_Protobuf_DeleteElement?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .deleteElement(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .deleteElement(v)
-        }
-      }()
-      case 74: try {
-        var v: Fuzzilli_Protobuf_ConfigureElement?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .configureElement(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .configureElement(v)
-        }
-      }()
-      case 75: try {
-        var v: Fuzzilli_Protobuf_GetComputedProperty?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .getComputedProperty(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .getComputedProperty(v)
-        }
-      }()
-      case 76: try {
-        var v: Fuzzilli_Protobuf_SetComputedProperty?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .setComputedProperty(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .setComputedProperty(v)
-        }
-      }()
-      case 77: try {
-        var v: Fuzzilli_Protobuf_UpdateComputedProperty?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .updateComputedProperty(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .updateComputedProperty(v)
-        }
-      }()
-      case 78: try {
-        var v: Fuzzilli_Protobuf_DeleteComputedProperty?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .deleteComputedProperty(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .deleteComputedProperty(v)
-        }
-      }()
-      case 79: try {
-        var v: Fuzzilli_Protobuf_ConfigureComputedProperty?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .configureComputedProperty(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .configureComputedProperty(v)
-        }
-      }()
-      case 80: try {
-        var v: Fuzzilli_Protobuf_TypeOf?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .typeOf(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .typeOf(v)
-        }
-      }()
-      case 81: try {
-        var v: Fuzzilli_Protobuf_TestInstanceOf?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .testInstanceOf(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .testInstanceOf(v)
-        }
-      }()
-      case 82: try {
-        var v: Fuzzilli_Protobuf_TestIn?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .testIn(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .testIn(v)
-        }
-      }()
-      case 83: try {
-        var v: Fuzzilli_Protobuf_BeginPlainFunction?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .beginPlainFunction(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .beginPlainFunction(v)
-        }
-      }()
-      case 84: try {
-        var v: Fuzzilli_Protobuf_EndPlainFunction?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .endPlainFunction(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .endPlainFunction(v)
-        }
-      }()
-      case 85: try {
-        var v: Fuzzilli_Protobuf_BeginArrowFunction?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .beginArrowFunction(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .beginArrowFunction(v)
-        }
-      }()
-      case 86: try {
-        var v: Fuzzilli_Protobuf_EndArrowFunction?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .endArrowFunction(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .endArrowFunction(v)
-        }
-      }()
-      case 87: try {
-        var v: Fuzzilli_Protobuf_BeginGeneratorFunction?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .beginGeneratorFunction(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .beginGeneratorFunction(v)
-        }
-      }()
-      case 88: try {
-        var v: Fuzzilli_Protobuf_EndGeneratorFunction?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .endGeneratorFunction(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .endGeneratorFunction(v)
-        }
-      }()
-      case 89: try {
-        var v: Fuzzilli_Protobuf_BeginAsyncFunction?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .beginAsyncFunction(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .beginAsyncFunction(v)
-        }
-      }()
-      case 90: try {
-        var v: Fuzzilli_Protobuf_EndAsyncFunction?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .endAsyncFunction(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .endAsyncFunction(v)
-        }
-      }()
-      case 91: try {
-        var v: Fuzzilli_Protobuf_BeginAsyncArrowFunction?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .beginAsyncArrowFunction(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .beginAsyncArrowFunction(v)
-        }
-      }()
-      case 92: try {
-        var v: Fuzzilli_Protobuf_EndAsyncArrowFunction?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .endAsyncArrowFunction(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .endAsyncArrowFunction(v)
-        }
-      }()
-      case 93: try {
-        var v: Fuzzilli_Protobuf_BeginAsyncGeneratorFunction?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .beginAsyncGeneratorFunction(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .beginAsyncGeneratorFunction(v)
-        }
-      }()
-      case 94: try {
-        var v: Fuzzilli_Protobuf_EndAsyncGeneratorFunction?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .endAsyncGeneratorFunction(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .endAsyncGeneratorFunction(v)
-        }
-      }()
-      case 95: try {
-        var v: Fuzzilli_Protobuf_BeginConstructor?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .beginConstructor(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .beginConstructor(v)
-        }
-      }()
-      case 96: try {
-        var v: Fuzzilli_Protobuf_EndConstructor?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .endConstructor(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .endConstructor(v)
-        }
-      }()
-      case 97: try {
-        var v: Fuzzilli_Protobuf_Return?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .return(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .return(v)
-        }
-      }()
-      case 98: try {
-        var v: Fuzzilli_Protobuf_Yield?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .yield(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .yield(v)
-        }
-      }()
-      case 99: try {
-        var v: Fuzzilli_Protobuf_YieldEach?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .yieldEach(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .yieldEach(v)
-        }
-      }()
-      case 100: try {
-        var v: Fuzzilli_Protobuf_Await?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .await(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .await(v)
-        }
-      }()
-      case 101: try {
-        var v: Fuzzilli_Protobuf_CallFunction?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .callFunction(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .callFunction(v)
-        }
-      }()
-      case 102: try {
-        var v: Fuzzilli_Protobuf_CallFunctionWithSpread?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .callFunctionWithSpread(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .callFunctionWithSpread(v)
-        }
-      }()
-      case 103: try {
-        var v: Fuzzilli_Protobuf_Construct?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .construct(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .construct(v)
-        }
-      }()
-      case 104: try {
-        var v: Fuzzilli_Protobuf_ConstructWithSpread?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .constructWithSpread(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .constructWithSpread(v)
-        }
-      }()
-      case 105: try {
-        var v: Fuzzilli_Protobuf_CallMethod?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .callMethod(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .callMethod(v)
-        }
-      }()
-      case 106: try {
-        var v: Fuzzilli_Protobuf_CallMethodWithSpread?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .callMethodWithSpread(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .callMethodWithSpread(v)
-        }
-      }()
-      case 107: try {
-        var v: Fuzzilli_Protobuf_CallComputedMethod?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .callComputedMethod(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .callComputedMethod(v)
-        }
-      }()
-      case 108: try {
-        var v: Fuzzilli_Protobuf_CallComputedMethodWithSpread?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .callComputedMethodWithSpread(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .callComputedMethodWithSpread(v)
-        }
-      }()
-      case 109: try {
-        var v: Fuzzilli_Protobuf_UnaryOperation?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .unaryOperation(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .unaryOperation(v)
-        }
-      }()
-      case 110: try {
-        var v: Fuzzilli_Protobuf_BinaryOperation?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .binaryOperation(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .binaryOperation(v)
-        }
-      }()
-      case 111: try {
-        var v: Fuzzilli_Protobuf_TernaryOperation?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .ternaryOperation(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .ternaryOperation(v)
-        }
-      }()
-      case 112: try {
-        var v: Fuzzilli_Protobuf_Update?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .update(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .update(v)
-        }
-      }()
-      case 113: try {
-        var v: Fuzzilli_Protobuf_Dup?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .dup(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .dup(v)
-        }
-      }()
-      case 114: try {
-        var v: Fuzzilli_Protobuf_Reassign?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .reassign(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .reassign(v)
-        }
-      }()
-      case 115: try {
-        var v: Fuzzilli_Protobuf_DestructArray?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .destructArray(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .destructArray(v)
-        }
-      }()
-      case 116: try {
-        var v: Fuzzilli_Protobuf_DestructArrayAndReassign?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .destructArrayAndReassign(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .destructArrayAndReassign(v)
-        }
-      }()
-      case 117: try {
-        var v: Fuzzilli_Protobuf_DestructObject?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .destructObject(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .destructObject(v)
-        }
-      }()
-      case 118: try {
-        var v: Fuzzilli_Protobuf_DestructObjectAndReassign?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .destructObjectAndReassign(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .destructObjectAndReassign(v)
-        }
-      }()
-      case 119: try {
-        var v: Fuzzilli_Protobuf_Compare?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .compare(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .compare(v)
-        }
-      }()
-      case 120: try {
-        var v: Fuzzilli_Protobuf_LoadNamedVariable?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .loadNamedVariable(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .loadNamedVariable(v)
-        }
-      }()
-      case 121: try {
-        var v: Fuzzilli_Protobuf_StoreNamedVariable?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .storeNamedVariable(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .storeNamedVariable(v)
-        }
-      }()
-      case 122: try {
-        var v: Fuzzilli_Protobuf_DefineNamedVariable?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .defineNamedVariable(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .defineNamedVariable(v)
-        }
-      }()
-      case 123: try {
-        var v: Fuzzilli_Protobuf_Eval?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .eval(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .eval(v)
-        }
-      }()
-      case 124: try {
-        var v: Fuzzilli_Protobuf_BeginWith?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .beginWith(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .beginWith(v)
-        }
-      }()
-      case 125: try {
-        var v: Fuzzilli_Protobuf_EndWith?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .endWith(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .endWith(v)
-        }
-      }()
-      case 126: try {
-        var v: Fuzzilli_Protobuf_CallSuperConstructor?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .callSuperConstructor(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .callSuperConstructor(v)
-        }
-      }()
-      case 127: try {
-        var v: Fuzzilli_Protobuf_CallSuperMethod?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .callSuperMethod(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .callSuperMethod(v)
-        }
-      }()
-      case 128: try {
-        var v: Fuzzilli_Protobuf_GetPrivateProperty?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .getPrivateProperty(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .getPrivateProperty(v)
-        }
-      }()
-      case 129: try {
-        var v: Fuzzilli_Protobuf_SetPrivateProperty?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .setPrivateProperty(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .setPrivateProperty(v)
-        }
-      }()
-      case 130: try {
-        var v: Fuzzilli_Protobuf_UpdatePrivateProperty?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .updatePrivateProperty(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .updatePrivateProperty(v)
-        }
-      }()
-      case 131: try {
-        var v: Fuzzilli_Protobuf_CallPrivateMethod?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .callPrivateMethod(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .callPrivateMethod(v)
-        }
-      }()
-      case 132: try {
-        var v: Fuzzilli_Protobuf_GetSuperProperty?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .getSuperProperty(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .getSuperProperty(v)
-        }
-      }()
-      case 133: try {
-        var v: Fuzzilli_Protobuf_SetSuperProperty?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .setSuperProperty(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .setSuperProperty(v)
-        }
-      }()
-      case 134: try {
-        var v: Fuzzilli_Protobuf_GetComputedSuperProperty?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .getComputedSuperProperty(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .getComputedSuperProperty(v)
-        }
-      }()
-      case 135: try {
-        var v: Fuzzilli_Protobuf_SetComputedSuperProperty?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .setComputedSuperProperty(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .setComputedSuperProperty(v)
-        }
-      }()
-      case 136: try {
-        var v: Fuzzilli_Protobuf_UpdateSuperProperty?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .updateSuperProperty(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .updateSuperProperty(v)
-        }
-      }()
-      case 137: try {
-        var v: Fuzzilli_Protobuf_BeginIf?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .beginIf(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .beginIf(v)
-        }
-      }()
-      case 138: try {
-        var v: Fuzzilli_Protobuf_BeginElse?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .beginElse(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .beginElse(v)
-        }
-      }()
-      case 139: try {
-        var v: Fuzzilli_Protobuf_EndIf?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .endIf(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .endIf(v)
-        }
-      }()
-      case 140: try {
-        var v: Fuzzilli_Protobuf_BeginWhileLoopHeader?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .beginWhileLoopHeader(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .beginWhileLoopHeader(v)
-        }
-      }()
-      case 141: try {
-        var v: Fuzzilli_Protobuf_BeginWhileLoopBody?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .beginWhileLoopBody(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .beginWhileLoopBody(v)
-        }
-      }()
-      case 142: try {
-        var v: Fuzzilli_Protobuf_EndWhileLoop?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .endWhileLoop(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .endWhileLoop(v)
-        }
-      }()
-      case 143: try {
-        var v: Fuzzilli_Protobuf_BeginDoWhileLoopBody?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .beginDoWhileLoopBody(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .beginDoWhileLoopBody(v)
-        }
-      }()
-      case 144: try {
-        var v: Fuzzilli_Protobuf_BeginDoWhileLoopHeader?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .beginDoWhileLoopHeader(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .beginDoWhileLoopHeader(v)
-        }
-      }()
-      case 145: try {
-        var v: Fuzzilli_Protobuf_EndDoWhileLoop?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .endDoWhileLoop(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .endDoWhileLoop(v)
-        }
-      }()
-      case 146: try {
-        var v: Fuzzilli_Protobuf_BeginForLoopInitializer?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .beginForLoopInitializer(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .beginForLoopInitializer(v)
-        }
-      }()
-      case 147: try {
-        var v: Fuzzilli_Protobuf_BeginForLoopCondition?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .beginForLoopCondition(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .beginForLoopCondition(v)
-        }
-      }()
-      case 148: try {
-        var v: Fuzzilli_Protobuf_BeginForLoopAfterthought?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .beginForLoopAfterthought(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .beginForLoopAfterthought(v)
-        }
-      }()
-      case 149: try {
-        var v: Fuzzilli_Protobuf_BeginForLoopBody?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .beginForLoopBody(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .beginForLoopBody(v)
-        }
-      }()
-      case 150: try {
-        var v: Fuzzilli_Protobuf_EndForLoop?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .endForLoop(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .endForLoop(v)
-        }
-      }()
-      case 151: try {
-        var v: Fuzzilli_Protobuf_BeginForInLoop?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .beginForInLoop(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .beginForInLoop(v)
-        }
-      }()
-      case 152: try {
-        var v: Fuzzilli_Protobuf_EndForInLoop?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .endForInLoop(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .endForInLoop(v)
-        }
-      }()
-      case 153: try {
-        var v: Fuzzilli_Protobuf_BeginForOfLoop?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .beginForOfLoop(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .beginForOfLoop(v)
-        }
-      }()
-      case 154: try {
-        var v: Fuzzilli_Protobuf_BeginForOfLoopWithDestruct?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .beginForOfLoopWithDestruct(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .beginForOfLoopWithDestruct(v)
-        }
-      }()
-      case 155: try {
-        var v: Fuzzilli_Protobuf_EndForOfLoop?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .endForOfLoop(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .endForOfLoop(v)
-        }
-      }()
-      case 156: try {
-        var v: Fuzzilli_Protobuf_BeginRepeatLoop?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .beginRepeatLoop(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .beginRepeatLoop(v)
-        }
-      }()
-      case 157: try {
-        var v: Fuzzilli_Protobuf_EndRepeatLoop?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .endRepeatLoop(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .endRepeatLoop(v)
-        }
-      }()
-      case 158: try {
-        var v: Fuzzilli_Protobuf_LoopBreak?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .loopBreak(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .loopBreak(v)
-        }
-      }()
-      case 159: try {
-        var v: Fuzzilli_Protobuf_LoopContinue?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .loopContinue(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .loopContinue(v)
-        }
-      }()
-      case 160: try {
-        var v: Fuzzilli_Protobuf_BeginTry?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .beginTry(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .beginTry(v)
-        }
-      }()
-      case 161: try {
-        var v: Fuzzilli_Protobuf_BeginCatch?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .beginCatch(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .beginCatch(v)
-        }
-      }()
-      case 162: try {
-        var v: Fuzzilli_Protobuf_BeginFinally?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .beginFinally(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .beginFinally(v)
-        }
-      }()
-      case 163: try {
-        var v: Fuzzilli_Protobuf_EndTryCatchFinally?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .endTryCatchFinally(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .endTryCatchFinally(v)
-        }
-      }()
-      case 164: try {
-        var v: Fuzzilli_Protobuf_ThrowException?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .throwException(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .throwException(v)
-        }
-      }()
-      case 165: try {
-        var v: Fuzzilli_Protobuf_BeginCodeString?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .beginCodeString(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .beginCodeString(v)
-        }
-      }()
-      case 166: try {
-        var v: Fuzzilli_Protobuf_EndCodeString?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .endCodeString(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .endCodeString(v)
-        }
-      }()
-      case 167: try {
-        var v: Fuzzilli_Protobuf_BeginBlockStatement?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .beginBlockStatement(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .beginBlockStatement(v)
-        }
-      }()
-      case 168: try {
-        var v: Fuzzilli_Protobuf_EndBlockStatement?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .endBlockStatement(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .endBlockStatement(v)
-        }
-      }()
-      case 169: try {
-        var v: Fuzzilli_Protobuf_BeginSwitch?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .beginSwitch(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .beginSwitch(v)
-        }
-      }()
-      case 170: try {
-        var v: Fuzzilli_Protobuf_BeginSwitchCase?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .beginSwitchCase(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .beginSwitchCase(v)
-        }
-      }()
-      case 171: try {
-        var v: Fuzzilli_Protobuf_BeginSwitchDefaultCase?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .beginSwitchDefaultCase(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .beginSwitchDefaultCase(v)
-        }
-      }()
-      case 172: try {
-        var v: Fuzzilli_Protobuf_EndSwitchCase?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .endSwitchCase(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .endSwitchCase(v)
-        }
-      }()
-      case 173: try {
-        var v: Fuzzilli_Protobuf_EndSwitch?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .endSwitch(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .endSwitch(v)
-        }
-      }()
-      case 174: try {
-        var v: Fuzzilli_Protobuf_SwitchBreak?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .switchBreak(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .switchBreak(v)
-        }
-      }()
-      case 175: try {
-        var v: Fuzzilli_Protobuf_LoadNewTarget?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .loadNewTarget(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .loadNewTarget(v)
-        }
-      }()
-      case 176: try {
-        var v: Fuzzilli_Protobuf_Print?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .print(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .print(v)
-        }
-      }()
-      case 177: try {
-        var v: Fuzzilli_Protobuf_Explore?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .explore(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .explore(v)
-        }
-      }()
-      case 178: try {
-        var v: Fuzzilli_Protobuf_Probe?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .probe(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .probe(v)
-        }
-      }()
-      case 179: try {
-        var v: Fuzzilli_Protobuf_Fixup?
-        var hadOneofValue = false
-        if let current = self.operation {
-          hadOneofValue = true
-          if case .fixup(let m) = current {v = m}
-        }
-        try decoder.decodeSingularMessageField(value: &v)
-        if let v = v {
-          if hadOneofValue {try decoder.handleConflictingOneOf()}
-          self.operation = .fixup(v)
+    _ = _uniqueStorage()
+    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
+      while let fieldNumber = try decoder.nextFieldNumber() {
+        switch fieldNumber {
+        case 1: try decoder.decodeRepeatedUInt32Field(value: &_storage._inouts)
+        case 2:
+          if _storage._operation != nil {try decoder.handleConflictingOneOf()}
+          var v: UInt32?
+          try decoder.decodeSingularUInt32Field(value: &v)
+          if let v = v {_storage._operation = .opIdx(v)}
+        case 3:
+          var v: Fuzzilli_Protobuf_Nop?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .nop(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .nop(v)}
+        case 4:
+          var v: Fuzzilli_Protobuf_LoadInteger?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .loadInteger(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .loadInteger(v)}
+        case 5:
+          var v: Fuzzilli_Protobuf_LoadBigInt?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .loadBigInt(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .loadBigInt(v)}
+        case 6:
+          var v: Fuzzilli_Protobuf_LoadFloat?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .loadFloat(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .loadFloat(v)}
+        case 7:
+          var v: Fuzzilli_Protobuf_LoadString?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .loadString(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .loadString(v)}
+        case 8:
+          var v: Fuzzilli_Protobuf_LoadBoolean?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .loadBoolean(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .loadBoolean(v)}
+        case 9:
+          var v: Fuzzilli_Protobuf_LoadUndefined?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .loadUndefined(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .loadUndefined(v)}
+        case 10:
+          var v: Fuzzilli_Protobuf_LoadNull?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .loadNull(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .loadNull(v)}
+        case 11:
+          var v: Fuzzilli_Protobuf_LoadThis?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .loadThis(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .loadThis(v)}
+        case 12:
+          var v: Fuzzilli_Protobuf_LoadArguments?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .loadArguments(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .loadArguments(v)}
+        case 13:
+          var v: Fuzzilli_Protobuf_LoadRegExp?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .loadRegExp(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .loadRegExp(v)}
+        case 14:
+          var v: Fuzzilli_Protobuf_BeginObjectLiteral?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .beginObjectLiteral(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .beginObjectLiteral(v)}
+        case 15:
+          var v: Fuzzilli_Protobuf_ObjectLiteralAddProperty?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .objectLiteralAddProperty(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .objectLiteralAddProperty(v)}
+        case 16:
+          var v: Fuzzilli_Protobuf_ObjectLiteralAddElement?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .objectLiteralAddElement(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .objectLiteralAddElement(v)}
+        case 17:
+          var v: Fuzzilli_Protobuf_ObjectLiteralAddComputedProperty?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .objectLiteralAddComputedProperty(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .objectLiteralAddComputedProperty(v)}
+        case 18:
+          var v: Fuzzilli_Protobuf_ObjectLiteralCopyProperties?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .objectLiteralCopyProperties(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .objectLiteralCopyProperties(v)}
+        case 19:
+          var v: Fuzzilli_Protobuf_ObjectLiteralSetPrototype?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .objectLiteralSetPrototype(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .objectLiteralSetPrototype(v)}
+        case 20:
+          var v: Fuzzilli_Protobuf_BeginObjectLiteralMethod?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .beginObjectLiteralMethod(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .beginObjectLiteralMethod(v)}
+        case 21:
+          var v: Fuzzilli_Protobuf_EndObjectLiteralMethod?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .endObjectLiteralMethod(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .endObjectLiteralMethod(v)}
+        case 22:
+          var v: Fuzzilli_Protobuf_BeginObjectLiteralComputedMethod?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .beginObjectLiteralComputedMethod(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .beginObjectLiteralComputedMethod(v)}
+        case 23:
+          var v: Fuzzilli_Protobuf_EndObjectLiteralComputedMethod?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .endObjectLiteralComputedMethod(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .endObjectLiteralComputedMethod(v)}
+        case 24:
+          var v: Fuzzilli_Protobuf_BeginObjectLiteralGetter?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .beginObjectLiteralGetter(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .beginObjectLiteralGetter(v)}
+        case 25:
+          var v: Fuzzilli_Protobuf_EndObjectLiteralGetter?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .endObjectLiteralGetter(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .endObjectLiteralGetter(v)}
+        case 26:
+          var v: Fuzzilli_Protobuf_BeginObjectLiteralSetter?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .beginObjectLiteralSetter(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .beginObjectLiteralSetter(v)}
+        case 27:
+          var v: Fuzzilli_Protobuf_EndObjectLiteralSetter?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .endObjectLiteralSetter(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .endObjectLiteralSetter(v)}
+        case 28:
+          var v: Fuzzilli_Protobuf_EndObjectLiteral?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .endObjectLiteral(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .endObjectLiteral(v)}
+        case 29:
+          var v: Fuzzilli_Protobuf_BeginClassDefinition?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .beginClassDefinition(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .beginClassDefinition(v)}
+        case 30:
+          var v: Fuzzilli_Protobuf_BeginClassConstructor?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .beginClassConstructor(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .beginClassConstructor(v)}
+        case 31:
+          var v: Fuzzilli_Protobuf_EndClassConstructor?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .endClassConstructor(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .endClassConstructor(v)}
+        case 32:
+          var v: Fuzzilli_Protobuf_ClassAddInstanceProperty?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .classAddInstanceProperty(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .classAddInstanceProperty(v)}
+        case 33:
+          var v: Fuzzilli_Protobuf_ClassAddInstanceElement?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .classAddInstanceElement(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .classAddInstanceElement(v)}
+        case 34:
+          var v: Fuzzilli_Protobuf_ClassAddInstanceComputedProperty?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .classAddInstanceComputedProperty(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .classAddInstanceComputedProperty(v)}
+        case 35:
+          var v: Fuzzilli_Protobuf_BeginClassInstanceMethod?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .beginClassInstanceMethod(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .beginClassInstanceMethod(v)}
+        case 36:
+          var v: Fuzzilli_Protobuf_EndClassInstanceMethod?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .endClassInstanceMethod(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .endClassInstanceMethod(v)}
+        case 37:
+          var v: Fuzzilli_Protobuf_BeginClassInstanceGetter?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .beginClassInstanceGetter(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .beginClassInstanceGetter(v)}
+        case 38:
+          var v: Fuzzilli_Protobuf_EndClassInstanceGetter?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .endClassInstanceGetter(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .endClassInstanceGetter(v)}
+        case 39:
+          var v: Fuzzilli_Protobuf_BeginClassInstanceSetter?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .beginClassInstanceSetter(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .beginClassInstanceSetter(v)}
+        case 40:
+          var v: Fuzzilli_Protobuf_EndClassInstanceSetter?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .endClassInstanceSetter(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .endClassInstanceSetter(v)}
+        case 41:
+          var v: Fuzzilli_Protobuf_ClassAddStaticProperty?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .classAddStaticProperty(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .classAddStaticProperty(v)}
+        case 42:
+          var v: Fuzzilli_Protobuf_ClassAddStaticElement?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .classAddStaticElement(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .classAddStaticElement(v)}
+        case 43:
+          var v: Fuzzilli_Protobuf_ClassAddStaticComputedProperty?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .classAddStaticComputedProperty(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .classAddStaticComputedProperty(v)}
+        case 44:
+          var v: Fuzzilli_Protobuf_BeginClassStaticInitializer?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .beginClassStaticInitializer(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .beginClassStaticInitializer(v)}
+        case 45:
+          var v: Fuzzilli_Protobuf_EndClassStaticInitializer?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .endClassStaticInitializer(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .endClassStaticInitializer(v)}
+        case 46:
+          var v: Fuzzilli_Protobuf_BeginClassStaticMethod?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .beginClassStaticMethod(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .beginClassStaticMethod(v)}
+        case 47:
+          var v: Fuzzilli_Protobuf_EndClassStaticMethod?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .endClassStaticMethod(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .endClassStaticMethod(v)}
+        case 48:
+          var v: Fuzzilli_Protobuf_BeginClassStaticGetter?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .beginClassStaticGetter(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .beginClassStaticGetter(v)}
+        case 49:
+          var v: Fuzzilli_Protobuf_EndClassStaticGetter?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .endClassStaticGetter(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .endClassStaticGetter(v)}
+        case 50:
+          var v: Fuzzilli_Protobuf_BeginClassStaticSetter?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .beginClassStaticSetter(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .beginClassStaticSetter(v)}
+        case 51:
+          var v: Fuzzilli_Protobuf_EndClassStaticSetter?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .endClassStaticSetter(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .endClassStaticSetter(v)}
+        case 52:
+          var v: Fuzzilli_Protobuf_ClassAddPrivateInstanceProperty?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .classAddPrivateInstanceProperty(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .classAddPrivateInstanceProperty(v)}
+        case 53:
+          var v: Fuzzilli_Protobuf_BeginClassPrivateInstanceMethod?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .beginClassPrivateInstanceMethod(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .beginClassPrivateInstanceMethod(v)}
+        case 54:
+          var v: Fuzzilli_Protobuf_EndClassPrivateInstanceMethod?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .endClassPrivateInstanceMethod(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .endClassPrivateInstanceMethod(v)}
+        case 55:
+          var v: Fuzzilli_Protobuf_ClassAddPrivateStaticProperty?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .classAddPrivateStaticProperty(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .classAddPrivateStaticProperty(v)}
+        case 56:
+          var v: Fuzzilli_Protobuf_BeginClassPrivateStaticMethod?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .beginClassPrivateStaticMethod(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .beginClassPrivateStaticMethod(v)}
+        case 57:
+          var v: Fuzzilli_Protobuf_EndClassPrivateStaticMethod?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .endClassPrivateStaticMethod(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .endClassPrivateStaticMethod(v)}
+        case 58:
+          var v: Fuzzilli_Protobuf_EndClassDefinition?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .endClassDefinition(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .endClassDefinition(v)}
+        case 59:
+          var v: Fuzzilli_Protobuf_CreateArray?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .createArray(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .createArray(v)}
+        case 60:
+          var v: Fuzzilli_Protobuf_CreateIntArray?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .createIntArray(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .createIntArray(v)}
+        case 61:
+          var v: Fuzzilli_Protobuf_CreateFloatArray?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .createFloatArray(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .createFloatArray(v)}
+        case 62:
+          var v: Fuzzilli_Protobuf_CreateArrayWithSpread?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .createArrayWithSpread(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .createArrayWithSpread(v)}
+        case 63:
+          var v: Fuzzilli_Protobuf_CreateTemplateString?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .createTemplateString(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .createTemplateString(v)}
+        case 64:
+          var v: Fuzzilli_Protobuf_LoadBuiltin?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .loadBuiltin(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .loadBuiltin(v)}
+        case 65:
+          var v: Fuzzilli_Protobuf_GetProperty?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .getProperty(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .getProperty(v)}
+        case 66:
+          var v: Fuzzilli_Protobuf_SetProperty?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .setProperty(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .setProperty(v)}
+        case 67:
+          var v: Fuzzilli_Protobuf_UpdateProperty?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .updateProperty(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .updateProperty(v)}
+        case 68:
+          var v: Fuzzilli_Protobuf_DeleteProperty?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .deleteProperty(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .deleteProperty(v)}
+        case 69:
+          var v: Fuzzilli_Protobuf_ConfigureProperty?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .configureProperty(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .configureProperty(v)}
+        case 70:
+          var v: Fuzzilli_Protobuf_GetElement?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .getElement(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .getElement(v)}
+        case 71:
+          var v: Fuzzilli_Protobuf_SetElement?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .setElement(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .setElement(v)}
+        case 72:
+          var v: Fuzzilli_Protobuf_UpdateElement?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .updateElement(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .updateElement(v)}
+        case 73:
+          var v: Fuzzilli_Protobuf_DeleteElement?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .deleteElement(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .deleteElement(v)}
+        case 74:
+          var v: Fuzzilli_Protobuf_ConfigureElement?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .configureElement(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .configureElement(v)}
+        case 75:
+          var v: Fuzzilli_Protobuf_GetComputedProperty?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .getComputedProperty(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .getComputedProperty(v)}
+        case 76:
+          var v: Fuzzilli_Protobuf_SetComputedProperty?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .setComputedProperty(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .setComputedProperty(v)}
+        case 77:
+          var v: Fuzzilli_Protobuf_UpdateComputedProperty?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .updateComputedProperty(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .updateComputedProperty(v)}
+        case 78:
+          var v: Fuzzilli_Protobuf_DeleteComputedProperty?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .deleteComputedProperty(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .deleteComputedProperty(v)}
+        case 79:
+          var v: Fuzzilli_Protobuf_ConfigureComputedProperty?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .configureComputedProperty(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .configureComputedProperty(v)}
+        case 80:
+          var v: Fuzzilli_Protobuf_TypeOf?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .typeOf(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .typeOf(v)}
+        case 81:
+          var v: Fuzzilli_Protobuf_TestInstanceOf?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .testInstanceOf(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .testInstanceOf(v)}
+        case 82:
+          var v: Fuzzilli_Protobuf_TestIn?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .testIn(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .testIn(v)}
+        case 83:
+          var v: Fuzzilli_Protobuf_BeginPlainFunction?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .beginPlainFunction(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .beginPlainFunction(v)}
+        case 84:
+          var v: Fuzzilli_Protobuf_EndPlainFunction?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .endPlainFunction(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .endPlainFunction(v)}
+        case 85:
+          var v: Fuzzilli_Protobuf_BeginArrowFunction?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .beginArrowFunction(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .beginArrowFunction(v)}
+        case 86:
+          var v: Fuzzilli_Protobuf_EndArrowFunction?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .endArrowFunction(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .endArrowFunction(v)}
+        case 87:
+          var v: Fuzzilli_Protobuf_BeginGeneratorFunction?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .beginGeneratorFunction(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .beginGeneratorFunction(v)}
+        case 88:
+          var v: Fuzzilli_Protobuf_EndGeneratorFunction?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .endGeneratorFunction(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .endGeneratorFunction(v)}
+        case 89:
+          var v: Fuzzilli_Protobuf_BeginAsyncFunction?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .beginAsyncFunction(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .beginAsyncFunction(v)}
+        case 90:
+          var v: Fuzzilli_Protobuf_EndAsyncFunction?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .endAsyncFunction(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .endAsyncFunction(v)}
+        case 91:
+          var v: Fuzzilli_Protobuf_BeginAsyncArrowFunction?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .beginAsyncArrowFunction(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .beginAsyncArrowFunction(v)}
+        case 92:
+          var v: Fuzzilli_Protobuf_EndAsyncArrowFunction?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .endAsyncArrowFunction(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .endAsyncArrowFunction(v)}
+        case 93:
+          var v: Fuzzilli_Protobuf_BeginAsyncGeneratorFunction?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .beginAsyncGeneratorFunction(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .beginAsyncGeneratorFunction(v)}
+        case 94:
+          var v: Fuzzilli_Protobuf_EndAsyncGeneratorFunction?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .endAsyncGeneratorFunction(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .endAsyncGeneratorFunction(v)}
+        case 95:
+          var v: Fuzzilli_Protobuf_BeginConstructor?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .beginConstructor(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .beginConstructor(v)}
+        case 96:
+          var v: Fuzzilli_Protobuf_EndConstructor?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .endConstructor(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .endConstructor(v)}
+        case 97:
+          var v: Fuzzilli_Protobuf_Return?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .return(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .return(v)}
+        case 98:
+          var v: Fuzzilli_Protobuf_Yield?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .yield(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .yield(v)}
+        case 99:
+          var v: Fuzzilli_Protobuf_YieldEach?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .yieldEach(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .yieldEach(v)}
+        case 100:
+          var v: Fuzzilli_Protobuf_Await?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .await(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .await(v)}
+        case 101:
+          var v: Fuzzilli_Protobuf_CallFunction?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .callFunction(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .callFunction(v)}
+        case 102:
+          var v: Fuzzilli_Protobuf_CallFunctionWithSpread?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .callFunctionWithSpread(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .callFunctionWithSpread(v)}
+        case 103:
+          var v: Fuzzilli_Protobuf_Construct?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .construct(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .construct(v)}
+        case 104:
+          var v: Fuzzilli_Protobuf_ConstructWithSpread?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .constructWithSpread(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .constructWithSpread(v)}
+        case 105:
+          var v: Fuzzilli_Protobuf_CallMethod?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .callMethod(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .callMethod(v)}
+        case 106:
+          var v: Fuzzilli_Protobuf_CallMethodWithSpread?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .callMethodWithSpread(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .callMethodWithSpread(v)}
+        case 107:
+          var v: Fuzzilli_Protobuf_CallComputedMethod?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .callComputedMethod(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .callComputedMethod(v)}
+        case 108:
+          var v: Fuzzilli_Protobuf_CallComputedMethodWithSpread?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .callComputedMethodWithSpread(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .callComputedMethodWithSpread(v)}
+        case 109:
+          var v: Fuzzilli_Protobuf_UnaryOperation?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .unaryOperation(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .unaryOperation(v)}
+        case 110:
+          var v: Fuzzilli_Protobuf_BinaryOperation?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .binaryOperation(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .binaryOperation(v)}
+        case 111:
+          var v: Fuzzilli_Protobuf_TernaryOperation?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .ternaryOperation(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .ternaryOperation(v)}
+        case 112:
+          var v: Fuzzilli_Protobuf_Update?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .update(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .update(v)}
+        case 113:
+          var v: Fuzzilli_Protobuf_Dup?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .dup(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .dup(v)}
+        case 114:
+          var v: Fuzzilli_Protobuf_Reassign?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .reassign(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .reassign(v)}
+        case 115:
+          var v: Fuzzilli_Protobuf_DestructArray?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .destructArray(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .destructArray(v)}
+        case 116:
+          var v: Fuzzilli_Protobuf_DestructArrayAndReassign?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .destructArrayAndReassign(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .destructArrayAndReassign(v)}
+        case 117:
+          var v: Fuzzilli_Protobuf_DestructObject?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .destructObject(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .destructObject(v)}
+        case 118:
+          var v: Fuzzilli_Protobuf_DestructObjectAndReassign?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .destructObjectAndReassign(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .destructObjectAndReassign(v)}
+        case 119:
+          var v: Fuzzilli_Protobuf_Compare?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .compare(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .compare(v)}
+        case 120:
+          var v: Fuzzilli_Protobuf_LoadNamedVariable?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .loadNamedVariable(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .loadNamedVariable(v)}
+        case 121:
+          var v: Fuzzilli_Protobuf_StoreNamedVariable?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .storeNamedVariable(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .storeNamedVariable(v)}
+        case 122:
+          var v: Fuzzilli_Protobuf_DefineNamedVariable?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .defineNamedVariable(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .defineNamedVariable(v)}
+        case 123:
+          var v: Fuzzilli_Protobuf_Eval?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .eval(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .eval(v)}
+        case 124:
+          var v: Fuzzilli_Protobuf_BeginWith?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .beginWith(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .beginWith(v)}
+        case 125:
+          var v: Fuzzilli_Protobuf_EndWith?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .endWith(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .endWith(v)}
+        case 126:
+          var v: Fuzzilli_Protobuf_CallSuperConstructor?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .callSuperConstructor(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .callSuperConstructor(v)}
+        case 127:
+          var v: Fuzzilli_Protobuf_CallSuperMethod?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .callSuperMethod(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .callSuperMethod(v)}
+        case 128:
+          var v: Fuzzilli_Protobuf_GetPrivateProperty?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .getPrivateProperty(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .getPrivateProperty(v)}
+        case 129:
+          var v: Fuzzilli_Protobuf_SetPrivateProperty?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .setPrivateProperty(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .setPrivateProperty(v)}
+        case 130:
+          var v: Fuzzilli_Protobuf_UpdatePrivateProperty?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .updatePrivateProperty(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .updatePrivateProperty(v)}
+        case 131:
+          var v: Fuzzilli_Protobuf_CallPrivateMethod?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .callPrivateMethod(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .callPrivateMethod(v)}
+        case 132:
+          var v: Fuzzilli_Protobuf_GetSuperProperty?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .getSuperProperty(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .getSuperProperty(v)}
+        case 133:
+          var v: Fuzzilli_Protobuf_SetSuperProperty?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .setSuperProperty(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .setSuperProperty(v)}
+        case 134:
+          var v: Fuzzilli_Protobuf_GetComputedSuperProperty?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .getComputedSuperProperty(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .getComputedSuperProperty(v)}
+        case 135:
+          var v: Fuzzilli_Protobuf_SetComputedSuperProperty?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .setComputedSuperProperty(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .setComputedSuperProperty(v)}
+        case 136:
+          var v: Fuzzilli_Protobuf_UpdateSuperProperty?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .updateSuperProperty(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .updateSuperProperty(v)}
+        case 137:
+          var v: Fuzzilli_Protobuf_BeginIf?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .beginIf(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .beginIf(v)}
+        case 138:
+          var v: Fuzzilli_Protobuf_BeginElse?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .beginElse(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .beginElse(v)}
+        case 139:
+          var v: Fuzzilli_Protobuf_EndIf?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .endIf(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .endIf(v)}
+        case 140:
+          var v: Fuzzilli_Protobuf_BeginWhileLoopHeader?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .beginWhileLoopHeader(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .beginWhileLoopHeader(v)}
+        case 141:
+          var v: Fuzzilli_Protobuf_BeginWhileLoopBody?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .beginWhileLoopBody(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .beginWhileLoopBody(v)}
+        case 142:
+          var v: Fuzzilli_Protobuf_EndWhileLoop?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .endWhileLoop(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .endWhileLoop(v)}
+        case 143:
+          var v: Fuzzilli_Protobuf_BeginDoWhileLoopBody?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .beginDoWhileLoopBody(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .beginDoWhileLoopBody(v)}
+        case 144:
+          var v: Fuzzilli_Protobuf_BeginDoWhileLoopHeader?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .beginDoWhileLoopHeader(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .beginDoWhileLoopHeader(v)}
+        case 145:
+          var v: Fuzzilli_Protobuf_EndDoWhileLoop?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .endDoWhileLoop(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .endDoWhileLoop(v)}
+        case 146:
+          var v: Fuzzilli_Protobuf_BeginForLoopInitializer?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .beginForLoopInitializer(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .beginForLoopInitializer(v)}
+        case 147:
+          var v: Fuzzilli_Protobuf_BeginForLoopCondition?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .beginForLoopCondition(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .beginForLoopCondition(v)}
+        case 148:
+          var v: Fuzzilli_Protobuf_BeginForLoopAfterthought?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .beginForLoopAfterthought(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .beginForLoopAfterthought(v)}
+        case 149:
+          var v: Fuzzilli_Protobuf_BeginForLoopBody?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .beginForLoopBody(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .beginForLoopBody(v)}
+        case 150:
+          var v: Fuzzilli_Protobuf_EndForLoop?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .endForLoop(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .endForLoop(v)}
+        case 151:
+          var v: Fuzzilli_Protobuf_BeginForInLoop?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .beginForInLoop(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .beginForInLoop(v)}
+        case 152:
+          var v: Fuzzilli_Protobuf_EndForInLoop?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .endForInLoop(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .endForInLoop(v)}
+        case 153:
+          var v: Fuzzilli_Protobuf_BeginForOfLoop?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .beginForOfLoop(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .beginForOfLoop(v)}
+        case 154:
+          var v: Fuzzilli_Protobuf_BeginForOfLoopWithDestruct?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .beginForOfLoopWithDestruct(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .beginForOfLoopWithDestruct(v)}
+        case 155:
+          var v: Fuzzilli_Protobuf_EndForOfLoop?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .endForOfLoop(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .endForOfLoop(v)}
+        case 156:
+          var v: Fuzzilli_Protobuf_BeginRepeatLoop?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .beginRepeatLoop(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .beginRepeatLoop(v)}
+        case 157:
+          var v: Fuzzilli_Protobuf_EndRepeatLoop?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .endRepeatLoop(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .endRepeatLoop(v)}
+        case 158:
+          var v: Fuzzilli_Protobuf_LoopBreak?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .loopBreak(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .loopBreak(v)}
+        case 159:
+          var v: Fuzzilli_Protobuf_LoopContinue?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .loopContinue(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .loopContinue(v)}
+        case 160:
+          var v: Fuzzilli_Protobuf_BeginTry?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .beginTry(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .beginTry(v)}
+        case 161:
+          var v: Fuzzilli_Protobuf_BeginCatch?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .beginCatch(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .beginCatch(v)}
+        case 162:
+          var v: Fuzzilli_Protobuf_BeginFinally?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .beginFinally(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .beginFinally(v)}
+        case 163:
+          var v: Fuzzilli_Protobuf_EndTryCatchFinally?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .endTryCatchFinally(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .endTryCatchFinally(v)}
+        case 164:
+          var v: Fuzzilli_Protobuf_ThrowException?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .throwException(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .throwException(v)}
+        case 165:
+          var v: Fuzzilli_Protobuf_BeginCodeString?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .beginCodeString(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .beginCodeString(v)}
+        case 166:
+          var v: Fuzzilli_Protobuf_EndCodeString?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .endCodeString(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .endCodeString(v)}
+        case 167:
+          var v: Fuzzilli_Protobuf_BeginBlockStatement?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .beginBlockStatement(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .beginBlockStatement(v)}
+        case 168:
+          var v: Fuzzilli_Protobuf_EndBlockStatement?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .endBlockStatement(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .endBlockStatement(v)}
+        case 169:
+          var v: Fuzzilli_Protobuf_BeginSwitch?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .beginSwitch(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .beginSwitch(v)}
+        case 170:
+          var v: Fuzzilli_Protobuf_BeginSwitchCase?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .beginSwitchCase(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .beginSwitchCase(v)}
+        case 171:
+          var v: Fuzzilli_Protobuf_BeginSwitchDefaultCase?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .beginSwitchDefaultCase(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .beginSwitchDefaultCase(v)}
+        case 172:
+          var v: Fuzzilli_Protobuf_EndSwitchCase?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .endSwitchCase(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .endSwitchCase(v)}
+        case 173:
+          var v: Fuzzilli_Protobuf_EndSwitch?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .endSwitch(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .endSwitch(v)}
+        case 174:
+          var v: Fuzzilli_Protobuf_SwitchBreak?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .switchBreak(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .switchBreak(v)}
+        case 175:
+          var v: Fuzzilli_Protobuf_LoadNewTarget?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .loadNewTarget(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .loadNewTarget(v)}
+        case 176:
+          var v: Fuzzilli_Protobuf_Print?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .print(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .print(v)}
+        case 177:
+          var v: Fuzzilli_Protobuf_Explore?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .explore(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .explore(v)}
+        case 178:
+          var v: Fuzzilli_Protobuf_Probe?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .probe(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .probe(v)}
+        case 179:
+          var v: Fuzzilli_Protobuf_Fixup?
+          if let current = _storage._operation {
+            try decoder.handleConflictingOneOf()
+            if case .fixup(let m) = current {v = m}
+          }
+          try decoder.decodeSingularMessageField(value: &v)
+          if let v = v {_storage._operation = .fixup(v)}
+        default: break
         }
-      }()
-      default: break
       }
     }
   }
 
   public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
-    // The use of inline closures is to circumvent an issue where the compiler
-    // allocates stack space for every if/case branch local when no optimizations
-    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
-    // https://github.com/apple/swift-protobuf/issues/1182
-    if !self.inouts.isEmpty {
-      try visitor.visitPackedUInt32Field(value: self.inouts, fieldNumber: 1)
-    }
-    switch self.operation {
-    case .opIdx?: try {
-      guard case .opIdx(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
-    }()
-    case .nop?: try {
-      guard case .nop(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
-    }()
-    case .loadInteger?: try {
-      guard case .loadInteger(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
-    }()
-    case .loadBigInt?: try {
-      guard case .loadBigInt(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
-    }()
-    case .loadFloat?: try {
-      guard case .loadFloat(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
-    }()
-    case .loadString?: try {
-      guard case .loadString(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
-    }()
-    case .loadBoolean?: try {
-      guard case .loadBoolean(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
-    }()
-    case .loadUndefined?: try {
-      guard case .loadUndefined(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
-    }()
-    case .loadNull?: try {
-      guard case .loadNull(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
-    }()
-    case .loadThis?: try {
-      guard case .loadThis(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
-    }()
-    case .loadArguments?: try {
-      guard case .loadArguments(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
-    }()
-    case .loadRegExp?: try {
-      guard case .loadRegExp(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
-    }()
-    case .beginObjectLiteral?: try {
-      guard case .beginObjectLiteral(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
-    }()
-    case .objectLiteralAddProperty?: try {
-      guard case .objectLiteralAddProperty(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
-    }()
-    case .objectLiteralAddElement?: try {
-      guard case .objectLiteralAddElement(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
-    }()
-    case .objectLiteralAddComputedProperty?: try {
-      guard case .objectLiteralAddComputedProperty(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
-    }()
-    case .objectLiteralCopyProperties?: try {
-      guard case .objectLiteralCopyProperties(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
-    }()
-    case .objectLiteralSetPrototype?: try {
-      guard case .objectLiteralSetPrototype(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
-    }()
-    case .beginObjectLiteralMethod?: try {
-      guard case .beginObjectLiteralMethod(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
-    }()
-    case .endObjectLiteralMethod?: try {
-      guard case .endObjectLiteralMethod(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
-    }()
-    case .beginObjectLiteralComputedMethod?: try {
-      guard case .beginObjectLiteralComputedMethod(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
-    }()
-    case .endObjectLiteralComputedMethod?: try {
-      guard case .endObjectLiteralComputedMethod(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 23)
-    }()
-    case .beginObjectLiteralGetter?: try {
-      guard case .beginObjectLiteralGetter(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 24)
-    }()
-    case .endObjectLiteralGetter?: try {
-      guard case .endObjectLiteralGetter(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 25)
-    }()
-    case .beginObjectLiteralSetter?: try {
-      guard case .beginObjectLiteralSetter(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 26)
-    }()
-    case .endObjectLiteralSetter?: try {
-      guard case .endObjectLiteralSetter(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 27)
-    }()
-    case .endObjectLiteral?: try {
-      guard case .endObjectLiteral(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 28)
-    }()
-    case .beginClassDefinition?: try {
-      guard case .beginClassDefinition(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 29)
-    }()
-    case .beginClassConstructor?: try {
-      guard case .beginClassConstructor(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 30)
-    }()
-    case .endClassConstructor?: try {
-      guard case .endClassConstructor(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 31)
-    }()
-    case .classAddInstanceProperty?: try {
-      guard case .classAddInstanceProperty(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 32)
-    }()
-    case .classAddInstanceElement?: try {
-      guard case .classAddInstanceElement(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 33)
-    }()
-    case .classAddInstanceComputedProperty?: try {
-      guard case .classAddInstanceComputedProperty(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 34)
-    }()
-    case .beginClassInstanceMethod?: try {
-      guard case .beginClassInstanceMethod(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 35)
-    }()
-    case .endClassInstanceMethod?: try {
-      guard case .endClassInstanceMethod(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 36)
-    }()
-    case .beginClassInstanceGetter?: try {
-      guard case .beginClassInstanceGetter(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 37)
-    }()
-    case .endClassInstanceGetter?: try {
-      guard case .endClassInstanceGetter(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 38)
-    }()
-    case .beginClassInstanceSetter?: try {
-      guard case .beginClassInstanceSetter(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 39)
-    }()
-    case .endClassInstanceSetter?: try {
-      guard case .endClassInstanceSetter(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 40)
-    }()
-    case .classAddStaticProperty?: try {
-      guard case .classAddStaticProperty(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 41)
-    }()
-    case .classAddStaticElement?: try {
-      guard case .classAddStaticElement(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 42)
-    }()
-    case .classAddStaticComputedProperty?: try {
-      guard case .classAddStaticComputedProperty(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 43)
-    }()
-    case .beginClassStaticInitializer?: try {
-      guard case .beginClassStaticInitializer(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 44)
-    }()
-    case .endClassStaticInitializer?: try {
-      guard case .endClassStaticInitializer(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 45)
-    }()
-    case .beginClassStaticMethod?: try {
-      guard case .beginClassStaticMethod(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 46)
-    }()
-    case .endClassStaticMethod?: try {
-      guard case .endClassStaticMethod(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 47)
-    }()
-    case .beginClassStaticGetter?: try {
-      guard case .beginClassStaticGetter(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 48)
-    }()
-    case .endClassStaticGetter?: try {
-      guard case .endClassStaticGetter(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 49)
-    }()
-    case .beginClassStaticSetter?: try {
-      guard case .beginClassStaticSetter(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 50)
-    }()
-    case .endClassStaticSetter?: try {
-      guard case .endClassStaticSetter(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 51)
-    }()
-    case .classAddPrivateInstanceProperty?: try {
-      guard case .classAddPrivateInstanceProperty(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 52)
-    }()
-    case .beginClassPrivateInstanceMethod?: try {
-      guard case .beginClassPrivateInstanceMethod(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 53)
-    }()
-    case .endClassPrivateInstanceMethod?: try {
-      guard case .endClassPrivateInstanceMethod(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 54)
-    }()
-    case .classAddPrivateStaticProperty?: try {
-      guard case .classAddPrivateStaticProperty(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 55)
-    }()
-    case .beginClassPrivateStaticMethod?: try {
-      guard case .beginClassPrivateStaticMethod(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 56)
-    }()
-    case .endClassPrivateStaticMethod?: try {
-      guard case .endClassPrivateStaticMethod(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 57)
-    }()
-    case .endClassDefinition?: try {
-      guard case .endClassDefinition(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 58)
-    }()
-    case .createArray?: try {
-      guard case .createArray(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 59)
-    }()
-    case .createIntArray?: try {
-      guard case .createIntArray(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 60)
-    }()
-    case .createFloatArray?: try {
-      guard case .createFloatArray(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 61)
-    }()
-    case .createArrayWithSpread?: try {
-      guard case .createArrayWithSpread(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 62)
-    }()
-    case .createTemplateString?: try {
-      guard case .createTemplateString(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 63)
-    }()
-    case .loadBuiltin?: try {
-      guard case .loadBuiltin(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 64)
-    }()
-    case .getProperty?: try {
-      guard case .getProperty(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 65)
-    }()
-    case .setProperty?: try {
-      guard case .setProperty(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 66)
-    }()
-    case .updateProperty?: try {
-      guard case .updateProperty(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 67)
-    }()
-    case .deleteProperty?: try {
-      guard case .deleteProperty(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 68)
-    }()
-    case .configureProperty?: try {
-      guard case .configureProperty(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 69)
-    }()
-    case .getElement?: try {
-      guard case .getElement(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 70)
-    }()
-    case .setElement?: try {
-      guard case .setElement(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 71)
-    }()
-    case .updateElement?: try {
-      guard case .updateElement(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 72)
-    }()
-    case .deleteElement?: try {
-      guard case .deleteElement(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 73)
-    }()
-    case .configureElement?: try {
-      guard case .configureElement(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 74)
-    }()
-    case .getComputedProperty?: try {
-      guard case .getComputedProperty(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 75)
-    }()
-    case .setComputedProperty?: try {
-      guard case .setComputedProperty(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 76)
-    }()
-    case .updateComputedProperty?: try {
-      guard case .updateComputedProperty(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 77)
-    }()
-    case .deleteComputedProperty?: try {
-      guard case .deleteComputedProperty(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 78)
-    }()
-    case .configureComputedProperty?: try {
-      guard case .configureComputedProperty(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 79)
-    }()
-    case .typeOf?: try {
-      guard case .typeOf(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 80)
-    }()
-    case .testInstanceOf?: try {
-      guard case .testInstanceOf(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 81)
-    }()
-    case .testIn?: try {
-      guard case .testIn(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 82)
-    }()
-    case .beginPlainFunction?: try {
-      guard case .beginPlainFunction(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 83)
-    }()
-    case .endPlainFunction?: try {
-      guard case .endPlainFunction(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 84)
-    }()
-    case .beginArrowFunction?: try {
-      guard case .beginArrowFunction(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 85)
-    }()
-    case .endArrowFunction?: try {
-      guard case .endArrowFunction(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 86)
-    }()
-    case .beginGeneratorFunction?: try {
-      guard case .beginGeneratorFunction(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 87)
-    }()
-    case .endGeneratorFunction?: try {
-      guard case .endGeneratorFunction(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 88)
-    }()
-    case .beginAsyncFunction?: try {
-      guard case .beginAsyncFunction(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 89)
-    }()
-    case .endAsyncFunction?: try {
-      guard case .endAsyncFunction(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 90)
-    }()
-    case .beginAsyncArrowFunction?: try {
-      guard case .beginAsyncArrowFunction(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 91)
-    }()
-    case .endAsyncArrowFunction?: try {
-      guard case .endAsyncArrowFunction(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 92)
-    }()
-    case .beginAsyncGeneratorFunction?: try {
-      guard case .beginAsyncGeneratorFunction(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 93)
-    }()
-    case .endAsyncGeneratorFunction?: try {
-      guard case .endAsyncGeneratorFunction(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 94)
-    }()
-    case .beginConstructor?: try {
-      guard case .beginConstructor(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 95)
-    }()
-    case .endConstructor?: try {
-      guard case .endConstructor(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 96)
-    }()
-    case .return?: try {
-      guard case .return(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 97)
-    }()
-    case .yield?: try {
-      guard case .yield(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 98)
-    }()
-    case .yieldEach?: try {
-      guard case .yieldEach(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 99)
-    }()
-    case .await?: try {
-      guard case .await(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 100)
-    }()
-    case .callFunction?: try {
-      guard case .callFunction(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 101)
-    }()
-    case .callFunctionWithSpread?: try {
-      guard case .callFunctionWithSpread(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 102)
-    }()
-    case .construct?: try {
-      guard case .construct(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 103)
-    }()
-    case .constructWithSpread?: try {
-      guard case .constructWithSpread(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 104)
-    }()
-    case .callMethod?: try {
-      guard case .callMethod(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 105)
-    }()
-    case .callMethodWithSpread?: try {
-      guard case .callMethodWithSpread(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 106)
-    }()
-    case .callComputedMethod?: try {
-      guard case .callComputedMethod(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 107)
-    }()
-    case .callComputedMethodWithSpread?: try {
-      guard case .callComputedMethodWithSpread(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 108)
-    }()
-    case .unaryOperation?: try {
-      guard case .unaryOperation(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 109)
-    }()
-    case .binaryOperation?: try {
-      guard case .binaryOperation(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 110)
-    }()
-    case .ternaryOperation?: try {
-      guard case .ternaryOperation(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 111)
-    }()
-    case .update?: try {
-      guard case .update(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 112)
-    }()
-    case .dup?: try {
-      guard case .dup(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 113)
-    }()
-    case .reassign?: try {
-      guard case .reassign(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 114)
-    }()
-    case .destructArray?: try {
-      guard case .destructArray(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 115)
-    }()
-    case .destructArrayAndReassign?: try {
-      guard case .destructArrayAndReassign(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 116)
-    }()
-    case .destructObject?: try {
-      guard case .destructObject(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 117)
-    }()
-    case .destructObjectAndReassign?: try {
-      guard case .destructObjectAndReassign(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 118)
-    }()
-    case .compare?: try {
-      guard case .compare(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 119)
-    }()
-    case .loadNamedVariable?: try {
-      guard case .loadNamedVariable(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 120)
-    }()
-    case .storeNamedVariable?: try {
-      guard case .storeNamedVariable(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 121)
-    }()
-    case .defineNamedVariable?: try {
-      guard case .defineNamedVariable(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 122)
-    }()
-    case .eval?: try {
-      guard case .eval(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 123)
-    }()
-    case .beginWith?: try {
-      guard case .beginWith(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 124)
-    }()
-    case .endWith?: try {
-      guard case .endWith(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 125)
-    }()
-    case .callSuperConstructor?: try {
-      guard case .callSuperConstructor(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 126)
-    }()
-    case .callSuperMethod?: try {
-      guard case .callSuperMethod(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 127)
-    }()
-    case .getPrivateProperty?: try {
-      guard case .getPrivateProperty(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 128)
-    }()
-    case .setPrivateProperty?: try {
-      guard case .setPrivateProperty(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 129)
-    }()
-    case .updatePrivateProperty?: try {
-      guard case .updatePrivateProperty(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 130)
-    }()
-    case .callPrivateMethod?: try {
-      guard case .callPrivateMethod(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 131)
-    }()
-    case .getSuperProperty?: try {
-      guard case .getSuperProperty(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 132)
-    }()
-    case .setSuperProperty?: try {
-      guard case .setSuperProperty(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 133)
-    }()
-    case .getComputedSuperProperty?: try {
-      guard case .getComputedSuperProperty(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 134)
-    }()
-    case .setComputedSuperProperty?: try {
-      guard case .setComputedSuperProperty(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 135)
-    }()
-    case .updateSuperProperty?: try {
-      guard case .updateSuperProperty(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 136)
-    }()
-    case .beginIf?: try {
-      guard case .beginIf(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 137)
-    }()
-    case .beginElse?: try {
-      guard case .beginElse(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 138)
-    }()
-    case .endIf?: try {
-      guard case .endIf(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 139)
-    }()
-    case .beginWhileLoopHeader?: try {
-      guard case .beginWhileLoopHeader(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 140)
-    }()
-    case .beginWhileLoopBody?: try {
-      guard case .beginWhileLoopBody(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 141)
-    }()
-    case .endWhileLoop?: try {
-      guard case .endWhileLoop(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 142)
-    }()
-    case .beginDoWhileLoopBody?: try {
-      guard case .beginDoWhileLoopBody(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 143)
-    }()
-    case .beginDoWhileLoopHeader?: try {
-      guard case .beginDoWhileLoopHeader(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 144)
-    }()
-    case .endDoWhileLoop?: try {
-      guard case .endDoWhileLoop(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 145)
-    }()
-    case .beginForLoopInitializer?: try {
-      guard case .beginForLoopInitializer(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 146)
-    }()
-    case .beginForLoopCondition?: try {
-      guard case .beginForLoopCondition(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 147)
-    }()
-    case .beginForLoopAfterthought?: try {
-      guard case .beginForLoopAfterthought(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 148)
-    }()
-    case .beginForLoopBody?: try {
-      guard case .beginForLoopBody(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 149)
-    }()
-    case .endForLoop?: try {
-      guard case .endForLoop(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 150)
-    }()
-    case .beginForInLoop?: try {
-      guard case .beginForInLoop(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 151)
-    }()
-    case .endForInLoop?: try {
-      guard case .endForInLoop(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 152)
-    }()
-    case .beginForOfLoop?: try {
-      guard case .beginForOfLoop(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 153)
-    }()
-    case .beginForOfLoopWithDestruct?: try {
-      guard case .beginForOfLoopWithDestruct(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 154)
-    }()
-    case .endForOfLoop?: try {
-      guard case .endForOfLoop(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 155)
-    }()
-    case .beginRepeatLoop?: try {
-      guard case .beginRepeatLoop(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 156)
-    }()
-    case .endRepeatLoop?: try {
-      guard case .endRepeatLoop(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 157)
-    }()
-    case .loopBreak?: try {
-      guard case .loopBreak(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 158)
-    }()
-    case .loopContinue?: try {
-      guard case .loopContinue(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 159)
-    }()
-    case .beginTry?: try {
-      guard case .beginTry(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 160)
-    }()
-    case .beginCatch?: try {
-      guard case .beginCatch(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 161)
-    }()
-    case .beginFinally?: try {
-      guard case .beginFinally(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 162)
-    }()
-    case .endTryCatchFinally?: try {
-      guard case .endTryCatchFinally(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 163)
-    }()
-    case .throwException?: try {
-      guard case .throwException(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 164)
-    }()
-    case .beginCodeString?: try {
-      guard case .beginCodeString(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 165)
-    }()
-    case .endCodeString?: try {
-      guard case .endCodeString(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 166)
-    }()
-    case .beginBlockStatement?: try {
-      guard case .beginBlockStatement(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 167)
-    }()
-    case .endBlockStatement?: try {
-      guard case .endBlockStatement(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 168)
-    }()
-    case .beginSwitch?: try {
-      guard case .beginSwitch(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 169)
-    }()
-    case .beginSwitchCase?: try {
-      guard case .beginSwitchCase(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 170)
-    }()
-    case .beginSwitchDefaultCase?: try {
-      guard case .beginSwitchDefaultCase(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 171)
-    }()
-    case .endSwitchCase?: try {
-      guard case .endSwitchCase(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 172)
-    }()
-    case .endSwitch?: try {
-      guard case .endSwitch(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 173)
-    }()
-    case .switchBreak?: try {
-      guard case .switchBreak(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 174)
-    }()
-    case .loadNewTarget?: try {
-      guard case .loadNewTarget(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 175)
-    }()
-    case .print?: try {
-      guard case .print(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 176)
-    }()
-    case .explore?: try {
-      guard case .explore(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 177)
-    }()
-    case .probe?: try {
-      guard case .probe(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 178)
-    }()
-    case .fixup?: try {
-      guard case .fixup(let v)? = self.operation else { preconditionFailure() }
-      try visitor.visitSingularMessageField(value: v, fieldNumber: 179)
-    }()
-    case nil: break
+    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
+      if !_storage._inouts.isEmpty {
+        try visitor.visitPackedUInt32Field(value: _storage._inouts, fieldNumber: 1)
+      }
+      switch _storage._operation {
+      case .opIdx(let v)?:
+        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
+      case .nop(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
+      case .loadInteger(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
+      case .loadBigInt(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
+      case .loadFloat(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
+      case .loadString(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
+      case .loadBoolean(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
+      case .loadUndefined(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
+      case .loadNull(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
+      case .loadThis(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
+      case .loadArguments(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
+      case .loadRegExp(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
+      case .beginObjectLiteral(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
+      case .objectLiteralAddProperty(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
+      case .objectLiteralAddElement(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
+      case .objectLiteralAddComputedProperty(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
+      case .objectLiteralCopyProperties(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
+      case .objectLiteralSetPrototype(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
+      case .beginObjectLiteralMethod(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
+      case .endObjectLiteralMethod(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
+      case .beginObjectLiteralComputedMethod(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
+      case .endObjectLiteralComputedMethod(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 23)
+      case .beginObjectLiteralGetter(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 24)
+      case .endObjectLiteralGetter(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 25)
+      case .beginObjectLiteralSetter(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 26)
+      case .endObjectLiteralSetter(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 27)
+      case .endObjectLiteral(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 28)
+      case .beginClassDefinition(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 29)
+      case .beginClassConstructor(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 30)
+      case .endClassConstructor(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 31)
+      case .classAddInstanceProperty(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 32)
+      case .classAddInstanceElement(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 33)
+      case .classAddInstanceComputedProperty(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 34)
+      case .beginClassInstanceMethod(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 35)
+      case .endClassInstanceMethod(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 36)
+      case .beginClassInstanceGetter(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 37)
+      case .endClassInstanceGetter(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 38)
+      case .beginClassInstanceSetter(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 39)
+      case .endClassInstanceSetter(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 40)
+      case .classAddStaticProperty(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 41)
+      case .classAddStaticElement(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 42)
+      case .classAddStaticComputedProperty(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 43)
+      case .beginClassStaticInitializer(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 44)
+      case .endClassStaticInitializer(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 45)
+      case .beginClassStaticMethod(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 46)
+      case .endClassStaticMethod(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 47)
+      case .beginClassStaticGetter(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 48)
+      case .endClassStaticGetter(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 49)
+      case .beginClassStaticSetter(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 50)
+      case .endClassStaticSetter(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 51)
+      case .classAddPrivateInstanceProperty(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 52)
+      case .beginClassPrivateInstanceMethod(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 53)
+      case .endClassPrivateInstanceMethod(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 54)
+      case .classAddPrivateStaticProperty(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 55)
+      case .beginClassPrivateStaticMethod(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 56)
+      case .endClassPrivateStaticMethod(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 57)
+      case .endClassDefinition(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 58)
+      case .createArray(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 59)
+      case .createIntArray(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 60)
+      case .createFloatArray(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 61)
+      case .createArrayWithSpread(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 62)
+      case .createTemplateString(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 63)
+      case .loadBuiltin(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 64)
+      case .getProperty(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 65)
+      case .setProperty(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 66)
+      case .updateProperty(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 67)
+      case .deleteProperty(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 68)
+      case .configureProperty(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 69)
+      case .getElement(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 70)
+      case .setElement(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 71)
+      case .updateElement(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 72)
+      case .deleteElement(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 73)
+      case .configureElement(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 74)
+      case .getComputedProperty(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 75)
+      case .setComputedProperty(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 76)
+      case .updateComputedProperty(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 77)
+      case .deleteComputedProperty(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 78)
+      case .configureComputedProperty(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 79)
+      case .typeOf(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 80)
+      case .testInstanceOf(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 81)
+      case .testIn(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 82)
+      case .beginPlainFunction(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 83)
+      case .endPlainFunction(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 84)
+      case .beginArrowFunction(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 85)
+      case .endArrowFunction(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 86)
+      case .beginGeneratorFunction(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 87)
+      case .endGeneratorFunction(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 88)
+      case .beginAsyncFunction(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 89)
+      case .endAsyncFunction(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 90)
+      case .beginAsyncArrowFunction(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 91)
+      case .endAsyncArrowFunction(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 92)
+      case .beginAsyncGeneratorFunction(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 93)
+      case .endAsyncGeneratorFunction(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 94)
+      case .beginConstructor(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 95)
+      case .endConstructor(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 96)
+      case .return(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 97)
+      case .yield(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 98)
+      case .yieldEach(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 99)
+      case .await(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 100)
+      case .callFunction(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 101)
+      case .callFunctionWithSpread(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 102)
+      case .construct(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 103)
+      case .constructWithSpread(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 104)
+      case .callMethod(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 105)
+      case .callMethodWithSpread(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 106)
+      case .callComputedMethod(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 107)
+      case .callComputedMethodWithSpread(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 108)
+      case .unaryOperation(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 109)
+      case .binaryOperation(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 110)
+      case .ternaryOperation(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 111)
+      case .update(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 112)
+      case .dup(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 113)
+      case .reassign(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 114)
+      case .destructArray(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 115)
+      case .destructArrayAndReassign(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 116)
+      case .destructObject(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 117)
+      case .destructObjectAndReassign(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 118)
+      case .compare(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 119)
+      case .loadNamedVariable(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 120)
+      case .storeNamedVariable(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 121)
+      case .defineNamedVariable(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 122)
+      case .eval(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 123)
+      case .beginWith(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 124)
+      case .endWith(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 125)
+      case .callSuperConstructor(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 126)
+      case .callSuperMethod(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 127)
+      case .getPrivateProperty(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 128)
+      case .setPrivateProperty(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 129)
+      case .updatePrivateProperty(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 130)
+      case .callPrivateMethod(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 131)
+      case .getSuperProperty(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 132)
+      case .setSuperProperty(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 133)
+      case .getComputedSuperProperty(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 134)
+      case .setComputedSuperProperty(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 135)
+      case .updateSuperProperty(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 136)
+      case .beginIf(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 137)
+      case .beginElse(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 138)
+      case .endIf(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 139)
+      case .beginWhileLoopHeader(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 140)
+      case .beginWhileLoopBody(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 141)
+      case .endWhileLoop(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 142)
+      case .beginDoWhileLoopBody(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 143)
+      case .beginDoWhileLoopHeader(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 144)
+      case .endDoWhileLoop(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 145)
+      case .beginForLoopInitializer(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 146)
+      case .beginForLoopCondition(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 147)
+      case .beginForLoopAfterthought(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 148)
+      case .beginForLoopBody(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 149)
+      case .endForLoop(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 150)
+      case .beginForInLoop(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 151)
+      case .endForInLoop(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 152)
+      case .beginForOfLoop(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 153)
+      case .beginForOfLoopWithDestruct(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 154)
+      case .endForOfLoop(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 155)
+      case .beginRepeatLoop(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 156)
+      case .endRepeatLoop(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 157)
+      case .loopBreak(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 158)
+      case .loopContinue(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 159)
+      case .beginTry(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 160)
+      case .beginCatch(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 161)
+      case .beginFinally(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 162)
+      case .endTryCatchFinally(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 163)
+      case .throwException(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 164)
+      case .beginCodeString(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 165)
+      case .endCodeString(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 166)
+      case .beginBlockStatement(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 167)
+      case .endBlockStatement(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 168)
+      case .beginSwitch(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 169)
+      case .beginSwitchCase(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 170)
+      case .beginSwitchDefaultCase(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 171)
+      case .endSwitchCase(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 172)
+      case .endSwitch(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 173)
+      case .switchBreak(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 174)
+      case .loadNewTarget(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 175)
+      case .print(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 176)
+      case .explore(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 177)
+      case .probe(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 178)
+      case .fixup(let v)?:
+        try visitor.visitSingularMessageField(value: v, fieldNumber: 179)
+      case nil: break
+      }
     }
     try unknownFields.traverse(visitor: &visitor)
   }
 
   public static func ==(lhs: Fuzzilli_Protobuf_Instruction, rhs: Fuzzilli_Protobuf_Instruction) -> Bool {
-    if lhs.inouts != rhs.inouts {return false}
-    if lhs.operation != rhs.operation {return false}
+    if lhs._storage !== rhs._storage {
+      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
+        let _storage = _args.0
+        let rhs_storage = _args.1
+        if _storage._inouts != rhs_storage._inouts {return false}
+        if _storage._operation != rhs_storage._operation {return false}
+        return true
+      }
+      if !storagesAreEqual {return false}
+    }
     if lhs.unknownFields != rhs.unknownFields {return false}
     return true
   }
@@ -5676,7 +3924,7 @@ extension Fuzzilli_Protobuf_Program: SwiftProtobuf.Message, SwiftProtobuf._Messa
   ]
 
   fileprivate class _StorageClass {
-    var _uuid: Data = Data()
+    var _uuid: Data = SwiftProtobuf.Internal.emptyData
     var _code: [Fuzzilli_Protobuf_Instruction] = []
     var _comments: Dictionary<Int32,String> = [:]
     var _parent: Fuzzilli_Protobuf_Program? = nil
@@ -5704,14 +3952,11 @@ extension Fuzzilli_Protobuf_Program: SwiftProtobuf.Message, SwiftProtobuf._Messa
     _ = _uniqueStorage()
     try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
       while let fieldNumber = try decoder.nextFieldNumber() {
-        // The use of inline closures is to circumvent an issue where the compiler
-        // allocates stack space for every case branch when no optimizations are
-        // enabled. https://github.com/apple/swift-protobuf/issues/1034
         switch fieldNumber {
-        case 1: try { try decoder.decodeSingularBytesField(value: &_storage._uuid) }()
-        case 2: try { try decoder.decodeRepeatedMessageField(value: &_storage._code) }()
-        case 3: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufSInt32,SwiftProtobuf.ProtobufString>.self, value: &_storage._comments) }()
-        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._parent) }()
+        case 1: try decoder.decodeSingularBytesField(value: &_storage._uuid)
+        case 2: try decoder.decodeRepeatedMessageField(value: &_storage._code)
+        case 3: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufSInt32,SwiftProtobuf.ProtobufString>.self, value: &_storage._comments)
+        case 4: try decoder.decodeSingularMessageField(value: &_storage._parent)
         default: break
         }
       }
@@ -5720,10 +3965,6 @@ extension Fuzzilli_Protobuf_Program: SwiftProtobuf.Message, SwiftProtobuf._Messa
 
   public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
     try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
-      // The use of inline closures is to circumvent an issue where the compiler
-      // allocates stack space for every if/case branch local when no optimizations
-      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
-      // https://github.com/apple/swift-protobuf/issues/1182
       if !_storage._uuid.isEmpty {
         try visitor.visitSingularBytesField(value: _storage._uuid, fieldNumber: 1)
       }
@@ -5733,9 +3974,9 @@ extension Fuzzilli_Protobuf_Program: SwiftProtobuf.Message, SwiftProtobuf._Messa
       if !_storage._comments.isEmpty {
         try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufSInt32,SwiftProtobuf.ProtobufString>.self, value: _storage._comments, fieldNumber: 3)
       }
-      try { if let v = _storage._parent {
+      if let v = _storage._parent {
         try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
-      } }()
+      }
     }
     try unknownFields.traverse(visitor: &visitor)
   }
diff --git a/Sources/Fuzzilli/Protobuf/program.proto b/Sources/Fuzzilli/Protobuf/program.proto
index 515dce6..c8da3a3 100644
--- a/Sources/Fuzzilli/Protobuf/program.proto
+++ b/Sources/Fuzzilli/Protobuf/program.proto
@@ -1,4 +1,4 @@
-// Copyright 2023 Google LLC
+// Copyright 2024 Google LLC
 //
 // Licensed under the Apache License, Version 2.0 (the "License");
 // you may not use this file except in compliance with the License.
diff --git a/Sources/Fuzzilli/Protobuf/sync.pb.swift b/Sources/Fuzzilli/Protobuf/sync.pb.swift
index 909deec..92bf762 100644
--- a/Sources/Fuzzilli/Protobuf/sync.pb.swift
+++ b/Sources/Fuzzilli/Protobuf/sync.pb.swift
@@ -58,9 +58,9 @@ public struct Fuzzilli_Protobuf_FuzzerState {
   // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
   // methods supported on all messages.
 
-  public var corpus: Data = Data()
+  public var corpus: Data = SwiftProtobuf.Internal.emptyData
 
-  public var evaluatorState: Data = Data()
+  public var evaluatorState: Data = SwiftProtobuf.Internal.emptyData
 
   public var unknownFields = SwiftProtobuf.UnknownStorage()
 
@@ -132,6 +132,11 @@ public struct Fuzzilli_Protobuf_Statistics {
     set {_uniqueStorage()._avgExecutionTime = newValue}
   }
 
+  public var avgBugOracleTime: Double {
+    get {return _storage._avgBugOracleTime}
+    set {_uniqueStorage()._avgBugOracleTime = newValue}
+  }
+
   //// The current number of executions per second.
   public var execsPerSecond: Double {
     get {return _storage._execsPerSecond}
@@ -174,6 +179,46 @@ public struct Fuzzilli_Protobuf_Statistics {
     set {_uniqueStorage()._timeoutRate = newValue}
   }
 
+  public var differentialSamples: UInt64 {
+    get {return _storage._differentialSamples}
+    set {_uniqueStorage()._differentialSamples = newValue}
+  }
+
+  public var turbofanSamples: UInt64 {
+    get {return _storage._turbofanSamples}
+    set {_uniqueStorage()._turbofanSamples = newValue}
+  }
+
+  public var maglevSamples: UInt64 {
+    get {return _storage._maglevSamples}
+    set {_uniqueStorage()._maglevSamples = newValue}
+  }
+
+  public var sparkplugSamples: UInt64 {
+    get {return _storage._sparkplugSamples}
+    set {_uniqueStorage()._sparkplugSamples = newValue}
+  }
+
+  public var relationsPerformed: UInt64 {
+    get {return _storage._relationsPerformed}
+    set {_uniqueStorage()._relationsPerformed = newValue}
+  }
+
+  public var jitSamples: UInt64 {
+    get {return _storage._jitSamples}
+    set {_uniqueStorage()._jitSamples = newValue}
+  }
+
+  public var avgDumpSizeOpt: Double {
+    get {return _storage._avgDumpSizeOpt}
+    set {_uniqueStorage()._avgDumpSizeOpt = newValue}
+  }
+
+  public var avgDumpSizeUnOpt: Double {
+    get {return _storage._avgDumpSizeUnOpt}
+    set {_uniqueStorage()._avgDumpSizeUnOpt = newValue}
+  }
+
   public var unknownFields = SwiftProtobuf.UnknownStorage()
 
   public init() {}
@@ -181,12 +226,6 @@ public struct Fuzzilli_Protobuf_Statistics {
   fileprivate var _storage = _StorageClass.defaultInstance
 }
 
-#if swift(>=5.5) && canImport(_Concurrency)
-extension Fuzzilli_Protobuf_LogMessage: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_FuzzerState: @unchecked Sendable {}
-extension Fuzzilli_Protobuf_Statistics: @unchecked Sendable {}
-#endif  // swift(>=5.5) && canImport(_Concurrency)
-
 // MARK: - Code below here is support for the SwiftProtobuf runtime.
 
 fileprivate let _protobuf_package = "fuzzilli.protobuf"
@@ -202,14 +241,11 @@ extension Fuzzilli_Protobuf_LogMessage: SwiftProtobuf.Message, SwiftProtobuf._Me
 
   public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
     while let fieldNumber = try decoder.nextFieldNumber() {
-      // The use of inline closures is to circumvent an issue where the compiler
-      // allocates stack space for every case branch when no optimizations are
-      // enabled. https://github.com/apple/swift-protobuf/issues/1034
       switch fieldNumber {
-      case 1: try { try decoder.decodeSingularStringField(value: &self.origin) }()
-      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.level) }()
-      case 3: try { try decoder.decodeSingularStringField(value: &self.label) }()
-      case 4: try { try decoder.decodeSingularStringField(value: &self.content) }()
+      case 1: try decoder.decodeSingularStringField(value: &self.origin)
+      case 2: try decoder.decodeSingularUInt32Field(value: &self.level)
+      case 3: try decoder.decodeSingularStringField(value: &self.label)
+      case 4: try decoder.decodeSingularStringField(value: &self.content)
       default: break
       }
     }
@@ -250,12 +286,9 @@ extension Fuzzilli_Protobuf_FuzzerState: SwiftProtobuf.Message, SwiftProtobuf._M
 
   public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
     while let fieldNumber = try decoder.nextFieldNumber() {
-      // The use of inline closures is to circumvent an issue where the compiler
-      // allocates stack space for every case branch when no optimizations are
-      // enabled. https://github.com/apple/swift-protobuf/issues/1034
       switch fieldNumber {
-      case 1: try { try decoder.decodeSingularBytesField(value: &self.corpus) }()
-      case 2: try { try decoder.decodeSingularBytesField(value: &self.evaluatorState) }()
+      case 1: try decoder.decodeSingularBytesField(value: &self.corpus)
+      case 2: try decoder.decodeSingularBytesField(value: &self.evaluatorState)
       default: break
       }
     }
@@ -299,6 +332,15 @@ extension Fuzzilli_Protobuf_Statistics: SwiftProtobuf.Message, SwiftProtobuf._Me
     15: .same(proto: "coverage"),
     16: .same(proto: "correctnessRate"),
     17: .same(proto: "timeoutRate"),
+    18: .same(proto: "differentialSamples"),
+    19: .same(proto: "turbofanSamples"),
+    20: .same(proto: "maglevSamples"),
+    21: .same(proto: "relationsPerformed"),
+    22: .same(proto: "sparkplugSamples"),
+    23: .same(proto: "avgBugOracleTime"),
+    24: .same(proto: "jitSamples"),
+    25: .same(proto: "avgDumpSizeOpt"),
+    26: .same(proto: "avgDumpSizeUnOpt"),
   ]
 
   fileprivate class _StorageClass {
@@ -319,6 +361,15 @@ extension Fuzzilli_Protobuf_Statistics: SwiftProtobuf.Message, SwiftProtobuf._Me
     var _coverage: Double = 0
     var _correctnessRate: Double = 0
     var _timeoutRate: Double = 0
+    var _differentialSamples: UInt64 = 0
+    var _turbofanSamples: UInt64 = 0
+    var _maglevSamples: UInt64 = 0
+    var _relationsPerformed: UInt64 = 0
+    var _sparkplugSamples: UInt64 = 0
+    var _avgBugOracleTime: Double = 0
+    var _jitSamples: UInt64 = 0
+    var _avgDumpSizeOpt: Double = 0
+    var _avgDumpSizeUnOpt: Double = 0
 
     static let defaultInstance = _StorageClass()
 
@@ -342,6 +393,15 @@ extension Fuzzilli_Protobuf_Statistics: SwiftProtobuf.Message, SwiftProtobuf._Me
       _coverage = source._coverage
       _correctnessRate = source._correctnessRate
       _timeoutRate = source._timeoutRate
+      _differentialSamples = source._differentialSamples
+      _turbofanSamples = source._turbofanSamples
+      _maglevSamples = source._maglevSamples
+      _relationsPerformed = source._relationsPerformed
+      _sparkplugSamples = source._sparkplugSamples
+      _avgBugOracleTime = source._avgBugOracleTime
+      _jitSamples = source._jitSamples
+      _avgDumpSizeOpt = source._avgDumpSizeOpt
+      _avgDumpSizeUnOpt = source._avgDumpSizeUnOpt
     }
   }
 
@@ -356,27 +416,33 @@ extension Fuzzilli_Protobuf_Statistics: SwiftProtobuf.Message, SwiftProtobuf._Me
     _ = _uniqueStorage()
     try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
       while let fieldNumber = try decoder.nextFieldNumber() {
-        // The use of inline closures is to circumvent an issue where the compiler
-        // allocates stack space for every case branch when no optimizations are
-        // enabled. https://github.com/apple/swift-protobuf/issues/1034
         switch fieldNumber {
-        case 1: try { try decoder.decodeSingularUInt64Field(value: &_storage._totalSamples) }()
-        case 2: try { try decoder.decodeSingularUInt64Field(value: &_storage._validSamples) }()
-        case 3: try { try decoder.decodeSingularUInt64Field(value: &_storage._interestingSamples) }()
-        case 4: try { try decoder.decodeSingularUInt64Field(value: &_storage._timedOutSamples) }()
-        case 5: try { try decoder.decodeSingularUInt64Field(value: &_storage._crashingSamples) }()
-        case 6: try { try decoder.decodeSingularUInt64Field(value: &_storage._totalExecs) }()
-        case 7: try { try decoder.decodeSingularDoubleField(value: &_storage._avgCorpusSize) }()
-        case 8: try { try decoder.decodeSingularDoubleField(value: &_storage._avgProgramSize) }()
-        case 9: try { try decoder.decodeSingularDoubleField(value: &_storage._avgCorpusProgramSize) }()
-        case 10: try { try decoder.decodeSingularDoubleField(value: &_storage._avgExecutionTime) }()
-        case 11: try { try decoder.decodeSingularDoubleField(value: &_storage._execsPerSecond) }()
-        case 12: try { try decoder.decodeSingularDoubleField(value: &_storage._fuzzerOverhead) }()
-        case 13: try { try decoder.decodeSingularDoubleField(value: &_storage._minimizationOverhead) }()
-        case 14: try { try decoder.decodeSingularUInt64Field(value: &_storage._numChildNodes) }()
-        case 15: try { try decoder.decodeSingularDoubleField(value: &_storage._coverage) }()
-        case 16: try { try decoder.decodeSingularDoubleField(value: &_storage._correctnessRate) }()
-        case 17: try { try decoder.decodeSingularDoubleField(value: &_storage._timeoutRate) }()
+        case 1: try decoder.decodeSingularUInt64Field(value: &_storage._totalSamples)
+        case 2: try decoder.decodeSingularUInt64Field(value: &_storage._validSamples)
+        case 3: try decoder.decodeSingularUInt64Field(value: &_storage._interestingSamples)
+        case 4: try decoder.decodeSingularUInt64Field(value: &_storage._timedOutSamples)
+        case 5: try decoder.decodeSingularUInt64Field(value: &_storage._crashingSamples)
+        case 6: try decoder.decodeSingularUInt64Field(value: &_storage._totalExecs)
+        case 7: try decoder.decodeSingularDoubleField(value: &_storage._avgCorpusSize)
+        case 8: try decoder.decodeSingularDoubleField(value: &_storage._avgProgramSize)
+        case 9: try decoder.decodeSingularDoubleField(value: &_storage._avgCorpusProgramSize)
+        case 10: try decoder.decodeSingularDoubleField(value: &_storage._avgExecutionTime)
+        case 11: try decoder.decodeSingularDoubleField(value: &_storage._execsPerSecond)
+        case 12: try decoder.decodeSingularDoubleField(value: &_storage._fuzzerOverhead)
+        case 13: try decoder.decodeSingularDoubleField(value: &_storage._minimizationOverhead)
+        case 14: try decoder.decodeSingularUInt64Field(value: &_storage._numChildNodes)
+        case 15: try decoder.decodeSingularDoubleField(value: &_storage._coverage)
+        case 16: try decoder.decodeSingularDoubleField(value: &_storage._correctnessRate)
+        case 17: try decoder.decodeSingularDoubleField(value: &_storage._timeoutRate)
+        case 18: try decoder.decodeSingularUInt64Field(value: &_storage._differentialSamples)
+        case 19: try decoder.decodeSingularUInt64Field(value: &_storage._turbofanSamples)
+        case 20: try decoder.decodeSingularUInt64Field(value: &_storage._maglevSamples)
+        case 21: try decoder.decodeSingularUInt64Field(value: &_storage._relationsPerformed)
+        case 22: try decoder.decodeSingularUInt64Field(value: &_storage._sparkplugSamples)
+        case 23: try decoder.decodeSingularDoubleField(value: &_storage._avgBugOracleTime)
+        case 24: try decoder.decodeSingularUInt64Field(value: &_storage._jitSamples)
+        case 25: try decoder.decodeSingularDoubleField(value: &_storage._avgDumpSizeOpt)
+        case 26: try decoder.decodeSingularDoubleField(value: &_storage._avgDumpSizeUnOpt)
         default: break
         }
       }
@@ -436,6 +502,33 @@ extension Fuzzilli_Protobuf_Statistics: SwiftProtobuf.Message, SwiftProtobuf._Me
       if _storage._timeoutRate != 0 {
         try visitor.visitSingularDoubleField(value: _storage._timeoutRate, fieldNumber: 17)
       }
+      if _storage._differentialSamples != 0 {
+        try visitor.visitSingularUInt64Field(value: _storage._differentialSamples, fieldNumber: 18)
+      }
+      if _storage._turbofanSamples != 0 {
+        try visitor.visitSingularUInt64Field(value: _storage._turbofanSamples, fieldNumber: 19)
+      }
+      if _storage._maglevSamples != 0 {
+        try visitor.visitSingularUInt64Field(value: _storage._maglevSamples, fieldNumber: 20)
+      }
+      if _storage._relationsPerformed != 0 {
+        try visitor.visitSingularUInt64Field(value: _storage._relationsPerformed, fieldNumber: 21)
+      }
+      if _storage._sparkplugSamples != 0 {
+        try visitor.visitSingularUInt64Field(value: _storage._sparkplugSamples, fieldNumber: 22)
+      }
+      if _storage._avgBugOracleTime != 0 {
+        try visitor.visitSingularDoubleField(value: _storage._avgBugOracleTime, fieldNumber: 23)
+      }
+      if _storage._jitSamples != 0 {
+        try visitor.visitSingularUInt64Field(value: _storage._jitSamples, fieldNumber: 24)
+      }
+      if _storage._avgDumpSizeOpt != 0 {
+        try visitor.visitSingularDoubleField(value: _storage._avgDumpSizeOpt, fieldNumber: 25)
+      }
+      if _storage._avgDumpSizeUnOpt != 0 {
+        try visitor.visitSingularDoubleField(value: _storage._avgDumpSizeUnOpt, fieldNumber: 26)
+      }
     }
     try unknownFields.traverse(visitor: &visitor)
   }
@@ -462,6 +555,15 @@ extension Fuzzilli_Protobuf_Statistics: SwiftProtobuf.Message, SwiftProtobuf._Me
         if _storage._coverage != rhs_storage._coverage {return false}
         if _storage._correctnessRate != rhs_storage._correctnessRate {return false}
         if _storage._timeoutRate != rhs_storage._timeoutRate {return false}
+        if _storage._differentialSamples != rhs_storage._differentialSamples {return false}
+        if _storage._turbofanSamples != rhs_storage._turbofanSamples {return false}
+        if _storage._maglevSamples != rhs_storage._maglevSamples {return false}
+        if _storage._relationsPerformed != rhs_storage._relationsPerformed {return false}
+        if _storage._sparkplugSamples != rhs_storage._sparkplugSamples {return false}
+        if _storage._avgBugOracleTime != rhs_storage._avgBugOracleTime {return false}
+        if _storage._jitSamples != rhs_storage._jitSamples {return false}
+        if _storage._avgDumpSizeOpt != rhs_storage._avgDumpSizeOpt {return false}
+        if _storage._avgDumpSizeUnOpt != rhs_storage._avgDumpSizeUnOpt {return false}
         return true
       }
       if !storagesAreEqual {return false}
diff --git a/Sources/Fuzzilli/Protobuf/sync.proto b/Sources/Fuzzilli/Protobuf/sync.proto
index f237d82..bb1942b 100644
--- a/Sources/Fuzzilli/Protobuf/sync.proto
+++ b/Sources/Fuzzilli/Protobuf/sync.proto
@@ -81,4 +81,22 @@ message Statistics {
 
         /// The timeout rate of recently generated programs (number of timeouts divided by number of generated programs).
         double timeoutRate = 17;
+
+        uint64 differentialSamples = 18;
+
+        uint64 turbofanSamples = 19;
+
+        uint64 maglevSamples = 20;
+
+        uint64 relationsPerformed = 21;
+
+        uint64 sparkplugSamples = 22;
+
+        double avgBugOracleTime = 23;
+
+        uint64 jitSamples = 24;
+
+        double avgDumpSizeOpt = 25;
+
+        double avgDumpSizeUnOpt = 26;
 }
diff --git a/Sources/Fuzzilli/Util/MockFuzzer.swift b/Sources/Fuzzilli/Util/MockFuzzer.swift
index be921c9..665b8e9 100644
--- a/Sources/Fuzzilli/Util/MockFuzzer.swift
+++ b/Sources/Fuzzilli/Util/MockFuzzer.swift
@@ -17,22 +17,31 @@ import Foundation
 // Mock implementations of fuzzer components for testing.
 
 struct MockExecution: Execution {
-    let outcome: ExecutionOutcome
+    var outcome: ExecutionOutcome
     let stdout: String
     let stderr: String
     let fuzzout: String
-    let execTime: TimeInterval
+    var execTime: TimeInterval
+    let executionHash: Int
+    var compilersUsed: [JITType]
+    var unOptStdout: String?=nil
+    var optStdout: String?=nil
+    var reproducesInNonReplMode: Bool?=false
+    var bugOracleTime: TimeInterval?=nil
 }
 
 class MockScriptRunner: ScriptRunner {
     var processArguments: [String] = []
 
-    func run(_ script: String, withTimeout timeout: UInt32) -> Execution {
+    func run(_ script: String, withTimeout timeout: UInt32,
+        differentialFuzzingPositionDumpSeed: UInt32) -> Execution {
         return MockExecution(outcome: .succeeded,
                              stdout: "",
                              stderr: "",
                              fuzzout: "",
-                             execTime: TimeInterval(0.1))
+                             execTime: TimeInterval(0.1),
+                             executionHash: 0,
+                             compilersUsed: [])
     }
 
     func setEnvironmentVariable(_ key: String, to value: String) {}
@@ -162,6 +171,7 @@ public func makeMockFuzzer(config maybeConfiguration: Configuration? = nil, engi
 
     // A script runner to execute JavaScript code in an instrumented JS engine.
     let runner = maybeRunner ?? MockScriptRunner()
+    let referenceRunner = maybeRunner ?? MockScriptRunner()
 
     // the mutators to use for this fuzzing engine.
     let mutators = WeightedList<Mutator>([
@@ -197,6 +207,7 @@ public func makeMockFuzzer(config maybeConfiguration: Configuration? = nil, engi
     // Construct the fuzzer instance.
     let fuzzer = Fuzzer(configuration: configuration,
                         scriptRunner: runner,
+                        referenceRunner: referenceRunner,
                         engine: engine,
                         mutators: mutators,
                         codeGenerators: codeGenerators,
@@ -206,6 +217,7 @@ public func makeMockFuzzer(config maybeConfiguration: Configuration? = nil, engi
                         lifter: lifter,
                         corpus: corpus,
                         minimizer: minimizer,
+                        localId: 0,
                         queue: DispatchQueue.main)
 
     fuzzer.registerEventListener(for: fuzzer.events.Log) { ev in
diff --git a/Sources/FuzzilliCli/Profiles/DuktapeProfile.swift b/Sources/FuzzilliCli/Profiles/DuktapeProfile.swift
index 8d38b9b..bcba056 100644
--- a/Sources/FuzzilliCli/Profiles/DuktapeProfile.swift
+++ b/Sources/FuzzilliCli/Profiles/DuktapeProfile.swift
@@ -19,6 +19,8 @@ let duktapeProfile = Profile(
         ["--reprl"]
     },
 
+    processArgsReference: ["--reprl"],
+
     processEnv: ["UBSAN_OPTIONS": "handle_segv=0"],
 
     maxExecsBeforeRespawn: 1000,
@@ -26,6 +28,7 @@ let duktapeProfile = Profile(
     timeout: 250,
 
     codePrefix: """
+                const fhash = () => null;
                 """,
 
     codeSuffix: """
@@ -35,6 +38,10 @@ let duktapeProfile = Profile(
 
     crashTests: ["fuzzilli('FUZZILLI_CRASH', 0)", "fuzzilli('FUZZILLI_CRASH', 1)"],
 
+    differentialTests: [],
+
+    differentialTestsInvariant: [],
+
     additionalCodeGenerators: [],
 
     additionalProgramTemplates: WeightedList<ProgramTemplate>([]),
diff --git a/Sources/FuzzilliCli/Profiles/JSCProfile.swift b/Sources/FuzzilliCli/Profiles/JSCProfile.swift
index ee6a2f3..11c29b1 100644
--- a/Sources/FuzzilliCli/Profiles/JSCProfile.swift
+++ b/Sources/FuzzilliCli/Profiles/JSCProfile.swift
@@ -36,10 +36,14 @@ fileprivate let GcGenerator = CodeGenerator("GcGenerator") { b in
     b.callFunction(b.loadBuiltin("gc"))
 }
 
+fileprivate let commonArgs = [
+    "--validateOptions=true",
+    "--reprl",
+]
+
 let jscProfile = Profile(
     processArgs: { randomize in
-        var args = [
-            "--validateOptions=true",
+        var args = commonArgs + [
             // No need to call functions thousands of times before they are JIT compiled
             "--thresholdForJITSoon=10",
             "--thresholdForJITAfterWarmUp=10",
@@ -49,8 +53,7 @@ let jscProfile = Profile(
             "--thresholdForFTLOptimizeAfterWarmUp=1000",
             "--thresholdForFTLOptimizeSoon=1000",
             // Enable bounds check elimination validation
-            "--validateBCE=true",
-            "--reprl"]
+            "--validateBCE=true"]
 
         guard randomize else { return args }
 
@@ -69,6 +72,13 @@ let jscProfile = Profile(
         return args
     },
 
+    processArgsReference: commonArgs + [
+                       "--useConcurrentGC=false",
+                       // Disable JIT
+                       "--useFTLJIT=false",
+                       "--useBaselineJIT=false",
+                       "--useDFGJIT=false"],
+
     processEnv: ["UBSAN_OPTIONS":"handle_segv=0"],
 
     maxExecsBeforeRespawn: 1000,
@@ -76,6 +86,7 @@ let jscProfile = Profile(
     timeout: 250,
 
     codePrefix: """
+                const fhash = fuzzilli_hash;
                 """,
 
     codeSuffix: """
@@ -84,7 +95,14 @@ let jscProfile = Profile(
 
     ecmaVersion: ECMAScriptVersion.es6,
 
-    crashTests: ["fuzzilli('FUZZILLI_CRASH', 0)", "fuzzilli('FUZZILLI_CRASH', 1)", "fuzzilli('FUZZILLI_CRASH', 2)"],
+    crashTests: ["fuzzilli('FUZZILLI_CRASH', 0)",
+                 "fuzzilli('FUZZILLI_CRASH', 1)",
+                 "fuzzilli('FUZZILLI_CRASH', 2)"],
+
+    differentialTests: ["fuzzilli_hash(fuzzilli('FUZZILLI_RANDOM'))",],
+
+    differentialTestsInvariant: ["fuzzilli_hash(Math.random())",
+                                 "fuzzilli_hash(Date.now())",],
 
     additionalCodeGenerators: [
         (ForceDFGCompilationGenerator, 5),
diff --git a/Sources/FuzzilliCli/Profiles/JerryscriptProfile.swift b/Sources/FuzzilliCli/Profiles/JerryscriptProfile.swift
index 3a41c64..cc069b1 100644
--- a/Sources/FuzzilliCli/Profiles/JerryscriptProfile.swift
+++ b/Sources/FuzzilliCli/Profiles/JerryscriptProfile.swift
@@ -19,6 +19,8 @@ let jerryscriptProfile = Profile(
         ["--reprl-fuzzilli"]
     },
 
+    processArgsReference: ["--reprl-fuzzilli"],
+
     processEnv: ["UBSAN_OPTIONS":"handle_segv=0"],
 
     maxExecsBeforeRespawn: 1000,
@@ -26,6 +28,7 @@ let jerryscriptProfile = Profile(
     timeout: 250,
 
     codePrefix: """
+                const fhash = () => null;
                 """,
 
     codeSuffix: """
@@ -35,6 +38,10 @@ let jerryscriptProfile = Profile(
 
     crashTests: ["fuzzilli('FUZZILLI_CRASH', 0)", "fuzzilli('FUZZILLI_CRASH', 1)"],
 
+    differentialTests: [],
+
+    differentialTestsInvariant: [],
+
     additionalCodeGenerators: [],
 
     additionalProgramTemplates: WeightedList<ProgramTemplate>([]),
diff --git a/Sources/FuzzilliCli/Profiles/Profile.swift b/Sources/FuzzilliCli/Profiles/Profile.swift
index 1a02a6d..dcd37d2 100644
--- a/Sources/FuzzilliCli/Profiles/Profile.swift
+++ b/Sources/FuzzilliCli/Profiles/Profile.swift
@@ -14,8 +14,9 @@
 
 import Fuzzilli
 
-struct Profile {
+public struct Profile {
     let processArgs: (_ randomize: Bool) -> [String]
+    let processArgsReference: [String]
     let processEnv: [String : String]
     let maxExecsBeforeRespawn: Int
     // Timeout is in milliseconds.
@@ -28,6 +29,9 @@ struct Profile {
     // Used to verify that crashes can be detected.
     let crashTests: [String]
 
+    let differentialTests: [String]
+    let differentialTestsInvariant: [String]
+
     let additionalCodeGenerators: [(CodeGenerator, Int)]
     let additionalProgramTemplates: WeightedList<ProgramTemplate>
 
@@ -40,7 +44,7 @@ struct Profile {
     let optionalPostProcessor: FuzzingPostProcessor?
 }
 
-let profiles = [
+public let profiles = [
     "qtjs": qtjsProfile,
     "qjs": qjsProfile,
     "jsc": jscProfile,
@@ -49,5 +53,4 @@ let profiles = [
     "duktape": duktapeProfile,
     "jerryscript": jerryscriptProfile,
     "xs": xsProfile,
-    "v8holefuzzing": v8HoleFuzzingProfile,
 ]
diff --git a/Sources/FuzzilliCli/Profiles/QjsProfile.swift b/Sources/FuzzilliCli/Profiles/QjsProfile.swift
index 90bcbf3..68f4ebd 100644
--- a/Sources/FuzzilliCli/Profiles/QjsProfile.swift
+++ b/Sources/FuzzilliCli/Profiles/QjsProfile.swift
@@ -19,6 +19,8 @@ let qjsProfile = Profile(
         ["--reprl"]
     },
 
+    processArgsReference: ["--reprl"],
+
     processEnv: ["UBSAN_OPTIONS": "handle_segv=0"],
 
     maxExecsBeforeRespawn: 1000,
@@ -26,6 +28,7 @@ let qjsProfile = Profile(
     timeout: 250,
 
     codePrefix: """
+                const fhash = () => null;
                 """,
 
     codeSuffix: """
@@ -35,6 +38,11 @@ let qjsProfile = Profile(
 
     crashTests: ["fuzzilli('FUZZILLI_CRASH', 0)", "fuzzilli('FUZZILLI_CRASH', 1)", "fuzzilli('FUZZILLI_CRASH', 2)"],
 
+    differentialTests: [],
+
+    differentialTestsInvariant: [],
+
+
     additionalCodeGenerators: [],
 
     additionalProgramTemplates: WeightedList<ProgramTemplate>([]),
diff --git a/Sources/FuzzilliCli/Profiles/QtjsProfile.swift b/Sources/FuzzilliCli/Profiles/QtjsProfile.swift
index 7595516..3ba7fc4 100644
--- a/Sources/FuzzilliCli/Profiles/QtjsProfile.swift
+++ b/Sources/FuzzilliCli/Profiles/QtjsProfile.swift
@@ -27,6 +27,8 @@ let qtjsProfile = Profile(
         ["-reprl"]
     },
 
+    processArgsReference: ["-reprl"],
+
     processEnv: ["UBSAN_OPTIONS":"handle_segv=0"],
 
     maxExecsBeforeRespawn: 1000,
@@ -34,6 +36,7 @@ let qtjsProfile = Profile(
     timeout: 250,
 
     codePrefix: """
+                const fhash = () => null;
                 """,
 
     codeSuffix: """
@@ -45,6 +48,10 @@ let qtjsProfile = Profile(
     // Used to verify that crashes can be detected.
     crashTests: ["fuzzilli('FUZZILLI_CRASH', 0)"],
 
+    differentialTests: [],
+
+    differentialTestsInvariant: [],
+
     additionalCodeGenerators: [
         (ForceQV4JITGenerator,    20),
     ],
@@ -57,6 +64,7 @@ let qtjsProfile = Profile(
 
     additionalBuiltins: [
         "gc"                : .function([] => .undefined),
+        "placeholder"   : .function([] => .undefined),
     ],
 
     optionalPostProcessor: nil
diff --git a/Sources/FuzzilliCli/Profiles/SpidermonkeyProfile.swift b/Sources/FuzzilliCli/Profiles/SpidermonkeyProfile.swift
index 081cbd3..4d7aced 100644
--- a/Sources/FuzzilliCli/Profiles/SpidermonkeyProfile.swift
+++ b/Sources/FuzzilliCli/Profiles/SpidermonkeyProfile.swift
@@ -27,16 +27,25 @@ fileprivate let GcGenerator = CodeGenerator("GcGenerator") { b in
     b.callFunction(b.loadBuiltin("gc"))
 }
 
+fileprivate let commonArgs = [
+    "--baseline-warmup-threshold=10",
+    "--fuzzing-safe",
+    "--disable-oom-functions",
+    "--reprl"
+]
+
+fileprivate let differentialArgs = [
+    "--differential-testing"
+]
+
 let spidermonkeyProfile = Profile(
     processArgs: { randomize in
-        var args = [
-            "--baseline-warmup-threshold=10",
+        var args = commonArgs + [
             "--ion-warmup-threshold=100",
             "--ion-check-range-analysis",
             "--ion-extra-checks",
-            "--fuzzing-safe",
-            "--disable-oom-functions",
-            "--reprl"]
+            ]
+
 
         guard randomize else { return args }
 
@@ -70,6 +79,11 @@ let spidermonkeyProfile = Profile(
         return args
     },
 
+    processArgsReference: commonArgs + differentialArgs + [
+        "--no-threads",
+        "--no-ion",
+    ],
+
     processEnv: ["UBSAN_OPTIONS": "handle_segv=0"],
 
     maxExecsBeforeRespawn: 1000,
@@ -77,6 +91,7 @@ let spidermonkeyProfile = Profile(
     timeout: 250,
 
     codePrefix: """
+                const fhash = fuzzilli_hash;
                 """,
 
     codeSuffix: """
@@ -85,7 +100,14 @@ let spidermonkeyProfile = Profile(
 
     ecmaVersion: ECMAScriptVersion.es6,
 
-    crashTests: ["fuzzilli('FUZZILLI_CRASH', 0)", "fuzzilli('FUZZILLI_CRASH', 1)", "fuzzilli('FUZZILLI_CRASH', 2)"],
+    crashTests: ["fuzzilli('FUZZILLI_CRASH', 0)",
+                 "fuzzilli('FUZZILLI_CRASH', 1)",
+                 "fuzzilli('FUZZILLI_CRASH', 2)"],
+
+    differentialTests: ["for(let i=0; i<200; i++) {fuzzilli_hash(fuzzilli('FUZZILLI_RANDOM'))}",],
+
+    differentialTestsInvariant: ["for(let i=0; i < 200; i++) {fuzzilli_hash(Math.random())}",
+                                 "for(let i=0; i < 200; i++) {fuzzilli_hash(Date.now())}",],
 
     additionalCodeGenerators: [
         (ForceSpidermonkeyIonGenerator, 10),
diff --git a/Sources/FuzzilliCli/Profiles/V8HoleFuzzingProfile.swift b/Sources/FuzzilliCli/Profiles/V8HoleFuzzingProfile.swift
deleted file mode 100644
index 1fcf1e3..0000000
--- a/Sources/FuzzilliCli/Profiles/V8HoleFuzzingProfile.swift
+++ /dev/null
@@ -1,106 +0,0 @@
-// Copyright 2023 Google LLC
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-// https://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-import Fuzzilli
-
-// TODO: move common parts (e.g. generators) into a V8CommonProfile.swift.
-fileprivate let ForceJITCompilationThroughLoopGenerator = CodeGenerator("ForceJITCompilationThroughLoopGenerator", inputs: .required(.function())) { b, f in
-    assert(b.type(of: f).Is(.function()))
-    let arguments = b.randomArguments(forCalling: f)
-    b.buildRepeatLoop(n: 100) { _ in
-        b.callFunction(f, withArgs: arguments)
-    }
-}
-fileprivate let ForceTurboFanCompilationGenerator = CodeGenerator("ForceTurboFanCompilationGenerator", inputs: .required(.function())) { b, f in
-    assert(b.type(of: f).Is(.function()))
-    let arguments = b.randomArguments(forCalling: f)
-    b.callFunction(f, withArgs: arguments)
-    b.eval("%PrepareFunctionForOptimization(%@)", with: [f]);
-    b.callFunction(f, withArgs: arguments)
-    b.callFunction(f, withArgs: arguments)
-    b.eval("%OptimizeFunctionOnNextCall(%@)", with: [f]);
-    b.callFunction(f, withArgs: arguments)
-}
-fileprivate let ForceMaglevCompilationGenerator = CodeGenerator("ForceMaglevCompilationGenerator", inputs: .required(.function())) { b, f in
-    assert(b.type(of: f).Is(.function()))
-    let arguments = b.randomArguments(forCalling: f)
-    b.callFunction(f, withArgs: arguments)
-    b.eval("%PrepareFunctionForOptimization(%@)", with: [f]);
-    b.callFunction(f, withArgs: arguments)
-    b.callFunction(f, withArgs: arguments)
-    b.eval("%OptimizeMaglevOnNextCall(%@)", with: [f]);
-    b.callFunction(f, withArgs: arguments)
-}
-// Insert random GC calls throughout our code.
-fileprivate let GcGenerator = CodeGenerator("GcGenerator") { b in
-    let gc = b.loadBuiltin("gc")
-    // Do minor GCs more frequently.
-    let type = b.loadString(probability(0.25) ? "major" : "minor")
-    // If the execution type is 'async', gc() returns a Promise, we currently
-    // do not really handle other than typing the return of gc to .undefined |
-    // .jsPromise. One could either chain a .then or create two wrapper
-    // functions that are differently typed such that fuzzilli always knows
-    // what the type of the return value is.
-    let execution = b.loadString(probability(0.5) ? "sync" : "async")
-    b.callFunction(gc, withArgs: [b.createObject(with: ["type": type, "execution": execution])])
-}
-
-// This value generator inserts Hole leaks into the program.  Use this if you
-// want to fuzz for Memory Corruption using holes, this should be used in
-// conjunction with the --hole-fuzzing runtime flag.
-fileprivate let HoleLeakGenerator = ValueGenerator("HoleLeakGenerator") { b, args in
-    b.eval("%LeakHole()", hasOutput: true)
-}
-
-let v8HoleFuzzingProfile = Profile(
-    processArgs: { randomize in
-        var args = [
-            "--expose-gc",
-            "--omit-quit",
-            "--allow-natives-syntax",
-            "--fuzzing",
-            "--hole-fuzzing",
-            "--jit-fuzzing",
-            "--future",
-            "--harmony",
-        ]
-        return args
-    },
-    processEnv: [:],
-    maxExecsBeforeRespawn: 1000,
-    timeout: 250,
-    codePrefix: """
-                """,
-    codeSuffix: """
-                """,
-    ecmaVersion: ECMAScriptVersion.es6,
-    crashTests: ["fuzzilli('FUZZILLI_CRASH', 0)", "fuzzilli('FUZZILLI_CRASH', 7)"],
-    additionalCodeGenerators: [
-        (ForceJITCompilationThroughLoopGenerator,  5),
-        (ForceTurboFanCompilationGenerator,        5),
-        (ForceMaglevCompilationGenerator,          5),
-        (GcGenerator,                             10),
-        (HoleLeakGenerator,                       25),
-    ],
-    additionalProgramTemplates: WeightedList<ProgramTemplate>([
-    ]),
-    disabledCodeGenerators: [],
-    disabledMutators: [],
-    additionalBuiltins: [
-        "gc"                                            : .function([] => (.undefined | .jsPromise)),
-        "d8"                                            : .object(),
-        "Worker"                                        : .constructor([.anything, .object()] => .object(withMethods: ["postMessage","getMessage"])),
-    ],
-    optionalPostProcessor: nil
-)
diff --git a/Sources/FuzzilliCli/Profiles/V8Profile.swift b/Sources/FuzzilliCli/Profiles/V8Profile.swift
index 6325b44..ae32f8e 100644
--- a/Sources/FuzzilliCli/Profiles/V8Profile.swift
+++ b/Sources/FuzzilliCli/Profiles/V8Profile.swift
@@ -411,131 +411,16 @@ fileprivate let RegExpFuzzer = ProgramTemplate("RegExpFuzzer") { b in
     b.build(n: 15)
 }
 
-let v8Profile = Profile(
-    processArgs: { randomize in
-        var args = [
-            "--expose-gc",
-            "--omit-quit",
-            "--allow-natives-syntax",
-            "--fuzzing",
-            "--jit-fuzzing",
-            "--future",
-            "--harmony",
-            "--js-staging"
-        ]
-
-        guard randomize else { return args }
-
-        //
-        // Existing features that should sometimes be disabled.
-        //
-        if probability(0.1) {
-            args.append("--no-turbofan")
-        }
-
-        if probability(0.1) {
-            args.append("--no-turboshaft")
-        }
-
-        if probability(0.1) {
-            args.append("--no-maglev")
-        }
-
-        if probability(0.1) {
-            args.append("--no-sparkplug")
-        }
-
-        if probability(0.1) {
-            args.append("--no-short-builtin-calls")
-        }
-
-        //
-        // Future features that should sometimes be enabled.
-        //
-        if probability(0.25) {
-            args.append("--minor-ms")
-        }
-
-        if probability(0.25) {
-            args.append("--shared-string-table")
-        }
-
-        if probability(0.25) && !args.contains("--no-maglev") {
-            args.append("--maglev-future")
-        }
-
-        if probability(0.25) && !args.contains("--no-turboshaft") {
-            args.append("--turboshaft-future")
-        }
+fileprivate let config = V8DifferentialConfig()
 
-        if probability(0.1) && !args.contains("--no-turboshaft") {
-            args.append("--turboshaft-typed-optimizations")
-        }
-
-        if probability(0.1) {
-            args.append("--harmony-struct")
-        }
-
-        //
-        // Sometimes enable additional verification/stressing logic (which may be fairly expensive).
-        //
-        if probability(0.1) {
-            args.append("--verify-heap")
-        }
-        if probability(0.1) {
-            args.append("--turbo-verify")
-        }
-        if probability(0.1) {
-            args.append("--turbo-verify-allocation")
-        }
-        if probability(0.1) {
-            args.append("--assert-types")
-        }
-        if probability(0.1) {
-            args.append("--turboshaft-assert-types")
-        }
-        if probability(0.1) {
-            args.append("--deopt-every-n-times=\(chooseUniform(from: [100, 250, 500, 1000, 2500, 5000, 10000]))")
-        }
-
-        //
-        // More exotic configuration changes.
-        //
-        if probability(0.05) {
-            if probability(0.5) { args.append("--stress-gc-during-compilation") }
-            if probability(0.5) { args.append("--lazy-new-space-shrinking") }
-
-            args.append(probability(0.5) ? "--always-sparkplug" : "--no-always-sparkplug")
-            args.append(probability(0.5) ? "--always-osr" : "--no-always-osr")
-            args.append(probability(0.5) ? "--concurrent-osr" : "--no-concurrent-osr")
-            args.append(probability(0.5) ? "--force-slow-path" : "--no-force-slow-path")
-
-            // Maglev related flags
-            args.append(probability(0.5) ? "--maglev-inline-api-calls" : "--no-maglev-inline-api-calls")
-
-            // Compiler related flags
-            args.append(probability(0.5) ? "--always-turbofan" : "--no-always-turbofan")
-            args.append(probability(0.5) ? "--turbo-move-optimization" : "--no-turbo-move-optimization")
-            args.append(probability(0.5) ? "--turbo-jt" : "--no-turbo-jt")
-            args.append(probability(0.5) ? "--turbo-loop-peeling" : "--no-turbo-loop-peeling")
-            args.append(probability(0.5) ? "--turbo-loop-variable" : "--no-turbo-loop-variable")
-            args.append(probability(0.5) ? "--turbo-loop-rotation" : "--no-turbo-loop-rotation")
-            args.append(probability(0.5) ? "--turbo-cf-optimization" : "--no-turbo-cf-optimization")
-            args.append(probability(0.5) ? "--turbo-escape" : "--no-turbo-escape")
-            args.append(probability(0.5) ? "--turbo-allocation-folding" : "--no-turbo-allocation-folding")
-            args.append(probability(0.5) ? "--turbo-instruction-scheduling" : "--no-turbo-instruction-scheduling")
-            args.append(probability(0.5) ? "--turbo-stress-instruction-scheduling" : "--no-turbo-stress-instruction-scheduling")
-            args.append(probability(0.5) ? "--turbo-store-elimination" : "--no-turbo-store-elimination")
-            args.append(probability(0.5) ? "--turbo-rewrite-far-jumps" : "--no-turbo-rewrite-far-jumps")
-            args.append(probability(0.5) ? "--turbo-optimize-apply" : "--no-turbo-optimize-apply")
-            args.append(chooseUniform(from: ["--no-enable-sse3", "--no-enable-ssse3", "--no-enable-sse4-1", "--no-enable-sse4-2", "--no-enable-avx", "--no-enable-avx2"]))
-            args.append(probability(0.5) ? "--turbo-load-elimination" : "--no-turbo-load-elimination")
-            args.append(probability(0.5) ? "--turbo-inlining" : "--no-turbo-inlining")
-            args.append(probability(0.5) ? "--turbo-splitting" : "--no-turbo-splitting")
-        }
+let v8Profile = Profile(
+    processArgs: { _ in
+                    var args = config.commonArgs
+                    args.append(contentsOf: config.differentialArgs)
+                    return args
+                 },
 
-        return args
-    },
+    processArgsReference: config.commonArgs + config.referenceArgs,
 
     processEnv: [:],
 
@@ -543,8 +428,9 @@ let v8Profile = Profile(
 
     timeout: 250,
 
-    codePrefix: """
-                """,
+     codePrefix: """
+%EnableFrameDumping();
+""",
 
     codeSuffix: """
                 """,
@@ -553,6 +439,10 @@ let v8Profile = Profile(
 
     crashTests: ["fuzzilli('FUZZILLI_CRASH', 0)", "fuzzilli('FUZZILLI_CRASH', 1)", "fuzzilli('FUZZILLI_CRASH', 2)", "fuzzilli('FUZZILLI_CRASH', 3)"],
 
+    differentialTests: [],
+
+    differentialTestsInvariant: [],
+
     additionalCodeGenerators: [
         (ForceJITCompilationThroughLoopGenerator,  5),
         (ForceTurboFanCompilationGenerator,        5),
diff --git a/Sources/FuzzilliCli/Profiles/XSProfile.swift b/Sources/FuzzilliCli/Profiles/XSProfile.swift
index 422ecc4..55a6239 100644
--- a/Sources/FuzzilliCli/Profiles/XSProfile.swift
+++ b/Sources/FuzzilliCli/Profiles/XSProfile.swift
@@ -19,6 +19,8 @@ let xsProfile = Profile(
         ["-f"]
     },
 
+    processArgsReference: ["-f"],
+
     processEnv: ["UBSAN_OPTIONS":"handle_segv=0"],
 
     maxExecsBeforeRespawn: 1000,
@@ -26,6 +28,7 @@ let xsProfile = Profile(
     timeout: 250,
 
     codePrefix: """
+                const fhash = () => null;
                 """,
 
     codeSuffix: """
@@ -36,6 +39,11 @@ let xsProfile = Profile(
 
     crashTests: ["fuzzilli('FUZZILLI_CRASH', 0)", "fuzzilli('FUZZILLI_CRASH', 1)", "fuzzilli('FUZZILLI_CRASH', 2)"],
 
+    differentialTests: ["fuzzilli_hash(fuzzilli('FUZZILLI_RANDOM'))",],
+
+    differentialTestsInvariant: ["fuzzilli_hash(Math.random())",
+                                 "fuzzilli_hash(Date.now())",],
+
     additionalCodeGenerators: [],
 
     additionalProgramTemplates: WeightedList<ProgramTemplate>([]),
diff --git a/Sources/FuzzilliCli/TerminalUI.swift b/Sources/FuzzilliCli/TerminalUI.swift
index 1bb5f1c..0d3eed9 100644
--- a/Sources/FuzzilliCli/TerminalUI.swift
+++ b/Sources/FuzzilliCli/TerminalUI.swift
@@ -38,6 +38,40 @@ class TerminalUI {
         }
     }
 
+    private func getProcessIDsForD8(_ d8Path: String) -> [pid_t] {
+        var pids: [pid_t] = []
+
+        let task = Process()
+        task.executableURL = URL(fileURLWithPath: "/bin/ps")
+        task.arguments = ["-e", "-o", "pid,command"]
+
+        let pipe = Pipe()
+        task.standardOutput = pipe
+
+        do {
+            try task.run()
+        } catch  {
+            return []
+        }
+
+        let data = pipe.fileHandleForReading.readDataToEndOfFile()
+        if let output = String(data: data, encoding: .utf8) {
+            let lines = output.components(separatedBy: "\n")
+            for line in lines {
+                if line.contains(d8Path) && !line.contains("ps -e -o pid,command") && !line.contains("FuzzilliCli") {
+                    let components = line.trimmingCharacters(in: .whitespacesAndNewlines).components(separatedBy: " ")
+                    if let pid = pid_t(components[0]) {
+                        pids.append(pid)
+                    }
+                }
+            }
+        }
+
+        task.waitUntilExit()
+
+        return pids
+    }
+
     func initOnFuzzerQueue(_ fuzzer: Fuzzer) {
         // Register log event listener now to be able to print log messages
         // generated during fuzzer initialization
@@ -52,6 +86,13 @@ class TerminalUI {
             }
         }
 
+        fuzzer.registerEventListener(for: fuzzer.events.DifferentialFound) { diff in
+            if diff.reproducesInNonReplMode {
+                print("########## Unique Differential Found ##########")
+                print(fuzzer.lifter.lift(diff.program, withOptions: .includeComments))
+            }
+        }
+
         fuzzer.registerEventListener(for: fuzzer.events.CrashFound) { crash in
             if crash.isUnique {
                 print("########## Unique Crash Found ##########")
@@ -90,12 +131,41 @@ class TerminalUI {
                     print()
                 }
 
+                // Nuke stray d8 processes. Pretty terrible but it is what it is
+                // With default timeout 250ms this will nuke a d8 process if it survives longer than ~30 minutes
+                fuzzer.timers.scheduleTask(every: (15 * Minutes + Double.random(in: (1 * Minutes)...(10 * Minutes)))) {
+                    let nukeAfterSeconds = ((Double(fuzzer.config.timeout) / 1000.0) * 8.0) * Double((fuzzer.runner as! REPRL).maxExecsBeforeRespawn)
+                    let d8Path = fuzzer.runner.processArguments[0]
+                    let pids = self.getProcessIDsForD8(d8Path)
+                    for p in pids {
+                        let statFilePath = "/proc/\(p)/stat"
+
+                        var fileStats = stat()
+
+                        if stat(statFilePath, &fileStats) == 0 {
+                            let accessTime = Double(fileStats.st_atim.tv_sec)
+
+                            let currentTime = Date().timeIntervalSince1970
+
+                            let secondsElapsed = currentTime - accessTime
+                            if (secondsElapsed >= nukeAfterSeconds) {
+                                let result = kill(p, SIGKILL)
+                                if result == 0 {
+                                    print("Nuked stray d8 process \(p)")
+                                }
+                            }
+                        }
+                    }
+                }
+
                 // Randomly sample generated and interesting programs and print them.
                 // The goal of this is to give users a better "feeling" for what the fuzzer is currently doing.
+                /*
                 fuzzer.timers.scheduleTask(every: 5 * Minutes) {
                     self.printNextInterestingProgram = true
                     self.printNextGeneratedProgram = true
                 }
+                */
             }
         }
     }
@@ -125,28 +195,49 @@ class TerminalUI {
         } else {
             print("Fuzzer Statistics")
         }
+
+        let bugOracleUsageRate = (Float(stats.relationsPerformed) / Float(stats.totalExecs)) * 100
+        let jitUsageRate = (Float(stats.jitSamples) / Float(stats.totalExecs)) * 100
+
+        let cestDateFormatter = DateFormatter()
+        cestDateFormatter.dateFormat = "HH:mm:ss - dd.MM.yyyy"
+
+        cestDateFormatter.timeZone = TimeZone(abbreviation: "CEST")
+        let date = Date()
+
         print("""
         -----------------
-        Fuzzer state:                 \(state)
-        Uptime:                       \(formatTimeInterval(fuzzer.uptime()))
-        Total Samples:                \(stats.totalSamples)
-        Interesting Samples Found:    \(stats.interestingSamples)
-        Last Interesting Sample:      \(formatTimeInterval(timeSinceLastInterestingProgram))
-        Valid Samples Found:          \(stats.validSamples)
-        Corpus Size:                  \(fuzzer.corpus.size)\(maybeAvgCorpusSize)
-        Correctness Rate:             \(String(format: "%.2f%%", stats.correctnessRate * 100)) (overall: \(String(format: "%.2f%%", stats.overallCorrectnessRate * 100)))
-        Timeout Rate:                 \(String(format: "%.2f%%", stats.timeoutRate * 100)) (overall: \(String(format: "%.2f%%", stats.overallTimeoutRate * 100)))
-        Crashes Found:                \(stats.crashingSamples)
-        Timeouts Hit:                 \(stats.timedOutSamples)
-        Coverage:                     \(String(format: "%.2f%%", stats.coverage * 100))
-        Avg. program size:            \(String(format: "%.2f", stats.avgProgramSize))
-        Avg. corpus program size:     \(String(format: "%.2f", stats.avgCorpusProgramSize))
-        Avg. program execution time:  \(Int(stats.avgExecutionTime * 1000))ms
-        Connected nodes:              \(stats.numChildNodes)
-        Execs / Second:               \(String(format: "%.2f", stats.execsPerSecond))
-        Fuzzer Overhead:              \(String(format: "%.2f", stats.fuzzerOverhead * 100))%
-        Minimization Overhead:        \(String(format: "%.2f", stats.minimizationOverhead * 100))%
-        Total Execs:                  \(stats.totalExecs)
+        Fuzzer state:                   \(state)
+        Uptime:                         \(formatTimeInterval(fuzzer.uptime()))
+        Current Time:                   \(cestDateFormatter.string(from: date))
+        Total Samples:                  \(stats.totalSamples)
+        Interesting Samples Found:      \(stats.interestingSamples)
+        Last Interesting Sample:        \(formatTimeInterval(timeSinceLastInterestingProgram))
+        Valid Samples Found:            \(stats.validSamples)
+        Corpus Size:                    \(fuzzer.corpus.size)\(maybeAvgCorpusSize)
+        Correctness Rate:               \(String(format: "%.2f%%", stats.correctnessRate * 100)) (overall: \(String(format: "%.2f%%", stats.overallCorrectnessRate * 100)))
+        Timeout Rate:                   \(String(format: "%.2f%%", stats.timeoutRate * 100)) (overall: \(String(format: "%.2f%%", stats.overallTimeoutRate * 100)))
+        Crashes Found:                  \(stats.crashingSamples)
+        Differentials Found:            \(stats.differentialSamples)
+        Sparkplug Executions:           \(stats.sparkplugSamples)
+        Maglev Executions:              \(stats.maglevSamples)
+        TurboFan Executions:            \(stats.turbofanSamples)
+        Relations Performed:            \(stats.relationsPerformed)
+        Bug Oracle Usage:               \(String(format: "%.2f%%", bugOracleUsageRate))
+        JIT Usage Rate:                 \(String(format: "%.2f%%", jitUsageRate))
+        Timeouts Hit:                   \(stats.timedOutSamples)
+        Coverage:                       \(String(format: "%.2f%%", stats.coverage * 100))
+        Avg. program size:              \(String(format: "%.2f", stats.avgProgramSize))
+        Avg. corpus program size:       \(String(format: "%.2f", stats.avgCorpusProgramSize))
+        Avg. program execution time:    \(Int(stats.avgExecutionTime * 1000))ms
+        Avg. bug oracle execution time: \(Int(stats.avgBugOracleTime * 1000))ms
+        Avg. dump size (opt):           \(String(format: "%.2f", stats.avgDumpSizeOpt / 1000.0))KB
+        Avg. dump size (unopt):         \(String(format: "%.2f", stats.avgDumpSizeUnOpt / 1000.0))KB
+        Connected nodes:                \(stats.numChildNodes)
+        Execs / Second:                 \(String(format: "%.2f", stats.execsPerSecond))
+        Fuzzer Overhead:                \(String(format: "%.2f", stats.fuzzerOverhead * 100))%
+        Minimization Overhead:          \(String(format: "%.2f", stats.minimizationOverhead * 100))%
+        Total Execs:                    \(stats.totalExecs)
         """)
     }
 
diff --git a/Sources/FuzzilliCli/main.swift b/Sources/FuzzilliCli/main.swift
index 98a9787..736e7de 100644
--- a/Sources/FuzzilliCli/main.swift
+++ b/Sources/FuzzilliCli/main.swift
@@ -97,6 +97,9 @@ Options:
     --additionalArguments=args   : Pass additional arguments to the JS engine. If multiple arguments are passed, they should be separated by a comma.
     --tag=tag                    : Optional string tag associated with this instance which will be stored in the settings.json file as well as in crashing samples.
                                    This can for example be used to remember the target revision that is being fuzzed.
+    --dumpling-depth             : Depth used during dumping to traverse objects (default: 3)
+    --dumpling-prop-count        : Amount of properties/array elements to consider during dumping (default: 5)
+
 """)
     exit(0)
 }
@@ -152,6 +155,9 @@ let swarmTesting = args.has("--swarmTesting")
 let argumentRandomization = args.has("--argumentRandomization")
 let additionalArguments = args["--additionalArguments"] ?? ""
 let tag = args["--tag"]
+let dumplingDepth = UInt32(args.int(for: "--dumpling-depth") ?? 3)
+let dumplingPropCount = UInt32(args.int(for: "--dumpling-prop-count") ?? 5)
+
 
 guard numJobs >= 1 else {
     configError("Must have at least 1 job")
@@ -363,12 +369,16 @@ func loadCorpus(from dirPath: String) -> [Program] {
 // When using multiple jobs, all Fuzzilli instances should use the same arguments for the JS shell, even if
 // argument randomization is enabled. This way, their corpora are "compatible" and crashes that require
 // (a subset of) the randomly chosen flags can be reproduced on the main instance.
-let jsShellArguments = profile.processArgs(argumentRandomization) + additionalArguments.split(separator: ",").map(String.init)
+let jsShellArguments = profile.processArgs(argumentRandomization) + additionalArguments.split(separator: ",").map(String.init) + ["--dumpling-depth=\(dumplingDepth)", "--dumpling-prop-count=\(dumplingPropCount)"]
 logger.info("Using the following arguments for the target engine: \(jsShellArguments)")
+let jsShellRefArguments = profile.processArgsReference + ["--dumpling-depth=\(dumplingDepth)", "--dumpling-prop-count=\(dumplingPropCount)"]
+
+func makeFuzzer(with configuration: Configuration, localId: UInt32) -> Fuzzer {
+    assert(localId >= 1)
 
-func makeFuzzer(with configuration: Configuration) -> Fuzzer {
     // A script runner to execute JavaScript code in an instrumented JS engine.
     let runner = REPRL(executable: jsShellPath, processArguments: jsShellArguments, processEnvironment: profile.processEnv, maxExecsBeforeRespawn: profile.maxExecsBeforeRespawn)
+    let referenceRunner = REPRL(executable: jsShellPath, processArguments: jsShellRefArguments, processEnvironment: profile.processEnv, maxExecsBeforeRespawn: profile.maxExecsBeforeRespawn)
 
     /// The mutation fuzzer responsible for mutating programs from the corpus and evaluating the outcome.
     let disabledMutators = Set(profile.disabledMutators)
@@ -461,10 +471,11 @@ func makeFuzzer(with configuration: Configuration) -> Fuzzer {
 
     // Minimizer to minimize crashes and interesting programs.
     let minimizer = Minimizer()
-    
+
     // Construct the fuzzer instance.
     return Fuzzer(configuration: configuration,
                   scriptRunner: runner,
+                  referenceRunner: referenceRunner,
                   engine: engine,
                   mutators: mutators,
                   codeGenerators: codeGenerators,
@@ -473,21 +484,45 @@ func makeFuzzer(with configuration: Configuration) -> Fuzzer {
                   environment: environment,
                   lifter: lifter,
                   corpus: corpus,
-                  minimizer: minimizer)
+                  minimizer: minimizer,
+                  localId: localId)
 }
 
+let cwd = FileManager.default.currentDirectoryPath
+#if DEBUG
+    public let relateToolPath = "\(cwd)/.build/debug/RelateTool"
+#else
+    public let relateToolPath = "\(cwd)/.build/release/RelateTool"
+#endif
+if !FileManager.default.fileExists(atPath: relateToolPath) {
+    logger.fatal("RelateTool not found in cwd (\(relateToolPath))")
+}
+if !FileManager.default.fileExists(atPath: "/usr/bin/timeout") {
+    logger.fatal("/usr/bin/timeout not found")
+}
+if !FileManager.default.fileExists(atPath: "/bin/ps") {
+    logger.fatal("/bin/ps not found")
+}
+
+
 // The configuration of the main fuzzer instance.
 let mainConfig = Configuration(arguments: CommandLine.arguments,
                                timeout: UInt32(timeout),
                                logLevel: logLevel,
                                crashTests: profile.crashTests,
+                               differentialTests: profile.differentialTests,
+                               differentialTestsInvariant: profile.differentialTestsInvariant,
                                minimizationLimit: minimizationLimit,
                                enableDiagnostics: diagnostics,
                                enableInspection: inspect,
                                staticCorpus: staticCorpus,
-                               tag: tag)
+                               tag: tag,
+                               relateToolPath: relateToolPath,
+                               dumplingDepth: dumplingDepth,
+                               dumplingPropCount: dumplingPropCount,
+                               storagePath: storagePath)
 
-let fuzzer = makeFuzzer(with: mainConfig)
+let fuzzer = makeFuzzer(with: mainConfig, localId: 1)
 
 // Create a "UI". We do this now, before fuzzer initialization, so
 // we are able to print log messages generated during initialization.
@@ -514,9 +549,6 @@ fuzzer.sync {
     // Always want some statistics.
     fuzzer.addModule(Statistics())
 
-    // Check core file generation on linux, prior to moving corpus file directories
-    fuzzer.checkCoreFileGeneration()
-
     // Exit this process when the main fuzzer stops.
     fuzzer.registerEventListener(for: fuzzer.events.ShutdownComplete) { reason in
         if resume, let path = storagePath {
@@ -617,20 +649,27 @@ let workerConfig = Configuration(arguments: CommandLine.arguments,
                                  timeout: UInt32(timeout),
                                  logLevel: .warning,
                                  crashTests: profile.crashTests,
+                                 differentialTests: profile.differentialTests,
+                                 differentialTestsInvariant: profile.differentialTestsInvariant,
                                  minimizationLimit: minimizationLimit,
                                  enableDiagnostics: false,
                                  enableInspection: inspect,
                                  staticCorpus: staticCorpus,
-                                 tag: tag)
-
-for _ in 1..<numJobs {
-    let worker = makeFuzzer(with: workerConfig)
+                                 tag: tag,
+                                 relateToolPath: relateToolPath,
+                                 dumplingDepth: dumplingDepth,
+                                 dumplingPropCount: dumplingPropCount,
+                                 storagePath: storagePath)
+
+for i in 1..<numJobs {
+    let localId = UInt32(i + 1);
+    let worker = makeFuzzer(with: workerConfig, localId: localId)
     worker.async {
         // Wait some time between starting workers to reduce the load on the main instance.
         // If we start the workers right away, they will all very quickly find new coverage
         // and send lots of (probably redundant) programs to the main instance.
         let minDelay = 1 * Minutes
-        let maxDelay = 10 * Minutes
+        let maxDelay = 5 * Minutes
         let delay = Double.random(in: minDelay...maxDelay)
         Thread.sleep(forTimeInterval: delay)
 
diff --git a/Sources/REPRLRun/main.swift b/Sources/REPRLRun/main.swift
index eb0b036..dba7092 100644
--- a/Sources/REPRLRun/main.swift
+++ b/Sources/REPRLRun/main.swift
@@ -45,8 +45,10 @@ if reprl_initialize_context(ctx, argv, envp, /* capture_stdout: */ 1, /* capture
 func execute(_ code: String) -> (status: Int32, exec_time: UInt64) {
     var exec_time: UInt64 = 0
     var status: Int32 = 0
+    var encodedJitState: UInt8 = 0
     code.withCString {
-        status = reprl_execute(ctx, $0, UInt64(code.count), 1_000_000, &exec_time, 0)
+        // differentialFuzzingPositionDumpSeed == 0 for tests
+        status = reprl_execute(ctx, $0, UInt64(code.count), 1_000_000, &exec_time, 0, 0, &encodedJitState)
     }
     return (status, exec_time)
 }
diff --git a/Sources/RelateTool/main.swift b/Sources/RelateTool/main.swift
new file mode 100644
index 0000000..0007d8b
--- /dev/null
+++ b/Sources/RelateTool/main.swift
@@ -0,0 +1,114 @@
+import Foundation
+import Fuzzilli
+
+
+func printRunningCmd(_ process: Process) {
+    print("Running command: \(process.executableURL!.path) \(process.arguments!.joined(separator: " "))")
+}
+
+//
+// Process commandline arguments.
+//
+let args = Arguments.parse(from: CommandLine.arguments)
+
+let jsShellPath = args["--d8"] ?? "/root/localTools/v8/out/fuzzbuild/d8"
+var poc = args["--poc"]!
+
+let logLevel: OracleLogLevel
+if args["--logLevel"] == nil || args["--logLevel"] == "info" {
+    logLevel = .info
+} else if args["--logLevel"] == "debug" {
+    logLevel = .debug
+} else {
+    logLevel = .none
+}
+
+let validate = args["--validate"]
+
+let usePrepend = args["--prepend"]
+
+let progOutput = args["--progOutput"]
+
+if usePrepend != nil {
+    var prependPath = URL(fileURLWithPath: #file)
+    for _ in 0...2 {
+        prependPath.deleteLastPathComponent()
+    }
+    prependPath = prependPath.appendingPathComponent("prepend.js")
+    print(prependPath.path)
+    if !FileManager.default.fileExists(atPath: prependPath.path) {
+        print("prepend.js not found!")
+        exit(-1)
+    }
+
+    let prependJS = try! String(contentsOfFile: prependPath.path)
+
+    let filename = "prepend_" + URL(fileURLWithPath: poc).lastPathComponent
+    let fileURL = URL(fileURLWithPath: "/tmp").appendingPathComponent(filename)
+
+    let prependedScript = prependJS + (try! String(contentsOfFile: poc))
+
+    do {
+        try prependedScript.write(to: fileURL, atomically: false, encoding: String.Encoding.utf8)
+    } catch {
+        print("Failed to write file \(fileURL): \(error)")
+        exit(-1)
+    }
+
+    poc = fileURL.path
+}
+
+let optRun = Process()
+
+let optOutput = Pipe()
+optRun.standardOutput = optOutput
+optRun.standardError = optOutput
+
+
+let config = V8DifferentialConfig()
+
+var g = SystemRandomNumberGenerator()
+let differentialFuzzingDumpSeed = UInt32(Int.random(in: 1...9999, using: &g));
+
+optRun.executableURL = URL(fileURLWithPath: jsShellPath)
+optRun.arguments = config.commonArgs + config.differentialArgs + ["--dumping-seed=\(differentialFuzzingDumpSeed)", poc]
+
+printRunningCmd(optRun)
+try! optRun.run()
+optRun.waitUntilExit()
+if progOutput != nil {
+    print(String(data: optOutput.fileHandleForReading.readDataToEndOfFile(), encoding: .utf8)!)
+}
+let optDumps = try? String(contentsOfFile: "/tmp/\(differentialFuzzingDumpSeed)_output_dump.txt", encoding: .utf8)
+if optDumps == nil {
+    if validate == nil {
+        print("Produced no opt Dumps")
+    } else {
+        exit(1)
+    }
+} else {
+    let unOptRun = Process()
+    let unOptOutput = Pipe()
+    unOptRun.standardOutput = unOptOutput
+    unOptRun.standardError = unOptOutput
+    unOptRun.executableURL = URL(fileURLWithPath: jsShellPath)
+    unOptRun.arguments = config.commonArgs + config.referenceArgs + ["--dumping-seed=\(differentialFuzzingDumpSeed)", poc]
+    printRunningCmd(unOptRun)
+    try! unOptRun.run()
+    unOptRun.waitUntilExit()
+    if progOutput != nil {
+        print(String(data: unOptOutput.fileHandleForReading.readDataToEndOfFile(), encoding: .utf8)!)
+    }
+    let unOptDumps = try! String(contentsOfFile: "/tmp/\(differentialFuzzingDumpSeed)_output_dump.txt", encoding: .utf8)
+    let result = relate(optDumps!, with: unOptDumps, logLevel)
+
+    if (usePrepend != nil) {
+        try? FileManager.default.removeItem(atPath: poc)
+    }
+
+    if validate == nil {
+        print(result)
+    } else if !result {
+        exit(1)
+    }
+}
diff --git a/Sources/libreprl/include/libreprl.h b/Sources/libreprl/include/libreprl.h
index 1bfd693..777288b 100644
--- a/Sources/libreprl/include/libreprl.h
+++ b/Sources/libreprl/include/libreprl.h
@@ -53,8 +53,9 @@ void reprl_destroy_context(struct reprl_context* ctx);
 /// @param timeout The maximum allowed execution time in microseconds
 /// @param execution_time A pointer to which, if execution succeeds, the execution time in microseconds is written to
 /// @param fresh_instance if true, forces the creation of a new instance of the target
+/// @param execHash A pointer to which the differential testing execution hash is written to
 /// @return A REPRL exit status (see below) or a negative number in case of an error
-int reprl_execute(struct reprl_context* ctx, const char* script, uint64_t script_length, uint64_t timeout, uint64_t* execution_time, int fresh_instance);
+int reprl_execute(struct reprl_context* ctx, const char* script, uint64_t script_length, uint64_t timeout, uint64_t* execution_time, int fresh_instance, uint32_t source_pos_dump_seed, uint8_t* jit_state);
 
 /// Returns true if the execution terminated due to a signal.
 ///
diff --git a/Sources/libreprl/libreprl-posix.c b/Sources/libreprl/libreprl-posix.c
index 43c4e48..94cc7f0 100644
--- a/Sources/libreprl/libreprl-posix.c
+++ b/Sources/libreprl/libreprl-posix.c
@@ -30,12 +30,17 @@
 #include <stdlib.h>
 #include <string.h>
 #include <sys/mman.h>
+#include <sys/resource.h>
 #include <sys/time.h>
 #include <sys/types.h>
 #include <sys/wait.h>
 #include <time.h>
 #include <unistd.h>
 
+// The REPRL protocol version. Must be identical between server and client.
+// Bump this up whenever there are non-backwards-compatible changes to the protocol
+#define REPRL_PROTOCOL_VERSION 2
+
 // Well-known file descriptor numbers for reprl <-> child communication, child process side
 #define REPRL_CHILD_CTRL_IN 100
 #define REPRL_CHILD_CTRL_OUT 101
@@ -141,7 +146,7 @@ static struct data_channel* reprl_create_data_channel(struct reprl_context* ctx)
         reprl_error(ctx, "Failed to mmap data channel file: %s", strerror(errno));
         return NULL;
     }
-    
+
     struct data_channel* channel = malloc(sizeof(struct data_channel));
     channel->fd = fd;
     channel->mapping = mapping;
@@ -214,6 +219,19 @@ static int reprl_spawn_child(struct reprl_context* ctx)
             _exit(-1);
         }
 
+	#ifdef __linux__
+        // Set RLIMIT_CORE to 0, such that we don't produce core dumps. The
+        // added benefit of doing this here, in the child process, is that we
+        // can still get core dumps when Fuzzilli crashes.
+        struct rlimit core_limit;
+        core_limit.rlim_cur = 0;
+        core_limit.rlim_max = 0;
+        if (setrlimit(RLIMIT_CORE, &core_limit) < 0) {
+            fprintf(stderr, "setrlimit failed in the child: %s\n", strerror(errno));
+            _exit(-1);
+        };
+	#endif
+
         // Unblock any blocked signals. It seems that libdispatch sometimes blocks delivery of certain signals.
         sigset_t newset;
         sigemptyset(&newset);
@@ -259,21 +277,42 @@ static int reprl_spawn_child(struct reprl_context* ctx)
     }
     ctx->pid = pid;
 
-    char helo[5] = { 0 };
-    if (read(ctx->ctrl_in, helo, 4) != 4) {
+    char handshake[5] = { 0 };
+    if (read(ctx->ctrl_in, handshake, 4) != 4) {
         reprl_terminate_child(ctx);
-        return reprl_error(ctx, "Did not receive HELO message from child: %s", strerror(errno));
+        return reprl_error(ctx, "Did not receive handshake message from child: %s", strerror(errno));
     }
-    
-    if (strncmp(helo, "HELO", 4) != 0) {
+
+    if (strncmp(handshake, "HELO", 4) == 0) {
+        // Client is using protocol version 1.
         reprl_terminate_child(ctx);
-        return reprl_error(ctx, "Received invalid HELO message from child: %s", helo);
+        return reprl_error(ctx, "The client uses an old version of the REPRL protocol, please update it to the latest version");
     }
-    
-    if (write(ctx->ctrl_out, helo, 4) != 4) {
+
+    if (strncmp(handshake, "XDXD", 4) != 0) {
+        reprl_terminate_child(ctx);
+        return reprl_error(ctx, "Received invalid handshake message from child: %s", handshake);
+    }
+
+    // The server side just sends back the handshake message, but not the protocol version.
+    if (write(ctx->ctrl_out, handshake, 4) != 4) {
+        reprl_terminate_child(ctx);
+        return reprl_error(ctx, "Failed to send handshake reply message to child: %s", strerror(errno));
+    }
+
+    #ifdef __linux__
+    struct rlimit core_limit = {};
+    if (prlimit(pid, RLIMIT_CORE, NULL, &core_limit) < 0) {
         reprl_terminate_child(ctx);
-        return reprl_error(ctx, "Failed to send HELO reply message to child: %s", strerror(errno));
+        return reprl_error(ctx, "prlimit failed: %s\n", strerror(errno));
     }
+    if (core_limit.rlim_cur != 0 || core_limit.rlim_max != 0) {
+        reprl_terminate_child(ctx);
+        return reprl_error(ctx, "Detected non-zero RLIMIT_CORE. Check that the child does not set RLIMIT_CORE manually.\n");
+    }
+    #endif
+
+
 
     return 0;
 }
@@ -326,20 +365,20 @@ int reprl_initialize_context(struct reprl_context* ctx, const char** argv, const
 void reprl_destroy_context(struct reprl_context* ctx)
 {
     reprl_terminate_child(ctx);
-    
+
     free_string_array(ctx->argv);
     free_string_array(ctx->envp);
-    
+
     reprl_destroy_data_channel(ctx->data_in);
     reprl_destroy_data_channel(ctx->data_out);
     reprl_destroy_data_channel(ctx->child_stdout);
     reprl_destroy_data_channel(ctx->child_stderr);
-    
+
     free(ctx->last_error);
     free(ctx);
 }
 
-int reprl_execute(struct reprl_context* ctx, const char* script, uint64_t script_length, uint64_t timeout, uint64_t* execution_time, int fresh_instance)
+int reprl_execute(struct reprl_context* ctx, const char* script, uint64_t script_length, uint64_t timeout, uint64_t* execution_time, int fresh_instance, uint32_t source_pos_dump_seed, uint8_t* jit_state)
 {
     if (!ctx->initialized) {
         return reprl_error(ctx, "REPRL context is not initialized");
@@ -363,11 +402,14 @@ int reprl_execute(struct reprl_context* ctx, const char* script, uint64_t script
     lseek(ctx->data_in->fd, 0, SEEK_SET);
     if (ctx->child_stdout) {
         lseek(ctx->child_stdout->fd, 0, SEEK_SET);
+
+        memset(ctx->child_stdout->mapping, 0, REPRL_MAX_DATA_SIZE);
     }
+
     if (ctx->child_stderr) {
         lseek(ctx->child_stderr->fd, 0, SEEK_SET);
     }
-    
+
     // Spawn a new instance if necessary.
     if (!ctx->pid) {
         int r = reprl_spawn_child(ctx);
@@ -379,6 +421,7 @@ int reprl_execute(struct reprl_context* ctx, const char* script, uint64_t script
 
     // Tell child to execute the script.
     if (write(ctx->ctrl_out, "exec", 4) != 4 ||
+        write(ctx->ctrl_out, &source_pos_dump_seed, sizeof(source_pos_dump_seed)) != sizeof(source_pos_dump_seed) ||
         write(ctx->ctrl_out, &script_length, 8) != 8) {
         // These can fail if the child unexpectedly terminated between executions.
         // Check for that here to be able to provide a better error message.
@@ -408,13 +451,26 @@ int reprl_execute(struct reprl_context* ctx, const char* script, uint64_t script
         // We expect all signal handlers to be installed with SA_RESTART, so receiving EINTR here is unexpected and thus also an error.
         return reprl_error(ctx, "Failed to poll: %s", strerror(errno));
     }
-    
+
     // Poll succeeded, so there must be something to read now (either the status or EOF).
+    #pragma pack(1)
+    struct {
+        int status;
+        uint8_t jit_state;
+    } s;
+    // we only want to read 5 bytes and not care about padding
+    // just to be sure for the future
+    const size_t ssize = 5;
+
+
+    ssize_t rv = read(ctx->ctrl_in, &s, ssize);
     int status;
-    ssize_t rv = read(ctx->ctrl_in, &status, 4);
+
+    // printf("---STDOUT---\n%s\n", reprl_fetch_stdout(ctx));
+    // printf("---STDERR---\n%s\n", reprl_fetch_stderr(ctx));
     if (rv < 0) {
         return reprl_error(ctx, "Failed to read from control pipe: %s", strerror(errno));
-    } else if (rv != 4) {
+    } else if (rv != ssize) {
         // Most likely, the child process crashed and closed the write end of the control pipe.
         // Unfortunately, there probably is nothing that guarantees that waitpid() will immediately succeed now,
         // and we also don't want to block here. So just retry waitpid() a few times...
@@ -423,7 +479,6 @@ int reprl_execute(struct reprl_context* ctx, const char* script, uint64_t script
             success = waitpid(ctx->pid, &status, WNOHANG) == ctx->pid;
             if (!success) usleep(10);
         } while (!success && current_usecs() - start_time < timeout);
-        
         if (!success) {
             // Wait failed, so something weird must have happened. Maybe somehow the control pipe was closed without the child exiting?
             // Probably the best we can do is kill the child and return an error.
@@ -443,7 +498,11 @@ int reprl_execute(struct reprl_context* ctx, const char* script, uint64_t script
             return reprl_error(ctx, "Waitpid returned unexpected child state %i", status);
         }
     }
-    
+    else {
+        status = s.status;
+        *jit_state = s.jit_state;
+    }
+
     // The status must be a positive number, see the status encoding format below.
     // We also don't allow the child process to indicate a timeout. If we wanted,
     // we could treat it as an error if the upper bits are set.
diff --git a/prepend.js b/prepend.js
new file mode 100644
index 0000000..104c9c2
--- /dev/null
+++ b/prepend.js
@@ -0,0 +1,282 @@
+const prettyPrinted = function prettyPrinted(msg) { return console.log(msg); };
+// Mock Math.random.
+(function() {
+  let index = 1;
+  Math.random = function() {
+      const x = Math.sin(index++) * 10000;
+      return x - Math.floor(x);
+  }
+})();
+// Mock Math.pow. Work around an optimization for -0.5.
+(function() {
+  const origMathPow = Math.pow;
+  Math.pow = function(a, b) {
+    if (b === -0.5) {
+      return 0;
+    } else {
+      return origMathPow(a, b);
+    }
+  }
+})();
+// Mock Date.
+(function() {
+  let index = 0;
+  let mockDate = 1477662728696;
+  const mockDateNow = function() {
+    index = (index + 1) % 10;
+    mockDate = mockDate + index + 1;
+    return mockDate;
+  }
+  const origDate = Date;
+  const construct = Reflect.construct;
+  const constructDate = function(args) {
+    let result;
+    if (args.length) {
+      result = construct(origDate, args);
+    } else {
+      result = new origDate(mockDateNow());
+    }
+    result.constructor = function(...args) { return constructDate(args); }
+    Object.defineProperty(
+        result, "constructor", { configurable: false, writable: false });
+    return result;
+  }
+  origDate.prototype.constructor = function(...args) {
+    return constructDate(args);
+  };
+  var handler = {
+    apply: function(target, thisArg, args) {
+      return constructDate(args);
+    },
+    construct: function(target, args, newTarget) {
+      return constructDate(args);
+    },
+    get: function(target, property, receiver) {
+      if (property == "now") {
+        return mockDateNow;
+      }
+      if (property == "prototype") {
+        return origDate.prototype;
+      }
+    },
+  }
+  Date = new Proxy(Date, handler);
+})();
+// Mock this.performance.
+(function() {
+  function mockPerformanceMark(name) {
+    return {entryType: "mark", name: name, startTime: 0.0, duration: 0}
+  }
+  function mockPerformanceMeasure(name) {
+    return {entryType: "measure", name: name, startTime: 0.0, duration: 0}
+  }
+
+  var handler = {
+    get: function(target, property, receiver) {
+      if (property == "now") {
+        return 1.1;
+      }
+      if (property == "prototype") {
+        return undefined;
+      }
+      if (property == "mark") {
+        return mockPerformanceMark;
+      }
+      if (property == "measure") {
+        return mockPerformanceMeasure;
+      }
+      if (property == "measureMemory") {
+        return [];
+      }
+    },
+  }
+  this.performance = new Proxy(this.performance, handler);
+})();
+// Mock readline so that test cases don't hang.
+readline = function() { return "foo"; };
+// Mock stack traces.
+Error.prepareStackTrace = function(error, structuredStackTrace) {
+  return "";
+};
+Object.defineProperty(
+    Error, 'prepareStackTrace', { configurable: false, writable: false });
+// Mock buffer access in float typed arrays because of varying NaN patterns.
+(function() {
+  const origArrayFrom = Array.from;
+  const origArrayIsArray = Array.isArray;
+  const origFunctionPrototype = Function.prototype;
+  const origIsNaN = isNaN;
+  const origIterator = Symbol.iterator;
+  const deNaNify = function(value) { return origIsNaN(value) ? 1 : value; };
+  const mock = function(type) {
+    // Remove NaN values from parameters to "set" function.
+    const set = type.prototype.set;
+    type.prototype.set = function(array, offset) {
+      if (Array.isArray(array)) {
+        array = array.map(deNaNify);
+      }
+      set.apply(this, [array, offset]);
+    };
+    const handler = {
+      // Remove NaN values from parameters to constructor.
+      construct: function(target, args) {
+        for (let i = 0; i < args.length; i++) {
+          if (args[i] != null &&
+              typeof args[i][origIterator] === 'function') {
+            // Consume iterators.
+            args[i] = origArrayFrom(args[i]);
+          }
+          if (origArrayIsArray(args[i])) {
+            args[i] = args[i].map(deNaNify);
+          }
+        }
+        const obj = new (
+            origFunctionPrototype.bind.call(type, null, ...args));
+        return new Proxy(obj, {
+          get: function(x, prop) {
+            if (typeof x[prop] == "function")
+              return x[prop].bind(obj);
+            return x[prop];
+          },
+          // Remove NaN values that get assigned.
+          set: function(target, prop, value, receiver) {
+            target[prop] = deNaNify(value);
+            return value;
+          }
+        });
+      },
+    };
+    return new Proxy(type, handler);
+  }
+  Float32Array = mock(Float32Array);
+  Float64Array = mock(Float64Array);
+})();
+// Mock buffer access via DataViews because of varying NaN patterns.
+(function() {
+  const origIsNaN = isNaN;
+  const deNaNify = function(value) { return origIsNaN(value) ? 1 : value; };
+  const origSetFloat32 = DataView.prototype.setFloat32;
+  DataView.prototype.setFloat32 = function(offset, value, ...rest) {
+    origSetFloat32.call(this, offset, deNaNify(value), ...rest);
+  };
+  const origSetFloat64 = DataView.prototype.setFloat64;
+  DataView.prototype.setFloat64 = function(offset, value, ...rest) {
+    origSetFloat64.call(this, offset, deNaNify(value), ...rest);
+  };
+})();
+// Mock maximum typed-array buffer and limit to 1MiB. Otherwise we might
+// get range errors. We ignore those by crashing, but that reduces coverage,
+// hence, let's reduce the range-error rate.
+(function() {
+  // Math.min might be manipulated in test cases.
+  const min = Math.min;
+  const maxBytes = 1048576;
+  const mock = function(type) {
+    const maxLength = maxBytes / (type.BYTES_PER_ELEMENT || 1);
+    const handler = {
+      construct: function(target, args) {
+        if (args[0] && typeof args[0] != "object") {
+          // Length used as first argument.
+          args[0] = min(maxLength, Number(args[0]));
+        } else if (args[0] instanceof ArrayBuffer && args.length > 1) {
+          // Buffer used as first argument.
+          const buffer = args[0];
+          args[1] = Number(args[1]);
+          // Ensure offset is multiple of bytes per element.
+          args[1] = args[1] - (args[1] % type.BYTES_PER_ELEMENT);
+          // Limit offset to length of buffer.
+          args[1] = min(args[1], buffer.byteLength || 0);
+          if (args.length > 2) {
+            // If also length is given, limit it to the maximum that's possible
+            // given buffer and offset. Avoid NaN offset turning the length
+            // NaN, too.
+            const maxBytesLeft = buffer.byteLength - (args[1] || 0);
+            const maxLengthLeft = maxBytesLeft / type.BYTES_PER_ELEMENT;
+            args[2] = min(Number(args[2]), maxLengthLeft);
+          }
+        }
+        return new (Function.prototype.bind.apply(type, [null].concat(args)));
+      },
+    };
+    return new Proxy(type, handler);
+  }
+  ArrayBuffer = mock(ArrayBuffer);
+  SharedArrayBuffer = mock(SharedArrayBuffer);
+  Int8Array = mock(Int8Array);
+  Uint8Array = mock(Uint8Array);
+  Uint8ClampedArray = mock(Uint8ClampedArray);
+  Int16Array = mock(Int16Array);
+  Uint16Array = mock(Uint16Array);
+  Int32Array = mock(Int32Array);
+  Uint32Array = mock(Uint32Array);
+  BigInt64Array = mock(BigInt64Array);
+  BigUint64Array = mock(BigUint64Array);
+  Float32Array = mock(Float32Array);
+  Float64Array = mock(Float64Array);
+})();
+// Mock typed array set function and cap offset to not throw a range error.
+(function() {
+  // Math.min might be manipulated in test cases.
+  const min = Math.min;
+  const types = [
+    Int8Array,
+    Uint8Array,
+    Uint8ClampedArray,
+    Int16Array,
+    Uint16Array,
+    Int32Array,
+    Uint32Array,
+    BigInt64Array,
+    BigUint64Array,
+    Float32Array,
+    Float64Array,
+  ];
+  for (const type of types) {
+    const set = type.prototype.set;
+    type.prototype.set = function(array, offset) {
+      if (Array.isArray(array)) {
+        offset = Number(offset);
+        offset = min(offset, this.length - array.length);
+      }
+      set.call(this, array, offset);
+    };
+  }
+})();
+// Mock Worker.
+(function() {
+  let index = 0;
+  const workerMessages = [
+    undefined, 0, -1, "", "foo", 42, [], {}, [0], {"x": 0}
+  ];
+  Worker = function(code){
+    try {
+      print(prettyPrinted(eval(code)));
+    } catch(e) {
+      print(prettyPrinted(e));
+    }
+    this.getMessage = function(){
+      index = (index + 1) % 10;
+      return workerMessages[index];
+    }
+    this.postMessage = function(msg){
+      print(prettyPrinted(msg));
+    }
+  };
+})();
+// Mock Realm.
+Realm.eval = function(realm, code) { return eval(code) };
+// Mock the nondeterministic parts of WeakRef and FinalizationRegistry.
+WeakRef.prototype.deref = function() { };
+FinalizationRegistry = function(callback) { };
+FinalizationRegistry.prototype.register = function(target, holdings) { };
+FinalizationRegistry.prototype.unregister = function(unregisterToken) { };
+FinalizationRegistry.prototype.cleanupSome = function() { };
+FinalizationRegistry.prototype[Symbol.toStringTag] = "FinalizationRegistry";
+// Mock the nondeterministic Atomics.waitAsync.
+Atomics.waitAsync = function() {
+  // Return a mock "Promise" whose "then" function will call the callback
+  // immediately.
+  return {'value': {'then': function (f) { f(); }}};
+}
+// Mock serializer API with no-ops.
+d8.serializer = {'serialize': (x) => x, 'deserialize': (x) => x};
